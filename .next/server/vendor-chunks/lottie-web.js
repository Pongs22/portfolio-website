"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/lottie-web";
exports.ids = ["vendor-chunks/lottie-web"];
exports.modules = {

/***/ "(ssr)/./node_modules/lottie-web/build/player/lottie.js":
/*!********************************************************!*\
  !*** ./node_modules/lottie-web/build/player/lottie.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\ntypeof navigator !== \"undefined\" && function(global, factory) {\n     true ? module.exports = factory() : 0;\n}(void 0, function() {\n    \"use strict\";\n    var svgNS = \"http://www.w3.org/2000/svg\";\n    var locationHref = \"\";\n    var _useWebWorker = false;\n    var initialDefaultFrame = -999999;\n    var setWebWorker = function setWebWorker(flag) {\n        _useWebWorker = !!flag;\n    };\n    var getWebWorker = function getWebWorker() {\n        return _useWebWorker;\n    };\n    var setLocationHref = function setLocationHref(value) {\n        locationHref = value;\n    };\n    var getLocationHref = function getLocationHref() {\n        return locationHref;\n    };\n    function createTag(type) {\n        // return {appendChild:function(){},setAttribute:function(){},style:{}}\n        return document.createElement(type);\n    }\n    function extendPrototype(sources, destination) {\n        var i;\n        var len = sources.length;\n        var sourcePrototype;\n        for(i = 0; i < len; i += 1){\n            sourcePrototype = sources[i].prototype;\n            for(var attr in sourcePrototype){\n                if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];\n            }\n        }\n    }\n    function getDescriptor(object, prop) {\n        return Object.getOwnPropertyDescriptor(object, prop);\n    }\n    function createProxyFunction(prototype) {\n        function ProxyFunction() {}\n        ProxyFunction.prototype = prototype;\n        return ProxyFunction;\n    }\n    // import Howl from '../../3rd_party/howler';\n    var audioControllerFactory = function() {\n        function AudioController(audioFactory) {\n            this.audios = [];\n            this.audioFactory = audioFactory;\n            this._volume = 1;\n            this._isMuted = false;\n        }\n        AudioController.prototype = {\n            addAudio: function addAudio(audio) {\n                this.audios.push(audio);\n            },\n            pause: function pause() {\n                var i;\n                var len = this.audios.length;\n                for(i = 0; i < len; i += 1){\n                    this.audios[i].pause();\n                }\n            },\n            resume: function resume() {\n                var i;\n                var len = this.audios.length;\n                for(i = 0; i < len; i += 1){\n                    this.audios[i].resume();\n                }\n            },\n            setRate: function setRate(rateValue) {\n                var i;\n                var len = this.audios.length;\n                for(i = 0; i < len; i += 1){\n                    this.audios[i].setRate(rateValue);\n                }\n            },\n            createAudio: function createAudio(assetPath) {\n                if (this.audioFactory) {\n                    return this.audioFactory(assetPath);\n                }\n                if (window.Howl) {\n                    return new window.Howl({\n                        src: [\n                            assetPath\n                        ]\n                    });\n                }\n                return {\n                    isPlaying: false,\n                    play: function play() {\n                        this.isPlaying = true;\n                    },\n                    seek: function seek() {\n                        this.isPlaying = false;\n                    },\n                    playing: function playing() {},\n                    rate: function rate() {},\n                    setVolume: function setVolume() {}\n                };\n            },\n            setAudioFactory: function setAudioFactory(audioFactory) {\n                this.audioFactory = audioFactory;\n            },\n            setVolume: function setVolume(value) {\n                this._volume = value;\n                this._updateVolume();\n            },\n            mute: function mute() {\n                this._isMuted = true;\n                this._updateVolume();\n            },\n            unmute: function unmute() {\n                this._isMuted = false;\n                this._updateVolume();\n            },\n            getVolume: function getVolume() {\n                return this._volume;\n            },\n            _updateVolume: function _updateVolume() {\n                var i;\n                var len = this.audios.length;\n                for(i = 0; i < len; i += 1){\n                    this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1));\n                }\n            }\n        };\n        return function() {\n            return new AudioController();\n        };\n    }();\n    var createTypedArray = function() {\n        function createRegularArray(type, len) {\n            var i = 0;\n            var arr = [];\n            var value;\n            switch(type){\n                case \"int16\":\n                case \"uint8c\":\n                    value = 1;\n                    break;\n                default:\n                    value = 1.1;\n                    break;\n            }\n            for(i = 0; i < len; i += 1){\n                arr.push(value);\n            }\n            return arr;\n        }\n        function createTypedArrayFactory(type, len) {\n            if (type === \"float32\") {\n                return new Float32Array(len);\n            }\n            if (type === \"int16\") {\n                return new Int16Array(len);\n            }\n            if (type === \"uint8c\") {\n                return new Uint8ClampedArray(len);\n            }\n            return createRegularArray(type, len);\n        }\n        if (typeof Uint8ClampedArray === \"function\" && typeof Float32Array === \"function\") {\n            return createTypedArrayFactory;\n        }\n        return createRegularArray;\n    }();\n    function createSizedArray(len) {\n        return Array.apply(null, {\n            length: len\n        });\n    }\n    function _typeof$6(obj) {\n        \"@babel/helpers - typeof\";\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof$6 = function _typeof(obj) {\n                return typeof obj;\n            };\n        } else {\n            _typeof$6 = function _typeof(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n        }\n        return _typeof$6(obj);\n    }\n    var subframeEnabled = true;\n    var expressionsPlugin = null;\n    var expressionsInterfaces = null;\n    var idPrefix$1 = \"\";\n    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n    var _shouldRoundValues = false;\n    var bmPow = Math.pow;\n    var bmSqrt = Math.sqrt;\n    var bmFloor = Math.floor;\n    var bmMax = Math.max;\n    var bmMin = Math.min;\n    var BMMath = {};\n    (function() {\n        var propertyNames = [\n            \"abs\",\n            \"acos\",\n            \"acosh\",\n            \"asin\",\n            \"asinh\",\n            \"atan\",\n            \"atanh\",\n            \"atan2\",\n            \"ceil\",\n            \"cbrt\",\n            \"expm1\",\n            \"clz32\",\n            \"cos\",\n            \"cosh\",\n            \"exp\",\n            \"floor\",\n            \"fround\",\n            \"hypot\",\n            \"imul\",\n            \"log\",\n            \"log1p\",\n            \"log2\",\n            \"log10\",\n            \"max\",\n            \"min\",\n            \"pow\",\n            \"random\",\n            \"round\",\n            \"sign\",\n            \"sin\",\n            \"sinh\",\n            \"sqrt\",\n            \"tan\",\n            \"tanh\",\n            \"trunc\",\n            \"E\",\n            \"LN10\",\n            \"LN2\",\n            \"LOG10E\",\n            \"LOG2E\",\n            \"PI\",\n            \"SQRT1_2\",\n            \"SQRT2\"\n        ];\n        var i;\n        var len = propertyNames.length;\n        for(i = 0; i < len; i += 1){\n            BMMath[propertyNames[i]] = Math[propertyNames[i]];\n        }\n    })();\n    function ProjectInterface$1() {\n        return {};\n    }\n    BMMath.random = Math.random;\n    BMMath.abs = function(val) {\n        var tOfVal = _typeof$6(val);\n        if (tOfVal === \"object\" && val.length) {\n            var absArr = createSizedArray(val.length);\n            var i;\n            var len = val.length;\n            for(i = 0; i < len; i += 1){\n                absArr[i] = Math.abs(val[i]);\n            }\n            return absArr;\n        }\n        return Math.abs(val);\n    };\n    var defaultCurveSegments = 150;\n    var degToRads = Math.PI / 180;\n    var roundCorner = 0.5519;\n    function roundValues(flag) {\n        _shouldRoundValues = !!flag;\n    }\n    function bmRnd(value) {\n        if (_shouldRoundValues) {\n            return Math.round(value);\n        }\n        return value;\n    }\n    function styleDiv(element) {\n        element.style.position = \"absolute\";\n        element.style.top = 0;\n        element.style.left = 0;\n        element.style.display = \"block\";\n        element.style.transformOrigin = \"0 0\";\n        element.style.webkitTransformOrigin = \"0 0\";\n        element.style.backfaceVisibility = \"visible\";\n        element.style.webkitBackfaceVisibility = \"visible\";\n        element.style.transformStyle = \"preserve-3d\";\n        element.style.webkitTransformStyle = \"preserve-3d\";\n        element.style.mozTransformStyle = \"preserve-3d\";\n    }\n    function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {\n        this.type = type;\n        this.currentTime = currentTime;\n        this.totalTime = totalTime;\n        this.direction = frameMultiplier < 0 ? -1 : 1;\n    }\n    function BMCompleteEvent(type, frameMultiplier) {\n        this.type = type;\n        this.direction = frameMultiplier < 0 ? -1 : 1;\n    }\n    function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {\n        this.type = type;\n        this.currentLoop = currentLoop;\n        this.totalLoops = totalLoops;\n        this.direction = frameMultiplier < 0 ? -1 : 1;\n    }\n    function BMSegmentStartEvent(type, firstFrame, totalFrames) {\n        this.type = type;\n        this.firstFrame = firstFrame;\n        this.totalFrames = totalFrames;\n    }\n    function BMDestroyEvent(type, target) {\n        this.type = type;\n        this.target = target;\n    }\n    function BMRenderFrameErrorEvent(nativeError, currentTime) {\n        this.type = \"renderFrameError\";\n        this.nativeError = nativeError;\n        this.currentTime = currentTime;\n    }\n    function BMConfigErrorEvent(nativeError) {\n        this.type = \"configError\";\n        this.nativeError = nativeError;\n    }\n    function BMAnimationConfigErrorEvent(type, nativeError) {\n        this.type = type;\n        this.nativeError = nativeError;\n    }\n    var createElementID = function() {\n        var _count = 0;\n        return function createID() {\n            _count += 1;\n            return idPrefix$1 + \"__lottie_element_\" + _count;\n        };\n    }();\n    function HSVtoRGB(h, s, v) {\n        var r;\n        var g;\n        var b;\n        var i;\n        var f;\n        var p;\n        var q;\n        var t;\n        i = Math.floor(h * 6);\n        f = h * 6 - i;\n        p = v * (1 - s);\n        q = v * (1 - f * s);\n        t = v * (1 - (1 - f) * s);\n        switch(i % 6){\n            case 0:\n                r = v;\n                g = t;\n                b = p;\n                break;\n            case 1:\n                r = q;\n                g = v;\n                b = p;\n                break;\n            case 2:\n                r = p;\n                g = v;\n                b = t;\n                break;\n            case 3:\n                r = p;\n                g = q;\n                b = v;\n                break;\n            case 4:\n                r = t;\n                g = p;\n                b = v;\n                break;\n            case 5:\n                r = v;\n                g = p;\n                b = q;\n                break;\n            default:\n                break;\n        }\n        return [\n            r,\n            g,\n            b\n        ];\n    }\n    function RGBtoHSV(r, g, b) {\n        var max = Math.max(r, g, b);\n        var min = Math.min(r, g, b);\n        var d = max - min;\n        var h;\n        var s = max === 0 ? 0 : d / max;\n        var v = max / 255;\n        switch(max){\n            case min:\n                h = 0;\n                break;\n            case r:\n                h = g - b + d * (g < b ? 6 : 0);\n                h /= 6 * d;\n                break;\n            case g:\n                h = b - r + d * 2;\n                h /= 6 * d;\n                break;\n            case b:\n                h = r - g + d * 4;\n                h /= 6 * d;\n                break;\n            default:\n                break;\n        }\n        return [\n            h,\n            s,\n            v\n        ];\n    }\n    function addSaturationToRGB(color, offset) {\n        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);\n        hsv[1] += offset;\n        if (hsv[1] > 1) {\n            hsv[1] = 1;\n        } else if (hsv[1] <= 0) {\n            hsv[1] = 0;\n        }\n        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);\n    }\n    function addBrightnessToRGB(color, offset) {\n        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);\n        hsv[2] += offset;\n        if (hsv[2] > 1) {\n            hsv[2] = 1;\n        } else if (hsv[2] < 0) {\n            hsv[2] = 0;\n        }\n        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);\n    }\n    function addHueToRGB(color, offset) {\n        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);\n        hsv[0] += offset / 360;\n        if (hsv[0] > 1) {\n            hsv[0] -= 1;\n        } else if (hsv[0] < 0) {\n            hsv[0] += 1;\n        }\n        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);\n    }\n    var rgbToHex = function() {\n        var colorMap = [];\n        var i;\n        var hex;\n        for(i = 0; i < 256; i += 1){\n            hex = i.toString(16);\n            colorMap[i] = hex.length === 1 ? \"0\" + hex : hex;\n        }\n        return function(r, g, b) {\n            if (r < 0) {\n                r = 0;\n            }\n            if (g < 0) {\n                g = 0;\n            }\n            if (b < 0) {\n                b = 0;\n            }\n            return \"#\" + colorMap[r] + colorMap[g] + colorMap[b];\n        };\n    }();\n    var setSubframeEnabled = function setSubframeEnabled(flag) {\n        subframeEnabled = !!flag;\n    };\n    var getSubframeEnabled = function getSubframeEnabled() {\n        return subframeEnabled;\n    };\n    var setExpressionsPlugin = function setExpressionsPlugin(value) {\n        expressionsPlugin = value;\n    };\n    var getExpressionsPlugin = function getExpressionsPlugin() {\n        return expressionsPlugin;\n    };\n    var setExpressionInterfaces = function setExpressionInterfaces(value) {\n        expressionsInterfaces = value;\n    };\n    var getExpressionInterfaces = function getExpressionInterfaces() {\n        return expressionsInterfaces;\n    };\n    var setDefaultCurveSegments = function setDefaultCurveSegments(value) {\n        defaultCurveSegments = value;\n    };\n    var getDefaultCurveSegments = function getDefaultCurveSegments() {\n        return defaultCurveSegments;\n    };\n    var setIdPrefix = function setIdPrefix(value) {\n        idPrefix$1 = value;\n    };\n    var getIdPrefix = function getIdPrefix() {\n        return idPrefix$1;\n    };\n    function createNS(type) {\n        // return {appendChild:function(){},setAttribute:function(){},style:{}}\n        return document.createElementNS(svgNS, type);\n    }\n    function _typeof$5(obj) {\n        \"@babel/helpers - typeof\";\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof$5 = function _typeof(obj) {\n                return typeof obj;\n            };\n        } else {\n            _typeof$5 = function _typeof(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n        }\n        return _typeof$5(obj);\n    }\n    var dataManager = function() {\n        var _counterId = 1;\n        var processes = [];\n        var workerFn;\n        var workerInstance;\n        var workerProxy = {\n            onmessage: function onmessage() {},\n            postMessage: function postMessage(path) {\n                workerFn({\n                    data: path\n                });\n            }\n        };\n        var _workerSelf = {\n            postMessage: function postMessage(data) {\n                workerProxy.onmessage({\n                    data: data\n                });\n            }\n        };\n        function createWorker(fn) {\n            if (window.Worker && window.Blob && getWebWorker()) {\n                var blob = new Blob([\n                    \"var _workerSelf = self; self.onmessage = \",\n                    fn.toString()\n                ], {\n                    type: \"text/javascript\"\n                }); // var blob = new Blob(['self.onmessage = ', fn.toString()], { type: 'text/javascript' });\n                var url = URL.createObjectURL(blob);\n                return new Worker(url);\n            }\n            workerFn = fn;\n            return workerProxy;\n        }\n        function setupWorker() {\n            if (!workerInstance) {\n                workerInstance = createWorker(function workerStart(e) {\n                    function dataFunctionManager() {\n                        function completeLayers(layers, comps) {\n                            var layerData;\n                            var i;\n                            var len = layers.length;\n                            var j;\n                            var jLen;\n                            var k;\n                            var kLen;\n                            for(i = 0; i < len; i += 1){\n                                layerData = layers[i];\n                                if (\"ks\" in layerData && !layerData.completed) {\n                                    layerData.completed = true;\n                                    if (layerData.hasMask) {\n                                        var maskProps = layerData.masksProperties;\n                                        jLen = maskProps.length;\n                                        for(j = 0; j < jLen; j += 1){\n                                            if (maskProps[j].pt.k.i) {\n                                                convertPathsToAbsoluteValues(maskProps[j].pt.k);\n                                            } else {\n                                                kLen = maskProps[j].pt.k.length;\n                                                for(k = 0; k < kLen; k += 1){\n                                                    if (maskProps[j].pt.k[k].s) {\n                                                        convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);\n                                                    }\n                                                    if (maskProps[j].pt.k[k].e) {\n                                                        convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                    if (layerData.ty === 0) {\n                                        layerData.layers = findCompLayers(layerData.refId, comps);\n                                        completeLayers(layerData.layers, comps);\n                                    } else if (layerData.ty === 4) {\n                                        completeShapes(layerData.shapes);\n                                    } else if (layerData.ty === 5) {\n                                        completeText(layerData);\n                                    }\n                                }\n                            }\n                        }\n                        function completeChars(chars, assets) {\n                            if (chars) {\n                                var i = 0;\n                                var len = chars.length;\n                                for(i = 0; i < len; i += 1){\n                                    if (chars[i].t === 1) {\n                                        // var compData = findComp(chars[i].data.refId, assets);\n                                        chars[i].data.layers = findCompLayers(chars[i].data.refId, assets); // chars[i].data.ip = 0;\n                                        // chars[i].data.op = 99999;\n                                        // chars[i].data.st = 0;\n                                        // chars[i].data.sr = 1;\n                                        // chars[i].w = compData.w;\n                                        // chars[i].data.ks = {\n                                        //   a: { k: [0, 0, 0], a: 0 },\n                                        //   p: { k: [0, -compData.h, 0], a: 0 },\n                                        //   r: { k: 0, a: 0 },\n                                        //   s: { k: [100, 100], a: 0 },\n                                        //   o: { k: 100, a: 0 },\n                                        // };\n                                        completeLayers(chars[i].data.layers, assets);\n                                    }\n                                }\n                            }\n                        }\n                        function findComp(id, comps) {\n                            var i = 0;\n                            var len = comps.length;\n                            while(i < len){\n                                if (comps[i].id === id) {\n                                    return comps[i];\n                                }\n                                i += 1;\n                            }\n                            return null;\n                        }\n                        function findCompLayers(id, comps) {\n                            var comp = findComp(id, comps);\n                            if (comp) {\n                                if (!comp.layers.__used) {\n                                    comp.layers.__used = true;\n                                    return comp.layers;\n                                }\n                                return JSON.parse(JSON.stringify(comp.layers));\n                            }\n                            return null;\n                        }\n                        function completeShapes(arr) {\n                            var i;\n                            var len = arr.length;\n                            var j;\n                            var jLen;\n                            for(i = len - 1; i >= 0; i -= 1){\n                                if (arr[i].ty === \"sh\") {\n                                    if (arr[i].ks.k.i) {\n                                        convertPathsToAbsoluteValues(arr[i].ks.k);\n                                    } else {\n                                        jLen = arr[i].ks.k.length;\n                                        for(j = 0; j < jLen; j += 1){\n                                            if (arr[i].ks.k[j].s) {\n                                                convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);\n                                            }\n                                            if (arr[i].ks.k[j].e) {\n                                                convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);\n                                            }\n                                        }\n                                    }\n                                } else if (arr[i].ty === \"gr\") {\n                                    completeShapes(arr[i].it);\n                                }\n                            }\n                        }\n                        function convertPathsToAbsoluteValues(path) {\n                            var i;\n                            var len = path.i.length;\n                            for(i = 0; i < len; i += 1){\n                                path.i[i][0] += path.v[i][0];\n                                path.i[i][1] += path.v[i][1];\n                                path.o[i][0] += path.v[i][0];\n                                path.o[i][1] += path.v[i][1];\n                            }\n                        }\n                        function checkVersion(minimum, animVersionString) {\n                            var animVersion = animVersionString ? animVersionString.split(\".\") : [\n                                100,\n                                100,\n                                100\n                            ];\n                            if (minimum[0] > animVersion[0]) {\n                                return true;\n                            }\n                            if (animVersion[0] > minimum[0]) {\n                                return false;\n                            }\n                            if (minimum[1] > animVersion[1]) {\n                                return true;\n                            }\n                            if (animVersion[1] > minimum[1]) {\n                                return false;\n                            }\n                            if (minimum[2] > animVersion[2]) {\n                                return true;\n                            }\n                            if (animVersion[2] > minimum[2]) {\n                                return false;\n                            }\n                            return null;\n                        }\n                        var checkText = function() {\n                            var minimumVersion = [\n                                4,\n                                4,\n                                14\n                            ];\n                            function updateTextLayer(textLayer) {\n                                var documentData = textLayer.t.d;\n                                textLayer.t.d = {\n                                    k: [\n                                        {\n                                            s: documentData,\n                                            t: 0\n                                        }\n                                    ]\n                                };\n                            }\n                            function iterateLayers(layers) {\n                                var i;\n                                var len = layers.length;\n                                for(i = 0; i < len; i += 1){\n                                    if (layers[i].ty === 5) {\n                                        updateTextLayer(layers[i]);\n                                    }\n                                }\n                            }\n                            return function(animationData) {\n                                if (checkVersion(minimumVersion, animationData.v)) {\n                                    iterateLayers(animationData.layers);\n                                    if (animationData.assets) {\n                                        var i;\n                                        var len = animationData.assets.length;\n                                        for(i = 0; i < len; i += 1){\n                                            if (animationData.assets[i].layers) {\n                                                iterateLayers(animationData.assets[i].layers);\n                                            }\n                                        }\n                                    }\n                                }\n                            };\n                        }();\n                        var checkChars = function() {\n                            var minimumVersion = [\n                                4,\n                                7,\n                                99\n                            ];\n                            return function(animationData) {\n                                if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {\n                                    var i;\n                                    var len = animationData.chars.length;\n                                    for(i = 0; i < len; i += 1){\n                                        var charData = animationData.chars[i];\n                                        if (charData.data && charData.data.shapes) {\n                                            completeShapes(charData.data.shapes);\n                                            charData.data.ip = 0;\n                                            charData.data.op = 99999;\n                                            charData.data.st = 0;\n                                            charData.data.sr = 1;\n                                            charData.data.ks = {\n                                                p: {\n                                                    k: [\n                                                        0,\n                                                        0\n                                                    ],\n                                                    a: 0\n                                                },\n                                                s: {\n                                                    k: [\n                                                        100,\n                                                        100\n                                                    ],\n                                                    a: 0\n                                                },\n                                                a: {\n                                                    k: [\n                                                        0,\n                                                        0\n                                                    ],\n                                                    a: 0\n                                                },\n                                                r: {\n                                                    k: 0,\n                                                    a: 0\n                                                },\n                                                o: {\n                                                    k: 100,\n                                                    a: 0\n                                                }\n                                            };\n                                            if (!animationData.chars[i].t) {\n                                                charData.data.shapes.push({\n                                                    ty: \"no\"\n                                                });\n                                                charData.data.shapes[0].it.push({\n                                                    p: {\n                                                        k: [\n                                                            0,\n                                                            0\n                                                        ],\n                                                        a: 0\n                                                    },\n                                                    s: {\n                                                        k: [\n                                                            100,\n                                                            100\n                                                        ],\n                                                        a: 0\n                                                    },\n                                                    a: {\n                                                        k: [\n                                                            0,\n                                                            0\n                                                        ],\n                                                        a: 0\n                                                    },\n                                                    r: {\n                                                        k: 0,\n                                                        a: 0\n                                                    },\n                                                    o: {\n                                                        k: 100,\n                                                        a: 0\n                                                    },\n                                                    sk: {\n                                                        k: 0,\n                                                        a: 0\n                                                    },\n                                                    sa: {\n                                                        k: 0,\n                                                        a: 0\n                                                    },\n                                                    ty: \"tr\"\n                                                });\n                                            }\n                                        }\n                                    }\n                                }\n                            };\n                        }();\n                        var checkPathProperties = function() {\n                            var minimumVersion = [\n                                5,\n                                7,\n                                15\n                            ];\n                            function updateTextLayer(textLayer) {\n                                var pathData = textLayer.t.p;\n                                if (typeof pathData.a === \"number\") {\n                                    pathData.a = {\n                                        a: 0,\n                                        k: pathData.a\n                                    };\n                                }\n                                if (typeof pathData.p === \"number\") {\n                                    pathData.p = {\n                                        a: 0,\n                                        k: pathData.p\n                                    };\n                                }\n                                if (typeof pathData.r === \"number\") {\n                                    pathData.r = {\n                                        a: 0,\n                                        k: pathData.r\n                                    };\n                                }\n                            }\n                            function iterateLayers(layers) {\n                                var i;\n                                var len = layers.length;\n                                for(i = 0; i < len; i += 1){\n                                    if (layers[i].ty === 5) {\n                                        updateTextLayer(layers[i]);\n                                    }\n                                }\n                            }\n                            return function(animationData) {\n                                if (checkVersion(minimumVersion, animationData.v)) {\n                                    iterateLayers(animationData.layers);\n                                    if (animationData.assets) {\n                                        var i;\n                                        var len = animationData.assets.length;\n                                        for(i = 0; i < len; i += 1){\n                                            if (animationData.assets[i].layers) {\n                                                iterateLayers(animationData.assets[i].layers);\n                                            }\n                                        }\n                                    }\n                                }\n                            };\n                        }();\n                        var checkColors = function() {\n                            var minimumVersion = [\n                                4,\n                                1,\n                                9\n                            ];\n                            function iterateShapes(shapes) {\n                                var i;\n                                var len = shapes.length;\n                                var j;\n                                var jLen;\n                                for(i = 0; i < len; i += 1){\n                                    if (shapes[i].ty === \"gr\") {\n                                        iterateShapes(shapes[i].it);\n                                    } else if (shapes[i].ty === \"fl\" || shapes[i].ty === \"st\") {\n                                        if (shapes[i].c.k && shapes[i].c.k[0].i) {\n                                            jLen = shapes[i].c.k.length;\n                                            for(j = 0; j < jLen; j += 1){\n                                                if (shapes[i].c.k[j].s) {\n                                                    shapes[i].c.k[j].s[0] /= 255;\n                                                    shapes[i].c.k[j].s[1] /= 255;\n                                                    shapes[i].c.k[j].s[2] /= 255;\n                                                    shapes[i].c.k[j].s[3] /= 255;\n                                                }\n                                                if (shapes[i].c.k[j].e) {\n                                                    shapes[i].c.k[j].e[0] /= 255;\n                                                    shapes[i].c.k[j].e[1] /= 255;\n                                                    shapes[i].c.k[j].e[2] /= 255;\n                                                    shapes[i].c.k[j].e[3] /= 255;\n                                                }\n                                            }\n                                        } else {\n                                            shapes[i].c.k[0] /= 255;\n                                            shapes[i].c.k[1] /= 255;\n                                            shapes[i].c.k[2] /= 255;\n                                            shapes[i].c.k[3] /= 255;\n                                        }\n                                    }\n                                }\n                            }\n                            function iterateLayers(layers) {\n                                var i;\n                                var len = layers.length;\n                                for(i = 0; i < len; i += 1){\n                                    if (layers[i].ty === 4) {\n                                        iterateShapes(layers[i].shapes);\n                                    }\n                                }\n                            }\n                            return function(animationData) {\n                                if (checkVersion(minimumVersion, animationData.v)) {\n                                    iterateLayers(animationData.layers);\n                                    if (animationData.assets) {\n                                        var i;\n                                        var len = animationData.assets.length;\n                                        for(i = 0; i < len; i += 1){\n                                            if (animationData.assets[i].layers) {\n                                                iterateLayers(animationData.assets[i].layers);\n                                            }\n                                        }\n                                    }\n                                }\n                            };\n                        }();\n                        var checkShapes = function() {\n                            var minimumVersion = [\n                                4,\n                                4,\n                                18\n                            ];\n                            function completeClosingShapes(arr) {\n                                var i;\n                                var len = arr.length;\n                                var j;\n                                var jLen;\n                                for(i = len - 1; i >= 0; i -= 1){\n                                    if (arr[i].ty === \"sh\") {\n                                        if (arr[i].ks.k.i) {\n                                            arr[i].ks.k.c = arr[i].closed;\n                                        } else {\n                                            jLen = arr[i].ks.k.length;\n                                            for(j = 0; j < jLen; j += 1){\n                                                if (arr[i].ks.k[j].s) {\n                                                    arr[i].ks.k[j].s[0].c = arr[i].closed;\n                                                }\n                                                if (arr[i].ks.k[j].e) {\n                                                    arr[i].ks.k[j].e[0].c = arr[i].closed;\n                                                }\n                                            }\n                                        }\n                                    } else if (arr[i].ty === \"gr\") {\n                                        completeClosingShapes(arr[i].it);\n                                    }\n                                }\n                            }\n                            function iterateLayers(layers) {\n                                var layerData;\n                                var i;\n                                var len = layers.length;\n                                var j;\n                                var jLen;\n                                var k;\n                                var kLen;\n                                for(i = 0; i < len; i += 1){\n                                    layerData = layers[i];\n                                    if (layerData.hasMask) {\n                                        var maskProps = layerData.masksProperties;\n                                        jLen = maskProps.length;\n                                        for(j = 0; j < jLen; j += 1){\n                                            if (maskProps[j].pt.k.i) {\n                                                maskProps[j].pt.k.c = maskProps[j].cl;\n                                            } else {\n                                                kLen = maskProps[j].pt.k.length;\n                                                for(k = 0; k < kLen; k += 1){\n                                                    if (maskProps[j].pt.k[k].s) {\n                                                        maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;\n                                                    }\n                                                    if (maskProps[j].pt.k[k].e) {\n                                                        maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                    if (layerData.ty === 4) {\n                                        completeClosingShapes(layerData.shapes);\n                                    }\n                                }\n                            }\n                            return function(animationData) {\n                                if (checkVersion(minimumVersion, animationData.v)) {\n                                    iterateLayers(animationData.layers);\n                                    if (animationData.assets) {\n                                        var i;\n                                        var len = animationData.assets.length;\n                                        for(i = 0; i < len; i += 1){\n                                            if (animationData.assets[i].layers) {\n                                                iterateLayers(animationData.assets[i].layers);\n                                            }\n                                        }\n                                    }\n                                }\n                            };\n                        }();\n                        function completeData(animationData) {\n                            if (animationData.__complete) {\n                                return;\n                            }\n                            checkColors(animationData);\n                            checkText(animationData);\n                            checkChars(animationData);\n                            checkPathProperties(animationData);\n                            checkShapes(animationData);\n                            completeLayers(animationData.layers, animationData.assets);\n                            completeChars(animationData.chars, animationData.assets);\n                            animationData.__complete = true;\n                        }\n                        function completeText(data) {\n                            if (data.t.a.length === 0 && !(\"m\" in data.t.p)) {}\n                        }\n                        var moduleOb = {};\n                        moduleOb.completeData = completeData;\n                        moduleOb.checkColors = checkColors;\n                        moduleOb.checkChars = checkChars;\n                        moduleOb.checkPathProperties = checkPathProperties;\n                        moduleOb.checkShapes = checkShapes;\n                        moduleOb.completeLayers = completeLayers;\n                        return moduleOb;\n                    }\n                    if (!_workerSelf.dataManager) {\n                        _workerSelf.dataManager = dataFunctionManager();\n                    }\n                    if (!_workerSelf.assetLoader) {\n                        _workerSelf.assetLoader = function() {\n                            function formatResponse(xhr) {\n                                // using typeof doubles the time of execution of this method,\n                                // so if available, it's better to use the header to validate the type\n                                var contentTypeHeader = xhr.getResponseHeader(\"content-type\");\n                                if (contentTypeHeader && xhr.responseType === \"json\" && contentTypeHeader.indexOf(\"json\") !== -1) {\n                                    return xhr.response;\n                                }\n                                if (xhr.response && _typeof$5(xhr.response) === \"object\") {\n                                    return xhr.response;\n                                }\n                                if (xhr.response && typeof xhr.response === \"string\") {\n                                    return JSON.parse(xhr.response);\n                                }\n                                if (xhr.responseText) {\n                                    return JSON.parse(xhr.responseText);\n                                }\n                                return null;\n                            }\n                            function loadAsset(path, fullPath, callback, errorCallback) {\n                                var response;\n                                var xhr = new XMLHttpRequest(); // set responseType after calling open or IE will break.\n                                try {\n                                    // This crashes on Android WebView prior to KitKat\n                                    xhr.responseType = \"json\";\n                                } catch (err) {} // eslint-disable-line no-empty\n                                xhr.onreadystatechange = function() {\n                                    if (xhr.readyState === 4) {\n                                        if (xhr.status === 200) {\n                                            response = formatResponse(xhr);\n                                            callback(response);\n                                        } else {\n                                            try {\n                                                response = formatResponse(xhr);\n                                                callback(response);\n                                            } catch (err) {\n                                                if (errorCallback) {\n                                                    errorCallback(err);\n                                                }\n                                            }\n                                        }\n                                    }\n                                };\n                                try {\n                                    // Hack to workaround banner validation\n                                    xhr.open([\n                                        \"G\",\n                                        \"E\",\n                                        \"T\"\n                                    ].join(\"\"), path, true);\n                                } catch (error) {\n                                    // Hack to workaround banner validation\n                                    xhr.open([\n                                        \"G\",\n                                        \"E\",\n                                        \"T\"\n                                    ].join(\"\"), fullPath + \"/\" + path, true);\n                                }\n                                xhr.send();\n                            }\n                            return {\n                                load: loadAsset\n                            };\n                        }();\n                    }\n                    if (e.data.type === \"loadAnimation\") {\n                        _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function(data) {\n                            _workerSelf.dataManager.completeData(data);\n                            _workerSelf.postMessage({\n                                id: e.data.id,\n                                payload: data,\n                                status: \"success\"\n                            });\n                        }, function() {\n                            _workerSelf.postMessage({\n                                id: e.data.id,\n                                status: \"error\"\n                            });\n                        });\n                    } else if (e.data.type === \"complete\") {\n                        var animation = e.data.animation;\n                        _workerSelf.dataManager.completeData(animation);\n                        _workerSelf.postMessage({\n                            id: e.data.id,\n                            payload: animation,\n                            status: \"success\"\n                        });\n                    } else if (e.data.type === \"loadData\") {\n                        _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function(data) {\n                            _workerSelf.postMessage({\n                                id: e.data.id,\n                                payload: data,\n                                status: \"success\"\n                            });\n                        }, function() {\n                            _workerSelf.postMessage({\n                                id: e.data.id,\n                                status: \"error\"\n                            });\n                        });\n                    }\n                });\n                workerInstance.onmessage = function(event) {\n                    var data = event.data;\n                    var id = data.id;\n                    var process = processes[id];\n                    processes[id] = null;\n                    if (data.status === \"success\") {\n                        process.onComplete(data.payload);\n                    } else if (process.onError) {\n                        process.onError();\n                    }\n                };\n            }\n        }\n        function createProcess(onComplete, onError) {\n            _counterId += 1;\n            var id = \"processId_\" + _counterId;\n            processes[id] = {\n                onComplete: onComplete,\n                onError: onError\n            };\n            return id;\n        }\n        function loadAnimation(path, onComplete, onError) {\n            setupWorker();\n            var processId = createProcess(onComplete, onError);\n            workerInstance.postMessage({\n                type: \"loadAnimation\",\n                path: path,\n                fullPath: window.location.origin + window.location.pathname,\n                id: processId\n            });\n        }\n        function loadData(path, onComplete, onError) {\n            setupWorker();\n            var processId = createProcess(onComplete, onError);\n            workerInstance.postMessage({\n                type: \"loadData\",\n                path: path,\n                fullPath: window.location.origin + window.location.pathname,\n                id: processId\n            });\n        }\n        function completeAnimation(anim, onComplete, onError) {\n            setupWorker();\n            var processId = createProcess(onComplete, onError);\n            workerInstance.postMessage({\n                type: \"complete\",\n                animation: anim,\n                id: processId\n            });\n        }\n        return {\n            loadAnimation: loadAnimation,\n            loadData: loadData,\n            completeAnimation: completeAnimation\n        };\n    }();\n    var ImagePreloader = function() {\n        var proxyImage = function() {\n            var canvas = createTag(\"canvas\");\n            canvas.width = 1;\n            canvas.height = 1;\n            var ctx = canvas.getContext(\"2d\");\n            ctx.fillStyle = \"rgba(0,0,0,0)\";\n            ctx.fillRect(0, 0, 1, 1);\n            return canvas;\n        }();\n        function imageLoaded() {\n            this.loadedAssets += 1;\n            if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {\n                if (this.imagesLoadedCb) {\n                    this.imagesLoadedCb(null);\n                }\n            }\n        }\n        function footageLoaded() {\n            this.loadedFootagesCount += 1;\n            if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {\n                if (this.imagesLoadedCb) {\n                    this.imagesLoadedCb(null);\n                }\n            }\n        }\n        function getAssetsPath(assetData, assetsPath, originalPath) {\n            var path = \"\";\n            if (assetData.e) {\n                path = assetData.p;\n            } else if (assetsPath) {\n                var imagePath = assetData.p;\n                if (imagePath.indexOf(\"images/\") !== -1) {\n                    imagePath = imagePath.split(\"/\")[1];\n                }\n                path = assetsPath + imagePath;\n            } else {\n                path = originalPath;\n                path += assetData.u ? assetData.u : \"\";\n                path += assetData.p;\n            }\n            return path;\n        }\n        function testImageLoaded(img) {\n            var _count = 0;\n            var intervalId = setInterval((function() {\n                var box = img.getBBox();\n                if (box.width || _count > 500) {\n                    this._imageLoaded();\n                    clearInterval(intervalId);\n                }\n                _count += 1;\n            }).bind(this), 50);\n        }\n        function createImageData(assetData) {\n            var path = getAssetsPath(assetData, this.assetsPath, this.path);\n            var img = createNS(\"image\");\n            if (isSafari) {\n                this.testImageLoaded(img);\n            } else {\n                img.addEventListener(\"load\", this._imageLoaded, false);\n            }\n            img.addEventListener(\"error\", (function() {\n                ob.img = proxyImage;\n                this._imageLoaded();\n            }).bind(this), false);\n            img.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", path);\n            if (this._elementHelper.append) {\n                this._elementHelper.append(img);\n            } else {\n                this._elementHelper.appendChild(img);\n            }\n            var ob = {\n                img: img,\n                assetData: assetData\n            };\n            return ob;\n        }\n        function createImgData(assetData) {\n            var path = getAssetsPath(assetData, this.assetsPath, this.path);\n            var img = createTag(\"img\");\n            img.crossOrigin = \"anonymous\";\n            img.addEventListener(\"load\", this._imageLoaded, false);\n            img.addEventListener(\"error\", (function() {\n                ob.img = proxyImage;\n                this._imageLoaded();\n            }).bind(this), false);\n            img.src = path;\n            var ob = {\n                img: img,\n                assetData: assetData\n            };\n            return ob;\n        }\n        function createFootageData(data) {\n            var ob = {\n                assetData: data\n            };\n            var path = getAssetsPath(data, this.assetsPath, this.path);\n            dataManager.loadData(path, (function(footageData) {\n                ob.img = footageData;\n                this._footageLoaded();\n            }).bind(this), (function() {\n                ob.img = {};\n                this._footageLoaded();\n            }).bind(this));\n            return ob;\n        }\n        function loadAssets(assets, cb) {\n            this.imagesLoadedCb = cb;\n            var i;\n            var len = assets.length;\n            for(i = 0; i < len; i += 1){\n                if (!assets[i].layers) {\n                    if (!assets[i].t || assets[i].t === \"seq\") {\n                        this.totalImages += 1;\n                        this.images.push(this._createImageData(assets[i]));\n                    } else if (assets[i].t === 3) {\n                        this.totalFootages += 1;\n                        this.images.push(this.createFootageData(assets[i]));\n                    }\n                }\n            }\n        }\n        function setPath(path) {\n            this.path = path || \"\";\n        }\n        function setAssetsPath(path) {\n            this.assetsPath = path || \"\";\n        }\n        function getAsset(assetData) {\n            var i = 0;\n            var len = this.images.length;\n            while(i < len){\n                if (this.images[i].assetData === assetData) {\n                    return this.images[i].img;\n                }\n                i += 1;\n            }\n            return null;\n        }\n        function destroy() {\n            this.imagesLoadedCb = null;\n            this.images.length = 0;\n        }\n        function loadedImages() {\n            return this.totalImages === this.loadedAssets;\n        }\n        function loadedFootages() {\n            return this.totalFootages === this.loadedFootagesCount;\n        }\n        function setCacheType(type, elementHelper) {\n            if (type === \"svg\") {\n                this._elementHelper = elementHelper;\n                this._createImageData = this.createImageData.bind(this);\n            } else {\n                this._createImageData = this.createImgData.bind(this);\n            }\n        }\n        function ImagePreloaderFactory() {\n            this._imageLoaded = imageLoaded.bind(this);\n            this._footageLoaded = footageLoaded.bind(this);\n            this.testImageLoaded = testImageLoaded.bind(this);\n            this.createFootageData = createFootageData.bind(this);\n            this.assetsPath = \"\";\n            this.path = \"\";\n            this.totalImages = 0;\n            this.totalFootages = 0;\n            this.loadedAssets = 0;\n            this.loadedFootagesCount = 0;\n            this.imagesLoadedCb = null;\n            this.images = [];\n        }\n        ImagePreloaderFactory.prototype = {\n            loadAssets: loadAssets,\n            setAssetsPath: setAssetsPath,\n            setPath: setPath,\n            loadedImages: loadedImages,\n            loadedFootages: loadedFootages,\n            destroy: destroy,\n            getAsset: getAsset,\n            createImgData: createImgData,\n            createImageData: createImageData,\n            imageLoaded: imageLoaded,\n            footageLoaded: footageLoaded,\n            setCacheType: setCacheType\n        };\n        return ImagePreloaderFactory;\n    }();\n    function BaseEvent() {}\n    BaseEvent.prototype = {\n        triggerEvent: function triggerEvent(eventName, args) {\n            if (this._cbs[eventName]) {\n                var callbacks = this._cbs[eventName];\n                for(var i = 0; i < callbacks.length; i += 1){\n                    callbacks[i](args);\n                }\n            }\n        },\n        addEventListener: function addEventListener(eventName, callback) {\n            if (!this._cbs[eventName]) {\n                this._cbs[eventName] = [];\n            }\n            this._cbs[eventName].push(callback);\n            return (function() {\n                this.removeEventListener(eventName, callback);\n            }).bind(this);\n        },\n        removeEventListener: function removeEventListener(eventName, callback) {\n            if (!callback) {\n                this._cbs[eventName] = null;\n            } else if (this._cbs[eventName]) {\n                var i = 0;\n                var len = this._cbs[eventName].length;\n                while(i < len){\n                    if (this._cbs[eventName][i] === callback) {\n                        this._cbs[eventName].splice(i, 1);\n                        i -= 1;\n                        len -= 1;\n                    }\n                    i += 1;\n                }\n                if (!this._cbs[eventName].length) {\n                    this._cbs[eventName] = null;\n                }\n            }\n        }\n    };\n    var markerParser = function() {\n        function parsePayloadLines(payload) {\n            var lines = payload.split(\"\\r\\n\");\n            var keys = {};\n            var line;\n            var keysCount = 0;\n            for(var i = 0; i < lines.length; i += 1){\n                line = lines[i].split(\":\");\n                if (line.length === 2) {\n                    keys[line[0]] = line[1].trim();\n                    keysCount += 1;\n                }\n            }\n            if (keysCount === 0) {\n                throw new Error();\n            }\n            return keys;\n        }\n        return function(_markers) {\n            var markers = [];\n            for(var i = 0; i < _markers.length; i += 1){\n                var _marker = _markers[i];\n                var markerData = {\n                    time: _marker.tm,\n                    duration: _marker.dr\n                };\n                try {\n                    markerData.payload = JSON.parse(_markers[i].cm);\n                } catch (_) {\n                    try {\n                        markerData.payload = parsePayloadLines(_markers[i].cm);\n                    } catch (__) {\n                        markerData.payload = {\n                            name: _markers[i].cm\n                        };\n                    }\n                }\n                markers.push(markerData);\n            }\n            return markers;\n        };\n    }();\n    var ProjectInterface = function() {\n        function registerComposition(comp) {\n            this.compositions.push(comp);\n        }\n        return function() {\n            function _thisProjectFunction(name) {\n                var i = 0;\n                var len = this.compositions.length;\n                while(i < len){\n                    if (this.compositions[i].data && this.compositions[i].data.nm === name) {\n                        if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) {\n                            this.compositions[i].prepareFrame(this.currentFrame);\n                        }\n                        return this.compositions[i].compInterface;\n                    }\n                    i += 1;\n                }\n                return null;\n            }\n            _thisProjectFunction.compositions = [];\n            _thisProjectFunction.currentFrame = 0;\n            _thisProjectFunction.registerComposition = registerComposition;\n            return _thisProjectFunction;\n        };\n    }();\n    var renderers = {};\n    var registerRenderer = function registerRenderer(key, value) {\n        renderers[key] = value;\n    };\n    function getRenderer(key) {\n        return renderers[key];\n    }\n    function getRegisteredRenderer() {\n        // Returns canvas by default for compatibility\n        if (renderers.canvas) {\n            return \"canvas\";\n        } // Returns any renderer that is registered\n        for(var key in renderers){\n            if (renderers[key]) {\n                return key;\n            }\n        }\n        return \"\";\n    }\n    function _typeof$4(obj) {\n        \"@babel/helpers - typeof\";\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof$4 = function _typeof(obj) {\n                return typeof obj;\n            };\n        } else {\n            _typeof$4 = function _typeof(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n        }\n        return _typeof$4(obj);\n    }\n    var AnimationItem = function AnimationItem() {\n        this._cbs = [];\n        this.name = \"\";\n        this.path = \"\";\n        this.isLoaded = false;\n        this.currentFrame = 0;\n        this.currentRawFrame = 0;\n        this.firstFrame = 0;\n        this.totalFrames = 0;\n        this.frameRate = 0;\n        this.frameMult = 0;\n        this.playSpeed = 1;\n        this.playDirection = 1;\n        this.playCount = 0;\n        this.animationData = {};\n        this.assets = [];\n        this.isPaused = true;\n        this.autoplay = false;\n        this.loop = true;\n        this.renderer = null;\n        this.animationID = createElementID();\n        this.assetsPath = \"\";\n        this.timeCompleted = 0;\n        this.segmentPos = 0;\n        this.isSubframeEnabled = getSubframeEnabled();\n        this.segments = [];\n        this._idle = true;\n        this._completedLoop = false;\n        this.projectInterface = ProjectInterface();\n        this.imagePreloader = new ImagePreloader();\n        this.audioController = audioControllerFactory();\n        this.markers = [];\n        this.configAnimation = this.configAnimation.bind(this);\n        this.onSetupError = this.onSetupError.bind(this);\n        this.onSegmentComplete = this.onSegmentComplete.bind(this);\n        this.drawnFrameEvent = new BMEnterFrameEvent(\"drawnFrame\", 0, 0, 0);\n        this.expressionsPlugin = getExpressionsPlugin();\n    };\n    extendPrototype([\n        BaseEvent\n    ], AnimationItem);\n    AnimationItem.prototype.setParams = function(params) {\n        if (params.wrapper || params.container) {\n            this.wrapper = params.wrapper || params.container;\n        }\n        var animType = \"svg\";\n        if (params.animType) {\n            animType = params.animType;\n        } else if (params.renderer) {\n            animType = params.renderer;\n        }\n        var RendererClass = getRenderer(animType);\n        this.renderer = new RendererClass(this, params.rendererSettings);\n        this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);\n        this.renderer.setProjectInterface(this.projectInterface);\n        this.animType = animType;\n        if (params.loop === \"\" || params.loop === null || params.loop === undefined || params.loop === true) {\n            this.loop = true;\n        } else if (params.loop === false) {\n            this.loop = false;\n        } else {\n            this.loop = parseInt(params.loop, 10);\n        }\n        this.autoplay = \"autoplay\" in params ? params.autoplay : true;\n        this.name = params.name ? params.name : \"\";\n        this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, \"autoloadSegments\") ? params.autoloadSegments : true;\n        this.assetsPath = params.assetsPath;\n        this.initialSegment = params.initialSegment;\n        if (params.audioFactory) {\n            this.audioController.setAudioFactory(params.audioFactory);\n        }\n        if (params.animationData) {\n            this.setupAnimation(params.animationData);\n        } else if (params.path) {\n            if (params.path.lastIndexOf(\"\\\\\") !== -1) {\n                this.path = params.path.substr(0, params.path.lastIndexOf(\"\\\\\") + 1);\n            } else {\n                this.path = params.path.substr(0, params.path.lastIndexOf(\"/\") + 1);\n            }\n            this.fileName = params.path.substr(params.path.lastIndexOf(\"/\") + 1);\n            this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(\".json\"));\n            dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);\n        }\n    };\n    AnimationItem.prototype.onSetupError = function() {\n        this.trigger(\"data_failed\");\n    };\n    AnimationItem.prototype.setupAnimation = function(data) {\n        dataManager.completeAnimation(data, this.configAnimation);\n    };\n    AnimationItem.prototype.setData = function(wrapper, animationData) {\n        if (animationData) {\n            if (_typeof$4(animationData) !== \"object\") {\n                animationData = JSON.parse(animationData);\n            }\n        }\n        var params = {\n            wrapper: wrapper,\n            animationData: animationData\n        };\n        var wrapperAttributes = wrapper.attributes;\n        params.path = wrapperAttributes.getNamedItem(\"data-animation-path\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-animation-path\").value : wrapperAttributes.getNamedItem(\"data-bm-path\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-bm-path\").value : wrapperAttributes.getNamedItem(\"bm-path\") ? wrapperAttributes.getNamedItem(\"bm-path\").value : \"\";\n        params.animType = wrapperAttributes.getNamedItem(\"data-anim-type\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-anim-type\").value : wrapperAttributes.getNamedItem(\"data-bm-type\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-bm-type\").value : wrapperAttributes.getNamedItem(\"bm-type\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"bm-type\").value : wrapperAttributes.getNamedItem(\"data-bm-renderer\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-bm-renderer\").value : wrapperAttributes.getNamedItem(\"bm-renderer\") ? wrapperAttributes.getNamedItem(\"bm-renderer\").value : getRegisteredRenderer() || \"canvas\";\n        var loop = wrapperAttributes.getNamedItem(\"data-anim-loop\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-anim-loop\").value : wrapperAttributes.getNamedItem(\"data-bm-loop\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-bm-loop\").value : wrapperAttributes.getNamedItem(\"bm-loop\") ? wrapperAttributes.getNamedItem(\"bm-loop\").value : \"\";\n        if (loop === \"false\") {\n            params.loop = false;\n        } else if (loop === \"true\") {\n            params.loop = true;\n        } else if (loop !== \"\") {\n            params.loop = parseInt(loop, 10);\n        }\n        var autoplay = wrapperAttributes.getNamedItem(\"data-anim-autoplay\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-anim-autoplay\").value : wrapperAttributes.getNamedItem(\"data-bm-autoplay\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-bm-autoplay\").value : wrapperAttributes.getNamedItem(\"bm-autoplay\") ? wrapperAttributes.getNamedItem(\"bm-autoplay\").value : true;\n        params.autoplay = autoplay !== \"false\";\n        params.name = wrapperAttributes.getNamedItem(\"data-name\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-name\").value : wrapperAttributes.getNamedItem(\"data-bm-name\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-bm-name\").value : wrapperAttributes.getNamedItem(\"bm-name\") ? wrapperAttributes.getNamedItem(\"bm-name\").value : \"\";\n        var prerender = wrapperAttributes.getNamedItem(\"data-anim-prerender\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-anim-prerender\").value : wrapperAttributes.getNamedItem(\"data-bm-prerender\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-bm-prerender\").value : wrapperAttributes.getNamedItem(\"bm-prerender\") ? wrapperAttributes.getNamedItem(\"bm-prerender\").value : \"\";\n        if (prerender === \"false\") {\n            params.prerender = false;\n        }\n        if (!params.path) {\n            this.trigger(\"destroy\");\n        } else {\n            this.setParams(params);\n        }\n    };\n    AnimationItem.prototype.includeLayers = function(data) {\n        if (data.op > this.animationData.op) {\n            this.animationData.op = data.op;\n            this.totalFrames = Math.floor(data.op - this.animationData.ip);\n        }\n        var layers = this.animationData.layers;\n        var i;\n        var len = layers.length;\n        var newLayers = data.layers;\n        var j;\n        var jLen = newLayers.length;\n        for(j = 0; j < jLen; j += 1){\n            i = 0;\n            while(i < len){\n                if (layers[i].id === newLayers[j].id) {\n                    layers[i] = newLayers[j];\n                    break;\n                }\n                i += 1;\n            }\n        }\n        if (data.chars || data.fonts) {\n            this.renderer.globalData.fontManager.addChars(data.chars);\n            this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);\n        }\n        if (data.assets) {\n            len = data.assets.length;\n            for(i = 0; i < len; i += 1){\n                this.animationData.assets.push(data.assets[i]);\n            }\n        }\n        this.animationData.__complete = false;\n        dataManager.completeAnimation(this.animationData, this.onSegmentComplete);\n    };\n    AnimationItem.prototype.onSegmentComplete = function(data) {\n        this.animationData = data;\n        var expressionsPlugin = getExpressionsPlugin();\n        if (expressionsPlugin) {\n            expressionsPlugin.initExpressions(this);\n        }\n        this.loadNextSegment();\n    };\n    AnimationItem.prototype.loadNextSegment = function() {\n        var segments = this.animationData.segments;\n        if (!segments || segments.length === 0 || !this.autoloadSegments) {\n            this.trigger(\"data_ready\");\n            this.timeCompleted = this.totalFrames;\n            return;\n        }\n        var segment = segments.shift();\n        this.timeCompleted = segment.time * this.frameRate;\n        var segmentPath = this.path + this.fileName + \"_\" + this.segmentPos + \".json\";\n        this.segmentPos += 1;\n        dataManager.loadData(segmentPath, this.includeLayers.bind(this), (function() {\n            this.trigger(\"data_failed\");\n        }).bind(this));\n    };\n    AnimationItem.prototype.loadSegments = function() {\n        var segments = this.animationData.segments;\n        if (!segments) {\n            this.timeCompleted = this.totalFrames;\n        }\n        this.loadNextSegment();\n    };\n    AnimationItem.prototype.imagesLoaded = function() {\n        this.trigger(\"loaded_images\");\n        this.checkLoaded();\n    };\n    AnimationItem.prototype.preloadImages = function() {\n        this.imagePreloader.setAssetsPath(this.assetsPath);\n        this.imagePreloader.setPath(this.path);\n        this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));\n    };\n    AnimationItem.prototype.configAnimation = function(animData) {\n        if (!this.renderer) {\n            return;\n        }\n        try {\n            this.animationData = animData;\n            if (this.initialSegment) {\n                this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);\n                this.firstFrame = Math.round(this.initialSegment[0]);\n            } else {\n                this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);\n                this.firstFrame = Math.round(this.animationData.ip);\n            }\n            this.renderer.configAnimation(animData);\n            if (!animData.assets) {\n                animData.assets = [];\n            }\n            this.assets = this.animationData.assets;\n            this.frameRate = this.animationData.fr;\n            this.frameMult = this.animationData.fr / 1000;\n            this.renderer.searchExtraCompositions(animData.assets);\n            this.markers = markerParser(animData.markers || []);\n            this.trigger(\"config_ready\");\n            this.preloadImages();\n            this.loadSegments();\n            this.updaFrameModifier();\n            this.waitForFontsLoaded();\n            if (this.isPaused) {\n                this.audioController.pause();\n            }\n        } catch (error) {\n            this.triggerConfigError(error);\n        }\n    };\n    AnimationItem.prototype.waitForFontsLoaded = function() {\n        if (!this.renderer) {\n            return;\n        }\n        if (this.renderer.globalData.fontManager.isLoaded) {\n            this.checkLoaded();\n        } else {\n            setTimeout(this.waitForFontsLoaded.bind(this), 20);\n        }\n    };\n    AnimationItem.prototype.checkLoaded = function() {\n        if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== \"canvas\") && this.imagePreloader.loadedFootages()) {\n            this.isLoaded = true;\n            var expressionsPlugin = getExpressionsPlugin();\n            if (expressionsPlugin) {\n                expressionsPlugin.initExpressions(this);\n            }\n            this.renderer.initItems();\n            setTimeout((function() {\n                this.trigger(\"DOMLoaded\");\n            }).bind(this), 0);\n            this.gotoFrame();\n            if (this.autoplay) {\n                this.play();\n            }\n        }\n    };\n    AnimationItem.prototype.resize = function(width, height) {\n        // Adding this validation for backwards compatibility in case an event object was being passed down\n        var _width = typeof width === \"number\" ? width : undefined;\n        var _height = typeof height === \"number\" ? height : undefined;\n        this.renderer.updateContainerSize(_width, _height);\n    };\n    AnimationItem.prototype.setSubframe = function(flag) {\n        this.isSubframeEnabled = !!flag;\n    };\n    AnimationItem.prototype.gotoFrame = function() {\n        this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame; // eslint-disable-line no-bitwise\n        if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {\n            this.currentFrame = this.timeCompleted;\n        }\n        this.trigger(\"enterFrame\");\n        this.renderFrame();\n        this.trigger(\"drawnFrame\");\n    };\n    AnimationItem.prototype.renderFrame = function() {\n        if (this.isLoaded === false || !this.renderer) {\n            return;\n        }\n        try {\n            if (this.expressionsPlugin) {\n                this.expressionsPlugin.resetFrame();\n            }\n            this.renderer.renderFrame(this.currentFrame + this.firstFrame);\n        } catch (error) {\n            this.triggerRenderFrameError(error);\n        }\n    };\n    AnimationItem.prototype.play = function(name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        if (this.isPaused === true) {\n            this.isPaused = false;\n            this.trigger(\"_play\");\n            this.audioController.resume();\n            if (this._idle) {\n                this._idle = false;\n                this.trigger(\"_active\");\n            }\n        }\n    };\n    AnimationItem.prototype.pause = function(name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        if (this.isPaused === false) {\n            this.isPaused = true;\n            this.trigger(\"_pause\");\n            this._idle = true;\n            this.trigger(\"_idle\");\n            this.audioController.pause();\n        }\n    };\n    AnimationItem.prototype.togglePause = function(name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        if (this.isPaused === true) {\n            this.play();\n        } else {\n            this.pause();\n        }\n    };\n    AnimationItem.prototype.stop = function(name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        this.pause();\n        this.playCount = 0;\n        this._completedLoop = false;\n        this.setCurrentRawFrameValue(0);\n    };\n    AnimationItem.prototype.getMarkerData = function(markerName) {\n        var marker;\n        for(var i = 0; i < this.markers.length; i += 1){\n            marker = this.markers[i];\n            if (marker.payload && marker.payload.name === markerName) {\n                return marker;\n            }\n        }\n        return null;\n    };\n    AnimationItem.prototype.goToAndStop = function(value, isFrame, name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        var numValue = Number(value);\n        if (isNaN(numValue)) {\n            var marker = this.getMarkerData(value);\n            if (marker) {\n                this.goToAndStop(marker.time, true);\n            }\n        } else if (isFrame) {\n            this.setCurrentRawFrameValue(value);\n        } else {\n            this.setCurrentRawFrameValue(value * this.frameModifier);\n        }\n        this.pause();\n    };\n    AnimationItem.prototype.goToAndPlay = function(value, isFrame, name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        var numValue = Number(value);\n        if (isNaN(numValue)) {\n            var marker = this.getMarkerData(value);\n            if (marker) {\n                if (!marker.duration) {\n                    this.goToAndStop(marker.time, true);\n                } else {\n                    this.playSegments([\n                        marker.time,\n                        marker.time + marker.duration\n                    ], true);\n                }\n            }\n        } else {\n            this.goToAndStop(numValue, isFrame, name);\n        }\n        this.play();\n    };\n    AnimationItem.prototype.advanceTime = function(value) {\n        if (this.isPaused === true || this.isLoaded === false) {\n            return;\n        }\n        var nextValue = this.currentRawFrame + value * this.frameModifier;\n        var _isComplete = false; // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.\n        // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.\n        if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {\n            if (!this.loop || this.playCount === this.loop) {\n                if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {\n                    _isComplete = true;\n                    nextValue = this.totalFrames - 1;\n                }\n            } else if (nextValue >= this.totalFrames) {\n                this.playCount += 1;\n                if (!this.checkSegments(nextValue % this.totalFrames)) {\n                    this.setCurrentRawFrameValue(nextValue % this.totalFrames);\n                    this._completedLoop = true;\n                    this.trigger(\"loopComplete\");\n                }\n            } else {\n                this.setCurrentRawFrameValue(nextValue);\n            }\n        } else if (nextValue < 0) {\n            if (!this.checkSegments(nextValue % this.totalFrames)) {\n                if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {\n                    // eslint-disable-line no-plusplus\n                    this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);\n                    if (!this._completedLoop) {\n                        this._completedLoop = true;\n                    } else {\n                        this.trigger(\"loopComplete\");\n                    }\n                } else {\n                    _isComplete = true;\n                    nextValue = 0;\n                }\n            }\n        } else {\n            this.setCurrentRawFrameValue(nextValue);\n        }\n        if (_isComplete) {\n            this.setCurrentRawFrameValue(nextValue);\n            this.pause();\n            this.trigger(\"complete\");\n        }\n    };\n    AnimationItem.prototype.adjustSegment = function(arr, offset) {\n        this.playCount = 0;\n        if (arr[1] < arr[0]) {\n            if (this.frameModifier > 0) {\n                if (this.playSpeed < 0) {\n                    this.setSpeed(-this.playSpeed);\n                } else {\n                    this.setDirection(-1);\n                }\n            }\n            this.totalFrames = arr[0] - arr[1];\n            this.timeCompleted = this.totalFrames;\n            this.firstFrame = arr[1];\n            this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);\n        } else if (arr[1] > arr[0]) {\n            if (this.frameModifier < 0) {\n                if (this.playSpeed < 0) {\n                    this.setSpeed(-this.playSpeed);\n                } else {\n                    this.setDirection(1);\n                }\n            }\n            this.totalFrames = arr[1] - arr[0];\n            this.timeCompleted = this.totalFrames;\n            this.firstFrame = arr[0];\n            this.setCurrentRawFrameValue(0.001 + offset);\n        }\n        this.trigger(\"segmentStart\");\n    };\n    AnimationItem.prototype.setSegment = function(init, end) {\n        var pendingFrame = -1;\n        if (this.isPaused) {\n            if (this.currentRawFrame + this.firstFrame < init) {\n                pendingFrame = init;\n            } else if (this.currentRawFrame + this.firstFrame > end) {\n                pendingFrame = end - init;\n            }\n        }\n        this.firstFrame = init;\n        this.totalFrames = end - init;\n        this.timeCompleted = this.totalFrames;\n        if (pendingFrame !== -1) {\n            this.goToAndStop(pendingFrame, true);\n        }\n    };\n    AnimationItem.prototype.playSegments = function(arr, forceFlag) {\n        if (forceFlag) {\n            this.segments.length = 0;\n        }\n        if (_typeof$4(arr[0]) === \"object\") {\n            var i;\n            var len = arr.length;\n            for(i = 0; i < len; i += 1){\n                this.segments.push(arr[i]);\n            }\n        } else {\n            this.segments.push(arr);\n        }\n        if (this.segments.length && forceFlag) {\n            this.adjustSegment(this.segments.shift(), 0);\n        }\n        if (this.isPaused) {\n            this.play();\n        }\n    };\n    AnimationItem.prototype.resetSegments = function(forceFlag) {\n        this.segments.length = 0;\n        this.segments.push([\n            this.animationData.ip,\n            this.animationData.op\n        ]);\n        if (forceFlag) {\n            this.checkSegments(0);\n        }\n    };\n    AnimationItem.prototype.checkSegments = function(offset) {\n        if (this.segments.length) {\n            this.adjustSegment(this.segments.shift(), offset);\n            return true;\n        }\n        return false;\n    };\n    AnimationItem.prototype.destroy = function(name) {\n        if (name && this.name !== name || !this.renderer) {\n            return;\n        }\n        this.renderer.destroy();\n        this.imagePreloader.destroy();\n        this.trigger(\"destroy\");\n        this._cbs = null;\n        this.onEnterFrame = null;\n        this.onLoopComplete = null;\n        this.onComplete = null;\n        this.onSegmentStart = null;\n        this.onDestroy = null;\n        this.renderer = null;\n        this.expressionsPlugin = null;\n        this.imagePreloader = null;\n        this.projectInterface = null;\n    };\n    AnimationItem.prototype.setCurrentRawFrameValue = function(value) {\n        this.currentRawFrame = value;\n        this.gotoFrame();\n    };\n    AnimationItem.prototype.setSpeed = function(val) {\n        this.playSpeed = val;\n        this.updaFrameModifier();\n    };\n    AnimationItem.prototype.setDirection = function(val) {\n        this.playDirection = val < 0 ? -1 : 1;\n        this.updaFrameModifier();\n    };\n    AnimationItem.prototype.setLoop = function(isLooping) {\n        this.loop = isLooping;\n    };\n    AnimationItem.prototype.setVolume = function(val, name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        this.audioController.setVolume(val);\n    };\n    AnimationItem.prototype.getVolume = function() {\n        return this.audioController.getVolume();\n    };\n    AnimationItem.prototype.mute = function(name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        this.audioController.mute();\n    };\n    AnimationItem.prototype.unmute = function(name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        this.audioController.unmute();\n    };\n    AnimationItem.prototype.updaFrameModifier = function() {\n        this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;\n        this.audioController.setRate(this.playSpeed * this.playDirection);\n    };\n    AnimationItem.prototype.getPath = function() {\n        return this.path;\n    };\n    AnimationItem.prototype.getAssetsPath = function(assetData) {\n        var path = \"\";\n        if (assetData.e) {\n            path = assetData.p;\n        } else if (this.assetsPath) {\n            var imagePath = assetData.p;\n            if (imagePath.indexOf(\"images/\") !== -1) {\n                imagePath = imagePath.split(\"/\")[1];\n            }\n            path = this.assetsPath + imagePath;\n        } else {\n            path = this.path;\n            path += assetData.u ? assetData.u : \"\";\n            path += assetData.p;\n        }\n        return path;\n    };\n    AnimationItem.prototype.getAssetData = function(id) {\n        var i = 0;\n        var len = this.assets.length;\n        while(i < len){\n            if (id === this.assets[i].id) {\n                return this.assets[i];\n            }\n            i += 1;\n        }\n        return null;\n    };\n    AnimationItem.prototype.hide = function() {\n        this.renderer.hide();\n    };\n    AnimationItem.prototype.show = function() {\n        this.renderer.show();\n    };\n    AnimationItem.prototype.getDuration = function(isFrame) {\n        return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;\n    };\n    AnimationItem.prototype.updateDocumentData = function(path, documentData, index) {\n        try {\n            var element = this.renderer.getElementByPath(path);\n            element.updateDocumentData(documentData, index);\n        } catch (error) {}\n    };\n    AnimationItem.prototype.trigger = function(name) {\n        if (this._cbs && this._cbs[name]) {\n            switch(name){\n                case \"enterFrame\":\n                    this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));\n                    break;\n                case \"drawnFrame\":\n                    this.drawnFrameEvent.currentTime = this.currentFrame;\n                    this.drawnFrameEvent.totalTime = this.totalFrames;\n                    this.drawnFrameEvent.direction = this.frameModifier;\n                    this.triggerEvent(name, this.drawnFrameEvent);\n                    break;\n                case \"loopComplete\":\n                    this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));\n                    break;\n                case \"complete\":\n                    this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));\n                    break;\n                case \"segmentStart\":\n                    this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));\n                    break;\n                case \"destroy\":\n                    this.triggerEvent(name, new BMDestroyEvent(name, this));\n                    break;\n                default:\n                    this.triggerEvent(name);\n            }\n        }\n        if (name === \"enterFrame\" && this.onEnterFrame) {\n            this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult));\n        }\n        if (name === \"loopComplete\" && this.onLoopComplete) {\n            this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));\n        }\n        if (name === \"complete\" && this.onComplete) {\n            this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult));\n        }\n        if (name === \"segmentStart\" && this.onSegmentStart) {\n            this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));\n        }\n        if (name === \"destroy\" && this.onDestroy) {\n            this.onDestroy.call(this, new BMDestroyEvent(name, this));\n        }\n    };\n    AnimationItem.prototype.triggerRenderFrameError = function(nativeError) {\n        var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);\n        this.triggerEvent(\"error\", error);\n        if (this.onError) {\n            this.onError.call(this, error);\n        }\n    };\n    AnimationItem.prototype.triggerConfigError = function(nativeError) {\n        var error = new BMConfigErrorEvent(nativeError, this.currentFrame);\n        this.triggerEvent(\"error\", error);\n        if (this.onError) {\n            this.onError.call(this, error);\n        }\n    };\n    var animationManager = function() {\n        var moduleOb = {};\n        var registeredAnimations = [];\n        var initTime = 0;\n        var len = 0;\n        var playingAnimationsNum = 0;\n        var _stopped = true;\n        var _isFrozen = false;\n        function removeElement(ev) {\n            var i = 0;\n            var animItem = ev.target;\n            while(i < len){\n                if (registeredAnimations[i].animation === animItem) {\n                    registeredAnimations.splice(i, 1);\n                    i -= 1;\n                    len -= 1;\n                    if (!animItem.isPaused) {\n                        subtractPlayingCount();\n                    }\n                }\n                i += 1;\n            }\n        }\n        function registerAnimation(element, animationData) {\n            if (!element) {\n                return null;\n            }\n            var i = 0;\n            while(i < len){\n                if (registeredAnimations[i].elem === element && registeredAnimations[i].elem !== null) {\n                    return registeredAnimations[i].animation;\n                }\n                i += 1;\n            }\n            var animItem = new AnimationItem();\n            setupAnimation(animItem, element);\n            animItem.setData(element, animationData);\n            return animItem;\n        }\n        function getRegisteredAnimations() {\n            var i;\n            var lenAnims = registeredAnimations.length;\n            var animations = [];\n            for(i = 0; i < lenAnims; i += 1){\n                animations.push(registeredAnimations[i].animation);\n            }\n            return animations;\n        }\n        function addPlayingCount() {\n            playingAnimationsNum += 1;\n            activate();\n        }\n        function subtractPlayingCount() {\n            playingAnimationsNum -= 1;\n        }\n        function setupAnimation(animItem, element) {\n            animItem.addEventListener(\"destroy\", removeElement);\n            animItem.addEventListener(\"_active\", addPlayingCount);\n            animItem.addEventListener(\"_idle\", subtractPlayingCount);\n            registeredAnimations.push({\n                elem: element,\n                animation: animItem\n            });\n            len += 1;\n        }\n        function loadAnimation(params) {\n            var animItem = new AnimationItem();\n            setupAnimation(animItem, null);\n            animItem.setParams(params);\n            return animItem;\n        }\n        function setSpeed(val, animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.setSpeed(val, animation);\n            }\n        }\n        function setDirection(val, animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.setDirection(val, animation);\n            }\n        }\n        function play(animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.play(animation);\n            }\n        }\n        function resume(nowTime) {\n            var elapsedTime = nowTime - initTime;\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.advanceTime(elapsedTime);\n            }\n            initTime = nowTime;\n            if (playingAnimationsNum && !_isFrozen) {\n                window.requestAnimationFrame(resume);\n            } else {\n                _stopped = true;\n            }\n        }\n        function first(nowTime) {\n            initTime = nowTime;\n            window.requestAnimationFrame(resume);\n        }\n        function pause(animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.pause(animation);\n            }\n        }\n        function goToAndStop(value, isFrame, animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.goToAndStop(value, isFrame, animation);\n            }\n        }\n        function stop(animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.stop(animation);\n            }\n        }\n        function togglePause(animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.togglePause(animation);\n            }\n        }\n        function destroy(animation) {\n            var i;\n            for(i = len - 1; i >= 0; i -= 1){\n                registeredAnimations[i].animation.destroy(animation);\n            }\n        }\n        function searchAnimations(animationData, standalone, renderer) {\n            var animElements = [].concat([].slice.call(document.getElementsByClassName(\"lottie\")), [].slice.call(document.getElementsByClassName(\"bodymovin\")));\n            var i;\n            var lenAnims = animElements.length;\n            for(i = 0; i < lenAnims; i += 1){\n                if (renderer) {\n                    animElements[i].setAttribute(\"data-bm-type\", renderer);\n                }\n                registerAnimation(animElements[i], animationData);\n            }\n            if (standalone && lenAnims === 0) {\n                if (!renderer) {\n                    renderer = \"svg\";\n                }\n                var body = document.getElementsByTagName(\"body\")[0];\n                body.innerText = \"\";\n                var div = createTag(\"div\");\n                div.style.width = \"100%\";\n                div.style.height = \"100%\";\n                div.setAttribute(\"data-bm-type\", renderer);\n                body.appendChild(div);\n                registerAnimation(div, animationData);\n            }\n        }\n        function resize() {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.resize();\n            }\n        }\n        function activate() {\n            if (!_isFrozen && playingAnimationsNum) {\n                if (_stopped) {\n                    window.requestAnimationFrame(first);\n                    _stopped = false;\n                }\n            }\n        }\n        function freeze() {\n            _isFrozen = true;\n        }\n        function unfreeze() {\n            _isFrozen = false;\n            activate();\n        }\n        function setVolume(val, animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.setVolume(val, animation);\n            }\n        }\n        function mute(animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.mute(animation);\n            }\n        }\n        function unmute(animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.unmute(animation);\n            }\n        }\n        moduleOb.registerAnimation = registerAnimation;\n        moduleOb.loadAnimation = loadAnimation;\n        moduleOb.setSpeed = setSpeed;\n        moduleOb.setDirection = setDirection;\n        moduleOb.play = play;\n        moduleOb.pause = pause;\n        moduleOb.stop = stop;\n        moduleOb.togglePause = togglePause;\n        moduleOb.searchAnimations = searchAnimations;\n        moduleOb.resize = resize; // moduleOb.start = start;\n        moduleOb.goToAndStop = goToAndStop;\n        moduleOb.destroy = destroy;\n        moduleOb.freeze = freeze;\n        moduleOb.unfreeze = unfreeze;\n        moduleOb.setVolume = setVolume;\n        moduleOb.mute = mute;\n        moduleOb.unmute = unmute;\n        moduleOb.getRegisteredAnimations = getRegisteredAnimations;\n        return moduleOb;\n    }();\n    /* eslint-disable */ var BezierFactory = function() {\n        /**\r\n       * BezierEasing - use bezier curve for transition easing function\r\n       * by Gatan Renaudeau 2014 - 2015  MIT License\r\n       *\r\n       * Credits: is based on Firefox's nsSMILKeySpline.cpp\r\n       * Usage:\r\n       * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])\r\n       * spline.get(x) => returns the easing value | x must be in [0, 1] range\r\n       *\r\n       */ var ob = {};\n        ob.getBezierEasing = getBezierEasing;\n        var beziers = {};\n        function getBezierEasing(a, b, c, d, nm) {\n            var str = nm || (\"bez_\" + a + \"_\" + b + \"_\" + c + \"_\" + d).replace(/\\./g, \"p\");\n            if (beziers[str]) {\n                return beziers[str];\n            }\n            var bezEasing = new BezierEasing([\n                a,\n                b,\n                c,\n                d\n            ]);\n            beziers[str] = bezEasing;\n            return bezEasing;\n        } // These values are established by empiricism with tests (tradeoff: performance VS precision)\n        var NEWTON_ITERATIONS = 4;\n        var NEWTON_MIN_SLOPE = 0.001;\n        var SUBDIVISION_PRECISION = 0.0000001;\n        var SUBDIVISION_MAX_ITERATIONS = 10;\n        var kSplineTableSize = 11;\n        var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n        var float32ArraySupported = typeof Float32Array === \"function\";\n        function A(aA1, aA2) {\n            return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n        }\n        function B(aA1, aA2) {\n            return 3.0 * aA2 - 6.0 * aA1;\n        }\n        function C(aA1) {\n            return 3.0 * aA1;\n        } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n        function calcBezier(aT, aA1, aA2) {\n            return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n        } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n        function getSlope(aT, aA1, aA2) {\n            return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n        }\n        function binarySubdivide(aX, aA, aB, mX1, mX2) {\n            var currentX, currentT, i = 0;\n            do {\n                currentT = aA + (aB - aA) / 2.0;\n                currentX = calcBezier(currentT, mX1, mX2) - aX;\n                if (currentX > 0.0) {\n                    aB = currentT;\n                } else {\n                    aA = currentT;\n                }\n            }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n            return currentT;\n        }\n        function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n            for(var i = 0; i < NEWTON_ITERATIONS; ++i){\n                var currentSlope = getSlope(aGuessT, mX1, mX2);\n                if (currentSlope === 0.0) return aGuessT;\n                var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n                aGuessT -= currentX / currentSlope;\n            }\n            return aGuessT;\n        }\n        /**\r\n       * points is an array of [ mX1, mY1, mX2, mY2 ]\r\n       */ function BezierEasing(points) {\n            this._p = points;\n            this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n            this._precomputed = false;\n            this.get = this.get.bind(this);\n        }\n        BezierEasing.prototype = {\n            get: function get(x) {\n                var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];\n                if (!this._precomputed) this._precompute();\n                if (mX1 === mY1 && mX2 === mY2) return x; // linear\n                // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n                if (x === 0) return 0;\n                if (x === 1) return 1;\n                return calcBezier(this._getTForX(x), mY1, mY2);\n            },\n            // Private part\n            _precompute: function _precompute() {\n                var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];\n                this._precomputed = true;\n                if (mX1 !== mY1 || mX2 !== mY2) {\n                    this._calcSampleValues();\n                }\n            },\n            _calcSampleValues: function _calcSampleValues() {\n                var mX1 = this._p[0], mX2 = this._p[2];\n                for(var i = 0; i < kSplineTableSize; ++i){\n                    this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n                }\n            },\n            /**\r\n           * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.\r\n           */ _getTForX: function _getTForX(aX) {\n                var mX1 = this._p[0], mX2 = this._p[2], mSampleValues = this._mSampleValues;\n                var intervalStart = 0.0;\n                var currentSample = 1;\n                var lastSample = kSplineTableSize - 1;\n                for(; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample){\n                    intervalStart += kSampleStepSize;\n                }\n                --currentSample; // Interpolate to provide an initial guess for t\n                var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);\n                var guessForT = intervalStart + dist * kSampleStepSize;\n                var initialSlope = getSlope(guessForT, mX1, mX2);\n                if (initialSlope >= NEWTON_MIN_SLOPE) {\n                    return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n                }\n                if (initialSlope === 0.0) {\n                    return guessForT;\n                }\n                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n            }\n        };\n        return ob;\n    }();\n    var pooling = function() {\n        function _double(arr) {\n            return arr.concat(createSizedArray(arr.length));\n        }\n        return {\n            \"double\": _double\n        };\n    }();\n    var poolFactory = function() {\n        return function(initialLength, _create, _release) {\n            var _length = 0;\n            var _maxLength = initialLength;\n            var pool = createSizedArray(_maxLength);\n            var ob = {\n                newElement: newElement,\n                release: release\n            };\n            function newElement() {\n                var element;\n                if (_length) {\n                    _length -= 1;\n                    element = pool[_length];\n                } else {\n                    element = _create();\n                }\n                return element;\n            }\n            function release(element) {\n                if (_length === _maxLength) {\n                    pool = pooling[\"double\"](pool);\n                    _maxLength *= 2;\n                }\n                if (_release) {\n                    _release(element);\n                }\n                pool[_length] = element;\n                _length += 1;\n            }\n            return ob;\n        };\n    }();\n    var bezierLengthPool = function() {\n        function create() {\n            return {\n                addedLength: 0,\n                percents: createTypedArray(\"float32\", getDefaultCurveSegments()),\n                lengths: createTypedArray(\"float32\", getDefaultCurveSegments())\n            };\n        }\n        return poolFactory(8, create);\n    }();\n    var segmentsLengthPool = function() {\n        function create() {\n            return {\n                lengths: [],\n                totalLength: 0\n            };\n        }\n        function release(element) {\n            var i;\n            var len = element.lengths.length;\n            for(i = 0; i < len; i += 1){\n                bezierLengthPool.release(element.lengths[i]);\n            }\n            element.lengths.length = 0;\n        }\n        return poolFactory(8, create, release);\n    }();\n    function bezFunction() {\n        var math = Math;\n        function pointOnLine2D(x1, y1, x2, y2, x3, y3) {\n            var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;\n            return det1 > -0.001 && det1 < 0.001;\n        }\n        function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {\n            if (z1 === 0 && z2 === 0 && z3 === 0) {\n                return pointOnLine2D(x1, y1, x2, y2, x3, y3);\n            }\n            var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));\n            var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));\n            var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));\n            var diffDist;\n            if (dist1 > dist2) {\n                if (dist1 > dist3) {\n                    diffDist = dist1 - dist2 - dist3;\n                } else {\n                    diffDist = dist3 - dist2 - dist1;\n                }\n            } else if (dist3 > dist2) {\n                diffDist = dist3 - dist2 - dist1;\n            } else {\n                diffDist = dist2 - dist1 - dist3;\n            }\n            return diffDist > -0.0001 && diffDist < 0.0001;\n        }\n        var getBezierLength = function() {\n            return function(pt1, pt2, pt3, pt4) {\n                var curveSegments = getDefaultCurveSegments();\n                var k;\n                var i;\n                var len;\n                var ptCoord;\n                var perc;\n                var addedLength = 0;\n                var ptDistance;\n                var point = [];\n                var lastPoint = [];\n                var lengthData = bezierLengthPool.newElement();\n                len = pt3.length;\n                for(k = 0; k < curveSegments; k += 1){\n                    perc = k / (curveSegments - 1);\n                    ptDistance = 0;\n                    for(i = 0; i < len; i += 1){\n                        ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i] + bmPow(perc, 3) * pt2[i];\n                        point[i] = ptCoord;\n                        if (lastPoint[i] !== null) {\n                            ptDistance += bmPow(point[i] - lastPoint[i], 2);\n                        }\n                        lastPoint[i] = point[i];\n                    }\n                    if (ptDistance) {\n                        ptDistance = bmSqrt(ptDistance);\n                        addedLength += ptDistance;\n                    }\n                    lengthData.percents[k] = perc;\n                    lengthData.lengths[k] = addedLength;\n                }\n                lengthData.addedLength = addedLength;\n                return lengthData;\n            };\n        }();\n        function getSegmentsLength(shapeData) {\n            var segmentsLength = segmentsLengthPool.newElement();\n            var closed = shapeData.c;\n            var pathV = shapeData.v;\n            var pathO = shapeData.o;\n            var pathI = shapeData.i;\n            var i;\n            var len = shapeData._length;\n            var lengths = segmentsLength.lengths;\n            var totalLength = 0;\n            for(i = 0; i < len - 1; i += 1){\n                lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]);\n                totalLength += lengths[i].addedLength;\n            }\n            if (closed && len) {\n                lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]);\n                totalLength += lengths[i].addedLength;\n            }\n            segmentsLength.totalLength = totalLength;\n            return segmentsLength;\n        }\n        function BezierData(length) {\n            this.segmentLength = 0;\n            this.points = new Array(length);\n        }\n        function PointData(partial, point) {\n            this.partialLength = partial;\n            this.point = point;\n        }\n        var buildBezierData = function() {\n            var storedData = {};\n            return function(pt1, pt2, pt3, pt4) {\n                var bezierName = (pt1[0] + \"_\" + pt1[1] + \"_\" + pt2[0] + \"_\" + pt2[1] + \"_\" + pt3[0] + \"_\" + pt3[1] + \"_\" + pt4[0] + \"_\" + pt4[1]).replace(/\\./g, \"p\");\n                if (!storedData[bezierName]) {\n                    var curveSegments = getDefaultCurveSegments();\n                    var k;\n                    var i;\n                    var len;\n                    var ptCoord;\n                    var perc;\n                    var addedLength = 0;\n                    var ptDistance;\n                    var point;\n                    var lastPoint = null;\n                    if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {\n                        curveSegments = 2;\n                    }\n                    var bezierData = new BezierData(curveSegments);\n                    len = pt3.length;\n                    for(k = 0; k < curveSegments; k += 1){\n                        point = createSizedArray(len);\n                        perc = k / (curveSegments - 1);\n                        ptDistance = 0;\n                        for(i = 0; i < len; i += 1){\n                            ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) + bmPow(perc, 3) * pt2[i];\n                            point[i] = ptCoord;\n                            if (lastPoint !== null) {\n                                ptDistance += bmPow(point[i] - lastPoint[i], 2);\n                            }\n                        }\n                        ptDistance = bmSqrt(ptDistance);\n                        addedLength += ptDistance;\n                        bezierData.points[k] = new PointData(ptDistance, point);\n                        lastPoint = point;\n                    }\n                    bezierData.segmentLength = addedLength;\n                    storedData[bezierName] = bezierData;\n                }\n                return storedData[bezierName];\n            };\n        }();\n        function getDistancePerc(perc, bezierData) {\n            var percents = bezierData.percents;\n            var lengths = bezierData.lengths;\n            var len = percents.length;\n            var initPos = bmFloor((len - 1) * perc);\n            var lengthPos = perc * bezierData.addedLength;\n            var lPerc = 0;\n            if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {\n                return percents[initPos];\n            }\n            var dir = lengths[initPos] > lengthPos ? -1 : 1;\n            var flag = true;\n            while(flag){\n                if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {\n                    lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);\n                    flag = false;\n                } else {\n                    initPos += dir;\n                }\n                if (initPos < 0 || initPos >= len - 1) {\n                    // FIX for TypedArrays that don't store floating point values with enough accuracy\n                    if (initPos === len - 1) {\n                        return percents[initPos];\n                    }\n                    flag = false;\n                }\n            }\n            return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;\n        }\n        function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {\n            var t1 = getDistancePerc(percent, bezierData);\n            var u1 = 1 - t1;\n            var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1000) / 1000;\n            var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1000) / 1000;\n            return [\n                ptX,\n                ptY\n            ];\n        }\n        var bezierSegmentPoints = createTypedArray(\"float32\", 8);\n        function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {\n            if (startPerc < 0) {\n                startPerc = 0;\n            } else if (startPerc > 1) {\n                startPerc = 1;\n            }\n            var t0 = getDistancePerc(startPerc, bezierData);\n            endPerc = endPerc > 1 ? 1 : endPerc;\n            var t1 = getDistancePerc(endPerc, bezierData);\n            var i;\n            var len = pt1.length;\n            var u0 = 1 - t0;\n            var u1 = 1 - t1;\n            var u0u0u0 = u0 * u0 * u0;\n            var t0u0u0_3 = t0 * u0 * u0 * 3; // eslint-disable-line camelcase\n            var t0t0u0_3 = t0 * t0 * u0 * 3; // eslint-disable-line camelcase\n            var t0t0t0 = t0 * t0 * t0; //\n            var u0u0u1 = u0 * u0 * u1;\n            var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1; // eslint-disable-line camelcase\n            var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1; // eslint-disable-line camelcase\n            var t0t0t1 = t0 * t0 * t1; //\n            var u0u1u1 = u0 * u1 * u1;\n            var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1; // eslint-disable-line camelcase\n            var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1; // eslint-disable-line camelcase\n            var t0t1t1 = t0 * t1 * t1; //\n            var u1u1u1 = u1 * u1 * u1;\n            var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1; // eslint-disable-line camelcase\n            var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1; // eslint-disable-line camelcase\n            var t1t1t1 = t1 * t1 * t1;\n            for(i = 0; i < len; i += 1){\n                bezierSegmentPoints[i * 4] = math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n                bezierSegmentPoints[i * 4 + 1] = math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n                bezierSegmentPoints[i * 4 + 2] = math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n                bezierSegmentPoints[i * 4 + 3] = math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n            }\n            return bezierSegmentPoints;\n        }\n        return {\n            getSegmentsLength: getSegmentsLength,\n            getNewSegment: getNewSegment,\n            getPointInSegment: getPointInSegment,\n            buildBezierData: buildBezierData,\n            pointOnLine2D: pointOnLine2D,\n            pointOnLine3D: pointOnLine3D\n        };\n    }\n    var bez = bezFunction();\n    var initFrame = initialDefaultFrame;\n    var mathAbs = Math.abs;\n    function interpolateValue(frameNum, caching) {\n        var offsetTime = this.offsetTime;\n        var newValue;\n        if (this.propType === \"multidimensional\") {\n            newValue = createTypedArray(\"float32\", this.pv.length);\n        }\n        var iterationIndex = caching.lastIndex;\n        var i = iterationIndex;\n        var len = this.keyframes.length - 1;\n        var flag = true;\n        var keyData;\n        var nextKeyData;\n        var keyframeMetadata;\n        while(flag){\n            keyData = this.keyframes[i];\n            nextKeyData = this.keyframes[i + 1];\n            if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {\n                if (keyData.h) {\n                    keyData = nextKeyData;\n                }\n                iterationIndex = 0;\n                break;\n            }\n            if (nextKeyData.t - offsetTime > frameNum) {\n                iterationIndex = i;\n                break;\n            }\n            if (i < len - 1) {\n                i += 1;\n            } else {\n                iterationIndex = 0;\n                flag = false;\n            }\n        }\n        keyframeMetadata = this.keyframesMetadata[i] || {};\n        var k;\n        var kLen;\n        var perc;\n        var jLen;\n        var j;\n        var fnc;\n        var nextKeyTime = nextKeyData.t - offsetTime;\n        var keyTime = keyData.t - offsetTime;\n        var endValue;\n        if (keyData.to) {\n            if (!keyframeMetadata.bezierData) {\n                keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);\n            }\n            var bezierData = keyframeMetadata.bezierData;\n            if (frameNum >= nextKeyTime || frameNum < keyTime) {\n                var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;\n                kLen = bezierData.points[ind].point.length;\n                for(k = 0; k < kLen; k += 1){\n                    newValue[k] = bezierData.points[ind].point[k];\n                } // caching._lastKeyframeIndex = -1;\n            } else {\n                if (keyframeMetadata.__fnct) {\n                    fnc = keyframeMetadata.__fnct;\n                } else {\n                    fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;\n                    keyframeMetadata.__fnct = fnc;\n                }\n                perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));\n                var distanceInLine = bezierData.segmentLength * perc;\n                var segmentPerc;\n                var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastAddedLength : 0;\n                j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastPoint : 0;\n                flag = true;\n                jLen = bezierData.points.length;\n                while(flag){\n                    addedLength += bezierData.points[j].partialLength;\n                    if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {\n                        kLen = bezierData.points[j].point.length;\n                        for(k = 0; k < kLen; k += 1){\n                            newValue[k] = bezierData.points[j].point[k];\n                        }\n                        break;\n                    } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {\n                        segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;\n                        kLen = bezierData.points[j].point.length;\n                        for(k = 0; k < kLen; k += 1){\n                            newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;\n                        }\n                        break;\n                    }\n                    if (j < jLen - 1) {\n                        j += 1;\n                    } else {\n                        flag = false;\n                    }\n                }\n                caching._lastPoint = j;\n                caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;\n                caching._lastKeyframeIndex = i;\n            }\n        } else {\n            var outX;\n            var outY;\n            var inX;\n            var inY;\n            var keyValue;\n            len = keyData.s.length;\n            endValue = nextKeyData.s || keyData.e;\n            if (this.sh && keyData.h !== 1) {\n                if (frameNum >= nextKeyTime) {\n                    newValue[0] = endValue[0];\n                    newValue[1] = endValue[1];\n                    newValue[2] = endValue[2];\n                } else if (frameNum <= keyTime) {\n                    newValue[0] = keyData.s[0];\n                    newValue[1] = keyData.s[1];\n                    newValue[2] = keyData.s[2];\n                } else {\n                    var quatStart = createQuaternion(keyData.s);\n                    var quatEnd = createQuaternion(endValue);\n                    var time = (frameNum - keyTime) / (nextKeyTime - keyTime);\n                    quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));\n                }\n            } else {\n                for(i = 0; i < len; i += 1){\n                    if (keyData.h !== 1) {\n                        if (frameNum >= nextKeyTime) {\n                            perc = 1;\n                        } else if (frameNum < keyTime) {\n                            perc = 0;\n                        } else {\n                            if (keyData.o.x.constructor === Array) {\n                                if (!keyframeMetadata.__fnct) {\n                                    keyframeMetadata.__fnct = [];\n                                }\n                                if (!keyframeMetadata.__fnct[i]) {\n                                    outX = keyData.o.x[i] === undefined ? keyData.o.x[0] : keyData.o.x[i];\n                                    outY = keyData.o.y[i] === undefined ? keyData.o.y[0] : keyData.o.y[i];\n                                    inX = keyData.i.x[i] === undefined ? keyData.i.x[0] : keyData.i.x[i];\n                                    inY = keyData.i.y[i] === undefined ? keyData.i.y[0] : keyData.i.y[i];\n                                    fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;\n                                    keyframeMetadata.__fnct[i] = fnc;\n                                } else {\n                                    fnc = keyframeMetadata.__fnct[i];\n                                }\n                            } else if (!keyframeMetadata.__fnct) {\n                                outX = keyData.o.x;\n                                outY = keyData.o.y;\n                                inX = keyData.i.x;\n                                inY = keyData.i.y;\n                                fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;\n                                keyData.keyframeMetadata = fnc;\n                            } else {\n                                fnc = keyframeMetadata.__fnct;\n                            }\n                            perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));\n                        }\n                    }\n                    endValue = nextKeyData.s || keyData.e;\n                    keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;\n                    if (this.propType === \"multidimensional\") {\n                        newValue[i] = keyValue;\n                    } else {\n                        newValue = keyValue;\n                    }\n                }\n            }\n        }\n        caching.lastIndex = iterationIndex;\n        return newValue;\n    } // based on @Toji's https://github.com/toji/gl-matrix/\n    function slerp(a, b, t) {\n        var out = [];\n        var ax = a[0];\n        var ay = a[1];\n        var az = a[2];\n        var aw = a[3];\n        var bx = b[0];\n        var by = b[1];\n        var bz = b[2];\n        var bw = b[3];\n        var omega;\n        var cosom;\n        var sinom;\n        var scale0;\n        var scale1;\n        cosom = ax * bx + ay * by + az * bz + aw * bw;\n        if (cosom < 0.0) {\n            cosom = -cosom;\n            bx = -bx;\n            by = -by;\n            bz = -bz;\n            bw = -bw;\n        }\n        if (1.0 - cosom > 0.000001) {\n            omega = Math.acos(cosom);\n            sinom = Math.sin(omega);\n            scale0 = Math.sin((1.0 - t) * omega) / sinom;\n            scale1 = Math.sin(t * omega) / sinom;\n        } else {\n            scale0 = 1.0 - t;\n            scale1 = t;\n        }\n        out[0] = scale0 * ax + scale1 * bx;\n        out[1] = scale0 * ay + scale1 * by;\n        out[2] = scale0 * az + scale1 * bz;\n        out[3] = scale0 * aw + scale1 * bw;\n        return out;\n    }\n    function quaternionToEuler(out, quat) {\n        var qx = quat[0];\n        var qy = quat[1];\n        var qz = quat[2];\n        var qw = quat[3];\n        var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);\n        var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);\n        var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);\n        out[0] = heading / degToRads;\n        out[1] = attitude / degToRads;\n        out[2] = bank / degToRads;\n    }\n    function createQuaternion(values) {\n        var heading = values[0] * degToRads;\n        var attitude = values[1] * degToRads;\n        var bank = values[2] * degToRads;\n        var c1 = Math.cos(heading / 2);\n        var c2 = Math.cos(attitude / 2);\n        var c3 = Math.cos(bank / 2);\n        var s1 = Math.sin(heading / 2);\n        var s2 = Math.sin(attitude / 2);\n        var s3 = Math.sin(bank / 2);\n        var w = c1 * c2 * c3 - s1 * s2 * s3;\n        var x = s1 * s2 * c3 + c1 * c2 * s3;\n        var y = s1 * c2 * c3 + c1 * s2 * s3;\n        var z = c1 * s2 * c3 - s1 * c2 * s3;\n        return [\n            x,\n            y,\n            z,\n            w\n        ];\n    }\n    function getValueAtCurrentTime() {\n        var frameNum = this.comp.renderedFrame - this.offsetTime;\n        var initTime = this.keyframes[0].t - this.offsetTime;\n        var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;\n        if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {\n            if (this._caching.lastFrame >= frameNum) {\n                this._caching._lastKeyframeIndex = -1;\n                this._caching.lastIndex = 0;\n            }\n            var renderResult = this.interpolateValue(frameNum, this._caching);\n            this.pv = renderResult;\n        }\n        this._caching.lastFrame = frameNum;\n        return this.pv;\n    }\n    function setVValue(val) {\n        var multipliedValue;\n        if (this.propType === \"unidimensional\") {\n            multipliedValue = val * this.mult;\n            if (mathAbs(this.v - multipliedValue) > 0.00001) {\n                this.v = multipliedValue;\n                this._mdf = true;\n            }\n        } else {\n            var i = 0;\n            var len = this.v.length;\n            while(i < len){\n                multipliedValue = val[i] * this.mult;\n                if (mathAbs(this.v[i] - multipliedValue) > 0.00001) {\n                    this.v[i] = multipliedValue;\n                    this._mdf = true;\n                }\n                i += 1;\n            }\n        }\n    }\n    function processEffectsSequence() {\n        if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {\n            return;\n        }\n        if (this.lock) {\n            this.setVValue(this.pv);\n            return;\n        }\n        this.lock = true;\n        this._mdf = this._isFirstFrame;\n        var i;\n        var len = this.effectsSequence.length;\n        var finalValue = this.kf ? this.pv : this.data.k;\n        for(i = 0; i < len; i += 1){\n            finalValue = this.effectsSequence[i](finalValue);\n        }\n        this.setVValue(finalValue);\n        this._isFirstFrame = false;\n        this.lock = false;\n        this.frameId = this.elem.globalData.frameId;\n    }\n    function addEffect(effectFunction) {\n        this.effectsSequence.push(effectFunction);\n        this.container.addDynamicProperty(this);\n    }\n    function ValueProperty(elem, data, mult, container) {\n        this.propType = \"unidimensional\";\n        this.mult = mult || 1;\n        this.data = data;\n        this.v = mult ? data.k * mult : data.k;\n        this.pv = data.k;\n        this._mdf = false;\n        this.elem = elem;\n        this.container = container;\n        this.comp = elem.comp;\n        this.k = false;\n        this.kf = false;\n        this.vel = 0;\n        this.effectsSequence = [];\n        this._isFirstFrame = true;\n        this.getValue = processEffectsSequence;\n        this.setVValue = setVValue;\n        this.addEffect = addEffect;\n    }\n    function MultiDimensionalProperty(elem, data, mult, container) {\n        this.propType = \"multidimensional\";\n        this.mult = mult || 1;\n        this.data = data;\n        this._mdf = false;\n        this.elem = elem;\n        this.container = container;\n        this.comp = elem.comp;\n        this.k = false;\n        this.kf = false;\n        this.frameId = -1;\n        var i;\n        var len = data.k.length;\n        this.v = createTypedArray(\"float32\", len);\n        this.pv = createTypedArray(\"float32\", len);\n        this.vel = createTypedArray(\"float32\", len);\n        for(i = 0; i < len; i += 1){\n            this.v[i] = data.k[i] * this.mult;\n            this.pv[i] = data.k[i];\n        }\n        this._isFirstFrame = true;\n        this.effectsSequence = [];\n        this.getValue = processEffectsSequence;\n        this.setVValue = setVValue;\n        this.addEffect = addEffect;\n    }\n    function KeyframedValueProperty(elem, data, mult, container) {\n        this.propType = \"unidimensional\";\n        this.keyframes = data.k;\n        this.keyframesMetadata = [];\n        this.offsetTime = elem.data.st;\n        this.frameId = -1;\n        this._caching = {\n            lastFrame: initFrame,\n            lastIndex: 0,\n            value: 0,\n            _lastKeyframeIndex: -1\n        };\n        this.k = true;\n        this.kf = true;\n        this.data = data;\n        this.mult = mult || 1;\n        this.elem = elem;\n        this.container = container;\n        this.comp = elem.comp;\n        this.v = initFrame;\n        this.pv = initFrame;\n        this._isFirstFrame = true;\n        this.getValue = processEffectsSequence;\n        this.setVValue = setVValue;\n        this.interpolateValue = interpolateValue;\n        this.effectsSequence = [\n            getValueAtCurrentTime.bind(this)\n        ];\n        this.addEffect = addEffect;\n    }\n    function KeyframedMultidimensionalProperty(elem, data, mult, container) {\n        this.propType = \"multidimensional\";\n        var i;\n        var len = data.k.length;\n        var s;\n        var e;\n        var to;\n        var ti;\n        for(i = 0; i < len - 1; i += 1){\n            if (data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s) {\n                s = data.k[i].s;\n                e = data.k[i + 1].s;\n                to = data.k[i].to;\n                ti = data.k[i].ti;\n                if (s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1]) || s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2])) {\n                    data.k[i].to = null;\n                    data.k[i].ti = null;\n                }\n                if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {\n                    if (s.length === 2 || s[2] === e[2] && to[2] === 0 && ti[2] === 0) {\n                        data.k[i].to = null;\n                        data.k[i].ti = null;\n                    }\n                }\n            }\n        }\n        this.effectsSequence = [\n            getValueAtCurrentTime.bind(this)\n        ];\n        this.data = data;\n        this.keyframes = data.k;\n        this.keyframesMetadata = [];\n        this.offsetTime = elem.data.st;\n        this.k = true;\n        this.kf = true;\n        this._isFirstFrame = true;\n        this.mult = mult || 1;\n        this.elem = elem;\n        this.container = container;\n        this.comp = elem.comp;\n        this.getValue = processEffectsSequence;\n        this.setVValue = setVValue;\n        this.interpolateValue = interpolateValue;\n        this.frameId = -1;\n        var arrLen = data.k[0].s.length;\n        this.v = createTypedArray(\"float32\", arrLen);\n        this.pv = createTypedArray(\"float32\", arrLen);\n        for(i = 0; i < arrLen; i += 1){\n            this.v[i] = initFrame;\n            this.pv[i] = initFrame;\n        }\n        this._caching = {\n            lastFrame: initFrame,\n            lastIndex: 0,\n            value: createTypedArray(\"float32\", arrLen)\n        };\n        this.addEffect = addEffect;\n    }\n    var PropertyFactory = function() {\n        function getProp(elem, data, type, mult, container) {\n            if (data.sid) {\n                data = elem.globalData.slotManager.getProp(data);\n            }\n            var p;\n            if (!data.k.length) {\n                p = new ValueProperty(elem, data, mult, container);\n            } else if (typeof data.k[0] === \"number\") {\n                p = new MultiDimensionalProperty(elem, data, mult, container);\n            } else {\n                switch(type){\n                    case 0:\n                        p = new KeyframedValueProperty(elem, data, mult, container);\n                        break;\n                    case 1:\n                        p = new KeyframedMultidimensionalProperty(elem, data, mult, container);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (p.effectsSequence.length) {\n                container.addDynamicProperty(p);\n            }\n            return p;\n        }\n        var ob = {\n            getProp: getProp\n        };\n        return ob;\n    }();\n    function DynamicPropertyContainer() {}\n    DynamicPropertyContainer.prototype = {\n        addDynamicProperty: function addDynamicProperty(prop) {\n            if (this.dynamicProperties.indexOf(prop) === -1) {\n                this.dynamicProperties.push(prop);\n                this.container.addDynamicProperty(this);\n                this._isAnimated = true;\n            }\n        },\n        iterateDynamicProperties: function iterateDynamicProperties() {\n            this._mdf = false;\n            var i;\n            var len = this.dynamicProperties.length;\n            for(i = 0; i < len; i += 1){\n                this.dynamicProperties[i].getValue();\n                if (this.dynamicProperties[i]._mdf) {\n                    this._mdf = true;\n                }\n            }\n        },\n        initDynamicPropertyContainer: function initDynamicPropertyContainer(container) {\n            this.container = container;\n            this.dynamicProperties = [];\n            this._mdf = false;\n            this._isAnimated = false;\n        }\n    };\n    var pointPool = function() {\n        function create() {\n            return createTypedArray(\"float32\", 2);\n        }\n        return poolFactory(8, create);\n    }();\n    function ShapePath() {\n        this.c = false;\n        this._length = 0;\n        this._maxLength = 8;\n        this.v = createSizedArray(this._maxLength);\n        this.o = createSizedArray(this._maxLength);\n        this.i = createSizedArray(this._maxLength);\n    }\n    ShapePath.prototype.setPathData = function(closed, len) {\n        this.c = closed;\n        this.setLength(len);\n        var i = 0;\n        while(i < len){\n            this.v[i] = pointPool.newElement();\n            this.o[i] = pointPool.newElement();\n            this.i[i] = pointPool.newElement();\n            i += 1;\n        }\n    };\n    ShapePath.prototype.setLength = function(len) {\n        while(this._maxLength < len){\n            this.doubleArrayLength();\n        }\n        this._length = len;\n    };\n    ShapePath.prototype.doubleArrayLength = function() {\n        this.v = this.v.concat(createSizedArray(this._maxLength));\n        this.i = this.i.concat(createSizedArray(this._maxLength));\n        this.o = this.o.concat(createSizedArray(this._maxLength));\n        this._maxLength *= 2;\n    };\n    ShapePath.prototype.setXYAt = function(x, y, type, pos, replace) {\n        var arr;\n        this._length = Math.max(this._length, pos + 1);\n        if (this._length >= this._maxLength) {\n            this.doubleArrayLength();\n        }\n        switch(type){\n            case \"v\":\n                arr = this.v;\n                break;\n            case \"i\":\n                arr = this.i;\n                break;\n            case \"o\":\n                arr = this.o;\n                break;\n            default:\n                arr = [];\n                break;\n        }\n        if (!arr[pos] || arr[pos] && !replace) {\n            arr[pos] = pointPool.newElement();\n        }\n        arr[pos][0] = x;\n        arr[pos][1] = y;\n    };\n    ShapePath.prototype.setTripleAt = function(vX, vY, oX, oY, iX, iY, pos, replace) {\n        this.setXYAt(vX, vY, \"v\", pos, replace);\n        this.setXYAt(oX, oY, \"o\", pos, replace);\n        this.setXYAt(iX, iY, \"i\", pos, replace);\n    };\n    ShapePath.prototype.reverse = function() {\n        var newPath = new ShapePath();\n        newPath.setPathData(this.c, this._length);\n        var vertices = this.v;\n        var outPoints = this.o;\n        var inPoints = this.i;\n        var init = 0;\n        if (this.c) {\n            newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);\n            init = 1;\n        }\n        var cnt = this._length - 1;\n        var len = this._length;\n        var i;\n        for(i = init; i < len; i += 1){\n            newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);\n            cnt -= 1;\n        }\n        return newPath;\n    };\n    ShapePath.prototype.length = function() {\n        return this._length;\n    };\n    var shapePool = function() {\n        function create() {\n            return new ShapePath();\n        }\n        function release(shapePath) {\n            var len = shapePath._length;\n            var i;\n            for(i = 0; i < len; i += 1){\n                pointPool.release(shapePath.v[i]);\n                pointPool.release(shapePath.i[i]);\n                pointPool.release(shapePath.o[i]);\n                shapePath.v[i] = null;\n                shapePath.i[i] = null;\n                shapePath.o[i] = null;\n            }\n            shapePath._length = 0;\n            shapePath.c = false;\n        }\n        function clone(shape) {\n            var cloned = factory.newElement();\n            var i;\n            var len = shape._length === undefined ? shape.v.length : shape._length;\n            cloned.setLength(len);\n            cloned.c = shape.c;\n            for(i = 0; i < len; i += 1){\n                cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);\n            }\n            return cloned;\n        }\n        var factory = poolFactory(4, create, release);\n        factory.clone = clone;\n        return factory;\n    }();\n    function ShapeCollection() {\n        this._length = 0;\n        this._maxLength = 4;\n        this.shapes = createSizedArray(this._maxLength);\n    }\n    ShapeCollection.prototype.addShape = function(shapeData) {\n        if (this._length === this._maxLength) {\n            this.shapes = this.shapes.concat(createSizedArray(this._maxLength));\n            this._maxLength *= 2;\n        }\n        this.shapes[this._length] = shapeData;\n        this._length += 1;\n    };\n    ShapeCollection.prototype.releaseShapes = function() {\n        var i;\n        for(i = 0; i < this._length; i += 1){\n            shapePool.release(this.shapes[i]);\n        }\n        this._length = 0;\n    };\n    var shapeCollectionPool = function() {\n        var ob = {\n            newShapeCollection: newShapeCollection,\n            release: release\n        };\n        var _length = 0;\n        var _maxLength = 4;\n        var pool = createSizedArray(_maxLength);\n        function newShapeCollection() {\n            var shapeCollection;\n            if (_length) {\n                _length -= 1;\n                shapeCollection = pool[_length];\n            } else {\n                shapeCollection = new ShapeCollection();\n            }\n            return shapeCollection;\n        }\n        function release(shapeCollection) {\n            var i;\n            var len = shapeCollection._length;\n            for(i = 0; i < len; i += 1){\n                shapePool.release(shapeCollection.shapes[i]);\n            }\n            shapeCollection._length = 0;\n            if (_length === _maxLength) {\n                pool = pooling[\"double\"](pool);\n                _maxLength *= 2;\n            }\n            pool[_length] = shapeCollection;\n            _length += 1;\n        }\n        return ob;\n    }();\n    var ShapePropertyFactory = function() {\n        var initFrame = -999999;\n        function interpolateShape(frameNum, previousValue, caching) {\n            var iterationIndex = caching.lastIndex;\n            var keyPropS;\n            var keyPropE;\n            var isHold;\n            var j;\n            var k;\n            var jLen;\n            var kLen;\n            var perc;\n            var vertexValue;\n            var kf = this.keyframes;\n            if (frameNum < kf[0].t - this.offsetTime) {\n                keyPropS = kf[0].s[0];\n                isHold = true;\n                iterationIndex = 0;\n            } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {\n                keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];\n                /* if(kf[kf.length - 1].s){\r\n                  keyPropS = kf[kf.length - 1].s[0];\r\n              }else{\r\n                  keyPropS = kf[kf.length - 2].e[0];\r\n              } */ isHold = true;\n            } else {\n                var i = iterationIndex;\n                var len = kf.length - 1;\n                var flag = true;\n                var keyData;\n                var nextKeyData;\n                var keyframeMetadata;\n                while(flag){\n                    keyData = kf[i];\n                    nextKeyData = kf[i + 1];\n                    if (nextKeyData.t - this.offsetTime > frameNum) {\n                        break;\n                    }\n                    if (i < len - 1) {\n                        i += 1;\n                    } else {\n                        flag = false;\n                    }\n                }\n                keyframeMetadata = this.keyframesMetadata[i] || {};\n                isHold = keyData.h === 1;\n                iterationIndex = i;\n                if (!isHold) {\n                    if (frameNum >= nextKeyData.t - this.offsetTime) {\n                        perc = 1;\n                    } else if (frameNum < keyData.t - this.offsetTime) {\n                        perc = 0;\n                    } else {\n                        var fnc;\n                        if (keyframeMetadata.__fnct) {\n                            fnc = keyframeMetadata.__fnct;\n                        } else {\n                            fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;\n                            keyframeMetadata.__fnct = fnc;\n                        }\n                        perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));\n                    }\n                    keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];\n                }\n                keyPropS = keyData.s[0];\n            }\n            jLen = previousValue._length;\n            kLen = keyPropS.i[0].length;\n            caching.lastIndex = iterationIndex;\n            for(j = 0; j < jLen; j += 1){\n                for(k = 0; k < kLen; k += 1){\n                    vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;\n                    previousValue.i[j][k] = vertexValue;\n                    vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;\n                    previousValue.o[j][k] = vertexValue;\n                    vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;\n                    previousValue.v[j][k] = vertexValue;\n                }\n            }\n        }\n        function interpolateShapeCurrentTime() {\n            var frameNum = this.comp.renderedFrame - this.offsetTime;\n            var initTime = this.keyframes[0].t - this.offsetTime;\n            var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;\n            var lastFrame = this._caching.lastFrame;\n            if (!(lastFrame !== initFrame && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {\n                /// /\n                this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;\n                this.interpolateShape(frameNum, this.pv, this._caching); /// /\n            }\n            this._caching.lastFrame = frameNum;\n            return this.pv;\n        }\n        function resetShape() {\n            this.paths = this.localShapeCollection;\n        }\n        function shapesEqual(shape1, shape2) {\n            if (shape1._length !== shape2._length || shape1.c !== shape2.c) {\n                return false;\n            }\n            var i;\n            var len = shape1._length;\n            for(i = 0; i < len; i += 1){\n                if (shape1.v[i][0] !== shape2.v[i][0] || shape1.v[i][1] !== shape2.v[i][1] || shape1.o[i][0] !== shape2.o[i][0] || shape1.o[i][1] !== shape2.o[i][1] || shape1.i[i][0] !== shape2.i[i][0] || shape1.i[i][1] !== shape2.i[i][1]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        function setVValue(newPath) {\n            if (!shapesEqual(this.v, newPath)) {\n                this.v = shapePool.clone(newPath);\n                this.localShapeCollection.releaseShapes();\n                this.localShapeCollection.addShape(this.v);\n                this._mdf = true;\n                this.paths = this.localShapeCollection;\n            }\n        }\n        function processEffectsSequence() {\n            if (this.elem.globalData.frameId === this.frameId) {\n                return;\n            }\n            if (!this.effectsSequence.length) {\n                this._mdf = false;\n                return;\n            }\n            if (this.lock) {\n                this.setVValue(this.pv);\n                return;\n            }\n            this.lock = true;\n            this._mdf = false;\n            var finalValue;\n            if (this.kf) {\n                finalValue = this.pv;\n            } else if (this.data.ks) {\n                finalValue = this.data.ks.k;\n            } else {\n                finalValue = this.data.pt.k;\n            }\n            var i;\n            var len = this.effectsSequence.length;\n            for(i = 0; i < len; i += 1){\n                finalValue = this.effectsSequence[i](finalValue);\n            }\n            this.setVValue(finalValue);\n            this.lock = false;\n            this.frameId = this.elem.globalData.frameId;\n        }\n        function ShapeProperty(elem, data, type) {\n            this.propType = \"shape\";\n            this.comp = elem.comp;\n            this.container = elem;\n            this.elem = elem;\n            this.data = data;\n            this.k = false;\n            this.kf = false;\n            this._mdf = false;\n            var pathData = type === 3 ? data.pt.k : data.ks.k;\n            this.v = shapePool.clone(pathData);\n            this.pv = shapePool.clone(this.v);\n            this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n            this.paths = this.localShapeCollection;\n            this.paths.addShape(this.v);\n            this.reset = resetShape;\n            this.effectsSequence = [];\n        }\n        function addEffect(effectFunction) {\n            this.effectsSequence.push(effectFunction);\n            this.container.addDynamicProperty(this);\n        }\n        ShapeProperty.prototype.interpolateShape = interpolateShape;\n        ShapeProperty.prototype.getValue = processEffectsSequence;\n        ShapeProperty.prototype.setVValue = setVValue;\n        ShapeProperty.prototype.addEffect = addEffect;\n        function KeyframedShapeProperty(elem, data, type) {\n            this.propType = \"shape\";\n            this.comp = elem.comp;\n            this.elem = elem;\n            this.container = elem;\n            this.offsetTime = elem.data.st;\n            this.keyframes = type === 3 ? data.pt.k : data.ks.k;\n            this.keyframesMetadata = [];\n            this.k = true;\n            this.kf = true;\n            var len = this.keyframes[0].s[0].i.length;\n            this.v = shapePool.newElement();\n            this.v.setPathData(this.keyframes[0].s[0].c, len);\n            this.pv = shapePool.clone(this.v);\n            this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n            this.paths = this.localShapeCollection;\n            this.paths.addShape(this.v);\n            this.lastFrame = initFrame;\n            this.reset = resetShape;\n            this._caching = {\n                lastFrame: initFrame,\n                lastIndex: 0\n            };\n            this.effectsSequence = [\n                interpolateShapeCurrentTime.bind(this)\n            ];\n        }\n        KeyframedShapeProperty.prototype.getValue = processEffectsSequence;\n        KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;\n        KeyframedShapeProperty.prototype.setVValue = setVValue;\n        KeyframedShapeProperty.prototype.addEffect = addEffect;\n        var EllShapeProperty = function() {\n            var cPoint = roundCorner;\n            function EllShapePropertyFactory(elem, data) {\n                this.v = shapePool.newElement();\n                this.v.setPathData(true, 4);\n                this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n                this.paths = this.localShapeCollection;\n                this.localShapeCollection.addShape(this.v);\n                this.d = data.d;\n                this.elem = elem;\n                this.comp = elem.comp;\n                this.frameId = -1;\n                this.initDynamicPropertyContainer(elem);\n                this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);\n                this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);\n                if (this.dynamicProperties.length) {\n                    this.k = true;\n                } else {\n                    this.k = false;\n                    this.convertEllToPath();\n                }\n            }\n            EllShapePropertyFactory.prototype = {\n                reset: resetShape,\n                getValue: function getValue() {\n                    if (this.elem.globalData.frameId === this.frameId) {\n                        return;\n                    }\n                    this.frameId = this.elem.globalData.frameId;\n                    this.iterateDynamicProperties();\n                    if (this._mdf) {\n                        this.convertEllToPath();\n                    }\n                },\n                convertEllToPath: function convertEllToPath() {\n                    var p0 = this.p.v[0];\n                    var p1 = this.p.v[1];\n                    var s0 = this.s.v[0] / 2;\n                    var s1 = this.s.v[1] / 2;\n                    var _cw = this.d !== 3;\n                    var _v = this.v;\n                    _v.v[0][0] = p0;\n                    _v.v[0][1] = p1 - s1;\n                    _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;\n                    _v.v[1][1] = p1;\n                    _v.v[2][0] = p0;\n                    _v.v[2][1] = p1 + s1;\n                    _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;\n                    _v.v[3][1] = p1;\n                    _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;\n                    _v.i[0][1] = p1 - s1;\n                    _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;\n                    _v.i[1][1] = p1 - s1 * cPoint;\n                    _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;\n                    _v.i[2][1] = p1 + s1;\n                    _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;\n                    _v.i[3][1] = p1 + s1 * cPoint;\n                    _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;\n                    _v.o[0][1] = p1 - s1;\n                    _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;\n                    _v.o[1][1] = p1 + s1 * cPoint;\n                    _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;\n                    _v.o[2][1] = p1 + s1;\n                    _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;\n                    _v.o[3][1] = p1 - s1 * cPoint;\n                }\n            };\n            extendPrototype([\n                DynamicPropertyContainer\n            ], EllShapePropertyFactory);\n            return EllShapePropertyFactory;\n        }();\n        var StarShapeProperty = function() {\n            function StarShapePropertyFactory(elem, data) {\n                this.v = shapePool.newElement();\n                this.v.setPathData(true, 0);\n                this.elem = elem;\n                this.comp = elem.comp;\n                this.data = data;\n                this.frameId = -1;\n                this.d = data.d;\n                this.initDynamicPropertyContainer(elem);\n                if (data.sy === 1) {\n                    this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);\n                    this.is = PropertyFactory.getProp(elem, data.is, 0, 0.01, this);\n                    this.convertToPath = this.convertStarToPath;\n                } else {\n                    this.convertToPath = this.convertPolygonToPath;\n                }\n                this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);\n                this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);\n                this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);\n                this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);\n                this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this);\n                this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n                this.localShapeCollection.addShape(this.v);\n                this.paths = this.localShapeCollection;\n                if (this.dynamicProperties.length) {\n                    this.k = true;\n                } else {\n                    this.k = false;\n                    this.convertToPath();\n                }\n            }\n            StarShapePropertyFactory.prototype = {\n                reset: resetShape,\n                getValue: function getValue() {\n                    if (this.elem.globalData.frameId === this.frameId) {\n                        return;\n                    }\n                    this.frameId = this.elem.globalData.frameId;\n                    this.iterateDynamicProperties();\n                    if (this._mdf) {\n                        this.convertToPath();\n                    }\n                },\n                convertStarToPath: function convertStarToPath() {\n                    var numPts = Math.floor(this.pt.v) * 2;\n                    var angle = Math.PI * 2 / numPts;\n                    /* this.v.v.length = numPts;\r\n                  this.v.i.length = numPts;\r\n                  this.v.o.length = numPts; */ var longFlag = true;\n                    var longRad = this.or.v;\n                    var shortRad = this.ir.v;\n                    var longRound = this.os.v;\n                    var shortRound = this.is.v;\n                    var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);\n                    var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);\n                    var i;\n                    var rad;\n                    var roundness;\n                    var perimSegment;\n                    var currentAng = -Math.PI / 2;\n                    currentAng += this.r.v;\n                    var dir = this.data.d === 3 ? -1 : 1;\n                    this.v._length = 0;\n                    for(i = 0; i < numPts; i += 1){\n                        rad = longFlag ? longRad : shortRad;\n                        roundness = longFlag ? longRound : shortRound;\n                        perimSegment = longFlag ? longPerimSegment : shortPerimSegment;\n                        var x = rad * Math.cos(currentAng);\n                        var y = rad * Math.sin(currentAng);\n                        var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);\n                        var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);\n                        x += +this.p.v[0];\n                        y += +this.p.v[1];\n                        this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);\n                        /* this.v.v[i] = [x,y];\r\n                      this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];\r\n                      this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];\r\n                      this.v._length = numPts; */ longFlag = !longFlag;\n                        currentAng += angle * dir;\n                    }\n                },\n                convertPolygonToPath: function convertPolygonToPath() {\n                    var numPts = Math.floor(this.pt.v);\n                    var angle = Math.PI * 2 / numPts;\n                    var rad = this.or.v;\n                    var roundness = this.os.v;\n                    var perimSegment = 2 * Math.PI * rad / (numPts * 4);\n                    var i;\n                    var currentAng = -Math.PI * 0.5;\n                    var dir = this.data.d === 3 ? -1 : 1;\n                    currentAng += this.r.v;\n                    this.v._length = 0;\n                    for(i = 0; i < numPts; i += 1){\n                        var x = rad * Math.cos(currentAng);\n                        var y = rad * Math.sin(currentAng);\n                        var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);\n                        var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);\n                        x += +this.p.v[0];\n                        y += +this.p.v[1];\n                        this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);\n                        currentAng += angle * dir;\n                    }\n                    this.paths.length = 0;\n                    this.paths[0] = this.v;\n                }\n            };\n            extendPrototype([\n                DynamicPropertyContainer\n            ], StarShapePropertyFactory);\n            return StarShapePropertyFactory;\n        }();\n        var RectShapeProperty = function() {\n            function RectShapePropertyFactory(elem, data) {\n                this.v = shapePool.newElement();\n                this.v.c = true;\n                this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n                this.localShapeCollection.addShape(this.v);\n                this.paths = this.localShapeCollection;\n                this.elem = elem;\n                this.comp = elem.comp;\n                this.frameId = -1;\n                this.d = data.d;\n                this.initDynamicPropertyContainer(elem);\n                this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);\n                this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);\n                this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);\n                if (this.dynamicProperties.length) {\n                    this.k = true;\n                } else {\n                    this.k = false;\n                    this.convertRectToPath();\n                }\n            }\n            RectShapePropertyFactory.prototype = {\n                convertRectToPath: function convertRectToPath() {\n                    var p0 = this.p.v[0];\n                    var p1 = this.p.v[1];\n                    var v0 = this.s.v[0] / 2;\n                    var v1 = this.s.v[1] / 2;\n                    var round = bmMin(v0, v1, this.r.v);\n                    var cPoint = round * (1 - roundCorner);\n                    this.v._length = 0;\n                    if (this.d === 2 || this.d === 1) {\n                        this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);\n                        this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);\n                        if (round !== 0) {\n                            this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);\n                            this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);\n                            this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);\n                            this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);\n                            this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);\n                            this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);\n                        } else {\n                            this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);\n                            this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);\n                        }\n                    } else {\n                        this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);\n                        if (round !== 0) {\n                            this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);\n                            this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);\n                            this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);\n                            this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);\n                            this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);\n                            this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);\n                            this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);\n                        } else {\n                            this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);\n                            this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);\n                            this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);\n                        }\n                    }\n                },\n                getValue: function getValue() {\n                    if (this.elem.globalData.frameId === this.frameId) {\n                        return;\n                    }\n                    this.frameId = this.elem.globalData.frameId;\n                    this.iterateDynamicProperties();\n                    if (this._mdf) {\n                        this.convertRectToPath();\n                    }\n                },\n                reset: resetShape\n            };\n            extendPrototype([\n                DynamicPropertyContainer\n            ], RectShapePropertyFactory);\n            return RectShapePropertyFactory;\n        }();\n        function getShapeProp(elem, data, type) {\n            var prop;\n            if (type === 3 || type === 4) {\n                var dataProp = type === 3 ? data.pt : data.ks;\n                var keys = dataProp.k;\n                if (keys.length) {\n                    prop = new KeyframedShapeProperty(elem, data, type);\n                } else {\n                    prop = new ShapeProperty(elem, data, type);\n                }\n            } else if (type === 5) {\n                prop = new RectShapeProperty(elem, data);\n            } else if (type === 6) {\n                prop = new EllShapeProperty(elem, data);\n            } else if (type === 7) {\n                prop = new StarShapeProperty(elem, data);\n            }\n            if (prop.k) {\n                elem.addDynamicProperty(prop);\n            }\n            return prop;\n        }\n        function getConstructorFunction() {\n            return ShapeProperty;\n        }\n        function getKeyframedConstructorFunction() {\n            return KeyframedShapeProperty;\n        }\n        var ob = {};\n        ob.getShapeProp = getShapeProp;\n        ob.getConstructorFunction = getConstructorFunction;\n        ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;\n        return ob;\n    }();\n    /*!\r\n   Transformation Matrix v2.0\r\n   (c) Epistemex 2014-2015\r\n   www.epistemex.com\r\n   By Ken Fyrstenberg\r\n   Contributions by leeoniya.\r\n   License: MIT, header required.\r\n   */ /**\r\n   * 2D transformation matrix object initialized with identity matrix.\r\n   *\r\n   * The matrix can synchronize a canvas context by supplying the context\r\n   * as an argument, or later apply current absolute transform to an\r\n   * existing context.\r\n   *\r\n   * All values are handled as floating point values.\r\n   *\r\n   * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix\r\n   * @prop {number} a - scale x\r\n   * @prop {number} b - shear y\r\n   * @prop {number} c - shear x\r\n   * @prop {number} d - scale y\r\n   * @prop {number} e - translate x\r\n   * @prop {number} f - translate y\r\n   * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context\r\n   * @constructor\r\n   */ var Matrix = function() {\n        var _cos = Math.cos;\n        var _sin = Math.sin;\n        var _tan = Math.tan;\n        var _rnd = Math.round;\n        function reset() {\n            this.props[0] = 1;\n            this.props[1] = 0;\n            this.props[2] = 0;\n            this.props[3] = 0;\n            this.props[4] = 0;\n            this.props[5] = 1;\n            this.props[6] = 0;\n            this.props[7] = 0;\n            this.props[8] = 0;\n            this.props[9] = 0;\n            this.props[10] = 1;\n            this.props[11] = 0;\n            this.props[12] = 0;\n            this.props[13] = 0;\n            this.props[14] = 0;\n            this.props[15] = 1;\n            return this;\n        }\n        function rotate(angle) {\n            if (angle === 0) {\n                return this;\n            }\n            var mCos = _cos(angle);\n            var mSin = _sin(angle);\n            return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n        }\n        function rotateX(angle) {\n            if (angle === 0) {\n                return this;\n            }\n            var mCos = _cos(angle);\n            var mSin = _sin(angle);\n            return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);\n        }\n        function rotateY(angle) {\n            if (angle === 0) {\n                return this;\n            }\n            var mCos = _cos(angle);\n            var mSin = _sin(angle);\n            return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);\n        }\n        function rotateZ(angle) {\n            if (angle === 0) {\n                return this;\n            }\n            var mCos = _cos(angle);\n            var mSin = _sin(angle);\n            return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n        }\n        function shear(sx, sy) {\n            return this._t(1, sy, sx, 1, 0, 0);\n        }\n        function skew(ax, ay) {\n            return this.shear(_tan(ax), _tan(ay));\n        }\n        function skewFromAxis(ax, angle) {\n            var mCos = _cos(angle);\n            var mSin = _sin(angle);\n            return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); // return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);\n        }\n        function scale(sx, sy, sz) {\n            if (!sz && sz !== 0) {\n                sz = 1;\n            }\n            if (sx === 1 && sy === 1 && sz === 1) {\n                return this;\n            }\n            return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);\n        }\n        function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {\n            this.props[0] = a;\n            this.props[1] = b;\n            this.props[2] = c;\n            this.props[3] = d;\n            this.props[4] = e;\n            this.props[5] = f;\n            this.props[6] = g;\n            this.props[7] = h;\n            this.props[8] = i;\n            this.props[9] = j;\n            this.props[10] = k;\n            this.props[11] = l;\n            this.props[12] = m;\n            this.props[13] = n;\n            this.props[14] = o;\n            this.props[15] = p;\n            return this;\n        }\n        function translate(tx, ty, tz) {\n            tz = tz || 0;\n            if (tx !== 0 || ty !== 0 || tz !== 0) {\n                return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);\n            }\n            return this;\n        }\n        function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {\n            var _p = this.props;\n            if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {\n                // NOTE: commenting this condition because TurboFan deoptimizes code when present\n                // if(m2 !== 0 || n2 !== 0 || o2 !== 0){\n                _p[12] = _p[12] * a2 + _p[15] * m2;\n                _p[13] = _p[13] * f2 + _p[15] * n2;\n                _p[14] = _p[14] * k2 + _p[15] * o2;\n                _p[15] *= p2; // }\n                this._identityCalculated = false;\n                return this;\n            }\n            var a1 = _p[0];\n            var b1 = _p[1];\n            var c1 = _p[2];\n            var d1 = _p[3];\n            var e1 = _p[4];\n            var f1 = _p[5];\n            var g1 = _p[6];\n            var h1 = _p[7];\n            var i1 = _p[8];\n            var j1 = _p[9];\n            var k1 = _p[10];\n            var l1 = _p[11];\n            var m1 = _p[12];\n            var n1 = _p[13];\n            var o1 = _p[14];\n            var p1 = _p[15];\n            /* matrix order (canvas compatible):\r\n           * ace\r\n           * bdf\r\n           * 001\r\n           */ _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;\n            _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;\n            _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;\n            _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;\n            _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;\n            _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;\n            _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;\n            _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;\n            _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;\n            _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;\n            _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;\n            _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;\n            _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;\n            _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;\n            _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;\n            _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;\n            this._identityCalculated = false;\n            return this;\n        }\n        function multiply(matrix) {\n            var matrixProps = matrix.props;\n            return this.transform(matrixProps[0], matrixProps[1], matrixProps[2], matrixProps[3], matrixProps[4], matrixProps[5], matrixProps[6], matrixProps[7], matrixProps[8], matrixProps[9], matrixProps[10], matrixProps[11], matrixProps[12], matrixProps[13], matrixProps[14], matrixProps[15]);\n        }\n        function isIdentity() {\n            if (!this._identityCalculated) {\n                this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);\n                this._identityCalculated = true;\n            }\n            return this._identity;\n        }\n        function equals(matr) {\n            var i = 0;\n            while(i < 16){\n                if (matr.props[i] !== this.props[i]) {\n                    return false;\n                }\n                i += 1;\n            }\n            return true;\n        }\n        function clone(matr) {\n            var i;\n            for(i = 0; i < 16; i += 1){\n                matr.props[i] = this.props[i];\n            }\n            return matr;\n        }\n        function cloneFromProps(props) {\n            var i;\n            for(i = 0; i < 16; i += 1){\n                this.props[i] = props[i];\n            }\n        }\n        function applyToPoint(x, y, z) {\n            return {\n                x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],\n                y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],\n                z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]\n            };\n        /* return {\r\n           x: x * me.a + y * me.c + me.e,\r\n           y: x * me.b + y * me.d + me.f\r\n           }; */ }\n        function applyToX(x, y, z) {\n            return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];\n        }\n        function applyToY(x, y, z) {\n            return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];\n        }\n        function applyToZ(x, y, z) {\n            return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];\n        }\n        function getInverseMatrix() {\n            var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];\n            var a = this.props[5] / determinant;\n            var b = -this.props[1] / determinant;\n            var c = -this.props[4] / determinant;\n            var d = this.props[0] / determinant;\n            var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;\n            var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;\n            var inverseMatrix = new Matrix();\n            inverseMatrix.props[0] = a;\n            inverseMatrix.props[1] = b;\n            inverseMatrix.props[4] = c;\n            inverseMatrix.props[5] = d;\n            inverseMatrix.props[12] = e;\n            inverseMatrix.props[13] = f;\n            return inverseMatrix;\n        }\n        function inversePoint(pt) {\n            var inverseMatrix = this.getInverseMatrix();\n            return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);\n        }\n        function inversePoints(pts) {\n            var i;\n            var len = pts.length;\n            var retPts = [];\n            for(i = 0; i < len; i += 1){\n                retPts[i] = inversePoint(pts[i]);\n            }\n            return retPts;\n        }\n        function applyToTriplePoints(pt1, pt2, pt3) {\n            var arr = createTypedArray(\"float32\", 6);\n            if (this.isIdentity()) {\n                arr[0] = pt1[0];\n                arr[1] = pt1[1];\n                arr[2] = pt2[0];\n                arr[3] = pt2[1];\n                arr[4] = pt3[0];\n                arr[5] = pt3[1];\n            } else {\n                var p0 = this.props[0];\n                var p1 = this.props[1];\n                var p4 = this.props[4];\n                var p5 = this.props[5];\n                var p12 = this.props[12];\n                var p13 = this.props[13];\n                arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;\n                arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;\n                arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;\n                arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;\n                arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;\n                arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;\n            }\n            return arr;\n        }\n        function applyToPointArray(x, y, z) {\n            var arr;\n            if (this.isIdentity()) {\n                arr = [\n                    x,\n                    y,\n                    z\n                ];\n            } else {\n                arr = [\n                    x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],\n                    x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],\n                    x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]\n                ];\n            }\n            return arr;\n        }\n        function applyToPointStringified(x, y) {\n            if (this.isIdentity()) {\n                return x + \",\" + y;\n            }\n            var _p = this.props;\n            return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + \",\" + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;\n        }\n        function toCSS() {\n            // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.\n            /* if(this.isIdentity()) {\r\n              return '';\r\n          } */ var i = 0;\n            var props = this.props;\n            var cssValue = \"matrix3d(\";\n            var v = 10000;\n            while(i < 16){\n                cssValue += _rnd(props[i] * v) / v;\n                cssValue += i === 15 ? \")\" : \",\";\n                i += 1;\n            }\n            return cssValue;\n        }\n        function roundMatrixProperty(val) {\n            var v = 10000;\n            if (val < 0.000001 && val > 0 || val > -0.000001 && val < 0) {\n                return _rnd(val * v) / v;\n            }\n            return val;\n        }\n        function to2dCSS() {\n            // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.\n            /* if(this.isIdentity()) {\r\n              return '';\r\n          } */ var props = this.props;\n            var _a = roundMatrixProperty(props[0]);\n            var _b = roundMatrixProperty(props[1]);\n            var _c = roundMatrixProperty(props[4]);\n            var _d = roundMatrixProperty(props[5]);\n            var _e = roundMatrixProperty(props[12]);\n            var _f = roundMatrixProperty(props[13]);\n            return \"matrix(\" + _a + \",\" + _b + \",\" + _c + \",\" + _d + \",\" + _e + \",\" + _f + \")\";\n        }\n        return function() {\n            this.reset = reset;\n            this.rotate = rotate;\n            this.rotateX = rotateX;\n            this.rotateY = rotateY;\n            this.rotateZ = rotateZ;\n            this.skew = skew;\n            this.skewFromAxis = skewFromAxis;\n            this.shear = shear;\n            this.scale = scale;\n            this.setTransform = setTransform;\n            this.translate = translate;\n            this.transform = transform;\n            this.multiply = multiply;\n            this.applyToPoint = applyToPoint;\n            this.applyToX = applyToX;\n            this.applyToY = applyToY;\n            this.applyToZ = applyToZ;\n            this.applyToPointArray = applyToPointArray;\n            this.applyToTriplePoints = applyToTriplePoints;\n            this.applyToPointStringified = applyToPointStringified;\n            this.toCSS = toCSS;\n            this.to2dCSS = to2dCSS;\n            this.clone = clone;\n            this.cloneFromProps = cloneFromProps;\n            this.equals = equals;\n            this.inversePoints = inversePoints;\n            this.inversePoint = inversePoint;\n            this.getInverseMatrix = getInverseMatrix;\n            this._t = this.transform;\n            this.isIdentity = isIdentity;\n            this._identity = true;\n            this._identityCalculated = false;\n            this.props = createTypedArray(\"float32\", 16);\n            this.reset();\n        };\n    }();\n    function _typeof$3(obj) {\n        \"@babel/helpers - typeof\";\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof$3 = function _typeof(obj) {\n                return typeof obj;\n            };\n        } else {\n            _typeof$3 = function _typeof(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n        }\n        return _typeof$3(obj);\n    }\n    var lottie = {};\n    var standalone = \"__[STANDALONE]__\";\n    var animationData = \"__[ANIMATIONDATA]__\";\n    var renderer = \"\";\n    function setLocation(href) {\n        setLocationHref(href);\n    }\n    function searchAnimations() {\n        if (standalone === true) {\n            animationManager.searchAnimations(animationData, standalone, renderer);\n        } else {\n            animationManager.searchAnimations();\n        }\n    }\n    function setSubframeRendering(flag) {\n        setSubframeEnabled(flag);\n    }\n    function setPrefix(prefix) {\n        setIdPrefix(prefix);\n    }\n    function loadAnimation(params) {\n        if (standalone === true) {\n            params.animationData = JSON.parse(animationData);\n        }\n        return animationManager.loadAnimation(params);\n    }\n    function setQuality(value) {\n        if (typeof value === \"string\") {\n            switch(value){\n                case \"high\":\n                    setDefaultCurveSegments(200);\n                    break;\n                default:\n                case \"medium\":\n                    setDefaultCurveSegments(50);\n                    break;\n                case \"low\":\n                    setDefaultCurveSegments(10);\n                    break;\n            }\n        } else if (!isNaN(value) && value > 1) {\n            setDefaultCurveSegments(value);\n        }\n        if (getDefaultCurveSegments() >= 50) {\n            roundValues(false);\n        } else {\n            roundValues(true);\n        }\n    }\n    function inBrowser() {\n        return typeof navigator !== \"undefined\";\n    }\n    function installPlugin(type, plugin) {\n        if (type === \"expressions\") {\n            setExpressionsPlugin(plugin);\n        }\n    }\n    function getFactory(name) {\n        switch(name){\n            case \"propertyFactory\":\n                return PropertyFactory;\n            case \"shapePropertyFactory\":\n                return ShapePropertyFactory;\n            case \"matrix\":\n                return Matrix;\n            default:\n                return null;\n        }\n    }\n    lottie.play = animationManager.play;\n    lottie.pause = animationManager.pause;\n    lottie.setLocationHref = setLocation;\n    lottie.togglePause = animationManager.togglePause;\n    lottie.setSpeed = animationManager.setSpeed;\n    lottie.setDirection = animationManager.setDirection;\n    lottie.stop = animationManager.stop;\n    lottie.searchAnimations = searchAnimations;\n    lottie.registerAnimation = animationManager.registerAnimation;\n    lottie.loadAnimation = loadAnimation;\n    lottie.setSubframeRendering = setSubframeRendering;\n    lottie.resize = animationManager.resize; // lottie.start = start;\n    lottie.goToAndStop = animationManager.goToAndStop;\n    lottie.destroy = animationManager.destroy;\n    lottie.setQuality = setQuality;\n    lottie.inBrowser = inBrowser;\n    lottie.installPlugin = installPlugin;\n    lottie.freeze = animationManager.freeze;\n    lottie.unfreeze = animationManager.unfreeze;\n    lottie.setVolume = animationManager.setVolume;\n    lottie.mute = animationManager.mute;\n    lottie.unmute = animationManager.unmute;\n    lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;\n    lottie.useWebWorker = setWebWorker;\n    lottie.setIDPrefix = setPrefix;\n    lottie.__getFactory = getFactory;\n    lottie.version = \"5.12.2\";\n    function checkReady() {\n        if (document.readyState === \"complete\") {\n            clearInterval(readyStateCheckInterval);\n            searchAnimations();\n        }\n    }\n    function getQueryVariable(variable) {\n        var vars = queryString.split(\"&\");\n        for(var i = 0; i < vars.length; i += 1){\n            var pair = vars[i].split(\"=\");\n            if (decodeURIComponent(pair[0]) == variable) {\n                // eslint-disable-line eqeqeq\n                return decodeURIComponent(pair[1]);\n            }\n        }\n        return null;\n    }\n    var queryString = \"\";\n    if (standalone) {\n        var scripts = document.getElementsByTagName(\"script\");\n        var index = scripts.length - 1;\n        var myScript = scripts[index] || {\n            src: \"\"\n        };\n        queryString = myScript.src ? myScript.src.replace(/^[^\\?]+\\??/, \"\") : \"\"; // eslint-disable-line no-useless-escape\n        renderer = getQueryVariable(\"renderer\");\n    }\n    var readyStateCheckInterval = setInterval(checkReady, 100); // this adds bodymovin to the window object for backwards compatibility\n    try {\n        if (!(( false ? 0 : _typeof$3(exports)) === \"object\" && \"object\" !== \"undefined\") && !( true && __webpack_require__.amdO // eslint-disable-line no-undef\n        )) {}\n    } catch (err) {}\n    var ShapeModifiers = function() {\n        var ob = {};\n        var modifiers = {};\n        ob.registerModifier = registerModifier;\n        ob.getModifier = getModifier;\n        function registerModifier(nm, factory) {\n            if (!modifiers[nm]) {\n                modifiers[nm] = factory;\n            }\n        }\n        function getModifier(nm, elem, data) {\n            return new modifiers[nm](elem, data);\n        }\n        return ob;\n    }();\n    function ShapeModifier() {}\n    ShapeModifier.prototype.initModifierProperties = function() {};\n    ShapeModifier.prototype.addShapeToModifier = function() {};\n    ShapeModifier.prototype.addShape = function(data) {\n        if (!this.closed) {\n            // Adding shape to dynamic properties. It covers the case where a shape has no effects applied, to reset it's _mdf state on every tick.\n            data.sh.container.addDynamicProperty(data.sh);\n            var shapeData = {\n                shape: data.sh,\n                data: data,\n                localShapeCollection: shapeCollectionPool.newShapeCollection()\n            };\n            this.shapes.push(shapeData);\n            this.addShapeToModifier(shapeData);\n            if (this._isAnimated) {\n                data.setAsAnimated();\n            }\n        }\n    };\n    ShapeModifier.prototype.init = function(elem, data) {\n        this.shapes = [];\n        this.elem = elem;\n        this.initDynamicPropertyContainer(elem);\n        this.initModifierProperties(elem, data);\n        this.frameId = initialDefaultFrame;\n        this.closed = false;\n        this.k = false;\n        if (this.dynamicProperties.length) {\n            this.k = true;\n        } else {\n            this.getValue(true);\n        }\n    };\n    ShapeModifier.prototype.processKeys = function() {\n        if (this.elem.globalData.frameId === this.frameId) {\n            return;\n        }\n        this.frameId = this.elem.globalData.frameId;\n        this.iterateDynamicProperties();\n    };\n    extendPrototype([\n        DynamicPropertyContainer\n    ], ShapeModifier);\n    function TrimModifier() {}\n    extendPrototype([\n        ShapeModifier\n    ], TrimModifier);\n    TrimModifier.prototype.initModifierProperties = function(elem, data) {\n        this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);\n        this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);\n        this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);\n        this.sValue = 0;\n        this.eValue = 0;\n        this.getValue = this.processKeys;\n        this.m = data.m;\n        this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;\n    };\n    TrimModifier.prototype.addShapeToModifier = function(shapeData) {\n        shapeData.pathsData = [];\n    };\n    TrimModifier.prototype.calculateShapeEdges = function(s, e, shapeLength, addedLength, totalModifierLength) {\n        var segments = [];\n        if (e <= 1) {\n            segments.push({\n                s: s,\n                e: e\n            });\n        } else if (s >= 1) {\n            segments.push({\n                s: s - 1,\n                e: e - 1\n            });\n        } else {\n            segments.push({\n                s: s,\n                e: 1\n            });\n            segments.push({\n                s: 0,\n                e: e - 1\n            });\n        }\n        var shapeSegments = [];\n        var i;\n        var len = segments.length;\n        var segmentOb;\n        for(i = 0; i < len; i += 1){\n            segmentOb = segments[i];\n            if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {\n                var shapeS;\n                var shapeE;\n                if (segmentOb.s * totalModifierLength <= addedLength) {\n                    shapeS = 0;\n                } else {\n                    shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;\n                }\n                if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {\n                    shapeE = 1;\n                } else {\n                    shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;\n                }\n                shapeSegments.push([\n                    shapeS,\n                    shapeE\n                ]);\n            }\n        }\n        if (!shapeSegments.length) {\n            shapeSegments.push([\n                0,\n                0\n            ]);\n        }\n        return shapeSegments;\n    };\n    TrimModifier.prototype.releasePathsData = function(pathsData) {\n        var i;\n        var len = pathsData.length;\n        for(i = 0; i < len; i += 1){\n            segmentsLengthPool.release(pathsData[i]);\n        }\n        pathsData.length = 0;\n        return pathsData;\n    };\n    TrimModifier.prototype.processShapes = function(_isFirstFrame) {\n        var s;\n        var e;\n        if (this._mdf || _isFirstFrame) {\n            var o = this.o.v % 360 / 360;\n            if (o < 0) {\n                o += 1;\n            }\n            if (this.s.v > 1) {\n                s = 1 + o;\n            } else if (this.s.v < 0) {\n                s = 0 + o;\n            } else {\n                s = this.s.v + o;\n            }\n            if (this.e.v > 1) {\n                e = 1 + o;\n            } else if (this.e.v < 0) {\n                e = 0 + o;\n            } else {\n                e = this.e.v + o;\n            }\n            if (s > e) {\n                var _s = s;\n                s = e;\n                e = _s;\n            }\n            s = Math.round(s * 10000) * 0.0001;\n            e = Math.round(e * 10000) * 0.0001;\n            this.sValue = s;\n            this.eValue = e;\n        } else {\n            s = this.sValue;\n            e = this.eValue;\n        }\n        var shapePaths;\n        var i;\n        var len = this.shapes.length;\n        var j;\n        var jLen;\n        var pathsData;\n        var pathData;\n        var totalShapeLength;\n        var totalModifierLength = 0;\n        if (e === s) {\n            for(i = 0; i < len; i += 1){\n                this.shapes[i].localShapeCollection.releaseShapes();\n                this.shapes[i].shape._mdf = true;\n                this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;\n                if (this._mdf) {\n                    this.shapes[i].pathsData.length = 0;\n                }\n            }\n        } else if (!(e === 1 && s === 0 || e === 0 && s === 1)) {\n            var segments = [];\n            var shapeData;\n            var localShapeCollection;\n            for(i = 0; i < len; i += 1){\n                shapeData = this.shapes[i]; // if shape hasn't changed and trim properties haven't changed, cached previous path can be used\n                if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {\n                    shapeData.shape.paths = shapeData.localShapeCollection;\n                } else {\n                    shapePaths = shapeData.shape.paths;\n                    jLen = shapePaths._length;\n                    totalShapeLength = 0;\n                    if (!shapeData.shape._mdf && shapeData.pathsData.length) {\n                        totalShapeLength = shapeData.totalShapeLength;\n                    } else {\n                        pathsData = this.releasePathsData(shapeData.pathsData);\n                        for(j = 0; j < jLen; j += 1){\n                            pathData = bez.getSegmentsLength(shapePaths.shapes[j]);\n                            pathsData.push(pathData);\n                            totalShapeLength += pathData.totalLength;\n                        }\n                        shapeData.totalShapeLength = totalShapeLength;\n                        shapeData.pathsData = pathsData;\n                    }\n                    totalModifierLength += totalShapeLength;\n                    shapeData.shape._mdf = true;\n                }\n            }\n            var shapeS = s;\n            var shapeE = e;\n            var addedLength = 0;\n            var edges;\n            for(i = len - 1; i >= 0; i -= 1){\n                shapeData = this.shapes[i];\n                if (shapeData.shape._mdf) {\n                    localShapeCollection = shapeData.localShapeCollection;\n                    localShapeCollection.releaseShapes(); // if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group\n                    if (this.m === 2 && len > 1) {\n                        edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);\n                        addedLength += shapeData.totalShapeLength;\n                    } else {\n                        edges = [\n                            [\n                                shapeS,\n                                shapeE\n                            ]\n                        ];\n                    }\n                    jLen = edges.length;\n                    for(j = 0; j < jLen; j += 1){\n                        shapeS = edges[j][0];\n                        shapeE = edges[j][1];\n                        segments.length = 0;\n                        if (shapeE <= 1) {\n                            segments.push({\n                                s: shapeData.totalShapeLength * shapeS,\n                                e: shapeData.totalShapeLength * shapeE\n                            });\n                        } else if (shapeS >= 1) {\n                            segments.push({\n                                s: shapeData.totalShapeLength * (shapeS - 1),\n                                e: shapeData.totalShapeLength * (shapeE - 1)\n                            });\n                        } else {\n                            segments.push({\n                                s: shapeData.totalShapeLength * shapeS,\n                                e: shapeData.totalShapeLength\n                            });\n                            segments.push({\n                                s: 0,\n                                e: shapeData.totalShapeLength * (shapeE - 1)\n                            });\n                        }\n                        var newShapesData = this.addShapes(shapeData, segments[0]);\n                        if (segments[0].s !== segments[0].e) {\n                            if (segments.length > 1) {\n                                var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];\n                                if (lastShapeInCollection.c) {\n                                    var lastShape = newShapesData.pop();\n                                    this.addPaths(newShapesData, localShapeCollection);\n                                    newShapesData = this.addShapes(shapeData, segments[1], lastShape);\n                                } else {\n                                    this.addPaths(newShapesData, localShapeCollection);\n                                    newShapesData = this.addShapes(shapeData, segments[1]);\n                                }\n                            }\n                            this.addPaths(newShapesData, localShapeCollection);\n                        }\n                    }\n                    shapeData.shape.paths = localShapeCollection;\n                }\n            }\n        } else if (this._mdf) {\n            for(i = 0; i < len; i += 1){\n                // Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.\n                // Don't remove this even if it's losing cached info.\n                this.shapes[i].pathsData.length = 0;\n                this.shapes[i].shape._mdf = true;\n            }\n        }\n    };\n    TrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {\n        var i;\n        var len = newPaths.length;\n        for(i = 0; i < len; i += 1){\n            localShapeCollection.addShape(newPaths[i]);\n        }\n    };\n    TrimModifier.prototype.addSegment = function(pt1, pt2, pt3, pt4, shapePath, pos, newShape) {\n        shapePath.setXYAt(pt2[0], pt2[1], \"o\", pos);\n        shapePath.setXYAt(pt3[0], pt3[1], \"i\", pos + 1);\n        if (newShape) {\n            shapePath.setXYAt(pt1[0], pt1[1], \"v\", pos);\n        }\n        shapePath.setXYAt(pt4[0], pt4[1], \"v\", pos + 1);\n    };\n    TrimModifier.prototype.addSegmentFromArray = function(points, shapePath, pos, newShape) {\n        shapePath.setXYAt(points[1], points[5], \"o\", pos);\n        shapePath.setXYAt(points[2], points[6], \"i\", pos + 1);\n        if (newShape) {\n            shapePath.setXYAt(points[0], points[4], \"v\", pos);\n        }\n        shapePath.setXYAt(points[3], points[7], \"v\", pos + 1);\n    };\n    TrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath) {\n        var pathsData = shapeData.pathsData;\n        var shapePaths = shapeData.shape.paths.shapes;\n        var i;\n        var len = shapeData.shape.paths._length;\n        var j;\n        var jLen;\n        var addedLength = 0;\n        var currentLengthData;\n        var segmentCount;\n        var lengths;\n        var segment;\n        var shapes = [];\n        var initPos;\n        var newShape = true;\n        if (!shapePath) {\n            shapePath = shapePool.newElement();\n            segmentCount = 0;\n            initPos = 0;\n        } else {\n            segmentCount = shapePath._length;\n            initPos = shapePath._length;\n        }\n        shapes.push(shapePath);\n        for(i = 0; i < len; i += 1){\n            lengths = pathsData[i].lengths;\n            shapePath.c = shapePaths[i].c;\n            jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;\n            for(j = 1; j < jLen; j += 1){\n                currentLengthData = lengths[j - 1];\n                if (addedLength + currentLengthData.addedLength < shapeSegment.s) {\n                    addedLength += currentLengthData.addedLength;\n                    shapePath.c = false;\n                } else if (addedLength > shapeSegment.e) {\n                    shapePath.c = false;\n                    break;\n                } else {\n                    if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {\n                        this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);\n                        newShape = false;\n                    } else {\n                        segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);\n                        this.addSegmentFromArray(segment, shapePath, segmentCount, newShape); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);\n                        newShape = false;\n                        shapePath.c = false;\n                    }\n                    addedLength += currentLengthData.addedLength;\n                    segmentCount += 1;\n                }\n            }\n            if (shapePaths[i].c && lengths.length) {\n                currentLengthData = lengths[j - 1];\n                if (addedLength <= shapeSegment.e) {\n                    var segmentLength = lengths[j - 1].addedLength;\n                    if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {\n                        this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);\n                        newShape = false;\n                    } else {\n                        segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);\n                        this.addSegmentFromArray(segment, shapePath, segmentCount, newShape); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);\n                        newShape = false;\n                        shapePath.c = false;\n                    }\n                } else {\n                    shapePath.c = false;\n                }\n                addedLength += currentLengthData.addedLength;\n                segmentCount += 1;\n            }\n            if (shapePath._length) {\n                shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], \"i\", initPos);\n                shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], \"o\", shapePath._length - 1);\n            }\n            if (addedLength > shapeSegment.e) {\n                break;\n            }\n            if (i < len - 1) {\n                shapePath = shapePool.newElement();\n                newShape = true;\n                shapes.push(shapePath);\n                segmentCount = 0;\n            }\n        }\n        return shapes;\n    };\n    function PuckerAndBloatModifier() {}\n    extendPrototype([\n        ShapeModifier\n    ], PuckerAndBloatModifier);\n    PuckerAndBloatModifier.prototype.initModifierProperties = function(elem, data) {\n        this.getValue = this.processKeys;\n        this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);\n        this._isAnimated = !!this.amount.effectsSequence.length;\n    };\n    PuckerAndBloatModifier.prototype.processPath = function(path, amount) {\n        var percent = amount / 100;\n        var centerPoint = [\n            0,\n            0\n        ];\n        var pathLength = path._length;\n        var i = 0;\n        for(i = 0; i < pathLength; i += 1){\n            centerPoint[0] += path.v[i][0];\n            centerPoint[1] += path.v[i][1];\n        }\n        centerPoint[0] /= pathLength;\n        centerPoint[1] /= pathLength;\n        var clonedPath = shapePool.newElement();\n        clonedPath.c = path.c;\n        var vX;\n        var vY;\n        var oX;\n        var oY;\n        var iX;\n        var iY;\n        for(i = 0; i < pathLength; i += 1){\n            vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;\n            vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;\n            oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;\n            oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;\n            iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;\n            iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;\n            clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);\n        }\n        return clonedPath;\n    };\n    PuckerAndBloatModifier.prototype.processShapes = function(_isFirstFrame) {\n        var shapePaths;\n        var i;\n        var len = this.shapes.length;\n        var j;\n        var jLen;\n        var amount = this.amount.v;\n        if (amount !== 0) {\n            var shapeData;\n            var localShapeCollection;\n            for(i = 0; i < len; i += 1){\n                shapeData = this.shapes[i];\n                localShapeCollection = shapeData.localShapeCollection;\n                if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n                    localShapeCollection.releaseShapes();\n                    shapeData.shape._mdf = true;\n                    shapePaths = shapeData.shape.paths.shapes;\n                    jLen = shapeData.shape.paths._length;\n                    for(j = 0; j < jLen; j += 1){\n                        localShapeCollection.addShape(this.processPath(shapePaths[j], amount));\n                    }\n                }\n                shapeData.shape.paths = shapeData.localShapeCollection;\n            }\n        }\n        if (!this.dynamicProperties.length) {\n            this._mdf = false;\n        }\n    };\n    var TransformPropertyFactory = function() {\n        var defaultVector = [\n            0,\n            0\n        ];\n        function applyToMatrix(mat) {\n            var _mdf = this._mdf;\n            this.iterateDynamicProperties();\n            this._mdf = this._mdf || _mdf;\n            if (this.a) {\n                mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);\n            }\n            if (this.s) {\n                mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);\n            }\n            if (this.sk) {\n                mat.skewFromAxis(-this.sk.v, this.sa.v);\n            }\n            if (this.r) {\n                mat.rotate(-this.r.v);\n            } else {\n                mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);\n            }\n            if (this.data.p.s) {\n                if (this.data.p.z) {\n                    mat.translate(this.px.v, this.py.v, -this.pz.v);\n                } else {\n                    mat.translate(this.px.v, this.py.v, 0);\n                }\n            } else {\n                mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);\n            }\n        }\n        function processKeys(forceRender) {\n            if (this.elem.globalData.frameId === this.frameId) {\n                return;\n            }\n            if (this._isDirty) {\n                this.precalculateMatrix();\n                this._isDirty = false;\n            }\n            this.iterateDynamicProperties();\n            if (this._mdf || forceRender) {\n                var frameRate;\n                this.v.cloneFromProps(this.pre.props);\n                if (this.appliedTransformations < 1) {\n                    this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);\n                }\n                if (this.appliedTransformations < 2) {\n                    this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);\n                }\n                if (this.sk && this.appliedTransformations < 3) {\n                    this.v.skewFromAxis(-this.sk.v, this.sa.v);\n                }\n                if (this.r && this.appliedTransformations < 4) {\n                    this.v.rotate(-this.r.v);\n                } else if (!this.r && this.appliedTransformations < 4) {\n                    this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);\n                }\n                if (this.autoOriented) {\n                    var v1;\n                    var v2;\n                    frameRate = this.elem.globalData.frameRate;\n                    if (this.p && this.p.keyframes && this.p.getValueAtTime) {\n                        if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {\n                            v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);\n                            v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);\n                        } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {\n                            v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);\n                            v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);\n                        } else {\n                            v1 = this.p.pv;\n                            v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);\n                        }\n                    } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {\n                        v1 = [];\n                        v2 = [];\n                        var px = this.px;\n                        var py = this.py;\n                        if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {\n                            v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);\n                            v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);\n                            v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);\n                            v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);\n                        } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {\n                            v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);\n                            v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);\n                            v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);\n                            v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);\n                        } else {\n                            v1 = [\n                                px.pv,\n                                py.pv\n                            ];\n                            v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);\n                            v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);\n                        }\n                    } else {\n                        v2 = defaultVector;\n                        v1 = v2;\n                    }\n                    this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));\n                }\n                if (this.data.p && this.data.p.s) {\n                    if (this.data.p.z) {\n                        this.v.translate(this.px.v, this.py.v, -this.pz.v);\n                    } else {\n                        this.v.translate(this.px.v, this.py.v, 0);\n                    }\n                } else {\n                    this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);\n                }\n            }\n            this.frameId = this.elem.globalData.frameId;\n        }\n        function precalculateMatrix() {\n            this.appliedTransformations = 0;\n            this.pre.reset();\n            if (!this.a.effectsSequence.length) {\n                this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);\n                this.appliedTransformations = 1;\n            } else {\n                return;\n            }\n            if (!this.s.effectsSequence.length) {\n                this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);\n                this.appliedTransformations = 2;\n            } else {\n                return;\n            }\n            if (this.sk) {\n                if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {\n                    this.pre.skewFromAxis(-this.sk.v, this.sa.v);\n                    this.appliedTransformations = 3;\n                } else {\n                    return;\n                }\n            }\n            if (this.r) {\n                if (!this.r.effectsSequence.length) {\n                    this.pre.rotate(-this.r.v);\n                    this.appliedTransformations = 4;\n                }\n            } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {\n                this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);\n                this.appliedTransformations = 4;\n            }\n        }\n        function autoOrient() {\n        // var prevP = this.getValueAtTime();\n        }\n        function addDynamicProperty(prop) {\n            this._addDynamicProperty(prop);\n            this.elem.addDynamicProperty(prop);\n            this._isDirty = true;\n        }\n        function TransformProperty(elem, data, container) {\n            this.elem = elem;\n            this.frameId = -1;\n            this.propType = \"transform\";\n            this.data = data;\n            this.v = new Matrix(); // Precalculated matrix with non animated properties\n            this.pre = new Matrix();\n            this.appliedTransformations = 0;\n            this.initDynamicPropertyContainer(container || elem);\n            if (data.p && data.p.s) {\n                this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);\n                this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);\n                if (data.p.z) {\n                    this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);\n                }\n            } else {\n                this.p = PropertyFactory.getProp(elem, data.p || {\n                    k: [\n                        0,\n                        0,\n                        0\n                    ]\n                }, 1, 0, this);\n            }\n            if (data.rx) {\n                this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);\n                this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);\n                this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);\n                if (data.or.k[0].ti) {\n                    var i;\n                    var len = data.or.k.length;\n                    for(i = 0; i < len; i += 1){\n                        data.or.k[i].to = null;\n                        data.or.k[i].ti = null;\n                    }\n                }\n                this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this); // sh Indicates it needs to be capped between -180 and 180\n                this.or.sh = true;\n            } else {\n                this.r = PropertyFactory.getProp(elem, data.r || {\n                    k: 0\n                }, 0, degToRads, this);\n            }\n            if (data.sk) {\n                this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);\n                this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);\n            }\n            this.a = PropertyFactory.getProp(elem, data.a || {\n                k: [\n                    0,\n                    0,\n                    0\n                ]\n            }, 1, 0, this);\n            this.s = PropertyFactory.getProp(elem, data.s || {\n                k: [\n                    100,\n                    100,\n                    100\n                ]\n            }, 1, 0.01, this); // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.\n            if (data.o) {\n                this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem);\n            } else {\n                this.o = {\n                    _mdf: false,\n                    v: 1\n                };\n            }\n            this._isDirty = true;\n            if (!this.dynamicProperties.length) {\n                this.getValue(true);\n            }\n        }\n        TransformProperty.prototype = {\n            applyToMatrix: applyToMatrix,\n            getValue: processKeys,\n            precalculateMatrix: precalculateMatrix,\n            autoOrient: autoOrient\n        };\n        extendPrototype([\n            DynamicPropertyContainer\n        ], TransformProperty);\n        TransformProperty.prototype.addDynamicProperty = addDynamicProperty;\n        TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;\n        function getTransformProperty(elem, data, container) {\n            return new TransformProperty(elem, data, container);\n        }\n        return {\n            getTransformProperty: getTransformProperty\n        };\n    }();\n    function RepeaterModifier() {}\n    extendPrototype([\n        ShapeModifier\n    ], RepeaterModifier);\n    RepeaterModifier.prototype.initModifierProperties = function(elem, data) {\n        this.getValue = this.processKeys;\n        this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);\n        this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);\n        this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this);\n        this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this);\n        this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this);\n        this.data = data;\n        if (!this.dynamicProperties.length) {\n            this.getValue(true);\n        }\n        this._isAnimated = !!this.dynamicProperties.length;\n        this.pMatrix = new Matrix();\n        this.rMatrix = new Matrix();\n        this.sMatrix = new Matrix();\n        this.tMatrix = new Matrix();\n        this.matrix = new Matrix();\n    };\n    RepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform, perc, inv) {\n        var dir = inv ? -1 : 1;\n        var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);\n        var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);\n        pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);\n        rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);\n        rMatrix.rotate(-transform.r.v * dir * perc);\n        rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);\n        sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);\n        sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);\n        sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);\n    };\n    RepeaterModifier.prototype.init = function(elem, arr, pos, elemsData) {\n        this.elem = elem;\n        this.arr = arr;\n        this.pos = pos;\n        this.elemsData = elemsData;\n        this._currentCopies = 0;\n        this._elements = [];\n        this._groups = [];\n        this.frameId = -1;\n        this.initDynamicPropertyContainer(elem);\n        this.initModifierProperties(elem, arr[pos]);\n        while(pos > 0){\n            pos -= 1; // this._elements.unshift(arr.splice(pos,1)[0]);\n            this._elements.unshift(arr[pos]);\n        }\n        if (this.dynamicProperties.length) {\n            this.k = true;\n        } else {\n            this.getValue(true);\n        }\n    };\n    RepeaterModifier.prototype.resetElements = function(elements) {\n        var i;\n        var len = elements.length;\n        for(i = 0; i < len; i += 1){\n            elements[i]._processed = false;\n            if (elements[i].ty === \"gr\") {\n                this.resetElements(elements[i].it);\n            }\n        }\n    };\n    RepeaterModifier.prototype.cloneElements = function(elements) {\n        var newElements = JSON.parse(JSON.stringify(elements));\n        this.resetElements(newElements);\n        return newElements;\n    };\n    RepeaterModifier.prototype.changeGroupRender = function(elements, renderFlag) {\n        var i;\n        var len = elements.length;\n        for(i = 0; i < len; i += 1){\n            elements[i]._render = renderFlag;\n            if (elements[i].ty === \"gr\") {\n                this.changeGroupRender(elements[i].it, renderFlag);\n            }\n        }\n    };\n    RepeaterModifier.prototype.processShapes = function(_isFirstFrame) {\n        var items;\n        var itemsTransform;\n        var i;\n        var dir;\n        var cont;\n        var hasReloaded = false;\n        if (this._mdf || _isFirstFrame) {\n            var copies = Math.ceil(this.c.v);\n            if (this._groups.length < copies) {\n                while(this._groups.length < copies){\n                    var group = {\n                        it: this.cloneElements(this._elements),\n                        ty: \"gr\"\n                    };\n                    group.it.push({\n                        a: {\n                            a: 0,\n                            ix: 1,\n                            k: [\n                                0,\n                                0\n                            ]\n                        },\n                        nm: \"Transform\",\n                        o: {\n                            a: 0,\n                            ix: 7,\n                            k: 100\n                        },\n                        p: {\n                            a: 0,\n                            ix: 2,\n                            k: [\n                                0,\n                                0\n                            ]\n                        },\n                        r: {\n                            a: 1,\n                            ix: 6,\n                            k: [\n                                {\n                                    s: 0,\n                                    e: 0,\n                                    t: 0\n                                },\n                                {\n                                    s: 0,\n                                    e: 0,\n                                    t: 1\n                                }\n                            ]\n                        },\n                        s: {\n                            a: 0,\n                            ix: 3,\n                            k: [\n                                100,\n                                100\n                            ]\n                        },\n                        sa: {\n                            a: 0,\n                            ix: 5,\n                            k: 0\n                        },\n                        sk: {\n                            a: 0,\n                            ix: 4,\n                            k: 0\n                        },\n                        ty: \"tr\"\n                    });\n                    this.arr.splice(0, 0, group);\n                    this._groups.splice(0, 0, group);\n                    this._currentCopies += 1;\n                }\n                this.elem.reloadShapes();\n                hasReloaded = true;\n            }\n            cont = 0;\n            var renderFlag;\n            for(i = 0; i <= this._groups.length - 1; i += 1){\n                renderFlag = cont < copies;\n                this._groups[i]._render = renderFlag;\n                this.changeGroupRender(this._groups[i].it, renderFlag);\n                if (!renderFlag) {\n                    var elems = this.elemsData[i].it;\n                    var transformData = elems[elems.length - 1];\n                    if (transformData.transform.op.v !== 0) {\n                        transformData.transform.op._mdf = true;\n                        transformData.transform.op.v = 0;\n                    } else {\n                        transformData.transform.op._mdf = false;\n                    }\n                }\n                cont += 1;\n            }\n            this._currentCopies = copies; /// /\n            var offset = this.o.v;\n            var offsetModulo = offset % 1;\n            var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);\n            var pProps = this.pMatrix.props;\n            var rProps = this.rMatrix.props;\n            var sProps = this.sMatrix.props;\n            this.pMatrix.reset();\n            this.rMatrix.reset();\n            this.sMatrix.reset();\n            this.tMatrix.reset();\n            this.matrix.reset();\n            var iteration = 0;\n            if (offset > 0) {\n                while(iteration < roundOffset){\n                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);\n                    iteration += 1;\n                }\n                if (offsetModulo) {\n                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);\n                    iteration += offsetModulo;\n                }\n            } else if (offset < 0) {\n                while(iteration > roundOffset){\n                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);\n                    iteration -= 1;\n                }\n                if (offsetModulo) {\n                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);\n                    iteration -= offsetModulo;\n                }\n            }\n            i = this.data.m === 1 ? 0 : this._currentCopies - 1;\n            dir = this.data.m === 1 ? 1 : -1;\n            cont = this._currentCopies;\n            var j;\n            var jLen;\n            while(cont){\n                items = this.elemsData[i].it;\n                itemsTransform = items[items.length - 1].transform.mProps.v.props;\n                jLen = itemsTransform.length;\n                items[items.length - 1].transform.mProps._mdf = true;\n                items[items.length - 1].transform.op._mdf = true;\n                items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));\n                if (iteration !== 0) {\n                    if (i !== 0 && dir === 1 || i !== this._currentCopies - 1 && dir === -1) {\n                        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);\n                    }\n                    this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);\n                    this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);\n                    this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);\n                    for(j = 0; j < jLen; j += 1){\n                        itemsTransform[j] = this.matrix.props[j];\n                    }\n                    this.matrix.reset();\n                } else {\n                    this.matrix.reset();\n                    for(j = 0; j < jLen; j += 1){\n                        itemsTransform[j] = this.matrix.props[j];\n                    }\n                }\n                iteration += 1;\n                cont -= 1;\n                i += dir;\n            }\n        } else {\n            cont = this._currentCopies;\n            i = 0;\n            dir = 1;\n            while(cont){\n                items = this.elemsData[i].it;\n                itemsTransform = items[items.length - 1].transform.mProps.v.props;\n                items[items.length - 1].transform.mProps._mdf = false;\n                items[items.length - 1].transform.op._mdf = false;\n                cont -= 1;\n                i += dir;\n            }\n        }\n        return hasReloaded;\n    };\n    RepeaterModifier.prototype.addShape = function() {};\n    function RoundCornersModifier() {}\n    extendPrototype([\n        ShapeModifier\n    ], RoundCornersModifier);\n    RoundCornersModifier.prototype.initModifierProperties = function(elem, data) {\n        this.getValue = this.processKeys;\n        this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);\n        this._isAnimated = !!this.rd.effectsSequence.length;\n    };\n    RoundCornersModifier.prototype.processPath = function(path, round) {\n        var clonedPath = shapePool.newElement();\n        clonedPath.c = path.c;\n        var i;\n        var len = path._length;\n        var currentV;\n        var currentI;\n        var currentO;\n        var closerV;\n        var distance;\n        var newPosPerc;\n        var index = 0;\n        var vX;\n        var vY;\n        var oX;\n        var oY;\n        var iX;\n        var iY;\n        for(i = 0; i < len; i += 1){\n            currentV = path.v[i];\n            currentO = path.o[i];\n            currentI = path.i[i];\n            if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {\n                if ((i === 0 || i === len - 1) && !path.c) {\n                    clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index);\n                    /* clonedPath.v[index] = currentV;\r\n                  clonedPath.o[index] = currentO;\r\n                  clonedPath.i[index] = currentI; */ index += 1;\n                } else {\n                    if (i === 0) {\n                        closerV = path.v[len - 1];\n                    } else {\n                        closerV = path.v[i - 1];\n                    }\n                    distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));\n                    newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;\n                    iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;\n                    vX = iX;\n                    iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;\n                    vY = iY;\n                    oX = vX - (vX - currentV[0]) * roundCorner;\n                    oY = vY - (vY - currentV[1]) * roundCorner;\n                    clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);\n                    index += 1;\n                    if (i === len - 1) {\n                        closerV = path.v[0];\n                    } else {\n                        closerV = path.v[i + 1];\n                    }\n                    distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));\n                    newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;\n                    oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;\n                    vX = oX;\n                    oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;\n                    vY = oY;\n                    iX = vX - (vX - currentV[0]) * roundCorner;\n                    iY = vY - (vY - currentV[1]) * roundCorner;\n                    clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);\n                    index += 1;\n                }\n            } else {\n                clonedPath.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index);\n                index += 1;\n            }\n        }\n        return clonedPath;\n    };\n    RoundCornersModifier.prototype.processShapes = function(_isFirstFrame) {\n        var shapePaths;\n        var i;\n        var len = this.shapes.length;\n        var j;\n        var jLen;\n        var rd = this.rd.v;\n        if (rd !== 0) {\n            var shapeData;\n            var localShapeCollection;\n            for(i = 0; i < len; i += 1){\n                shapeData = this.shapes[i];\n                localShapeCollection = shapeData.localShapeCollection;\n                if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n                    localShapeCollection.releaseShapes();\n                    shapeData.shape._mdf = true;\n                    shapePaths = shapeData.shape.paths.shapes;\n                    jLen = shapeData.shape.paths._length;\n                    for(j = 0; j < jLen; j += 1){\n                        localShapeCollection.addShape(this.processPath(shapePaths[j], rd));\n                    }\n                }\n                shapeData.shape.paths = shapeData.localShapeCollection;\n            }\n        }\n        if (!this.dynamicProperties.length) {\n            this._mdf = false;\n        }\n    };\n    function floatEqual(a, b) {\n        return Math.abs(a - b) * 100000 <= Math.min(Math.abs(a), Math.abs(b));\n    }\n    function floatZero(f) {\n        return Math.abs(f) <= 0.00001;\n    }\n    function lerp(p0, p1, amount) {\n        return p0 * (1 - amount) + p1 * amount;\n    }\n    function lerpPoint(p0, p1, amount) {\n        return [\n            lerp(p0[0], p1[0], amount),\n            lerp(p0[1], p1[1], amount)\n        ];\n    }\n    function quadRoots(a, b, c) {\n        // no root\n        if (a === 0) return [];\n        var s = b * b - 4 * a * c; // Complex roots\n        if (s < 0) return [];\n        var singleRoot = -b / (2 * a); // 1 root\n        if (s === 0) return [\n            singleRoot\n        ];\n        var delta = Math.sqrt(s) / (2 * a); // 2 roots\n        return [\n            singleRoot - delta,\n            singleRoot + delta\n        ];\n    }\n    function polynomialCoefficients(p0, p1, p2, p3) {\n        return [\n            -p0 + 3 * p1 - 3 * p2 + p3,\n            3 * p0 - 6 * p1 + 3 * p2,\n            -3 * p0 + 3 * p1,\n            p0\n        ];\n    }\n    function singlePoint(p) {\n        return new PolynomialBezier(p, p, p, p, false);\n    }\n    function PolynomialBezier(p0, p1, p2, p3, linearize) {\n        if (linearize && pointEqual(p0, p1)) {\n            p1 = lerpPoint(p0, p3, 1 / 3);\n        }\n        if (linearize && pointEqual(p2, p3)) {\n            p2 = lerpPoint(p0, p3, 2 / 3);\n        }\n        var coeffx = polynomialCoefficients(p0[0], p1[0], p2[0], p3[0]);\n        var coeffy = polynomialCoefficients(p0[1], p1[1], p2[1], p3[1]);\n        this.a = [\n            coeffx[0],\n            coeffy[0]\n        ];\n        this.b = [\n            coeffx[1],\n            coeffy[1]\n        ];\n        this.c = [\n            coeffx[2],\n            coeffy[2]\n        ];\n        this.d = [\n            coeffx[3],\n            coeffy[3]\n        ];\n        this.points = [\n            p0,\n            p1,\n            p2,\n            p3\n        ];\n    }\n    PolynomialBezier.prototype.point = function(t) {\n        return [\n            ((this.a[0] * t + this.b[0]) * t + this.c[0]) * t + this.d[0],\n            ((this.a[1] * t + this.b[1]) * t + this.c[1]) * t + this.d[1]\n        ];\n    };\n    PolynomialBezier.prototype.derivative = function(t) {\n        return [\n            (3 * t * this.a[0] + 2 * this.b[0]) * t + this.c[0],\n            (3 * t * this.a[1] + 2 * this.b[1]) * t + this.c[1]\n        ];\n    };\n    PolynomialBezier.prototype.tangentAngle = function(t) {\n        var p = this.derivative(t);\n        return Math.atan2(p[1], p[0]);\n    };\n    PolynomialBezier.prototype.normalAngle = function(t) {\n        var p = this.derivative(t);\n        return Math.atan2(p[0], p[1]);\n    };\n    PolynomialBezier.prototype.inflectionPoints = function() {\n        var denom = this.a[1] * this.b[0] - this.a[0] * this.b[1];\n        if (floatZero(denom)) return [];\n        var tcusp = -0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / denom;\n        var square = tcusp * tcusp - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / denom;\n        if (square < 0) return [];\n        var root = Math.sqrt(square);\n        if (floatZero(root)) {\n            if (root > 0 && root < 1) return [\n                tcusp\n            ];\n            return [];\n        }\n        return [\n            tcusp - root,\n            tcusp + root\n        ].filter(function(r) {\n            return r > 0 && r < 1;\n        });\n    };\n    PolynomialBezier.prototype.split = function(t) {\n        if (t <= 0) return [\n            singlePoint(this.points[0]),\n            this\n        ];\n        if (t >= 1) return [\n            this,\n            singlePoint(this.points[this.points.length - 1])\n        ];\n        var p10 = lerpPoint(this.points[0], this.points[1], t);\n        var p11 = lerpPoint(this.points[1], this.points[2], t);\n        var p12 = lerpPoint(this.points[2], this.points[3], t);\n        var p20 = lerpPoint(p10, p11, t);\n        var p21 = lerpPoint(p11, p12, t);\n        var p3 = lerpPoint(p20, p21, t);\n        return [\n            new PolynomialBezier(this.points[0], p10, p20, p3, true),\n            new PolynomialBezier(p3, p21, p12, this.points[3], true)\n        ];\n    };\n    function extrema(bez, comp) {\n        var min = bez.points[0][comp];\n        var max = bez.points[bez.points.length - 1][comp];\n        if (min > max) {\n            var e = max;\n            max = min;\n            min = e;\n        } // Derivative roots to find min/max\n        var f = quadRoots(3 * bez.a[comp], 2 * bez.b[comp], bez.c[comp]);\n        for(var i = 0; i < f.length; i += 1){\n            if (f[i] > 0 && f[i] < 1) {\n                var val = bez.point(f[i])[comp];\n                if (val < min) min = val;\n                else if (val > max) max = val;\n            }\n        }\n        return {\n            min: min,\n            max: max\n        };\n    }\n    PolynomialBezier.prototype.bounds = function() {\n        return {\n            x: extrema(this, 0),\n            y: extrema(this, 1)\n        };\n    };\n    PolynomialBezier.prototype.boundingBox = function() {\n        var bounds = this.bounds();\n        return {\n            left: bounds.x.min,\n            right: bounds.x.max,\n            top: bounds.y.min,\n            bottom: bounds.y.max,\n            width: bounds.x.max - bounds.x.min,\n            height: bounds.y.max - bounds.y.min,\n            cx: (bounds.x.max + bounds.x.min) / 2,\n            cy: (bounds.y.max + bounds.y.min) / 2\n        };\n    };\n    function intersectData(bez, t1, t2) {\n        var box = bez.boundingBox();\n        return {\n            cx: box.cx,\n            cy: box.cy,\n            width: box.width,\n            height: box.height,\n            bez: bez,\n            t: (t1 + t2) / 2,\n            t1: t1,\n            t2: t2\n        };\n    }\n    function splitData(data) {\n        var split = data.bez.split(0.5);\n        return [\n            intersectData(split[0], data.t1, data.t),\n            intersectData(split[1], data.t, data.t2)\n        ];\n    }\n    function boxIntersect(b1, b2) {\n        return Math.abs(b1.cx - b2.cx) * 2 < b1.width + b2.width && Math.abs(b1.cy - b2.cy) * 2 < b1.height + b2.height;\n    }\n    function intersectsImpl(d1, d2, depth, tolerance, intersections, maxRecursion) {\n        if (!boxIntersect(d1, d2)) return;\n        if (depth >= maxRecursion || d1.width <= tolerance && d1.height <= tolerance && d2.width <= tolerance && d2.height <= tolerance) {\n            intersections.push([\n                d1.t,\n                d2.t\n            ]);\n            return;\n        }\n        var d1s = splitData(d1);\n        var d2s = splitData(d2);\n        intersectsImpl(d1s[0], d2s[0], depth + 1, tolerance, intersections, maxRecursion);\n        intersectsImpl(d1s[0], d2s[1], depth + 1, tolerance, intersections, maxRecursion);\n        intersectsImpl(d1s[1], d2s[0], depth + 1, tolerance, intersections, maxRecursion);\n        intersectsImpl(d1s[1], d2s[1], depth + 1, tolerance, intersections, maxRecursion);\n    }\n    PolynomialBezier.prototype.intersections = function(other, tolerance, maxRecursion) {\n        if (tolerance === undefined) tolerance = 2;\n        if (maxRecursion === undefined) maxRecursion = 7;\n        var intersections = [];\n        intersectsImpl(intersectData(this, 0, 1), intersectData(other, 0, 1), 0, tolerance, intersections, maxRecursion);\n        return intersections;\n    };\n    PolynomialBezier.shapeSegment = function(shapePath, index) {\n        var nextIndex = (index + 1) % shapePath.length();\n        return new PolynomialBezier(shapePath.v[index], shapePath.o[index], shapePath.i[nextIndex], shapePath.v[nextIndex], true);\n    };\n    PolynomialBezier.shapeSegmentInverted = function(shapePath, index) {\n        var nextIndex = (index + 1) % shapePath.length();\n        return new PolynomialBezier(shapePath.v[nextIndex], shapePath.i[nextIndex], shapePath.o[index], shapePath.v[index], true);\n    };\n    function crossProduct(a, b) {\n        return [\n            a[1] * b[2] - a[2] * b[1],\n            a[2] * b[0] - a[0] * b[2],\n            a[0] * b[1] - a[1] * b[0]\n        ];\n    }\n    function lineIntersection(start1, end1, start2, end2) {\n        var v1 = [\n            start1[0],\n            start1[1],\n            1\n        ];\n        var v2 = [\n            end1[0],\n            end1[1],\n            1\n        ];\n        var v3 = [\n            start2[0],\n            start2[1],\n            1\n        ];\n        var v4 = [\n            end2[0],\n            end2[1],\n            1\n        ];\n        var r = crossProduct(crossProduct(v1, v2), crossProduct(v3, v4));\n        if (floatZero(r[2])) return null;\n        return [\n            r[0] / r[2],\n            r[1] / r[2]\n        ];\n    }\n    function polarOffset(p, angle, length) {\n        return [\n            p[0] + Math.cos(angle) * length,\n            p[1] - Math.sin(angle) * length\n        ];\n    }\n    function pointDistance(p1, p2) {\n        return Math.hypot(p1[0] - p2[0], p1[1] - p2[1]);\n    }\n    function pointEqual(p1, p2) {\n        return floatEqual(p1[0], p2[0]) && floatEqual(p1[1], p2[1]);\n    }\n    function ZigZagModifier() {}\n    extendPrototype([\n        ShapeModifier\n    ], ZigZagModifier);\n    ZigZagModifier.prototype.initModifierProperties = function(elem, data) {\n        this.getValue = this.processKeys;\n        this.amplitude = PropertyFactory.getProp(elem, data.s, 0, null, this);\n        this.frequency = PropertyFactory.getProp(elem, data.r, 0, null, this);\n        this.pointsType = PropertyFactory.getProp(elem, data.pt, 0, null, this);\n        this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;\n    };\n    function setPoint(outputBezier, point, angle, direction, amplitude, outAmplitude, inAmplitude) {\n        var angO = angle - Math.PI / 2;\n        var angI = angle + Math.PI / 2;\n        var px = point[0] + Math.cos(angle) * direction * amplitude;\n        var py = point[1] - Math.sin(angle) * direction * amplitude;\n        outputBezier.setTripleAt(px, py, px + Math.cos(angO) * outAmplitude, py - Math.sin(angO) * outAmplitude, px + Math.cos(angI) * inAmplitude, py - Math.sin(angI) * inAmplitude, outputBezier.length());\n    }\n    function getPerpendicularVector(pt1, pt2) {\n        var vector = [\n            pt2[0] - pt1[0],\n            pt2[1] - pt1[1]\n        ];\n        var rot = -Math.PI * 0.5;\n        var rotatedVector = [\n            Math.cos(rot) * vector[0] - Math.sin(rot) * vector[1],\n            Math.sin(rot) * vector[0] + Math.cos(rot) * vector[1]\n        ];\n        return rotatedVector;\n    }\n    function getProjectingAngle(path, cur) {\n        var prevIndex = cur === 0 ? path.length() - 1 : cur - 1;\n        var nextIndex = (cur + 1) % path.length();\n        var prevPoint = path.v[prevIndex];\n        var nextPoint = path.v[nextIndex];\n        var pVector = getPerpendicularVector(prevPoint, nextPoint);\n        return Math.atan2(0, 1) - Math.atan2(pVector[1], pVector[0]);\n    }\n    function zigZagCorner(outputBezier, path, cur, amplitude, frequency, pointType, direction) {\n        var angle = getProjectingAngle(path, cur);\n        var point = path.v[cur % path._length];\n        var prevPoint = path.v[cur === 0 ? path._length - 1 : cur - 1];\n        var nextPoint = path.v[(cur + 1) % path._length];\n        var prevDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - prevPoint[0], 2) + Math.pow(point[1] - prevPoint[1], 2)) : 0;\n        var nextDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - nextPoint[0], 2) + Math.pow(point[1] - nextPoint[1], 2)) : 0;\n        setPoint(outputBezier, path.v[cur % path._length], angle, direction, amplitude, nextDist / ((frequency + 1) * 2), prevDist / ((frequency + 1) * 2), pointType);\n    }\n    function zigZagSegment(outputBezier, segment, amplitude, frequency, pointType, direction) {\n        for(var i = 0; i < frequency; i += 1){\n            var t = (i + 1) / (frequency + 1);\n            var dist = pointType === 2 ? Math.sqrt(Math.pow(segment.points[3][0] - segment.points[0][0], 2) + Math.pow(segment.points[3][1] - segment.points[0][1], 2)) : 0;\n            var angle = segment.normalAngle(t);\n            var point = segment.point(t);\n            setPoint(outputBezier, point, angle, direction, amplitude, dist / ((frequency + 1) * 2), dist / ((frequency + 1) * 2), pointType);\n            direction = -direction;\n        }\n        return direction;\n    }\n    ZigZagModifier.prototype.processPath = function(path, amplitude, frequency, pointType) {\n        var count = path._length;\n        var clonedPath = shapePool.newElement();\n        clonedPath.c = path.c;\n        if (!path.c) {\n            count -= 1;\n        }\n        if (count === 0) return clonedPath;\n        var direction = -1;\n        var segment = PolynomialBezier.shapeSegment(path, 0);\n        zigZagCorner(clonedPath, path, 0, amplitude, frequency, pointType, direction);\n        for(var i = 0; i < count; i += 1){\n            direction = zigZagSegment(clonedPath, segment, amplitude, frequency, pointType, -direction);\n            if (i === count - 1 && !path.c) {\n                segment = null;\n            } else {\n                segment = PolynomialBezier.shapeSegment(path, (i + 1) % count);\n            }\n            zigZagCorner(clonedPath, path, i + 1, amplitude, frequency, pointType, direction);\n        }\n        return clonedPath;\n    };\n    ZigZagModifier.prototype.processShapes = function(_isFirstFrame) {\n        var shapePaths;\n        var i;\n        var len = this.shapes.length;\n        var j;\n        var jLen;\n        var amplitude = this.amplitude.v;\n        var frequency = Math.max(0, Math.round(this.frequency.v));\n        var pointType = this.pointsType.v;\n        if (amplitude !== 0) {\n            var shapeData;\n            var localShapeCollection;\n            for(i = 0; i < len; i += 1){\n                shapeData = this.shapes[i];\n                localShapeCollection = shapeData.localShapeCollection;\n                if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n                    localShapeCollection.releaseShapes();\n                    shapeData.shape._mdf = true;\n                    shapePaths = shapeData.shape.paths.shapes;\n                    jLen = shapeData.shape.paths._length;\n                    for(j = 0; j < jLen; j += 1){\n                        localShapeCollection.addShape(this.processPath(shapePaths[j], amplitude, frequency, pointType));\n                    }\n                }\n                shapeData.shape.paths = shapeData.localShapeCollection;\n            }\n        }\n        if (!this.dynamicProperties.length) {\n            this._mdf = false;\n        }\n    };\n    function linearOffset(p1, p2, amount) {\n        var angle = Math.atan2(p2[0] - p1[0], p2[1] - p1[1]);\n        return [\n            polarOffset(p1, angle, amount),\n            polarOffset(p2, angle, amount)\n        ];\n    }\n    function offsetSegment(segment, amount) {\n        var p0;\n        var p1a;\n        var p1b;\n        var p2b;\n        var p2a;\n        var p3;\n        var e;\n        e = linearOffset(segment.points[0], segment.points[1], amount);\n        p0 = e[0];\n        p1a = e[1];\n        e = linearOffset(segment.points[1], segment.points[2], amount);\n        p1b = e[0];\n        p2b = e[1];\n        e = linearOffset(segment.points[2], segment.points[3], amount);\n        p2a = e[0];\n        p3 = e[1];\n        var p1 = lineIntersection(p0, p1a, p1b, p2b);\n        if (p1 === null) p1 = p1a;\n        var p2 = lineIntersection(p2a, p3, p1b, p2b);\n        if (p2 === null) p2 = p2a;\n        return new PolynomialBezier(p0, p1, p2, p3);\n    }\n    function joinLines(outputBezier, seg1, seg2, lineJoin, miterLimit) {\n        var p0 = seg1.points[3];\n        var p1 = seg2.points[0]; // Bevel\n        if (lineJoin === 3) return p0; // Connected, they don't need a joint\n        if (pointEqual(p0, p1)) return p0; // Round\n        if (lineJoin === 2) {\n            var angleOut = -seg1.tangentAngle(1);\n            var angleIn = -seg2.tangentAngle(0) + Math.PI;\n            var center = lineIntersection(p0, polarOffset(p0, angleOut + Math.PI / 2, 100), p1, polarOffset(p1, angleOut + Math.PI / 2, 100));\n            var radius = center ? pointDistance(center, p0) : pointDistance(p0, p1) / 2;\n            var tan = polarOffset(p0, angleOut, 2 * radius * roundCorner);\n            outputBezier.setXYAt(tan[0], tan[1], \"o\", outputBezier.length() - 1);\n            tan = polarOffset(p1, angleIn, 2 * radius * roundCorner);\n            outputBezier.setTripleAt(p1[0], p1[1], p1[0], p1[1], tan[0], tan[1], outputBezier.length());\n            return p1;\n        } // Miter\n        var t0 = pointEqual(p0, seg1.points[2]) ? seg1.points[0] : seg1.points[2];\n        var t1 = pointEqual(p1, seg2.points[1]) ? seg2.points[3] : seg2.points[1];\n        var intersection = lineIntersection(t0, p0, p1, t1);\n        if (intersection && pointDistance(intersection, p0) < miterLimit) {\n            outputBezier.setTripleAt(intersection[0], intersection[1], intersection[0], intersection[1], intersection[0], intersection[1], outputBezier.length());\n            return intersection;\n        }\n        return p0;\n    }\n    function getIntersection(a, b) {\n        var intersect = a.intersections(b);\n        if (intersect.length && floatEqual(intersect[0][0], 1)) intersect.shift();\n        if (intersect.length) return intersect[0];\n        return null;\n    }\n    function pruneSegmentIntersection(a, b) {\n        var outa = a.slice();\n        var outb = b.slice();\n        var intersect = getIntersection(a[a.length - 1], b[0]);\n        if (intersect) {\n            outa[a.length - 1] = a[a.length - 1].split(intersect[0])[0];\n            outb[0] = b[0].split(intersect[1])[1];\n        }\n        if (a.length > 1 && b.length > 1) {\n            intersect = getIntersection(a[0], b[b.length - 1]);\n            if (intersect) {\n                return [\n                    [\n                        a[0].split(intersect[0])[0]\n                    ],\n                    [\n                        b[b.length - 1].split(intersect[1])[1]\n                    ]\n                ];\n            }\n        }\n        return [\n            outa,\n            outb\n        ];\n    }\n    function pruneIntersections(segments) {\n        var e;\n        for(var i = 1; i < segments.length; i += 1){\n            e = pruneSegmentIntersection(segments[i - 1], segments[i]);\n            segments[i - 1] = e[0];\n            segments[i] = e[1];\n        }\n        if (segments.length > 1) {\n            e = pruneSegmentIntersection(segments[segments.length - 1], segments[0]);\n            segments[segments.length - 1] = e[0];\n            segments[0] = e[1];\n        }\n        return segments;\n    }\n    function offsetSegmentSplit(segment, amount) {\n        /*\r\n      We split each bezier segment into smaller pieces based\r\n      on inflection points, this ensures the control point\r\n      polygon is convex.\r\n        (A cubic bezier can have none, one, or two inflection points)\r\n    */ var flex = segment.inflectionPoints();\n        var left;\n        var right;\n        var split;\n        var mid;\n        if (flex.length === 0) {\n            return [\n                offsetSegment(segment, amount)\n            ];\n        }\n        if (flex.length === 1 || floatEqual(flex[1], 1)) {\n            split = segment.split(flex[0]);\n            left = split[0];\n            right = split[1];\n            return [\n                offsetSegment(left, amount),\n                offsetSegment(right, amount)\n            ];\n        }\n        split = segment.split(flex[0]);\n        left = split[0];\n        var t = (flex[1] - flex[0]) / (1 - flex[0]);\n        split = split[1].split(t);\n        mid = split[0];\n        right = split[1];\n        return [\n            offsetSegment(left, amount),\n            offsetSegment(mid, amount),\n            offsetSegment(right, amount)\n        ];\n    }\n    function OffsetPathModifier() {}\n    extendPrototype([\n        ShapeModifier\n    ], OffsetPathModifier);\n    OffsetPathModifier.prototype.initModifierProperties = function(elem, data) {\n        this.getValue = this.processKeys;\n        this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);\n        this.miterLimit = PropertyFactory.getProp(elem, data.ml, 0, null, this);\n        this.lineJoin = data.lj;\n        this._isAnimated = this.amount.effectsSequence.length !== 0;\n    };\n    OffsetPathModifier.prototype.processPath = function(inputBezier, amount, lineJoin, miterLimit) {\n        var outputBezier = shapePool.newElement();\n        outputBezier.c = inputBezier.c;\n        var count = inputBezier.length();\n        if (!inputBezier.c) {\n            count -= 1;\n        }\n        var i;\n        var j;\n        var segment;\n        var multiSegments = [];\n        for(i = 0; i < count; i += 1){\n            segment = PolynomialBezier.shapeSegment(inputBezier, i);\n            multiSegments.push(offsetSegmentSplit(segment, amount));\n        }\n        if (!inputBezier.c) {\n            for(i = count - 1; i >= 0; i -= 1){\n                segment = PolynomialBezier.shapeSegmentInverted(inputBezier, i);\n                multiSegments.push(offsetSegmentSplit(segment, amount));\n            }\n        }\n        multiSegments = pruneIntersections(multiSegments); // Add bezier segments to the output and apply line joints\n        var lastPoint = null;\n        var lastSeg = null;\n        for(i = 0; i < multiSegments.length; i += 1){\n            var multiSegment = multiSegments[i];\n            if (lastSeg) lastPoint = joinLines(outputBezier, lastSeg, multiSegment[0], lineJoin, miterLimit);\n            lastSeg = multiSegment[multiSegment.length - 1];\n            for(j = 0; j < multiSegment.length; j += 1){\n                segment = multiSegment[j];\n                if (lastPoint && pointEqual(segment.points[0], lastPoint)) {\n                    outputBezier.setXYAt(segment.points[1][0], segment.points[1][1], \"o\", outputBezier.length() - 1);\n                } else {\n                    outputBezier.setTripleAt(segment.points[0][0], segment.points[0][1], segment.points[1][0], segment.points[1][1], segment.points[0][0], segment.points[0][1], outputBezier.length());\n                }\n                outputBezier.setTripleAt(segment.points[3][0], segment.points[3][1], segment.points[3][0], segment.points[3][1], segment.points[2][0], segment.points[2][1], outputBezier.length());\n                lastPoint = segment.points[3];\n            }\n        }\n        if (multiSegments.length) joinLines(outputBezier, lastSeg, multiSegments[0][0], lineJoin, miterLimit);\n        return outputBezier;\n    };\n    OffsetPathModifier.prototype.processShapes = function(_isFirstFrame) {\n        var shapePaths;\n        var i;\n        var len = this.shapes.length;\n        var j;\n        var jLen;\n        var amount = this.amount.v;\n        var miterLimit = this.miterLimit.v;\n        var lineJoin = this.lineJoin;\n        if (amount !== 0) {\n            var shapeData;\n            var localShapeCollection;\n            for(i = 0; i < len; i += 1){\n                shapeData = this.shapes[i];\n                localShapeCollection = shapeData.localShapeCollection;\n                if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n                    localShapeCollection.releaseShapes();\n                    shapeData.shape._mdf = true;\n                    shapePaths = shapeData.shape.paths.shapes;\n                    jLen = shapeData.shape.paths._length;\n                    for(j = 0; j < jLen; j += 1){\n                        localShapeCollection.addShape(this.processPath(shapePaths[j], amount, lineJoin, miterLimit));\n                    }\n                }\n                shapeData.shape.paths = shapeData.localShapeCollection;\n            }\n        }\n        if (!this.dynamicProperties.length) {\n            this._mdf = false;\n        }\n    };\n    function getFontProperties(fontData) {\n        var styles = fontData.fStyle ? fontData.fStyle.split(\" \") : [];\n        var fWeight = \"normal\";\n        var fStyle = \"normal\";\n        var len = styles.length;\n        var styleName;\n        for(var i = 0; i < len; i += 1){\n            styleName = styles[i].toLowerCase();\n            switch(styleName){\n                case \"italic\":\n                    fStyle = \"italic\";\n                    break;\n                case \"bold\":\n                    fWeight = \"700\";\n                    break;\n                case \"black\":\n                    fWeight = \"900\";\n                    break;\n                case \"medium\":\n                    fWeight = \"500\";\n                    break;\n                case \"regular\":\n                case \"normal\":\n                    fWeight = \"400\";\n                    break;\n                case \"light\":\n                case \"thin\":\n                    fWeight = \"200\";\n                    break;\n                default:\n                    break;\n            }\n        }\n        return {\n            style: fStyle,\n            weight: fontData.fWeight || fWeight\n        };\n    }\n    var FontManager = function() {\n        var maxWaitingTime = 5000;\n        var emptyChar = {\n            w: 0,\n            size: 0,\n            shapes: [],\n            data: {\n                shapes: []\n            }\n        };\n        var combinedCharacters = []; // Hindi characters\n        combinedCharacters = combinedCharacters.concat([\n            2304,\n            2305,\n            2306,\n            2307,\n            2362,\n            2363,\n            2364,\n            2364,\n            2366,\n            2367,\n            2368,\n            2369,\n            2370,\n            2371,\n            2372,\n            2373,\n            2374,\n            2375,\n            2376,\n            2377,\n            2378,\n            2379,\n            2380,\n            2381,\n            2382,\n            2383,\n            2387,\n            2388,\n            2389,\n            2390,\n            2391,\n            2402,\n            2403\n        ]);\n        var BLACK_FLAG_CODE_POINT = 127988;\n        var CANCEL_TAG_CODE_POINT = 917631;\n        var A_TAG_CODE_POINT = 917601;\n        var Z_TAG_CODE_POINT = 917626;\n        var VARIATION_SELECTOR_16_CODE_POINT = 65039;\n        var ZERO_WIDTH_JOINER_CODE_POINT = 8205;\n        var REGIONAL_CHARACTER_A_CODE_POINT = 127462;\n        var REGIONAL_CHARACTER_Z_CODE_POINT = 127487;\n        var surrogateModifiers = [\n            \"d83cdffb\",\n            \"d83cdffc\",\n            \"d83cdffd\",\n            \"d83cdffe\",\n            \"d83cdfff\"\n        ];\n        function trimFontOptions(font) {\n            var familyArray = font.split(\",\");\n            var i;\n            var len = familyArray.length;\n            var enabledFamilies = [];\n            for(i = 0; i < len; i += 1){\n                if (familyArray[i] !== \"sans-serif\" && familyArray[i] !== \"monospace\") {\n                    enabledFamilies.push(familyArray[i]);\n                }\n            }\n            return enabledFamilies.join(\",\");\n        }\n        function setUpNode(font, family) {\n            var parentNode = createTag(\"span\"); // Node is invisible to screen readers.\n            parentNode.setAttribute(\"aria-hidden\", true);\n            parentNode.style.fontFamily = family;\n            var node = createTag(\"span\"); // Characters that vary significantly among different fonts\n            node.innerText = \"giItT1WQy@!-/#\"; // Visible - so we can measure it - but not on the screen\n            parentNode.style.position = \"absolute\";\n            parentNode.style.left = \"-10000px\";\n            parentNode.style.top = \"-10000px\"; // Large font size makes even subtle changes obvious\n            parentNode.style.fontSize = \"300px\"; // Reset any font properties\n            parentNode.style.fontVariant = \"normal\";\n            parentNode.style.fontStyle = \"normal\";\n            parentNode.style.fontWeight = \"normal\";\n            parentNode.style.letterSpacing = \"0\";\n            parentNode.appendChild(node);\n            document.body.appendChild(parentNode); // Remember width with no applied web font\n            var width = node.offsetWidth;\n            node.style.fontFamily = trimFontOptions(font) + \", \" + family;\n            return {\n                node: node,\n                w: width,\n                parent: parentNode\n            };\n        }\n        function checkLoadedFonts() {\n            var i;\n            var len = this.fonts.length;\n            var node;\n            var w;\n            var loadedCount = len;\n            for(i = 0; i < len; i += 1){\n                if (this.fonts[i].loaded) {\n                    loadedCount -= 1;\n                } else if (this.fonts[i].fOrigin === \"n\" || this.fonts[i].origin === 0) {\n                    this.fonts[i].loaded = true;\n                } else {\n                    node = this.fonts[i].monoCase.node;\n                    w = this.fonts[i].monoCase.w;\n                    if (node.offsetWidth !== w) {\n                        loadedCount -= 1;\n                        this.fonts[i].loaded = true;\n                    } else {\n                        node = this.fonts[i].sansCase.node;\n                        w = this.fonts[i].sansCase.w;\n                        if (node.offsetWidth !== w) {\n                            loadedCount -= 1;\n                            this.fonts[i].loaded = true;\n                        }\n                    }\n                    if (this.fonts[i].loaded) {\n                        this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);\n                        this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);\n                    }\n                }\n            }\n            if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {\n                setTimeout(this.checkLoadedFontsBinded, 20);\n            } else {\n                setTimeout(this.setIsLoadedBinded, 10);\n            }\n        }\n        function createHelper(fontData, def) {\n            var engine = document.body && def ? \"svg\" : \"canvas\";\n            var helper;\n            var fontProps = getFontProperties(fontData);\n            if (engine === \"svg\") {\n                var tHelper = createNS(\"text\");\n                tHelper.style.fontSize = \"100px\"; // tHelper.style.fontFamily = fontData.fFamily;\n                tHelper.setAttribute(\"font-family\", fontData.fFamily);\n                tHelper.setAttribute(\"font-style\", fontProps.style);\n                tHelper.setAttribute(\"font-weight\", fontProps.weight);\n                tHelper.textContent = \"1\";\n                if (fontData.fClass) {\n                    tHelper.style.fontFamily = \"inherit\";\n                    tHelper.setAttribute(\"class\", fontData.fClass);\n                } else {\n                    tHelper.style.fontFamily = fontData.fFamily;\n                }\n                def.appendChild(tHelper);\n                helper = tHelper;\n            } else {\n                var tCanvasHelper = new OffscreenCanvas(500, 500).getContext(\"2d\");\n                tCanvasHelper.font = fontProps.style + \" \" + fontProps.weight + \" 100px \" + fontData.fFamily;\n                helper = tCanvasHelper;\n            }\n            function measure(text) {\n                if (engine === \"svg\") {\n                    helper.textContent = text;\n                    return helper.getComputedTextLength();\n                }\n                return helper.measureText(text).width;\n            }\n            return {\n                measureText: measure\n            };\n        }\n        function addFonts(fontData, defs) {\n            if (!fontData) {\n                this.isLoaded = true;\n                return;\n            }\n            if (this.chars) {\n                this.isLoaded = true;\n                this.fonts = fontData.list;\n                return;\n            }\n            if (!document.body) {\n                this.isLoaded = true;\n                fontData.list.forEach(function(data) {\n                    data.helper = createHelper(data);\n                    data.cache = {};\n                });\n                this.fonts = fontData.list;\n                return;\n            }\n            var fontArr = fontData.list;\n            var i;\n            var len = fontArr.length;\n            var _pendingFonts = len;\n            for(i = 0; i < len; i += 1){\n                var shouldLoadFont = true;\n                var loadedSelector;\n                var j;\n                fontArr[i].loaded = false;\n                fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, \"monospace\");\n                fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, \"sans-serif\");\n                if (!fontArr[i].fPath) {\n                    fontArr[i].loaded = true;\n                    _pendingFonts -= 1;\n                } else if (fontArr[i].fOrigin === \"p\" || fontArr[i].origin === 3) {\n                    loadedSelector = document.querySelectorAll('style[f-forigin=\"p\"][f-family=\"' + fontArr[i].fFamily + '\"], style[f-origin=\"3\"][f-family=\"' + fontArr[i].fFamily + '\"]');\n                    if (loadedSelector.length > 0) {\n                        shouldLoadFont = false;\n                    }\n                    if (shouldLoadFont) {\n                        var s = createTag(\"style\");\n                        s.setAttribute(\"f-forigin\", fontArr[i].fOrigin);\n                        s.setAttribute(\"f-origin\", fontArr[i].origin);\n                        s.setAttribute(\"f-family\", fontArr[i].fFamily);\n                        s.type = \"text/css\";\n                        s.innerText = \"@font-face {font-family: \" + fontArr[i].fFamily + \"; font-style: normal; src: url('\" + fontArr[i].fPath + \"');}\";\n                        defs.appendChild(s);\n                    }\n                } else if (fontArr[i].fOrigin === \"g\" || fontArr[i].origin === 1) {\n                    loadedSelector = document.querySelectorAll('link[f-forigin=\"g\"], link[f-origin=\"1\"]');\n                    for(j = 0; j < loadedSelector.length; j += 1){\n                        if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {\n                            // Font is already loaded\n                            shouldLoadFont = false;\n                        }\n                    }\n                    if (shouldLoadFont) {\n                        var l = createTag(\"link\");\n                        l.setAttribute(\"f-forigin\", fontArr[i].fOrigin);\n                        l.setAttribute(\"f-origin\", fontArr[i].origin);\n                        l.type = \"text/css\";\n                        l.rel = \"stylesheet\";\n                        l.href = fontArr[i].fPath;\n                        document.body.appendChild(l);\n                    }\n                } else if (fontArr[i].fOrigin === \"t\" || fontArr[i].origin === 2) {\n                    loadedSelector = document.querySelectorAll('script[f-forigin=\"t\"], script[f-origin=\"2\"]');\n                    for(j = 0; j < loadedSelector.length; j += 1){\n                        if (fontArr[i].fPath === loadedSelector[j].src) {\n                            // Font is already loaded\n                            shouldLoadFont = false;\n                        }\n                    }\n                    if (shouldLoadFont) {\n                        var sc = createTag(\"link\");\n                        sc.setAttribute(\"f-forigin\", fontArr[i].fOrigin);\n                        sc.setAttribute(\"f-origin\", fontArr[i].origin);\n                        sc.setAttribute(\"rel\", \"stylesheet\");\n                        sc.setAttribute(\"href\", fontArr[i].fPath);\n                        defs.appendChild(sc);\n                    }\n                }\n                fontArr[i].helper = createHelper(fontArr[i], defs);\n                fontArr[i].cache = {};\n                this.fonts.push(fontArr[i]);\n            }\n            if (_pendingFonts === 0) {\n                this.isLoaded = true;\n            } else {\n                // On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.\n                // Adding this timeout seems to fix it\n                setTimeout(this.checkLoadedFonts.bind(this), 100);\n            }\n        }\n        function addChars(chars) {\n            if (!chars) {\n                return;\n            }\n            if (!this.chars) {\n                this.chars = [];\n            }\n            var i;\n            var len = chars.length;\n            var j;\n            var jLen = this.chars.length;\n            var found;\n            for(i = 0; i < len; i += 1){\n                j = 0;\n                found = false;\n                while(j < jLen){\n                    if (this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch) {\n                        found = true;\n                    }\n                    j += 1;\n                }\n                if (!found) {\n                    this.chars.push(chars[i]);\n                    jLen += 1;\n                }\n            }\n        }\n        function getCharData(_char, style, font) {\n            var i = 0;\n            var len = this.chars.length;\n            while(i < len){\n                if (this.chars[i].ch === _char && this.chars[i].style === style && this.chars[i].fFamily === font) {\n                    return this.chars[i];\n                }\n                i += 1;\n            }\n            if ((typeof _char === \"string\" && _char.charCodeAt(0) !== 13 || !_char) && console && console.warn // eslint-disable-line no-console\n             && !this._warned) {\n                this._warned = true;\n                console.warn(\"Missing character from exported characters list: \", _char, style, font); // eslint-disable-line no-console\n            }\n            return emptyChar;\n        }\n        function measureText(_char2, fontName, size) {\n            var fontData = this.getFontByName(fontName); // Using the char instead of char.charCodeAt(0)\n            // to avoid collisions between equal chars\n            var index = _char2;\n            if (!fontData.cache[index]) {\n                var tHelper = fontData.helper;\n                if (_char2 === \" \") {\n                    var doubleSize = tHelper.measureText(\"|\" + _char2 + \"|\");\n                    var singleSize = tHelper.measureText(\"||\");\n                    fontData.cache[index] = (doubleSize - singleSize) / 100;\n                } else {\n                    fontData.cache[index] = tHelper.measureText(_char2) / 100;\n                }\n            }\n            return fontData.cache[index] * size;\n        }\n        function getFontByName(name) {\n            var i = 0;\n            var len = this.fonts.length;\n            while(i < len){\n                if (this.fonts[i].fName === name) {\n                    return this.fonts[i];\n                }\n                i += 1;\n            }\n            return this.fonts[0];\n        }\n        function getCodePoint(string) {\n            var codePoint = 0;\n            var first = string.charCodeAt(0);\n            if (first >= 0xD800 && first <= 0xDBFF) {\n                var second = string.charCodeAt(1);\n                if (second >= 0xDC00 && second <= 0xDFFF) {\n                    codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n                }\n            }\n            return codePoint;\n        } // Skin tone modifiers\n        function isModifier(firstCharCode, secondCharCode) {\n            var sum = firstCharCode.toString(16) + secondCharCode.toString(16);\n            return surrogateModifiers.indexOf(sum) !== -1;\n        }\n        function isZeroWidthJoiner(charCode) {\n            return charCode === ZERO_WIDTH_JOINER_CODE_POINT;\n        } // This codepoint may change the appearance of the preceding character.\n        // If that is a symbol, dingbat or emoji, U+FE0F forces it to be rendered\n        // as a colorful image as compared to a monochrome text variant.\n        function isVariationSelector(charCode) {\n            return charCode === VARIATION_SELECTOR_16_CODE_POINT;\n        } // The regional indicator symbols are a set of 26 alphabetic Unicode\n        /// characters (AZ) intended to be used to encode ISO 3166-1 alpha-2\n        // two-letter country codes in a way that allows optional special treatment.\n        function isRegionalCode(string) {\n            var codePoint = getCodePoint(string);\n            if (codePoint >= REGIONAL_CHARACTER_A_CODE_POINT && codePoint <= REGIONAL_CHARACTER_Z_CODE_POINT) {\n                return true;\n            }\n            return false;\n        } // Some Emoji implementations represent combinations of\n        // two regional indicator letters as a single flag symbol.\n        function isFlagEmoji(string) {\n            return isRegionalCode(string.substr(0, 2)) && isRegionalCode(string.substr(2, 2));\n        }\n        function isCombinedCharacter(_char3) {\n            return combinedCharacters.indexOf(_char3) !== -1;\n        } // Regional flags start with a BLACK_FLAG_CODE_POINT\n        // folowed by 5 chars in the TAG range\n        // and end with a CANCEL_TAG_CODE_POINT\n        function isRegionalFlag(text, index) {\n            var codePoint = getCodePoint(text.substr(index, 2));\n            if (codePoint !== BLACK_FLAG_CODE_POINT) {\n                return false;\n            }\n            var count = 0;\n            index += 2;\n            while(count < 5){\n                codePoint = getCodePoint(text.substr(index, 2));\n                if (codePoint < A_TAG_CODE_POINT || codePoint > Z_TAG_CODE_POINT) {\n                    return false;\n                }\n                count += 1;\n                index += 2;\n            }\n            return getCodePoint(text.substr(index, 2)) === CANCEL_TAG_CODE_POINT;\n        }\n        function setIsLoaded() {\n            this.isLoaded = true;\n        }\n        var Font = function Font() {\n            this.fonts = [];\n            this.chars = null;\n            this.typekitLoaded = 0;\n            this.isLoaded = false;\n            this._warned = false;\n            this.initTime = Date.now();\n            this.setIsLoadedBinded = this.setIsLoaded.bind(this);\n            this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);\n        };\n        Font.isModifier = isModifier;\n        Font.isZeroWidthJoiner = isZeroWidthJoiner;\n        Font.isFlagEmoji = isFlagEmoji;\n        Font.isRegionalCode = isRegionalCode;\n        Font.isCombinedCharacter = isCombinedCharacter;\n        Font.isRegionalFlag = isRegionalFlag;\n        Font.isVariationSelector = isVariationSelector;\n        Font.BLACK_FLAG_CODE_POINT = BLACK_FLAG_CODE_POINT;\n        var fontPrototype = {\n            addChars: addChars,\n            addFonts: addFonts,\n            getCharData: getCharData,\n            getFontByName: getFontByName,\n            measureText: measureText,\n            checkLoadedFonts: checkLoadedFonts,\n            setIsLoaded: setIsLoaded\n        };\n        Font.prototype = fontPrototype;\n        return Font;\n    }();\n    function SlotManager(animationData) {\n        this.animationData = animationData;\n    }\n    SlotManager.prototype.getProp = function(data) {\n        if (this.animationData.slots && this.animationData.slots[data.sid]) {\n            return Object.assign(data, this.animationData.slots[data.sid].p);\n        }\n        return data;\n    };\n    function slotFactory(animationData) {\n        return new SlotManager(animationData);\n    }\n    function RenderableElement() {}\n    RenderableElement.prototype = {\n        initRenderable: function initRenderable() {\n            // layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange\n            this.isInRange = false; // layer's display state\n            this.hidden = false; // If layer's transparency equals 0, it can be hidden\n            this.isTransparent = false; // list of animated components\n            this.renderableComponents = [];\n        },\n        addRenderableComponent: function addRenderableComponent(component) {\n            if (this.renderableComponents.indexOf(component) === -1) {\n                this.renderableComponents.push(component);\n            }\n        },\n        removeRenderableComponent: function removeRenderableComponent(component) {\n            if (this.renderableComponents.indexOf(component) !== -1) {\n                this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);\n            }\n        },\n        prepareRenderableFrame: function prepareRenderableFrame(num) {\n            this.checkLayerLimits(num);\n        },\n        checkTransparency: function checkTransparency() {\n            if (this.finalTransform.mProp.o.v <= 0) {\n                if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {\n                    this.isTransparent = true;\n                    this.hide();\n                }\n            } else if (this.isTransparent) {\n                this.isTransparent = false;\n                this.show();\n            }\n        },\n        /**\r\n       * @function\r\n       * Initializes frame related properties.\r\n       *\r\n       * @param {number} num\r\n       * current frame number in Layer's time\r\n       *\r\n       */ checkLayerLimits: function checkLayerLimits(num) {\n            if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {\n                if (this.isInRange !== true) {\n                    this.globalData._mdf = true;\n                    this._mdf = true;\n                    this.isInRange = true;\n                    this.show();\n                }\n            } else if (this.isInRange !== false) {\n                this.globalData._mdf = true;\n                this.isInRange = false;\n                this.hide();\n            }\n        },\n        renderRenderable: function renderRenderable() {\n            var i;\n            var len = this.renderableComponents.length;\n            for(i = 0; i < len; i += 1){\n                this.renderableComponents[i].renderFrame(this._isFirstFrame);\n            }\n        /* this.maskManager.renderFrame(this.finalTransform.mat);\r\n          this.renderableEffectsManager.renderFrame(this._isFirstFrame); */ },\n        sourceRectAtTime: function sourceRectAtTime() {\n            return {\n                top: 0,\n                left: 0,\n                width: 100,\n                height: 100\n            };\n        },\n        getLayerSize: function getLayerSize() {\n            if (this.data.ty === 5) {\n                return {\n                    w: this.data.textData.width,\n                    h: this.data.textData.height\n                };\n            }\n            return {\n                w: this.data.width,\n                h: this.data.height\n            };\n        }\n    };\n    var getBlendMode = function() {\n        var blendModeEnums = {\n            0: \"source-over\",\n            1: \"multiply\",\n            2: \"screen\",\n            3: \"overlay\",\n            4: \"darken\",\n            5: \"lighten\",\n            6: \"color-dodge\",\n            7: \"color-burn\",\n            8: \"hard-light\",\n            9: \"soft-light\",\n            10: \"difference\",\n            11: \"exclusion\",\n            12: \"hue\",\n            13: \"saturation\",\n            14: \"color\",\n            15: \"luminosity\"\n        };\n        return function(mode) {\n            return blendModeEnums[mode] || \"\";\n        };\n    }();\n    function SliderEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n    }\n    function AngleEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n    }\n    function ColorEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);\n    }\n    function PointEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);\n    }\n    function LayerIndexEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n    }\n    function MaskIndexEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n    }\n    function CheckboxEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n    }\n    function NoValueEffect() {\n        this.p = {};\n    }\n    function EffectsManager(data, element) {\n        var effects = data.ef || [];\n        this.effectElements = [];\n        var i;\n        var len = effects.length;\n        var effectItem;\n        for(i = 0; i < len; i += 1){\n            effectItem = new GroupEffect(effects[i], element);\n            this.effectElements.push(effectItem);\n        }\n    }\n    function GroupEffect(data, element) {\n        this.init(data, element);\n    }\n    extendPrototype([\n        DynamicPropertyContainer\n    ], GroupEffect);\n    GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;\n    GroupEffect.prototype.init = function(data, element) {\n        this.data = data;\n        this.effectElements = [];\n        this.initDynamicPropertyContainer(element);\n        var i;\n        var len = this.data.ef.length;\n        var eff;\n        var effects = this.data.ef;\n        for(i = 0; i < len; i += 1){\n            eff = null;\n            switch(effects[i].ty){\n                case 0:\n                    eff = new SliderEffect(effects[i], element, this);\n                    break;\n                case 1:\n                    eff = new AngleEffect(effects[i], element, this);\n                    break;\n                case 2:\n                    eff = new ColorEffect(effects[i], element, this);\n                    break;\n                case 3:\n                    eff = new PointEffect(effects[i], element, this);\n                    break;\n                case 4:\n                case 7:\n                    eff = new CheckboxEffect(effects[i], element, this);\n                    break;\n                case 10:\n                    eff = new LayerIndexEffect(effects[i], element, this);\n                    break;\n                case 11:\n                    eff = new MaskIndexEffect(effects[i], element, this);\n                    break;\n                case 5:\n                    eff = new EffectsManager(effects[i], element, this);\n                    break;\n                // case 6:\n                default:\n                    eff = new NoValueEffect(effects[i], element, this);\n                    break;\n            }\n            if (eff) {\n                this.effectElements.push(eff);\n            }\n        }\n    };\n    function BaseElement() {}\n    BaseElement.prototype = {\n        checkMasks: function checkMasks() {\n            if (!this.data.hasMask) {\n                return false;\n            }\n            var i = 0;\n            var len = this.data.masksProperties.length;\n            while(i < len){\n                if (this.data.masksProperties[i].mode !== \"n\" && this.data.masksProperties[i].cl !== false) {\n                    return true;\n                }\n                i += 1;\n            }\n            return false;\n        },\n        initExpressions: function initExpressions() {\n            var expressionsInterfaces = getExpressionInterfaces();\n            if (!expressionsInterfaces) {\n                return;\n            }\n            var LayerExpressionInterface = expressionsInterfaces(\"layer\");\n            var EffectsExpressionInterface = expressionsInterfaces(\"effects\");\n            var ShapeExpressionInterface = expressionsInterfaces(\"shape\");\n            var TextExpressionInterface = expressionsInterfaces(\"text\");\n            var CompExpressionInterface = expressionsInterfaces(\"comp\");\n            this.layerInterface = LayerExpressionInterface(this);\n            if (this.data.hasMask && this.maskManager) {\n                this.layerInterface.registerMaskInterface(this.maskManager);\n            }\n            var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);\n            this.layerInterface.registerEffectsInterface(effectsInterface);\n            if (this.data.ty === 0 || this.data.xt) {\n                this.compInterface = CompExpressionInterface(this);\n            } else if (this.data.ty === 4) {\n                this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface);\n                this.layerInterface.content = this.layerInterface.shapeInterface;\n            } else if (this.data.ty === 5) {\n                this.layerInterface.textInterface = TextExpressionInterface(this);\n                this.layerInterface.text = this.layerInterface.textInterface;\n            }\n        },\n        setBlendMode: function setBlendMode() {\n            var blendModeValue = getBlendMode(this.data.bm);\n            var elem = this.baseElement || this.layerElement;\n            elem.style[\"mix-blend-mode\"] = blendModeValue;\n        },\n        initBaseData: function initBaseData(data, globalData, comp) {\n            this.globalData = globalData;\n            this.comp = comp;\n            this.data = data;\n            this.layerId = createElementID(); // Stretch factor for old animations missing this property.\n            if (!this.data.sr) {\n                this.data.sr = 1;\n            } // effects manager\n            this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);\n        },\n        getType: function getType() {\n            return this.type;\n        },\n        sourceRectAtTime: function sourceRectAtTime() {}\n    };\n    /**\r\n   * @file\r\n   * Handles element's layer frame update.\r\n   * Checks layer in point and out point\r\n   *\r\n   */ function FrameElement() {}\n    FrameElement.prototype = {\n        /**\r\n       * @function\r\n       * Initializes frame related properties.\r\n       *\r\n       */ initFrame: function initFrame() {\n            // set to true when inpoint is rendered\n            this._isFirstFrame = false; // list of animated properties\n            this.dynamicProperties = []; // If layer has been modified in current tick this will be true\n            this._mdf = false;\n        },\n        /**\r\n       * @function\r\n       * Calculates all dynamic values\r\n       *\r\n       * @param {number} num\r\n       * current frame number in Layer's time\r\n       * @param {boolean} isVisible\r\n       * if layers is currently in range\r\n       *\r\n       */ prepareProperties: function prepareProperties(num, isVisible) {\n            var i;\n            var len = this.dynamicProperties.length;\n            for(i = 0; i < len; i += 1){\n                if (isVisible || this._isParent && this.dynamicProperties[i].propType === \"transform\") {\n                    this.dynamicProperties[i].getValue();\n                    if (this.dynamicProperties[i]._mdf) {\n                        this.globalData._mdf = true;\n                        this._mdf = true;\n                    }\n                }\n            }\n        },\n        addDynamicProperty: function addDynamicProperty(prop) {\n            if (this.dynamicProperties.indexOf(prop) === -1) {\n                this.dynamicProperties.push(prop);\n            }\n        }\n    };\n    function FootageElement(data, globalData, comp) {\n        this.initFrame();\n        this.initRenderable();\n        this.assetData = globalData.getAssetData(data.refId);\n        this.footageData = globalData.imageLoader.getAsset(this.assetData);\n        this.initBaseData(data, globalData, comp);\n    }\n    FootageElement.prototype.prepareFrame = function() {};\n    extendPrototype([\n        RenderableElement,\n        BaseElement,\n        FrameElement\n    ], FootageElement);\n    FootageElement.prototype.getBaseElement = function() {\n        return null;\n    };\n    FootageElement.prototype.renderFrame = function() {};\n    FootageElement.prototype.destroy = function() {};\n    FootageElement.prototype.initExpressions = function() {\n        var expressionsInterfaces = getExpressionInterfaces();\n        if (!expressionsInterfaces) {\n            return;\n        }\n        var FootageInterface = expressionsInterfaces(\"footage\");\n        this.layerInterface = FootageInterface(this);\n    };\n    FootageElement.prototype.getFootageData = function() {\n        return this.footageData;\n    };\n    function AudioElement(data, globalData, comp) {\n        this.initFrame();\n        this.initRenderable();\n        this.assetData = globalData.getAssetData(data.refId);\n        this.initBaseData(data, globalData, comp);\n        this._isPlaying = false;\n        this._canPlay = false;\n        var assetPath = this.globalData.getAssetsPath(this.assetData);\n        this.audio = this.globalData.audioController.createAudio(assetPath);\n        this._currentTime = 0;\n        this.globalData.audioController.addAudio(this);\n        this._volumeMultiplier = 1;\n        this._volume = 1;\n        this._previousVolume = null;\n        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n            _placeholder: true\n        };\n        this.lv = PropertyFactory.getProp(this, data.au && data.au.lv ? data.au.lv : {\n            k: [\n                100\n            ]\n        }, 1, 0.01, this);\n    }\n    AudioElement.prototype.prepareFrame = function(num) {\n        this.prepareRenderableFrame(num, true);\n        this.prepareProperties(num, true);\n        if (!this.tm._placeholder) {\n            var timeRemapped = this.tm.v;\n            this._currentTime = timeRemapped;\n        } else {\n            this._currentTime = num / this.data.sr;\n        }\n        this._volume = this.lv.v[0];\n        var totalVolume = this._volume * this._volumeMultiplier;\n        if (this._previousVolume !== totalVolume) {\n            this._previousVolume = totalVolume;\n            this.audio.volume(totalVolume);\n        }\n    };\n    extendPrototype([\n        RenderableElement,\n        BaseElement,\n        FrameElement\n    ], AudioElement);\n    AudioElement.prototype.renderFrame = function() {\n        if (this.isInRange && this._canPlay) {\n            if (!this._isPlaying) {\n                this.audio.play();\n                this.audio.seek(this._currentTime / this.globalData.frameRate);\n                this._isPlaying = true;\n            } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) {\n                this.audio.seek(this._currentTime / this.globalData.frameRate);\n            }\n        }\n    };\n    AudioElement.prototype.show = function() {};\n    AudioElement.prototype.hide = function() {\n        this.audio.pause();\n        this._isPlaying = false;\n    };\n    AudioElement.prototype.pause = function() {\n        this.audio.pause();\n        this._isPlaying = false;\n        this._canPlay = false;\n    };\n    AudioElement.prototype.resume = function() {\n        this._canPlay = true;\n    };\n    AudioElement.prototype.setRate = function(rateValue) {\n        this.audio.rate(rateValue);\n    };\n    AudioElement.prototype.volume = function(volumeValue) {\n        this._volumeMultiplier = volumeValue;\n        this._previousVolume = volumeValue * this._volume;\n        this.audio.volume(this._previousVolume);\n    };\n    AudioElement.prototype.getBaseElement = function() {\n        return null;\n    };\n    AudioElement.prototype.destroy = function() {};\n    AudioElement.prototype.sourceRectAtTime = function() {};\n    AudioElement.prototype.initExpressions = function() {};\n    function BaseRenderer() {}\n    BaseRenderer.prototype.checkLayers = function(num) {\n        var i;\n        var len = this.layers.length;\n        var data;\n        this.completeLayers = true;\n        for(i = len - 1; i >= 0; i -= 1){\n            if (!this.elements[i]) {\n                data = this.layers[i];\n                if (data.ip - data.st <= num - this.layers[i].st && data.op - data.st > num - this.layers[i].st) {\n                    this.buildItem(i);\n                }\n            }\n            this.completeLayers = this.elements[i] ? this.completeLayers : false;\n        }\n        this.checkPendingElements();\n    };\n    BaseRenderer.prototype.createItem = function(layer) {\n        switch(layer.ty){\n            case 2:\n                return this.createImage(layer);\n            case 0:\n                return this.createComp(layer);\n            case 1:\n                return this.createSolid(layer);\n            case 3:\n                return this.createNull(layer);\n            case 4:\n                return this.createShape(layer);\n            case 5:\n                return this.createText(layer);\n            case 6:\n                return this.createAudio(layer);\n            case 13:\n                return this.createCamera(layer);\n            case 15:\n                return this.createFootage(layer);\n            default:\n                return this.createNull(layer);\n        }\n    };\n    BaseRenderer.prototype.createCamera = function() {\n        throw new Error(\"You're using a 3d camera. Try the html renderer.\");\n    };\n    BaseRenderer.prototype.createAudio = function(data) {\n        return new AudioElement(data, this.globalData, this);\n    };\n    BaseRenderer.prototype.createFootage = function(data) {\n        return new FootageElement(data, this.globalData, this);\n    };\n    BaseRenderer.prototype.buildAllItems = function() {\n        var i;\n        var len = this.layers.length;\n        for(i = 0; i < len; i += 1){\n            this.buildItem(i);\n        }\n        this.checkPendingElements();\n    };\n    BaseRenderer.prototype.includeLayers = function(newLayers) {\n        this.completeLayers = false;\n        var i;\n        var len = newLayers.length;\n        var j;\n        var jLen = this.layers.length;\n        for(i = 0; i < len; i += 1){\n            j = 0;\n            while(j < jLen){\n                if (this.layers[j].id === newLayers[i].id) {\n                    this.layers[j] = newLayers[i];\n                    break;\n                }\n                j += 1;\n            }\n        }\n    };\n    BaseRenderer.prototype.setProjectInterface = function(pInterface) {\n        this.globalData.projectInterface = pInterface;\n    };\n    BaseRenderer.prototype.initItems = function() {\n        if (!this.globalData.progressiveLoad) {\n            this.buildAllItems();\n        }\n    };\n    BaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy) {\n        var elements = this.elements;\n        var layers = this.layers;\n        var i = 0;\n        var len = layers.length;\n        while(i < len){\n            if (layers[i].ind == parentName) {\n                // eslint-disable-line eqeqeq\n                if (!elements[i] || elements[i] === true) {\n                    this.buildItem(i);\n                    this.addPendingElement(element);\n                } else {\n                    hierarchy.push(elements[i]);\n                    elements[i].setAsParent();\n                    if (layers[i].parent !== undefined) {\n                        this.buildElementParenting(element, layers[i].parent, hierarchy);\n                    } else {\n                        element.setHierarchy(hierarchy);\n                    }\n                }\n            }\n            i += 1;\n        }\n    };\n    BaseRenderer.prototype.addPendingElement = function(element) {\n        this.pendingElements.push(element);\n    };\n    BaseRenderer.prototype.searchExtraCompositions = function(assets) {\n        var i;\n        var len = assets.length;\n        for(i = 0; i < len; i += 1){\n            if (assets[i].xt) {\n                var comp = this.createComp(assets[i]);\n                comp.initExpressions();\n                this.globalData.projectInterface.registerComposition(comp);\n            }\n        }\n    };\n    BaseRenderer.prototype.getElementById = function(ind) {\n        var i;\n        var len = this.elements.length;\n        for(i = 0; i < len; i += 1){\n            if (this.elements[i].data.ind === ind) {\n                return this.elements[i];\n            }\n        }\n        return null;\n    };\n    BaseRenderer.prototype.getElementByPath = function(path) {\n        var pathValue = path.shift();\n        var element;\n        if (typeof pathValue === \"number\") {\n            element = this.elements[pathValue];\n        } else {\n            var i;\n            var len = this.elements.length;\n            for(i = 0; i < len; i += 1){\n                if (this.elements[i].data.nm === pathValue) {\n                    element = this.elements[i];\n                    break;\n                }\n            }\n        }\n        if (path.length === 0) {\n            return element;\n        }\n        return element.getElementByPath(path);\n    };\n    BaseRenderer.prototype.setupGlobalData = function(animData, fontsContainer) {\n        this.globalData.fontManager = new FontManager();\n        this.globalData.slotManager = slotFactory(animData);\n        this.globalData.fontManager.addChars(animData.chars);\n        this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);\n        this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);\n        this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);\n        this.globalData.imageLoader = this.animationItem.imagePreloader;\n        this.globalData.audioController = this.animationItem.audioController;\n        this.globalData.frameId = 0;\n        this.globalData.frameRate = animData.fr;\n        this.globalData.nm = animData.nm;\n        this.globalData.compSize = {\n            w: animData.w,\n            h: animData.h\n        };\n    };\n    var effectTypes = {\n        TRANSFORM_EFFECT: \"transformEFfect\"\n    };\n    function TransformElement() {}\n    TransformElement.prototype = {\n        initTransform: function initTransform() {\n            var mat = new Matrix();\n            this.finalTransform = {\n                mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {\n                    o: 0\n                },\n                _matMdf: false,\n                _localMatMdf: false,\n                _opMdf: false,\n                mat: mat,\n                localMat: mat,\n                localOpacity: 1\n            };\n            if (this.data.ao) {\n                this.finalTransform.mProp.autoOriented = true;\n            } // TODO: check TYPE 11: Guided elements\n            if (this.data.ty !== 11) {}\n        },\n        renderTransform: function renderTransform() {\n            this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;\n            this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;\n            if (this.hierarchy) {\n                var mat;\n                var finalMat = this.finalTransform.mat;\n                var i = 0;\n                var len = this.hierarchy.length; // Checking if any of the transformation matrices in the hierarchy chain has changed.\n                if (!this.finalTransform._matMdf) {\n                    while(i < len){\n                        if (this.hierarchy[i].finalTransform.mProp._mdf) {\n                            this.finalTransform._matMdf = true;\n                            break;\n                        }\n                        i += 1;\n                    }\n                }\n                if (this.finalTransform._matMdf) {\n                    mat = this.finalTransform.mProp.v.props;\n                    finalMat.cloneFromProps(mat);\n                    for(i = 0; i < len; i += 1){\n                        finalMat.multiply(this.hierarchy[i].finalTransform.mProp.v);\n                    }\n                }\n            }\n            if (this.finalTransform._matMdf) {\n                this.finalTransform._localMatMdf = this.finalTransform._matMdf;\n            }\n            if (this.finalTransform._opMdf) {\n                this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;\n            }\n        },\n        renderLocalTransform: function renderLocalTransform() {\n            if (this.localTransforms) {\n                var i = 0;\n                var len = this.localTransforms.length;\n                this.finalTransform._localMatMdf = this.finalTransform._matMdf;\n                if (!this.finalTransform._localMatMdf || !this.finalTransform._opMdf) {\n                    while(i < len){\n                        if (this.localTransforms[i]._mdf) {\n                            this.finalTransform._localMatMdf = true;\n                        }\n                        if (this.localTransforms[i]._opMdf && !this.finalTransform._opMdf) {\n                            this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;\n                            this.finalTransform._opMdf = true;\n                        }\n                        i += 1;\n                    }\n                }\n                if (this.finalTransform._localMatMdf) {\n                    var localMat = this.finalTransform.localMat;\n                    this.localTransforms[0].matrix.clone(localMat);\n                    for(i = 1; i < len; i += 1){\n                        var lmat = this.localTransforms[i].matrix;\n                        localMat.multiply(lmat);\n                    }\n                    localMat.multiply(this.finalTransform.mat);\n                }\n                if (this.finalTransform._opMdf) {\n                    var localOp = this.finalTransform.localOpacity;\n                    for(i = 0; i < len; i += 1){\n                        localOp *= this.localTransforms[i].opacity * 0.01;\n                    }\n                    this.finalTransform.localOpacity = localOp;\n                }\n            }\n        },\n        searchEffectTransforms: function searchEffectTransforms() {\n            if (this.renderableEffectsManager) {\n                var transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);\n                if (transformEffects.length) {\n                    this.localTransforms = [];\n                    this.finalTransform.localMat = new Matrix();\n                    var i = 0;\n                    var len = transformEffects.length;\n                    for(i = 0; i < len; i += 1){\n                        this.localTransforms.push(transformEffects[i]);\n                    }\n                }\n            }\n        },\n        globalToLocal: function globalToLocal(pt) {\n            var transforms = [];\n            transforms.push(this.finalTransform);\n            var flag = true;\n            var comp = this.comp;\n            while(flag){\n                if (comp.finalTransform) {\n                    if (comp.data.hasMask) {\n                        transforms.splice(0, 0, comp.finalTransform);\n                    }\n                    comp = comp.comp;\n                } else {\n                    flag = false;\n                }\n            }\n            var i;\n            var len = transforms.length;\n            var ptNew;\n            for(i = 0; i < len; i += 1){\n                ptNew = transforms[i].mat.applyToPointArray(0, 0, 0); // ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);\n                pt = [\n                    pt[0] - ptNew[0],\n                    pt[1] - ptNew[1],\n                    0\n                ];\n            }\n            return pt;\n        },\n        mHelper: new Matrix()\n    };\n    function MaskElement(data, element, globalData) {\n        this.data = data;\n        this.element = element;\n        this.globalData = globalData;\n        this.storedData = [];\n        this.masksProperties = this.data.masksProperties || [];\n        this.maskElement = null;\n        var defs = this.globalData.defs;\n        var i;\n        var len = this.masksProperties ? this.masksProperties.length : 0;\n        this.viewData = createSizedArray(len);\n        this.solidPath = \"\";\n        var path;\n        var properties = this.masksProperties;\n        var count = 0;\n        var currentMasks = [];\n        var j;\n        var jLen;\n        var layerId = createElementID();\n        var rect;\n        var expansor;\n        var feMorph;\n        var x;\n        var maskType = \"clipPath\";\n        var maskRef = \"clip-path\";\n        for(i = 0; i < len; i += 1){\n            if (properties[i].mode !== \"a\" && properties[i].mode !== \"n\" || properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x) {\n                maskType = \"mask\";\n                maskRef = \"mask\";\n            }\n            if ((properties[i].mode === \"s\" || properties[i].mode === \"i\") && count === 0) {\n                rect = createNS(\"rect\");\n                rect.setAttribute(\"fill\", \"#ffffff\");\n                rect.setAttribute(\"width\", this.element.comp.data.w || 0);\n                rect.setAttribute(\"height\", this.element.comp.data.h || 0);\n                currentMasks.push(rect);\n            } else {\n                rect = null;\n            }\n            path = createNS(\"path\");\n            if (properties[i].mode === \"n\") {\n                // TODO move this to a factory or to a constructor\n                this.viewData[i] = {\n                    op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),\n                    prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),\n                    elem: path,\n                    lastPath: \"\"\n                };\n                defs.appendChild(path);\n            } else {\n                count += 1;\n                path.setAttribute(\"fill\", properties[i].mode === \"s\" ? \"#000000\" : \"#ffffff\");\n                path.setAttribute(\"clip-rule\", \"nonzero\");\n                var filterID;\n                if (properties[i].x.k !== 0) {\n                    maskType = \"mask\";\n                    maskRef = \"mask\";\n                    x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element);\n                    filterID = createElementID();\n                    expansor = createNS(\"filter\");\n                    expansor.setAttribute(\"id\", filterID);\n                    feMorph = createNS(\"feMorphology\");\n                    feMorph.setAttribute(\"operator\", \"erode\");\n                    feMorph.setAttribute(\"in\", \"SourceGraphic\");\n                    feMorph.setAttribute(\"radius\", \"0\");\n                    expansor.appendChild(feMorph);\n                    defs.appendChild(expansor);\n                    path.setAttribute(\"stroke\", properties[i].mode === \"s\" ? \"#000000\" : \"#ffffff\");\n                } else {\n                    feMorph = null;\n                    x = null;\n                } // TODO move this to a factory or to a constructor\n                this.storedData[i] = {\n                    elem: path,\n                    x: x,\n                    expan: feMorph,\n                    lastPath: \"\",\n                    lastOperator: \"\",\n                    filterId: filterID,\n                    lastRadius: 0\n                };\n                if (properties[i].mode === \"i\") {\n                    jLen = currentMasks.length;\n                    var g = createNS(\"g\");\n                    for(j = 0; j < jLen; j += 1){\n                        g.appendChild(currentMasks[j]);\n                    }\n                    var mask = createNS(\"mask\");\n                    mask.setAttribute(\"mask-type\", \"alpha\");\n                    mask.setAttribute(\"id\", layerId + \"_\" + count);\n                    mask.appendChild(path);\n                    defs.appendChild(mask);\n                    g.setAttribute(\"mask\", \"url(\" + getLocationHref() + \"#\" + layerId + \"_\" + count + \")\");\n                    currentMasks.length = 0;\n                    currentMasks.push(g);\n                } else {\n                    currentMasks.push(path);\n                }\n                if (properties[i].inv && !this.solidPath) {\n                    this.solidPath = this.createLayerSolidPath();\n                } // TODO move this to a factory or to a constructor\n                this.viewData[i] = {\n                    elem: path,\n                    lastPath: \"\",\n                    op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),\n                    prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),\n                    invRect: rect\n                };\n                if (!this.viewData[i].prop.k) {\n                    this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i]);\n                }\n            }\n        }\n        this.maskElement = createNS(maskType);\n        len = currentMasks.length;\n        for(i = 0; i < len; i += 1){\n            this.maskElement.appendChild(currentMasks[i]);\n        }\n        if (count > 0) {\n            this.maskElement.setAttribute(\"id\", layerId);\n            this.element.maskedElement.setAttribute(maskRef, \"url(\" + getLocationHref() + \"#\" + layerId + \")\");\n            defs.appendChild(this.maskElement);\n        }\n        if (this.viewData.length) {\n            this.element.addRenderableComponent(this);\n        }\n    }\n    MaskElement.prototype.getMaskProperty = function(pos) {\n        return this.viewData[pos].prop;\n    };\n    MaskElement.prototype.renderFrame = function(isFirstFrame) {\n        var finalMat = this.element.finalTransform.mat;\n        var i;\n        var len = this.masksProperties.length;\n        for(i = 0; i < len; i += 1){\n            if (this.viewData[i].prop._mdf || isFirstFrame) {\n                this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]);\n            }\n            if (this.viewData[i].op._mdf || isFirstFrame) {\n                this.viewData[i].elem.setAttribute(\"fill-opacity\", this.viewData[i].op.v);\n            }\n            if (this.masksProperties[i].mode !== \"n\") {\n                if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {\n                    this.viewData[i].invRect.setAttribute(\"transform\", finalMat.getInverseMatrix().to2dCSS());\n                }\n                if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {\n                    var feMorph = this.storedData[i].expan;\n                    if (this.storedData[i].x.v < 0) {\n                        if (this.storedData[i].lastOperator !== \"erode\") {\n                            this.storedData[i].lastOperator = \"erode\";\n                            this.storedData[i].elem.setAttribute(\"filter\", \"url(\" + getLocationHref() + \"#\" + this.storedData[i].filterId + \")\");\n                        }\n                        feMorph.setAttribute(\"radius\", -this.storedData[i].x.v);\n                    } else {\n                        if (this.storedData[i].lastOperator !== \"dilate\") {\n                            this.storedData[i].lastOperator = \"dilate\";\n                            this.storedData[i].elem.setAttribute(\"filter\", null);\n                        }\n                        this.storedData[i].elem.setAttribute(\"stroke-width\", this.storedData[i].x.v * 2);\n                    }\n                }\n            }\n        }\n    };\n    MaskElement.prototype.getMaskelement = function() {\n        return this.maskElement;\n    };\n    MaskElement.prototype.createLayerSolidPath = function() {\n        var path = \"M0,0 \";\n        path += \" h\" + this.globalData.compSize.w;\n        path += \" v\" + this.globalData.compSize.h;\n        path += \" h-\" + this.globalData.compSize.w;\n        path += \" v-\" + this.globalData.compSize.h + \" \";\n        return path;\n    };\n    MaskElement.prototype.drawPath = function(pathData, pathNodes, viewData) {\n        var pathString = \" M\" + pathNodes.v[0][0] + \",\" + pathNodes.v[0][1];\n        var i;\n        var len;\n        len = pathNodes._length;\n        for(i = 1; i < len; i += 1){\n            // pathString += \" C\"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + \" \"+pathNodes.i[i][0]+','+pathNodes.i[i][1] + \" \"+pathNodes.v[i][0]+','+pathNodes.v[i][1];\n            pathString += \" C\" + pathNodes.o[i - 1][0] + \",\" + pathNodes.o[i - 1][1] + \" \" + pathNodes.i[i][0] + \",\" + pathNodes.i[i][1] + \" \" + pathNodes.v[i][0] + \",\" + pathNodes.v[i][1];\n        } // pathString += \" C\"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + \" \"+pathNodes.i[0][0]+','+pathNodes.i[0][1] + \" \"+pathNodes.v[0][0]+','+pathNodes.v[0][1];\n        if (pathNodes.c && len > 1) {\n            pathString += \" C\" + pathNodes.o[i - 1][0] + \",\" + pathNodes.o[i - 1][1] + \" \" + pathNodes.i[0][0] + \",\" + pathNodes.i[0][1] + \" \" + pathNodes.v[0][0] + \",\" + pathNodes.v[0][1];\n        } // pathNodes.__renderedString = pathString;\n        if (viewData.lastPath !== pathString) {\n            var pathShapeValue = \"\";\n            if (viewData.elem) {\n                if (pathNodes.c) {\n                    pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;\n                }\n                viewData.elem.setAttribute(\"d\", pathShapeValue);\n            }\n            viewData.lastPath = pathString;\n        }\n    };\n    MaskElement.prototype.destroy = function() {\n        this.element = null;\n        this.globalData = null;\n        this.maskElement = null;\n        this.data = null;\n        this.masksProperties = null;\n    };\n    var filtersFactory = function() {\n        var ob = {};\n        ob.createFilter = createFilter;\n        ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;\n        function createFilter(filId, skipCoordinates) {\n            var fil = createNS(\"filter\");\n            fil.setAttribute(\"id\", filId);\n            if (skipCoordinates !== true) {\n                fil.setAttribute(\"filterUnits\", \"objectBoundingBox\");\n                fil.setAttribute(\"x\", \"0%\");\n                fil.setAttribute(\"y\", \"0%\");\n                fil.setAttribute(\"width\", \"100%\");\n                fil.setAttribute(\"height\", \"100%\");\n            }\n            return fil;\n        }\n        function createAlphaToLuminanceFilter() {\n            var feColorMatrix = createNS(\"feColorMatrix\");\n            feColorMatrix.setAttribute(\"type\", \"matrix\");\n            feColorMatrix.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n            feColorMatrix.setAttribute(\"values\", \"0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1\");\n            return feColorMatrix;\n        }\n        return ob;\n    }();\n    var featureSupport = function() {\n        var ob = {\n            maskType: true,\n            svgLumaHidden: true,\n            offscreenCanvas: typeof OffscreenCanvas !== \"undefined\"\n        };\n        if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\\/\\d./i.test(navigator.userAgent)) {\n            ob.maskType = false;\n        }\n        if (/firefox/i.test(navigator.userAgent)) {\n            ob.svgLumaHidden = false;\n        }\n        return ob;\n    }();\n    var registeredEffects$1 = {};\n    var idPrefix = \"filter_result_\";\n    function SVGEffects(elem) {\n        var i;\n        var source = \"SourceGraphic\";\n        var len = elem.data.ef ? elem.data.ef.length : 0;\n        var filId = createElementID();\n        var fil = filtersFactory.createFilter(filId, true);\n        var count = 0;\n        this.filters = [];\n        var filterManager;\n        for(i = 0; i < len; i += 1){\n            filterManager = null;\n            var type = elem.data.ef[i].ty;\n            if (registeredEffects$1[type]) {\n                var Effect = registeredEffects$1[type].effect;\n                filterManager = new Effect(fil, elem.effectsManager.effectElements[i], elem, idPrefix + count, source);\n                source = idPrefix + count;\n                if (registeredEffects$1[type].countsAsEffect) {\n                    count += 1;\n                }\n            }\n            if (filterManager) {\n                this.filters.push(filterManager);\n            }\n        }\n        if (count) {\n            elem.globalData.defs.appendChild(fil);\n            elem.layerElement.setAttribute(\"filter\", \"url(\" + getLocationHref() + \"#\" + filId + \")\");\n        }\n        if (this.filters.length) {\n            elem.addRenderableComponent(this);\n        }\n    }\n    SVGEffects.prototype.renderFrame = function(_isFirstFrame) {\n        var i;\n        var len = this.filters.length;\n        for(i = 0; i < len; i += 1){\n            this.filters[i].renderFrame(_isFirstFrame);\n        }\n    };\n    SVGEffects.prototype.getEffects = function(type) {\n        var i;\n        var len = this.filters.length;\n        var effects = [];\n        for(i = 0; i < len; i += 1){\n            if (this.filters[i].type === type) {\n                effects.push(this.filters[i]);\n            }\n        }\n        return effects;\n    };\n    function registerEffect$1(id, effect, countsAsEffect) {\n        registeredEffects$1[id] = {\n            effect: effect,\n            countsAsEffect: countsAsEffect\n        };\n    }\n    function SVGBaseElement() {}\n    SVGBaseElement.prototype = {\n        initRendererElement: function initRendererElement() {\n            this.layerElement = createNS(\"g\");\n        },\n        createContainerElements: function createContainerElements() {\n            this.matteElement = createNS(\"g\");\n            this.transformedElement = this.layerElement;\n            this.maskedElement = this.layerElement;\n            this._sizeChanged = false;\n            var layerElementParent = null; // If this layer acts as a mask for the following layer\n            if (this.data.td) {\n                this.matteMasks = {};\n                var gg = createNS(\"g\");\n                gg.setAttribute(\"id\", this.layerId);\n                gg.appendChild(this.layerElement);\n                layerElementParent = gg;\n                this.globalData.defs.appendChild(gg);\n            } else if (this.data.tt) {\n                this.matteElement.appendChild(this.layerElement);\n                layerElementParent = this.matteElement;\n                this.baseElement = this.matteElement;\n            } else {\n                this.baseElement = this.layerElement;\n            }\n            if (this.data.ln) {\n                this.layerElement.setAttribute(\"id\", this.data.ln);\n            }\n            if (this.data.cl) {\n                this.layerElement.setAttribute(\"class\", this.data.cl);\n            } // Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped\n            if (this.data.ty === 0 && !this.data.hd) {\n                var cp = createNS(\"clipPath\");\n                var pt = createNS(\"path\");\n                pt.setAttribute(\"d\", \"M0,0 L\" + this.data.w + \",0 L\" + this.data.w + \",\" + this.data.h + \" L0,\" + this.data.h + \"z\");\n                var clipId = createElementID();\n                cp.setAttribute(\"id\", clipId);\n                cp.appendChild(pt);\n                this.globalData.defs.appendChild(cp);\n                if (this.checkMasks()) {\n                    var cpGroup = createNS(\"g\");\n                    cpGroup.setAttribute(\"clip-path\", \"url(\" + getLocationHref() + \"#\" + clipId + \")\");\n                    cpGroup.appendChild(this.layerElement);\n                    this.transformedElement = cpGroup;\n                    if (layerElementParent) {\n                        layerElementParent.appendChild(this.transformedElement);\n                    } else {\n                        this.baseElement = this.transformedElement;\n                    }\n                } else {\n                    this.layerElement.setAttribute(\"clip-path\", \"url(\" + getLocationHref() + \"#\" + clipId + \")\");\n                }\n            }\n            if (this.data.bm !== 0) {\n                this.setBlendMode();\n            }\n        },\n        renderElement: function renderElement() {\n            if (this.finalTransform._localMatMdf) {\n                this.transformedElement.setAttribute(\"transform\", this.finalTransform.localMat.to2dCSS());\n            }\n            if (this.finalTransform._opMdf) {\n                this.transformedElement.setAttribute(\"opacity\", this.finalTransform.localOpacity);\n            }\n        },\n        destroyBaseElement: function destroyBaseElement() {\n            this.layerElement = null;\n            this.matteElement = null;\n            this.maskManager.destroy();\n        },\n        getBaseElement: function getBaseElement() {\n            if (this.data.hd) {\n                return null;\n            }\n            return this.baseElement;\n        },\n        createRenderableComponents: function createRenderableComponents() {\n            this.maskManager = new MaskElement(this.data, this, this.globalData);\n            this.renderableEffectsManager = new SVGEffects(this);\n            this.searchEffectTransforms();\n        },\n        getMatte: function getMatte(matteType) {\n            // This should not be a common case. But for backward compatibility, we'll create the matte object.\n            // It solves animations that have two consecutive layers marked as matte masks.\n            // Which is an undefined behavior in AE.\n            if (!this.matteMasks) {\n                this.matteMasks = {};\n            }\n            if (!this.matteMasks[matteType]) {\n                var id = this.layerId + \"_\" + matteType;\n                var filId;\n                var fil;\n                var useElement;\n                var gg;\n                if (matteType === 1 || matteType === 3) {\n                    var masker = createNS(\"mask\");\n                    masker.setAttribute(\"id\", id);\n                    masker.setAttribute(\"mask-type\", matteType === 3 ? \"luminance\" : \"alpha\");\n                    useElement = createNS(\"use\");\n                    useElement.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", \"#\" + this.layerId);\n                    masker.appendChild(useElement);\n                    this.globalData.defs.appendChild(masker);\n                    if (!featureSupport.maskType && matteType === 1) {\n                        masker.setAttribute(\"mask-type\", \"luminance\");\n                        filId = createElementID();\n                        fil = filtersFactory.createFilter(filId);\n                        this.globalData.defs.appendChild(fil);\n                        fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());\n                        gg = createNS(\"g\");\n                        gg.appendChild(useElement);\n                        masker.appendChild(gg);\n                        gg.setAttribute(\"filter\", \"url(\" + getLocationHref() + \"#\" + filId + \")\");\n                    }\n                } else if (matteType === 2) {\n                    var maskGroup = createNS(\"mask\");\n                    maskGroup.setAttribute(\"id\", id);\n                    maskGroup.setAttribute(\"mask-type\", \"alpha\");\n                    var maskGrouper = createNS(\"g\");\n                    maskGroup.appendChild(maskGrouper);\n                    filId = createElementID();\n                    fil = filtersFactory.createFilter(filId); /// /\n                    var feCTr = createNS(\"feComponentTransfer\");\n                    feCTr.setAttribute(\"in\", \"SourceGraphic\");\n                    fil.appendChild(feCTr);\n                    var feFunc = createNS(\"feFuncA\");\n                    feFunc.setAttribute(\"type\", \"table\");\n                    feFunc.setAttribute(\"tableValues\", \"1.0 0.0\");\n                    feCTr.appendChild(feFunc); /// /\n                    this.globalData.defs.appendChild(fil);\n                    var alphaRect = createNS(\"rect\");\n                    alphaRect.setAttribute(\"width\", this.comp.data.w);\n                    alphaRect.setAttribute(\"height\", this.comp.data.h);\n                    alphaRect.setAttribute(\"x\", \"0\");\n                    alphaRect.setAttribute(\"y\", \"0\");\n                    alphaRect.setAttribute(\"fill\", \"#ffffff\");\n                    alphaRect.setAttribute(\"opacity\", \"0\");\n                    maskGrouper.setAttribute(\"filter\", \"url(\" + getLocationHref() + \"#\" + filId + \")\");\n                    maskGrouper.appendChild(alphaRect);\n                    useElement = createNS(\"use\");\n                    useElement.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", \"#\" + this.layerId);\n                    maskGrouper.appendChild(useElement);\n                    if (!featureSupport.maskType) {\n                        maskGroup.setAttribute(\"mask-type\", \"luminance\");\n                        fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());\n                        gg = createNS(\"g\");\n                        maskGrouper.appendChild(alphaRect);\n                        gg.appendChild(this.layerElement);\n                        maskGrouper.appendChild(gg);\n                    }\n                    this.globalData.defs.appendChild(maskGroup);\n                }\n                this.matteMasks[matteType] = id;\n            }\n            return this.matteMasks[matteType];\n        },\n        setMatte: function setMatte(id) {\n            if (!this.matteElement) {\n                return;\n            }\n            this.matteElement.setAttribute(\"mask\", \"url(\" + getLocationHref() + \"#\" + id + \")\");\n        }\n    };\n    /**\r\n   * @file\r\n   * Handles AE's layer parenting property.\r\n   *\r\n   */ function HierarchyElement() {}\n    HierarchyElement.prototype = {\n        /**\r\n       * @function\r\n       * Initializes hierarchy properties\r\n       *\r\n       */ initHierarchy: function initHierarchy() {\n            // element's parent list\n            this.hierarchy = []; // if element is parent of another layer _isParent will be true\n            this._isParent = false;\n            this.checkParenting();\n        },\n        /**\r\n       * @function\r\n       * Sets layer's hierarchy.\r\n       * @param {array} hierarch\r\n       * layer's parent list\r\n       *\r\n       */ setHierarchy: function setHierarchy(hierarchy) {\n            this.hierarchy = hierarchy;\n        },\n        /**\r\n       * @function\r\n       * Sets layer as parent.\r\n       *\r\n       */ setAsParent: function setAsParent() {\n            this._isParent = true;\n        },\n        /**\r\n       * @function\r\n       * Searches layer's parenting chain\r\n       *\r\n       */ checkParenting: function checkParenting() {\n            if (this.data.parent !== undefined) {\n                this.comp.buildElementParenting(this, this.data.parent, []);\n            }\n        }\n    };\n    function RenderableDOMElement() {}\n    (function() {\n        var _prototype = {\n            initElement: function initElement(data, globalData, comp) {\n                this.initFrame();\n                this.initBaseData(data, globalData, comp);\n                this.initTransform(data, globalData, comp);\n                this.initHierarchy();\n                this.initRenderable();\n                this.initRendererElement();\n                this.createContainerElements();\n                this.createRenderableComponents();\n                this.createContent();\n                this.hide();\n            },\n            hide: function hide() {\n                // console.log('HIDE', this);\n                if (!this.hidden && (!this.isInRange || this.isTransparent)) {\n                    var elem = this.baseElement || this.layerElement;\n                    elem.style.display = \"none\";\n                    this.hidden = true;\n                }\n            },\n            show: function show() {\n                // console.log('SHOW', this);\n                if (this.isInRange && !this.isTransparent) {\n                    if (!this.data.hd) {\n                        var elem = this.baseElement || this.layerElement;\n                        elem.style.display = \"block\";\n                    }\n                    this.hidden = false;\n                    this._isFirstFrame = true;\n                }\n            },\n            renderFrame: function renderFrame() {\n                // If it is exported as hidden (data.hd === true) no need to render\n                // If it is not visible no need to render\n                if (this.data.hd || this.hidden) {\n                    return;\n                }\n                this.renderTransform();\n                this.renderRenderable();\n                this.renderLocalTransform();\n                this.renderElement();\n                this.renderInnerContent();\n                if (this._isFirstFrame) {\n                    this._isFirstFrame = false;\n                }\n            },\n            renderInnerContent: function renderInnerContent() {},\n            prepareFrame: function prepareFrame(num) {\n                this._mdf = false;\n                this.prepareRenderableFrame(num);\n                this.prepareProperties(num, this.isInRange);\n                this.checkTransparency();\n            },\n            destroy: function destroy() {\n                this.innerElem = null;\n                this.destroyBaseElement();\n            }\n        };\n        extendPrototype([\n            RenderableElement,\n            createProxyFunction(_prototype)\n        ], RenderableDOMElement);\n    })();\n    function IImageElement(data, globalData, comp) {\n        this.assetData = globalData.getAssetData(data.refId);\n        if (this.assetData && this.assetData.sid) {\n            this.assetData = globalData.slotManager.getProp(this.assetData);\n        }\n        this.initElement(data, globalData, comp);\n        this.sourceRect = {\n            top: 0,\n            left: 0,\n            width: this.assetData.w,\n            height: this.assetData.h\n        };\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        SVGBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableDOMElement\n    ], IImageElement);\n    IImageElement.prototype.createContent = function() {\n        var assetPath = this.globalData.getAssetsPath(this.assetData);\n        this.innerElem = createNS(\"image\");\n        this.innerElem.setAttribute(\"width\", this.assetData.w + \"px\");\n        this.innerElem.setAttribute(\"height\", this.assetData.h + \"px\");\n        this.innerElem.setAttribute(\"preserveAspectRatio\", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);\n        this.innerElem.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", assetPath);\n        this.layerElement.appendChild(this.innerElem);\n    };\n    IImageElement.prototype.sourceRectAtTime = function() {\n        return this.sourceRect;\n    };\n    function ProcessedElement(element, position) {\n        this.elem = element;\n        this.pos = position;\n    }\n    function IShapeElement() {}\n    IShapeElement.prototype = {\n        addShapeToModifiers: function addShapeToModifiers(data) {\n            var i;\n            var len = this.shapeModifiers.length;\n            for(i = 0; i < len; i += 1){\n                this.shapeModifiers[i].addShape(data);\n            }\n        },\n        isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data) {\n            var i = 0;\n            var len = this.shapeModifiers.length;\n            while(i < len){\n                if (this.shapeModifiers[i].isAnimatedWithShape(data)) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        renderModifiers: function renderModifiers() {\n            if (!this.shapeModifiers.length) {\n                return;\n            }\n            var i;\n            var len = this.shapes.length;\n            for(i = 0; i < len; i += 1){\n                this.shapes[i].sh.reset();\n            }\n            len = this.shapeModifiers.length;\n            var shouldBreakProcess;\n            for(i = len - 1; i >= 0; i -= 1){\n                shouldBreakProcess = this.shapeModifiers[i].processShapes(this._isFirstFrame); // workaround to fix cases where a repeater resets the shape so the following processes get called twice\n                // TODO: find a better solution for this\n                if (shouldBreakProcess) {\n                    break;\n                }\n            }\n        },\n        searchProcessedElement: function searchProcessedElement(elem) {\n            var elements = this.processedElements;\n            var i = 0;\n            var len = elements.length;\n            while(i < len){\n                if (elements[i].elem === elem) {\n                    return elements[i].pos;\n                }\n                i += 1;\n            }\n            return 0;\n        },\n        addProcessedElement: function addProcessedElement(elem, pos) {\n            var elements = this.processedElements;\n            var i = elements.length;\n            while(i){\n                i -= 1;\n                if (elements[i].elem === elem) {\n                    elements[i].pos = pos;\n                    return;\n                }\n            }\n            elements.push(new ProcessedElement(elem, pos));\n        },\n        prepareFrame: function prepareFrame(num) {\n            this.prepareRenderableFrame(num);\n            this.prepareProperties(num, this.isInRange);\n        }\n    };\n    var lineCapEnum = {\n        1: \"butt\",\n        2: \"round\",\n        3: \"square\"\n    };\n    var lineJoinEnum = {\n        1: \"miter\",\n        2: \"round\",\n        3: \"bevel\"\n    };\n    function SVGShapeData(transformers, level, shape) {\n        this.caches = [];\n        this.styles = [];\n        this.transformers = transformers;\n        this.lStr = \"\";\n        this.sh = shape;\n        this.lvl = level; // TODO find if there are some cases where _isAnimated can be false.\n        // For now, since shapes add up with other shapes. They have to be calculated every time.\n        // One way of finding out is checking if all styles associated to this shape depend only of this shape\n        this._isAnimated = !!shape.k; // TODO: commenting this for now since all shapes are animated\n        var i = 0;\n        var len = transformers.length;\n        while(i < len){\n            if (transformers[i].mProps.dynamicProperties.length) {\n                this._isAnimated = true;\n                break;\n            }\n            i += 1;\n        }\n    }\n    SVGShapeData.prototype.setAsAnimated = function() {\n        this._isAnimated = true;\n    };\n    function SVGStyleData(data, level) {\n        this.data = data;\n        this.type = data.ty;\n        this.d = \"\";\n        this.lvl = level;\n        this._mdf = false;\n        this.closed = data.hd === true;\n        this.pElem = createNS(\"path\");\n        this.msElem = null;\n    }\n    SVGStyleData.prototype.reset = function() {\n        this.d = \"\";\n        this._mdf = false;\n    };\n    function DashProperty(elem, data, renderer, container) {\n        this.elem = elem;\n        this.frameId = -1;\n        this.dataProps = createSizedArray(data.length);\n        this.renderer = renderer;\n        this.k = false;\n        this.dashStr = \"\";\n        this.dashArray = createTypedArray(\"float32\", data.length ? data.length - 1 : 0);\n        this.dashoffset = createTypedArray(\"float32\", 1);\n        this.initDynamicPropertyContainer(container);\n        var i;\n        var len = data.length || 0;\n        var prop;\n        for(i = 0; i < len; i += 1){\n            prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this);\n            this.k = prop.k || this.k;\n            this.dataProps[i] = {\n                n: data[i].n,\n                p: prop\n            };\n        }\n        if (!this.k) {\n            this.getValue(true);\n        }\n        this._isAnimated = this.k;\n    }\n    DashProperty.prototype.getValue = function(forceRender) {\n        if (this.elem.globalData.frameId === this.frameId && !forceRender) {\n            return;\n        }\n        this.frameId = this.elem.globalData.frameId;\n        this.iterateDynamicProperties();\n        this._mdf = this._mdf || forceRender;\n        if (this._mdf) {\n            var i = 0;\n            var len = this.dataProps.length;\n            if (this.renderer === \"svg\") {\n                this.dashStr = \"\";\n            }\n            for(i = 0; i < len; i += 1){\n                if (this.dataProps[i].n !== \"o\") {\n                    if (this.renderer === \"svg\") {\n                        this.dashStr += \" \" + this.dataProps[i].p.v;\n                    } else {\n                        this.dashArray[i] = this.dataProps[i].p.v;\n                    }\n                } else {\n                    this.dashoffset[0] = this.dataProps[i].p.v;\n                }\n            }\n        }\n    };\n    extendPrototype([\n        DynamicPropertyContainer\n    ], DashProperty);\n    function SVGStrokeStyleData(elem, data, styleOb) {\n        this.initDynamicPropertyContainer(elem);\n        this.getValue = this.iterateDynamicProperties;\n        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);\n        this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);\n        this.d = new DashProperty(elem, data.d || {}, \"svg\", this);\n        this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);\n        this.style = styleOb;\n        this._isAnimated = !!this._isAnimated;\n    }\n    extendPrototype([\n        DynamicPropertyContainer\n    ], SVGStrokeStyleData);\n    function SVGFillStyleData(elem, data, styleOb) {\n        this.initDynamicPropertyContainer(elem);\n        this.getValue = this.iterateDynamicProperties;\n        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);\n        this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);\n        this.style = styleOb;\n    }\n    extendPrototype([\n        DynamicPropertyContainer\n    ], SVGFillStyleData);\n    function SVGNoStyleData(elem, data, styleOb) {\n        this.initDynamicPropertyContainer(elem);\n        this.getValue = this.iterateDynamicProperties;\n        this.style = styleOb;\n    }\n    extendPrototype([\n        DynamicPropertyContainer\n    ], SVGNoStyleData);\n    function GradientProperty(elem, data, container) {\n        this.data = data;\n        this.c = createTypedArray(\"uint8c\", data.p * 4);\n        var cLength = data.k.k[0].s ? data.k.k[0].s.length - data.p * 4 : data.k.k.length - data.p * 4;\n        this.o = createTypedArray(\"float32\", cLength);\n        this._cmdf = false;\n        this._omdf = false;\n        this._collapsable = this.checkCollapsable();\n        this._hasOpacity = cLength;\n        this.initDynamicPropertyContainer(container);\n        this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);\n        this.k = this.prop.k;\n        this.getValue(true);\n    }\n    GradientProperty.prototype.comparePoints = function(values, points) {\n        var i = 0;\n        var len = this.o.length / 2;\n        var diff;\n        while(i < len){\n            diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);\n            if (diff > 0.01) {\n                return false;\n            }\n            i += 1;\n        }\n        return true;\n    };\n    GradientProperty.prototype.checkCollapsable = function() {\n        if (this.o.length / 2 !== this.c.length / 4) {\n            return false;\n        }\n        if (this.data.k.k[0].s) {\n            var i = 0;\n            var len = this.data.k.k.length;\n            while(i < len){\n                if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {\n                    return false;\n                }\n                i += 1;\n            }\n        } else if (!this.comparePoints(this.data.k.k, this.data.p)) {\n            return false;\n        }\n        return true;\n    };\n    GradientProperty.prototype.getValue = function(forceRender) {\n        this.prop.getValue();\n        this._mdf = false;\n        this._cmdf = false;\n        this._omdf = false;\n        if (this.prop._mdf || forceRender) {\n            var i;\n            var len = this.data.p * 4;\n            var mult;\n            var val;\n            for(i = 0; i < len; i += 1){\n                mult = i % 4 === 0 ? 100 : 255;\n                val = Math.round(this.prop.v[i] * mult);\n                if (this.c[i] !== val) {\n                    this.c[i] = val;\n                    this._cmdf = !forceRender;\n                }\n            }\n            if (this.o.length) {\n                len = this.prop.v.length;\n                for(i = this.data.p * 4; i < len; i += 1){\n                    mult = i % 2 === 0 ? 100 : 1;\n                    val = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i];\n                    if (this.o[i - this.data.p * 4] !== val) {\n                        this.o[i - this.data.p * 4] = val;\n                        this._omdf = !forceRender;\n                    }\n                }\n            }\n            this._mdf = !forceRender;\n        }\n    };\n    extendPrototype([\n        DynamicPropertyContainer\n    ], GradientProperty);\n    function SVGGradientFillStyleData(elem, data, styleOb) {\n        this.initDynamicPropertyContainer(elem);\n        this.getValue = this.iterateDynamicProperties;\n        this.initGradientData(elem, data, styleOb);\n    }\n    SVGGradientFillStyleData.prototype.initGradientData = function(elem, data, styleOb) {\n        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);\n        this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);\n        this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);\n        this.h = PropertyFactory.getProp(elem, data.h || {\n            k: 0\n        }, 0, 0.01, this);\n        this.a = PropertyFactory.getProp(elem, data.a || {\n            k: 0\n        }, 0, degToRads, this);\n        this.g = new GradientProperty(elem, data.g, this);\n        this.style = styleOb;\n        this.stops = [];\n        this.setGradientData(styleOb.pElem, data);\n        this.setGradientOpacity(data, styleOb);\n        this._isAnimated = !!this._isAnimated;\n    };\n    SVGGradientFillStyleData.prototype.setGradientData = function(pathElement, data) {\n        var gradientId = createElementID();\n        var gfill = createNS(data.t === 1 ? \"linearGradient\" : \"radialGradient\");\n        gfill.setAttribute(\"id\", gradientId);\n        gfill.setAttribute(\"spreadMethod\", \"pad\");\n        gfill.setAttribute(\"gradientUnits\", \"userSpaceOnUse\");\n        var stops = [];\n        var stop;\n        var j;\n        var jLen;\n        jLen = data.g.p * 4;\n        for(j = 0; j < jLen; j += 4){\n            stop = createNS(\"stop\");\n            gfill.appendChild(stop);\n            stops.push(stop);\n        }\n        pathElement.setAttribute(data.ty === \"gf\" ? \"fill\" : \"stroke\", \"url(\" + getLocationHref() + \"#\" + gradientId + \")\");\n        this.gf = gfill;\n        this.cst = stops;\n    };\n    SVGGradientFillStyleData.prototype.setGradientOpacity = function(data, styleOb) {\n        if (this.g._hasOpacity && !this.g._collapsable) {\n            var stop;\n            var j;\n            var jLen;\n            var mask = createNS(\"mask\");\n            var maskElement = createNS(\"path\");\n            mask.appendChild(maskElement);\n            var opacityId = createElementID();\n            var maskId = createElementID();\n            mask.setAttribute(\"id\", maskId);\n            var opFill = createNS(data.t === 1 ? \"linearGradient\" : \"radialGradient\");\n            opFill.setAttribute(\"id\", opacityId);\n            opFill.setAttribute(\"spreadMethod\", \"pad\");\n            opFill.setAttribute(\"gradientUnits\", \"userSpaceOnUse\");\n            jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;\n            var stops = this.stops;\n            for(j = data.g.p * 4; j < jLen; j += 2){\n                stop = createNS(\"stop\");\n                stop.setAttribute(\"stop-color\", \"rgb(255,255,255)\");\n                opFill.appendChild(stop);\n                stops.push(stop);\n            }\n            maskElement.setAttribute(data.ty === \"gf\" ? \"fill\" : \"stroke\", \"url(\" + getLocationHref() + \"#\" + opacityId + \")\");\n            if (data.ty === \"gs\") {\n                maskElement.setAttribute(\"stroke-linecap\", lineCapEnum[data.lc || 2]);\n                maskElement.setAttribute(\"stroke-linejoin\", lineJoinEnum[data.lj || 2]);\n                if (data.lj === 1) {\n                    maskElement.setAttribute(\"stroke-miterlimit\", data.ml);\n                }\n            }\n            this.of = opFill;\n            this.ms = mask;\n            this.ost = stops;\n            this.maskId = maskId;\n            styleOb.msElem = maskElement;\n        }\n    };\n    extendPrototype([\n        DynamicPropertyContainer\n    ], SVGGradientFillStyleData);\n    function SVGGradientStrokeStyleData(elem, data, styleOb) {\n        this.initDynamicPropertyContainer(elem);\n        this.getValue = this.iterateDynamicProperties;\n        this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);\n        this.d = new DashProperty(elem, data.d || {}, \"svg\", this);\n        this.initGradientData(elem, data, styleOb);\n        this._isAnimated = !!this._isAnimated;\n    }\n    extendPrototype([\n        SVGGradientFillStyleData,\n        DynamicPropertyContainer\n    ], SVGGradientStrokeStyleData);\n    function ShapeGroupData() {\n        this.it = [];\n        this.prevViewData = [];\n        this.gr = createNS(\"g\");\n    }\n    function SVGTransformData(mProps, op, container) {\n        this.transform = {\n            mProps: mProps,\n            op: op,\n            container: container\n        };\n        this.elements = [];\n        this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;\n    }\n    var buildShapeString = function buildShapeString(pathNodes, length, closed, mat) {\n        if (length === 0) {\n            return \"\";\n        }\n        var _o = pathNodes.o;\n        var _i = pathNodes.i;\n        var _v = pathNodes.v;\n        var i;\n        var shapeString = \" M\" + mat.applyToPointStringified(_v[0][0], _v[0][1]);\n        for(i = 1; i < length; i += 1){\n            shapeString += \" C\" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + \" \" + mat.applyToPointStringified(_i[i][0], _i[i][1]) + \" \" + mat.applyToPointStringified(_v[i][0], _v[i][1]);\n        }\n        if (closed && length) {\n            shapeString += \" C\" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + \" \" + mat.applyToPointStringified(_i[0][0], _i[0][1]) + \" \" + mat.applyToPointStringified(_v[0][0], _v[0][1]);\n            shapeString += \"z\";\n        }\n        return shapeString;\n    };\n    var SVGElementsRenderer = function() {\n        var _identityMatrix = new Matrix();\n        var _matrixHelper = new Matrix();\n        var ob = {\n            createRenderFunction: createRenderFunction\n        };\n        function createRenderFunction(data) {\n            switch(data.ty){\n                case \"fl\":\n                    return renderFill;\n                case \"gf\":\n                    return renderGradient;\n                case \"gs\":\n                    return renderGradientStroke;\n                case \"st\":\n                    return renderStroke;\n                case \"sh\":\n                case \"el\":\n                case \"rc\":\n                case \"sr\":\n                    return renderPath;\n                case \"tr\":\n                    return renderContentTransform;\n                case \"no\":\n                    return renderNoop;\n                default:\n                    return null;\n            }\n        }\n        function renderContentTransform(styleData, itemData, isFirstFrame) {\n            if (isFirstFrame || itemData.transform.op._mdf) {\n                itemData.transform.container.setAttribute(\"opacity\", itemData.transform.op.v);\n            }\n            if (isFirstFrame || itemData.transform.mProps._mdf) {\n                itemData.transform.container.setAttribute(\"transform\", itemData.transform.mProps.v.to2dCSS());\n            }\n        }\n        function renderNoop() {}\n        function renderPath(styleData, itemData, isFirstFrame) {\n            var j;\n            var jLen;\n            var pathStringTransformed;\n            var redraw;\n            var pathNodes;\n            var l;\n            var lLen = itemData.styles.length;\n            var lvl = itemData.lvl;\n            var paths;\n            var mat;\n            var iterations;\n            var k;\n            for(l = 0; l < lLen; l += 1){\n                redraw = itemData.sh._mdf || isFirstFrame;\n                if (itemData.styles[l].lvl < lvl) {\n                    mat = _matrixHelper.reset();\n                    iterations = lvl - itemData.styles[l].lvl;\n                    k = itemData.transformers.length - 1;\n                    while(!redraw && iterations > 0){\n                        redraw = itemData.transformers[k].mProps._mdf || redraw;\n                        iterations -= 1;\n                        k -= 1;\n                    }\n                    if (redraw) {\n                        iterations = lvl - itemData.styles[l].lvl;\n                        k = itemData.transformers.length - 1;\n                        while(iterations > 0){\n                            mat.multiply(itemData.transformers[k].mProps.v);\n                            iterations -= 1;\n                            k -= 1;\n                        }\n                    }\n                } else {\n                    mat = _identityMatrix;\n                }\n                paths = itemData.sh.paths;\n                jLen = paths._length;\n                if (redraw) {\n                    pathStringTransformed = \"\";\n                    for(j = 0; j < jLen; j += 1){\n                        pathNodes = paths.shapes[j];\n                        if (pathNodes && pathNodes._length) {\n                            pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);\n                        }\n                    }\n                    itemData.caches[l] = pathStringTransformed;\n                } else {\n                    pathStringTransformed = itemData.caches[l];\n                }\n                itemData.styles[l].d += styleData.hd === true ? \"\" : pathStringTransformed;\n                itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;\n            }\n        }\n        function renderFill(styleData, itemData, isFirstFrame) {\n            var styleElem = itemData.style;\n            if (itemData.c._mdf || isFirstFrame) {\n                styleElem.pElem.setAttribute(\"fill\", \"rgb(\" + bmFloor(itemData.c.v[0]) + \",\" + bmFloor(itemData.c.v[1]) + \",\" + bmFloor(itemData.c.v[2]) + \")\");\n            }\n            if (itemData.o._mdf || isFirstFrame) {\n                styleElem.pElem.setAttribute(\"fill-opacity\", itemData.o.v);\n            }\n        }\n        function renderGradientStroke(styleData, itemData, isFirstFrame) {\n            renderGradient(styleData, itemData, isFirstFrame);\n            renderStroke(styleData, itemData, isFirstFrame);\n        }\n        function renderGradient(styleData, itemData, isFirstFrame) {\n            var gfill = itemData.gf;\n            var hasOpacity = itemData.g._hasOpacity;\n            var pt1 = itemData.s.v;\n            var pt2 = itemData.e.v;\n            if (itemData.o._mdf || isFirstFrame) {\n                var attr = styleData.ty === \"gf\" ? \"fill-opacity\" : \"stroke-opacity\";\n                itemData.style.pElem.setAttribute(attr, itemData.o.v);\n            }\n            if (itemData.s._mdf || isFirstFrame) {\n                var attr1 = styleData.t === 1 ? \"x1\" : \"cx\";\n                var attr2 = attr1 === \"x1\" ? \"y1\" : \"cy\";\n                gfill.setAttribute(attr1, pt1[0]);\n                gfill.setAttribute(attr2, pt1[1]);\n                if (hasOpacity && !itemData.g._collapsable) {\n                    itemData.of.setAttribute(attr1, pt1[0]);\n                    itemData.of.setAttribute(attr2, pt1[1]);\n                }\n            }\n            var stops;\n            var i;\n            var len;\n            var stop;\n            if (itemData.g._cmdf || isFirstFrame) {\n                stops = itemData.cst;\n                var cValues = itemData.g.c;\n                len = stops.length;\n                for(i = 0; i < len; i += 1){\n                    stop = stops[i];\n                    stop.setAttribute(\"offset\", cValues[i * 4] + \"%\");\n                    stop.setAttribute(\"stop-color\", \"rgb(\" + cValues[i * 4 + 1] + \",\" + cValues[i * 4 + 2] + \",\" + cValues[i * 4 + 3] + \")\");\n                }\n            }\n            if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {\n                var oValues = itemData.g.o;\n                if (itemData.g._collapsable) {\n                    stops = itemData.cst;\n                } else {\n                    stops = itemData.ost;\n                }\n                len = stops.length;\n                for(i = 0; i < len; i += 1){\n                    stop = stops[i];\n                    if (!itemData.g._collapsable) {\n                        stop.setAttribute(\"offset\", oValues[i * 2] + \"%\");\n                    }\n                    stop.setAttribute(\"stop-opacity\", oValues[i * 2 + 1]);\n                }\n            }\n            if (styleData.t === 1) {\n                if (itemData.e._mdf || isFirstFrame) {\n                    gfill.setAttribute(\"x2\", pt2[0]);\n                    gfill.setAttribute(\"y2\", pt2[1]);\n                    if (hasOpacity && !itemData.g._collapsable) {\n                        itemData.of.setAttribute(\"x2\", pt2[0]);\n                        itemData.of.setAttribute(\"y2\", pt2[1]);\n                    }\n                }\n            } else {\n                var rad;\n                if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {\n                    rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));\n                    gfill.setAttribute(\"r\", rad);\n                    if (hasOpacity && !itemData.g._collapsable) {\n                        itemData.of.setAttribute(\"r\", rad);\n                    }\n                }\n                if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {\n                    if (!rad) {\n                        rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));\n                    }\n                    var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);\n                    var percent = itemData.h.v;\n                    if (percent >= 1) {\n                        percent = 0.99;\n                    } else if (percent <= -1) {\n                        percent = -0.99;\n                    }\n                    var dist = rad * percent;\n                    var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];\n                    var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];\n                    gfill.setAttribute(\"fx\", x);\n                    gfill.setAttribute(\"fy\", y);\n                    if (hasOpacity && !itemData.g._collapsable) {\n                        itemData.of.setAttribute(\"fx\", x);\n                        itemData.of.setAttribute(\"fy\", y);\n                    }\n                } // gfill.setAttribute('fy','200');\n            }\n        }\n        function renderStroke(styleData, itemData, isFirstFrame) {\n            var styleElem = itemData.style;\n            var d = itemData.d;\n            if (d && (d._mdf || isFirstFrame) && d.dashStr) {\n                styleElem.pElem.setAttribute(\"stroke-dasharray\", d.dashStr);\n                styleElem.pElem.setAttribute(\"stroke-dashoffset\", d.dashoffset[0]);\n            }\n            if (itemData.c && (itemData.c._mdf || isFirstFrame)) {\n                styleElem.pElem.setAttribute(\"stroke\", \"rgb(\" + bmFloor(itemData.c.v[0]) + \",\" + bmFloor(itemData.c.v[1]) + \",\" + bmFloor(itemData.c.v[2]) + \")\");\n            }\n            if (itemData.o._mdf || isFirstFrame) {\n                styleElem.pElem.setAttribute(\"stroke-opacity\", itemData.o.v);\n            }\n            if (itemData.w._mdf || isFirstFrame) {\n                styleElem.pElem.setAttribute(\"stroke-width\", itemData.w.v);\n                if (styleElem.msElem) {\n                    styleElem.msElem.setAttribute(\"stroke-width\", itemData.w.v);\n                }\n            }\n        }\n        return ob;\n    }();\n    function SVGShapeElement(data, globalData, comp) {\n        // List of drawable elements\n        this.shapes = []; // Full shape data\n        this.shapesData = data.shapes; // List of styles that will be applied to shapes\n        this.stylesList = []; // List of modifiers that will be applied to shapes\n        this.shapeModifiers = []; // List of items in shape tree\n        this.itemsData = []; // List of items in previous shape tree\n        this.processedElements = []; // List of animated components\n        this.animatedContents = [];\n        this.initElement(data, globalData, comp); // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\n        // List of elements that have been created\n        this.prevViewData = []; // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        SVGBaseElement,\n        IShapeElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableDOMElement\n    ], SVGShapeElement);\n    SVGShapeElement.prototype.initSecondaryElement = function() {};\n    SVGShapeElement.prototype.identityMatrix = new Matrix();\n    SVGShapeElement.prototype.buildExpressionInterface = function() {};\n    SVGShapeElement.prototype.createContent = function() {\n        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);\n        this.filterUniqueShapes();\n    };\n    /*\r\n  This method searches for multiple shapes that affect a single element and one of them is animated\r\n  */ SVGShapeElement.prototype.filterUniqueShapes = function() {\n        var i;\n        var len = this.shapes.length;\n        var shape;\n        var j;\n        var jLen = this.stylesList.length;\n        var style;\n        var tempShapes = [];\n        var areAnimated = false;\n        for(j = 0; j < jLen; j += 1){\n            style = this.stylesList[j];\n            areAnimated = false;\n            tempShapes.length = 0;\n            for(i = 0; i < len; i += 1){\n                shape = this.shapes[i];\n                if (shape.styles.indexOf(style) !== -1) {\n                    tempShapes.push(shape);\n                    areAnimated = shape._isAnimated || areAnimated;\n                }\n            }\n            if (tempShapes.length > 1 && areAnimated) {\n                this.setShapesAsAnimated(tempShapes);\n            }\n        }\n    };\n    SVGShapeElement.prototype.setShapesAsAnimated = function(shapes) {\n        var i;\n        var len = shapes.length;\n        for(i = 0; i < len; i += 1){\n            shapes[i].setAsAnimated();\n        }\n    };\n    SVGShapeElement.prototype.createStyleElement = function(data, level) {\n        // TODO: prevent drawing of hidden styles\n        var elementData;\n        var styleOb = new SVGStyleData(data, level);\n        var pathElement = styleOb.pElem;\n        if (data.ty === \"st\") {\n            elementData = new SVGStrokeStyleData(this, data, styleOb);\n        } else if (data.ty === \"fl\") {\n            elementData = new SVGFillStyleData(this, data, styleOb);\n        } else if (data.ty === \"gf\" || data.ty === \"gs\") {\n            var GradientConstructor = data.ty === \"gf\" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;\n            elementData = new GradientConstructor(this, data, styleOb);\n            this.globalData.defs.appendChild(elementData.gf);\n            if (elementData.maskId) {\n                this.globalData.defs.appendChild(elementData.ms);\n                this.globalData.defs.appendChild(elementData.of);\n                pathElement.setAttribute(\"mask\", \"url(\" + getLocationHref() + \"#\" + elementData.maskId + \")\");\n            }\n        } else if (data.ty === \"no\") {\n            elementData = new SVGNoStyleData(this, data, styleOb);\n        }\n        if (data.ty === \"st\" || data.ty === \"gs\") {\n            pathElement.setAttribute(\"stroke-linecap\", lineCapEnum[data.lc || 2]);\n            pathElement.setAttribute(\"stroke-linejoin\", lineJoinEnum[data.lj || 2]);\n            pathElement.setAttribute(\"fill-opacity\", \"0\");\n            if (data.lj === 1) {\n                pathElement.setAttribute(\"stroke-miterlimit\", data.ml);\n            }\n        }\n        if (data.r === 2) {\n            pathElement.setAttribute(\"fill-rule\", \"evenodd\");\n        }\n        if (data.ln) {\n            pathElement.setAttribute(\"id\", data.ln);\n        }\n        if (data.cl) {\n            pathElement.setAttribute(\"class\", data.cl);\n        }\n        if (data.bm) {\n            pathElement.style[\"mix-blend-mode\"] = getBlendMode(data.bm);\n        }\n        this.stylesList.push(styleOb);\n        this.addToAnimatedContents(data, elementData);\n        return elementData;\n    };\n    SVGShapeElement.prototype.createGroupElement = function(data) {\n        var elementData = new ShapeGroupData();\n        if (data.ln) {\n            elementData.gr.setAttribute(\"id\", data.ln);\n        }\n        if (data.cl) {\n            elementData.gr.setAttribute(\"class\", data.cl);\n        }\n        if (data.bm) {\n            elementData.gr.style[\"mix-blend-mode\"] = getBlendMode(data.bm);\n        }\n        return elementData;\n    };\n    SVGShapeElement.prototype.createTransformElement = function(data, container) {\n        var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this);\n        var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);\n        this.addToAnimatedContents(data, elementData);\n        return elementData;\n    };\n    SVGShapeElement.prototype.createShapeElement = function(data, ownTransformers, level) {\n        var ty = 4;\n        if (data.ty === \"rc\") {\n            ty = 5;\n        } else if (data.ty === \"el\") {\n            ty = 6;\n        } else if (data.ty === \"sr\") {\n            ty = 7;\n        }\n        var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this);\n        var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);\n        this.shapes.push(elementData);\n        this.addShapeToModifiers(elementData);\n        this.addToAnimatedContents(data, elementData);\n        return elementData;\n    };\n    SVGShapeElement.prototype.addToAnimatedContents = function(data, element) {\n        var i = 0;\n        var len = this.animatedContents.length;\n        while(i < len){\n            if (this.animatedContents[i].element === element) {\n                return;\n            }\n            i += 1;\n        }\n        this.animatedContents.push({\n            fn: SVGElementsRenderer.createRenderFunction(data),\n            element: element,\n            data: data\n        });\n    };\n    SVGShapeElement.prototype.setElementStyles = function(elementData) {\n        var arr = elementData.styles;\n        var j;\n        var jLen = this.stylesList.length;\n        for(j = 0; j < jLen; j += 1){\n            if (!this.stylesList[j].closed) {\n                arr.push(this.stylesList[j]);\n            }\n        }\n    };\n    SVGShapeElement.prototype.reloadShapes = function() {\n        this._isFirstFrame = true;\n        var i;\n        var len = this.itemsData.length;\n        for(i = 0; i < len; i += 1){\n            this.prevViewData[i] = this.itemsData[i];\n        }\n        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);\n        this.filterUniqueShapes();\n        len = this.dynamicProperties.length;\n        for(i = 0; i < len; i += 1){\n            this.dynamicProperties[i].getValue();\n        }\n        this.renderModifiers();\n    };\n    SVGShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, container, level, transformers, render) {\n        var ownTransformers = [].concat(transformers);\n        var i;\n        var len = arr.length - 1;\n        var j;\n        var jLen;\n        var ownStyles = [];\n        var ownModifiers = [];\n        var currentTransform;\n        var modifier;\n        var processedPos;\n        for(i = len; i >= 0; i -= 1){\n            processedPos = this.searchProcessedElement(arr[i]);\n            if (!processedPos) {\n                arr[i]._render = render;\n            } else {\n                itemsData[i] = prevViewData[processedPos - 1];\n            }\n            if (arr[i].ty === \"fl\" || arr[i].ty === \"st\" || arr[i].ty === \"gf\" || arr[i].ty === \"gs\" || arr[i].ty === \"no\") {\n                if (!processedPos) {\n                    itemsData[i] = this.createStyleElement(arr[i], level);\n                } else {\n                    itemsData[i].style.closed = false;\n                }\n                if (arr[i]._render) {\n                    if (itemsData[i].style.pElem.parentNode !== container) {\n                        container.appendChild(itemsData[i].style.pElem);\n                    }\n                }\n                ownStyles.push(itemsData[i].style);\n            } else if (arr[i].ty === \"gr\") {\n                if (!processedPos) {\n                    itemsData[i] = this.createGroupElement(arr[i]);\n                } else {\n                    jLen = itemsData[i].it.length;\n                    for(j = 0; j < jLen; j += 1){\n                        itemsData[i].prevViewData[j] = itemsData[i].it[j];\n                    }\n                }\n                this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render);\n                if (arr[i]._render) {\n                    if (itemsData[i].gr.parentNode !== container) {\n                        container.appendChild(itemsData[i].gr);\n                    }\n                }\n            } else if (arr[i].ty === \"tr\") {\n                if (!processedPos) {\n                    itemsData[i] = this.createTransformElement(arr[i], container);\n                }\n                currentTransform = itemsData[i].transform;\n                ownTransformers.push(currentTransform);\n            } else if (arr[i].ty === \"sh\" || arr[i].ty === \"rc\" || arr[i].ty === \"el\" || arr[i].ty === \"sr\") {\n                if (!processedPos) {\n                    itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);\n                }\n                this.setElementStyles(itemsData[i]);\n            } else if (arr[i].ty === \"tm\" || arr[i].ty === \"rd\" || arr[i].ty === \"ms\" || arr[i].ty === \"pb\" || arr[i].ty === \"zz\" || arr[i].ty === \"op\") {\n                if (!processedPos) {\n                    modifier = ShapeModifiers.getModifier(arr[i].ty);\n                    modifier.init(this, arr[i]);\n                    itemsData[i] = modifier;\n                    this.shapeModifiers.push(modifier);\n                } else {\n                    modifier = itemsData[i];\n                    modifier.closed = false;\n                }\n                ownModifiers.push(modifier);\n            } else if (arr[i].ty === \"rp\") {\n                if (!processedPos) {\n                    modifier = ShapeModifiers.getModifier(arr[i].ty);\n                    itemsData[i] = modifier;\n                    modifier.init(this, arr, i, itemsData);\n                    this.shapeModifiers.push(modifier);\n                    render = false;\n                } else {\n                    modifier = itemsData[i];\n                    modifier.closed = true;\n                }\n                ownModifiers.push(modifier);\n            }\n            this.addProcessedElement(arr[i], i + 1);\n        }\n        len = ownStyles.length;\n        for(i = 0; i < len; i += 1){\n            ownStyles[i].closed = true;\n        }\n        len = ownModifiers.length;\n        for(i = 0; i < len; i += 1){\n            ownModifiers[i].closed = true;\n        }\n    };\n    SVGShapeElement.prototype.renderInnerContent = function() {\n        this.renderModifiers();\n        var i;\n        var len = this.stylesList.length;\n        for(i = 0; i < len; i += 1){\n            this.stylesList[i].reset();\n        }\n        this.renderShape();\n        for(i = 0; i < len; i += 1){\n            if (this.stylesList[i]._mdf || this._isFirstFrame) {\n                if (this.stylesList[i].msElem) {\n                    this.stylesList[i].msElem.setAttribute(\"d\", this.stylesList[i].d); // Adding M0 0 fixes same mask bug on all browsers\n                    this.stylesList[i].d = \"M0 0\" + this.stylesList[i].d;\n                }\n                this.stylesList[i].pElem.setAttribute(\"d\", this.stylesList[i].d || \"M0 0\");\n            }\n        }\n    };\n    SVGShapeElement.prototype.renderShape = function() {\n        var i;\n        var len = this.animatedContents.length;\n        var animatedContent;\n        for(i = 0; i < len; i += 1){\n            animatedContent = this.animatedContents[i];\n            if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {\n                animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);\n            }\n        }\n    };\n    SVGShapeElement.prototype.destroy = function() {\n        this.destroyBaseElement();\n        this.shapesData = null;\n        this.itemsData = null;\n    };\n    function LetterProps(o, sw, sc, fc, m, p) {\n        this.o = o;\n        this.sw = sw;\n        this.sc = sc;\n        this.fc = fc;\n        this.m = m;\n        this.p = p;\n        this._mdf = {\n            o: true,\n            sw: !!sw,\n            sc: !!sc,\n            fc: !!fc,\n            m: true,\n            p: true\n        };\n    }\n    LetterProps.prototype.update = function(o, sw, sc, fc, m, p) {\n        this._mdf.o = false;\n        this._mdf.sw = false;\n        this._mdf.sc = false;\n        this._mdf.fc = false;\n        this._mdf.m = false;\n        this._mdf.p = false;\n        var updated = false;\n        if (this.o !== o) {\n            this.o = o;\n            this._mdf.o = true;\n            updated = true;\n        }\n        if (this.sw !== sw) {\n            this.sw = sw;\n            this._mdf.sw = true;\n            updated = true;\n        }\n        if (this.sc !== sc) {\n            this.sc = sc;\n            this._mdf.sc = true;\n            updated = true;\n        }\n        if (this.fc !== fc) {\n            this.fc = fc;\n            this._mdf.fc = true;\n            updated = true;\n        }\n        if (this.m !== m) {\n            this.m = m;\n            this._mdf.m = true;\n            updated = true;\n        }\n        if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {\n            this.p = p;\n            this._mdf.p = true;\n            updated = true;\n        }\n        return updated;\n    };\n    function TextProperty(elem, data) {\n        this._frameId = initialDefaultFrame;\n        this.pv = \"\";\n        this.v = \"\";\n        this.kf = false;\n        this._isFirstFrame = true;\n        this._mdf = false;\n        if (data.d && data.d.sid) {\n            data.d = elem.globalData.slotManager.getProp(data.d);\n        }\n        this.data = data;\n        this.elem = elem;\n        this.comp = this.elem.comp;\n        this.keysIndex = 0;\n        this.canResize = false;\n        this.minimumFontSize = 1;\n        this.effectsSequence = [];\n        this.currentData = {\n            ascent: 0,\n            boxWidth: this.defaultBoxWidth,\n            f: \"\",\n            fStyle: \"\",\n            fWeight: \"\",\n            fc: \"\",\n            j: \"\",\n            justifyOffset: \"\",\n            l: [],\n            lh: 0,\n            lineWidths: [],\n            ls: \"\",\n            of: \"\",\n            s: \"\",\n            sc: \"\",\n            sw: 0,\n            t: 0,\n            tr: 0,\n            sz: 0,\n            ps: null,\n            fillColorAnim: false,\n            strokeColorAnim: false,\n            strokeWidthAnim: false,\n            yOffset: 0,\n            finalSize: 0,\n            finalText: [],\n            finalLineHeight: 0,\n            __complete: false\n        };\n        this.copyData(this.currentData, this.data.d.k[0].s);\n        if (!this.searchProperty()) {\n            this.completeTextData(this.currentData);\n        }\n    }\n    TextProperty.prototype.defaultBoxWidth = [\n        0,\n        0\n    ];\n    TextProperty.prototype.copyData = function(obj, data) {\n        for(var s in data){\n            if (Object.prototype.hasOwnProperty.call(data, s)) {\n                obj[s] = data[s];\n            }\n        }\n        return obj;\n    };\n    TextProperty.prototype.setCurrentData = function(data) {\n        if (!data.__complete) {\n            this.completeTextData(data);\n        }\n        this.currentData = data;\n        this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;\n        this._mdf = true;\n    };\n    TextProperty.prototype.searchProperty = function() {\n        return this.searchKeyframes();\n    };\n    TextProperty.prototype.searchKeyframes = function() {\n        this.kf = this.data.d.k.length > 1;\n        if (this.kf) {\n            this.addEffect(this.getKeyframeValue.bind(this));\n        }\n        return this.kf;\n    };\n    TextProperty.prototype.addEffect = function(effectFunction) {\n        this.effectsSequence.push(effectFunction);\n        this.elem.addDynamicProperty(this);\n    };\n    TextProperty.prototype.getValue = function(_finalValue) {\n        if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {\n            return;\n        }\n        this.currentData.t = this.data.d.k[this.keysIndex].s.t;\n        var currentValue = this.currentData;\n        var currentIndex = this.keysIndex;\n        if (this.lock) {\n            this.setCurrentData(this.currentData);\n            return;\n        }\n        this.lock = true;\n        this._mdf = false;\n        var i;\n        var len = this.effectsSequence.length;\n        var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;\n        for(i = 0; i < len; i += 1){\n            // Checking if index changed to prevent creating a new object every time the expression updates.\n            if (currentIndex !== this.keysIndex) {\n                finalValue = this.effectsSequence[i](finalValue, finalValue.t);\n            } else {\n                finalValue = this.effectsSequence[i](this.currentData, finalValue.t);\n            }\n        }\n        if (currentValue !== finalValue) {\n            this.setCurrentData(finalValue);\n        }\n        this.v = this.currentData;\n        this.pv = this.v;\n        this.lock = false;\n        this.frameId = this.elem.globalData.frameId;\n    };\n    TextProperty.prototype.getKeyframeValue = function() {\n        var textKeys = this.data.d.k;\n        var frameNum = this.elem.comp.renderedFrame;\n        var i = 0;\n        var len = textKeys.length;\n        while(i <= len - 1){\n            if (i === len - 1 || textKeys[i + 1].t > frameNum) {\n                break;\n            }\n            i += 1;\n        }\n        if (this.keysIndex !== i) {\n            this.keysIndex = i;\n        }\n        return this.data.d.k[this.keysIndex].s;\n    };\n    TextProperty.prototype.buildFinalText = function(text) {\n        var charactersArray = [];\n        var i = 0;\n        var len = text.length;\n        var charCode;\n        var secondCharCode;\n        var shouldCombine = false;\n        var shouldCombineNext = false;\n        var currentChars = \"\";\n        while(i < len){\n            shouldCombine = shouldCombineNext;\n            shouldCombineNext = false;\n            charCode = text.charCodeAt(i);\n            currentChars = text.charAt(i);\n            if (FontManager.isCombinedCharacter(charCode)) {\n                shouldCombine = true; // It's a potential surrogate pair (this is the High surrogate)\n            } else if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n                if (FontManager.isRegionalFlag(text, i)) {\n                    currentChars = text.substr(i, 14);\n                } else {\n                    secondCharCode = text.charCodeAt(i + 1); // It's a surrogate pair (this is the Low surrogate)\n                    if (secondCharCode >= 0xDC00 && secondCharCode <= 0xDFFF) {\n                        if (FontManager.isModifier(charCode, secondCharCode)) {\n                            currentChars = text.substr(i, 2);\n                            shouldCombine = true;\n                        } else if (FontManager.isFlagEmoji(text.substr(i, 4))) {\n                            currentChars = text.substr(i, 4);\n                        } else {\n                            currentChars = text.substr(i, 2);\n                        }\n                    }\n                }\n            } else if (charCode > 0xDBFF) {\n                secondCharCode = text.charCodeAt(i + 1);\n                if (FontManager.isVariationSelector(charCode)) {\n                    shouldCombine = true;\n                }\n            } else if (FontManager.isZeroWidthJoiner(charCode)) {\n                shouldCombine = true;\n                shouldCombineNext = true;\n            }\n            if (shouldCombine) {\n                charactersArray[charactersArray.length - 1] += currentChars;\n                shouldCombine = false;\n            } else {\n                charactersArray.push(currentChars);\n            }\n            i += currentChars.length;\n        }\n        return charactersArray;\n    };\n    TextProperty.prototype.completeTextData = function(documentData) {\n        documentData.__complete = true;\n        var fontManager = this.elem.globalData.fontManager;\n        var data = this.data;\n        var letters = [];\n        var i;\n        var len;\n        var newLineFlag;\n        var index = 0;\n        var val;\n        var anchorGrouping = data.m.g;\n        var currentSize = 0;\n        var currentPos = 0;\n        var currentLine = 0;\n        var lineWidths = [];\n        var lineWidth = 0;\n        var maxLineWidth = 0;\n        var j;\n        var jLen;\n        var fontData = fontManager.getFontByName(documentData.f);\n        var charData;\n        var cLength = 0;\n        var fontProps = getFontProperties(fontData);\n        documentData.fWeight = fontProps.weight;\n        documentData.fStyle = fontProps.style;\n        documentData.finalSize = documentData.s;\n        documentData.finalText = this.buildFinalText(documentData.t);\n        len = documentData.finalText.length;\n        documentData.finalLineHeight = documentData.lh;\n        var trackingOffset = documentData.tr / 1000 * documentData.finalSize;\n        var charCode;\n        if (documentData.sz) {\n            var flag = true;\n            var boxWidth = documentData.sz[0];\n            var boxHeight = documentData.sz[1];\n            var currentHeight;\n            var finalText;\n            while(flag){\n                finalText = this.buildFinalText(documentData.t);\n                currentHeight = 0;\n                lineWidth = 0;\n                len = finalText.length;\n                trackingOffset = documentData.tr / 1000 * documentData.finalSize;\n                var lastSpaceIndex = -1;\n                for(i = 0; i < len; i += 1){\n                    charCode = finalText[i].charCodeAt(0);\n                    newLineFlag = false;\n                    if (finalText[i] === \" \") {\n                        lastSpaceIndex = i;\n                    } else if (charCode === 13 || charCode === 3) {\n                        lineWidth = 0;\n                        newLineFlag = true;\n                        currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;\n                    }\n                    if (fontManager.chars) {\n                        charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);\n                        cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;\n                    } else {\n                        // tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;\n                        cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);\n                    }\n                    if (lineWidth + cLength > boxWidth && finalText[i] !== \" \") {\n                        if (lastSpaceIndex === -1) {\n                            len += 1;\n                        } else {\n                            i = lastSpaceIndex;\n                        }\n                        currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;\n                        finalText.splice(i, lastSpaceIndex === i ? 1 : 0, \"\\r\"); // finalText = finalText.substr(0,i) + \"\\r\" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);\n                        lastSpaceIndex = -1;\n                        lineWidth = 0;\n                    } else {\n                        lineWidth += cLength;\n                        lineWidth += trackingOffset;\n                    }\n                }\n                currentHeight += fontData.ascent * documentData.finalSize / 100;\n                if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {\n                    documentData.finalSize -= 1;\n                    documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;\n                } else {\n                    documentData.finalText = finalText;\n                    len = documentData.finalText.length;\n                    flag = false;\n                }\n            }\n        }\n        lineWidth = -trackingOffset;\n        cLength = 0;\n        var uncollapsedSpaces = 0;\n        var currentChar;\n        for(i = 0; i < len; i += 1){\n            newLineFlag = false;\n            currentChar = documentData.finalText[i];\n            charCode = currentChar.charCodeAt(0);\n            if (charCode === 13 || charCode === 3) {\n                uncollapsedSpaces = 0;\n                lineWidths.push(lineWidth);\n                maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;\n                lineWidth = -2 * trackingOffset;\n                val = \"\";\n                newLineFlag = true;\n                currentLine += 1;\n            } else {\n                val = currentChar;\n            }\n            if (fontManager.chars) {\n                charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);\n                cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;\n            } else {\n                // var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);\n                // tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;\n                cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);\n            } //\n            if (currentChar === \" \") {\n                uncollapsedSpaces += cLength + trackingOffset;\n            } else {\n                lineWidth += cLength + trackingOffset + uncollapsedSpaces;\n                uncollapsedSpaces = 0;\n            }\n            letters.push({\n                l: cLength,\n                an: cLength,\n                add: currentSize,\n                n: newLineFlag,\n                anIndexes: [],\n                val: val,\n                line: currentLine,\n                animatorJustifyOffset: 0\n            });\n            if (anchorGrouping == 2) {\n                // eslint-disable-line eqeqeq\n                currentSize += cLength;\n                if (val === \"\" || val === \" \" || i === len - 1) {\n                    if (val === \"\" || val === \" \") {\n                        currentSize -= cLength;\n                    }\n                    while(currentPos <= i){\n                        letters[currentPos].an = currentSize;\n                        letters[currentPos].ind = index;\n                        letters[currentPos].extra = cLength;\n                        currentPos += 1;\n                    }\n                    index += 1;\n                    currentSize = 0;\n                }\n            } else if (anchorGrouping == 3) {\n                // eslint-disable-line eqeqeq\n                currentSize += cLength;\n                if (val === \"\" || i === len - 1) {\n                    if (val === \"\") {\n                        currentSize -= cLength;\n                    }\n                    while(currentPos <= i){\n                        letters[currentPos].an = currentSize;\n                        letters[currentPos].ind = index;\n                        letters[currentPos].extra = cLength;\n                        currentPos += 1;\n                    }\n                    currentSize = 0;\n                    index += 1;\n                }\n            } else {\n                letters[index].ind = index;\n                letters[index].extra = 0;\n                index += 1;\n            }\n        }\n        documentData.l = letters;\n        maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;\n        lineWidths.push(lineWidth);\n        if (documentData.sz) {\n            documentData.boxWidth = documentData.sz[0];\n            documentData.justifyOffset = 0;\n        } else {\n            documentData.boxWidth = maxLineWidth;\n            switch(documentData.j){\n                case 1:\n                    documentData.justifyOffset = -documentData.boxWidth;\n                    break;\n                case 2:\n                    documentData.justifyOffset = -documentData.boxWidth / 2;\n                    break;\n                default:\n                    documentData.justifyOffset = 0;\n            }\n        }\n        documentData.lineWidths = lineWidths;\n        var animators = data.a;\n        var animatorData;\n        var letterData;\n        jLen = animators.length;\n        var based;\n        var ind;\n        var indexes = [];\n        for(j = 0; j < jLen; j += 1){\n            animatorData = animators[j];\n            if (animatorData.a.sc) {\n                documentData.strokeColorAnim = true;\n            }\n            if (animatorData.a.sw) {\n                documentData.strokeWidthAnim = true;\n            }\n            if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {\n                documentData.fillColorAnim = true;\n            }\n            ind = 0;\n            based = animatorData.s.b;\n            for(i = 0; i < len; i += 1){\n                letterData = letters[i];\n                letterData.anIndexes[j] = ind;\n                if (based == 1 && letterData.val !== \"\" || based == 2 && letterData.val !== \"\" && letterData.val !== \" \" || based == 3 && (letterData.n || letterData.val == \" \" || i == len - 1) || based == 4 && (letterData.n || i == len - 1)) {\n                    // eslint-disable-line eqeqeq\n                    if (animatorData.s.rn === 1) {\n                        indexes.push(ind);\n                    }\n                    ind += 1;\n                }\n            }\n            data.a[j].s.totalChars = ind;\n            var currentInd = -1;\n            var newInd;\n            if (animatorData.s.rn === 1) {\n                for(i = 0; i < len; i += 1){\n                    letterData = letters[i];\n                    if (currentInd != letterData.anIndexes[j]) {\n                        // eslint-disable-line eqeqeq\n                        currentInd = letterData.anIndexes[j];\n                        newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];\n                    }\n                    letterData.anIndexes[j] = newInd;\n                }\n            }\n        }\n        documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;\n        documentData.ls = documentData.ls || 0;\n        documentData.ascent = fontData.ascent * documentData.finalSize / 100;\n    };\n    TextProperty.prototype.updateDocumentData = function(newData, index) {\n        index = index === undefined ? this.keysIndex : index;\n        var dData = this.copyData({}, this.data.d.k[index].s);\n        dData = this.copyData(dData, newData);\n        this.data.d.k[index].s = dData;\n        this.recalculate(index);\n        this.setCurrentData(dData);\n        this.elem.addDynamicProperty(this);\n    };\n    TextProperty.prototype.recalculate = function(index) {\n        var dData = this.data.d.k[index].s;\n        dData.__complete = false;\n        this.keysIndex = 0;\n        this._isFirstFrame = true;\n        this.getValue(dData);\n    };\n    TextProperty.prototype.canResizeFont = function(_canResize) {\n        this.canResize = _canResize;\n        this.recalculate(this.keysIndex);\n        this.elem.addDynamicProperty(this);\n    };\n    TextProperty.prototype.setMinimumFontSize = function(_fontValue) {\n        this.minimumFontSize = Math.floor(_fontValue) || 1;\n        this.recalculate(this.keysIndex);\n        this.elem.addDynamicProperty(this);\n    };\n    var TextSelectorProp = function() {\n        var max = Math.max;\n        var min = Math.min;\n        var floor = Math.floor;\n        function TextSelectorPropFactory(elem, data) {\n            this._currentTextLength = -1;\n            this.k = false;\n            this.data = data;\n            this.elem = elem;\n            this.comp = elem.comp;\n            this.finalS = 0;\n            this.finalE = 0;\n            this.initDynamicPropertyContainer(elem);\n            this.s = PropertyFactory.getProp(elem, data.s || {\n                k: 0\n            }, 0, 0, this);\n            if (\"e\" in data) {\n                this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this);\n            } else {\n                this.e = {\n                    v: 100\n                };\n            }\n            this.o = PropertyFactory.getProp(elem, data.o || {\n                k: 0\n            }, 0, 0, this);\n            this.xe = PropertyFactory.getProp(elem, data.xe || {\n                k: 0\n            }, 0, 0, this);\n            this.ne = PropertyFactory.getProp(elem, data.ne || {\n                k: 0\n            }, 0, 0, this);\n            this.sm = PropertyFactory.getProp(elem, data.sm || {\n                k: 100\n            }, 0, 0, this);\n            this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this);\n            if (!this.dynamicProperties.length) {\n                this.getValue();\n            }\n        }\n        TextSelectorPropFactory.prototype = {\n            getMult: function getMult(ind) {\n                if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {\n                    this.getValue();\n                }\n                var x1 = 0;\n                var y1 = 0;\n                var x2 = 1;\n                var y2 = 1;\n                if (this.ne.v > 0) {\n                    x1 = this.ne.v / 100.0;\n                } else {\n                    y1 = -this.ne.v / 100.0;\n                }\n                if (this.xe.v > 0) {\n                    x2 = 1.0 - this.xe.v / 100.0;\n                } else {\n                    y2 = 1.0 + this.xe.v / 100.0;\n                }\n                var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;\n                var mult = 0;\n                var s = this.finalS;\n                var e = this.finalE;\n                var type = this.data.sh;\n                if (type === 2) {\n                    if (e === s) {\n                        mult = ind >= e ? 1 : 0;\n                    } else {\n                        mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));\n                    }\n                    mult = easer(mult);\n                } else if (type === 3) {\n                    if (e === s) {\n                        mult = ind >= e ? 0 : 1;\n                    } else {\n                        mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));\n                    }\n                    mult = easer(mult);\n                } else if (type === 4) {\n                    if (e === s) {\n                        mult = 0;\n                    } else {\n                        mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));\n                        if (mult < 0.5) {\n                            mult *= 2;\n                        } else {\n                            mult = 1 - 2 * (mult - 0.5);\n                        }\n                    }\n                    mult = easer(mult);\n                } else if (type === 5) {\n                    if (e === s) {\n                        mult = 0;\n                    } else {\n                        var tot = e - s;\n                        /* ind += 0.5;\r\n                      mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind; */ ind = min(max(0, ind + 0.5 - s), e - s);\n                        var x = -tot / 2 + ind;\n                        var a = tot / 2;\n                        mult = Math.sqrt(1 - x * x / (a * a));\n                    }\n                    mult = easer(mult);\n                } else if (type === 6) {\n                    if (e === s) {\n                        mult = 0;\n                    } else {\n                        ind = min(max(0, ind + 0.5 - s), e - s);\n                        mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e - s))) / 2; // eslint-disable-line\n                    }\n                    mult = easer(mult);\n                } else {\n                    if (ind >= floor(s)) {\n                        if (ind - s < 0) {\n                            mult = max(0, min(min(e, 1) - (s - ind), 1));\n                        } else {\n                            mult = max(0, min(e - ind, 1));\n                        }\n                    }\n                    mult = easer(mult);\n                } // Smoothness implementation.\n                // The smoothness represents a reduced range of the original [0; 1] range.\n                // if smoothness is 25%, the new range will be [0.375; 0.625]\n                // Steps are:\n                // - find the lower value of the new range (threshold)\n                // - if multiplier is smaller than that value, floor it to 0\n                // - if it is larger,\n                //     - subtract the threshold\n                //     - divide it by the smoothness (this will return the range to [0; 1])\n                // Note: If it doesn't work on some scenarios, consider applying it before the easer.\n                if (this.sm.v !== 100) {\n                    var smoothness = this.sm.v * 0.01;\n                    if (smoothness === 0) {\n                        smoothness = 0.00000001;\n                    }\n                    var threshold = 0.5 - smoothness * 0.5;\n                    if (mult < threshold) {\n                        mult = 0;\n                    } else {\n                        mult = (mult - threshold) / smoothness;\n                        if (mult > 1) {\n                            mult = 1;\n                        }\n                    }\n                }\n                return mult * this.a.v;\n            },\n            getValue: function getValue(newCharsFlag) {\n                this.iterateDynamicProperties();\n                this._mdf = newCharsFlag || this._mdf;\n                this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;\n                if (newCharsFlag && this.data.r === 2) {\n                    this.e.v = this._currentTextLength;\n                }\n                var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;\n                var o = this.o.v / divisor;\n                var s = this.s.v / divisor + o;\n                var e = this.e.v / divisor + o;\n                if (s > e) {\n                    var _s = s;\n                    s = e;\n                    e = _s;\n                }\n                this.finalS = s;\n                this.finalE = e;\n            }\n        };\n        extendPrototype([\n            DynamicPropertyContainer\n        ], TextSelectorPropFactory);\n        function getTextSelectorProp(elem, data, arr) {\n            return new TextSelectorPropFactory(elem, data, arr);\n        }\n        return {\n            getTextSelectorProp: getTextSelectorProp\n        };\n    }();\n    function TextAnimatorDataProperty(elem, animatorProps, container) {\n        var defaultData = {\n            propType: false\n        };\n        var getProp = PropertyFactory.getProp;\n        var textAnimatorAnimatables = animatorProps.a;\n        this.a = {\n            r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,\n            rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,\n            ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,\n            sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,\n            sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,\n            s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,\n            a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,\n            o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,\n            p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,\n            sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,\n            sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,\n            fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,\n            fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,\n            fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,\n            fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,\n            t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData\n        };\n        this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container);\n        this.s.t = animatorProps.s.t;\n    }\n    function TextAnimatorProperty(textData, renderType, elem) {\n        this._isFirstFrame = true;\n        this._hasMaskedPath = false;\n        this._frameId = -1;\n        this._textData = textData;\n        this._renderType = renderType;\n        this._elem = elem;\n        this._animatorsData = createSizedArray(this._textData.a.length);\n        this._pathData = {};\n        this._moreOptions = {\n            alignment: {}\n        };\n        this.renderedLetters = [];\n        this.lettersChangedFlag = false;\n        this.initDynamicPropertyContainer(elem);\n    }\n    TextAnimatorProperty.prototype.searchProperties = function() {\n        var i;\n        var len = this._textData.a.length;\n        var animatorProps;\n        var getProp = PropertyFactory.getProp;\n        for(i = 0; i < len; i += 1){\n            animatorProps = this._textData.a[i];\n            this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);\n        }\n        if (this._textData.p && \"m\" in this._textData.p) {\n            this._pathData = {\n                a: getProp(this._elem, this._textData.p.a, 0, 0, this),\n                f: getProp(this._elem, this._textData.p.f, 0, 0, this),\n                l: getProp(this._elem, this._textData.p.l, 0, 0, this),\n                r: getProp(this._elem, this._textData.p.r, 0, 0, this),\n                p: getProp(this._elem, this._textData.p.p, 0, 0, this),\n                m: this._elem.maskManager.getMaskProperty(this._textData.p.m)\n            };\n            this._hasMaskedPath = true;\n        } else {\n            this._hasMaskedPath = false;\n        }\n        this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);\n    };\n    TextAnimatorProperty.prototype.getMeasures = function(documentData, lettersChangedFlag) {\n        this.lettersChangedFlag = lettersChangedFlag;\n        if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {\n            return;\n        }\n        this._isFirstFrame = false;\n        var alignment = this._moreOptions.alignment.v;\n        var animators = this._animatorsData;\n        var textData = this._textData;\n        var matrixHelper = this.mHelper;\n        var renderType = this._renderType;\n        var renderedLettersCount = this.renderedLetters.length;\n        var xPos;\n        var yPos;\n        var i;\n        var len;\n        var letters = documentData.l;\n        var pathInfo;\n        var currentLength;\n        var currentPoint;\n        var segmentLength;\n        var flag;\n        var pointInd;\n        var segmentInd;\n        var prevPoint;\n        var points;\n        var segments;\n        var partialLength;\n        var totalLength;\n        var perc;\n        var tanAngle;\n        var mask;\n        if (this._hasMaskedPath) {\n            mask = this._pathData.m;\n            if (!this._pathData.n || this._pathData._mdf) {\n                var paths = mask.v;\n                if (this._pathData.r.v) {\n                    paths = paths.reverse();\n                } // TODO: release bezier data cached from previous pathInfo: this._pathData.pi\n                pathInfo = {\n                    tLength: 0,\n                    segments: []\n                };\n                len = paths._length - 1;\n                var bezierData;\n                totalLength = 0;\n                for(i = 0; i < len; i += 1){\n                    bezierData = bez.buildBezierData(paths.v[i], paths.v[i + 1], [\n                        paths.o[i][0] - paths.v[i][0],\n                        paths.o[i][1] - paths.v[i][1]\n                    ], [\n                        paths.i[i + 1][0] - paths.v[i + 1][0],\n                        paths.i[i + 1][1] - paths.v[i + 1][1]\n                    ]);\n                    pathInfo.tLength += bezierData.segmentLength;\n                    pathInfo.segments.push(bezierData);\n                    totalLength += bezierData.segmentLength;\n                }\n                i = len;\n                if (mask.v.c) {\n                    bezierData = bez.buildBezierData(paths.v[i], paths.v[0], [\n                        paths.o[i][0] - paths.v[i][0],\n                        paths.o[i][1] - paths.v[i][1]\n                    ], [\n                        paths.i[0][0] - paths.v[0][0],\n                        paths.i[0][1] - paths.v[0][1]\n                    ]);\n                    pathInfo.tLength += bezierData.segmentLength;\n                    pathInfo.segments.push(bezierData);\n                    totalLength += bezierData.segmentLength;\n                }\n                this._pathData.pi = pathInfo;\n            }\n            pathInfo = this._pathData.pi;\n            currentLength = this._pathData.f.v;\n            segmentInd = 0;\n            pointInd = 1;\n            segmentLength = 0;\n            flag = true;\n            segments = pathInfo.segments;\n            if (currentLength < 0 && mask.v.c) {\n                if (pathInfo.tLength < Math.abs(currentLength)) {\n                    currentLength = -Math.abs(currentLength) % pathInfo.tLength;\n                }\n                segmentInd = segments.length - 1;\n                points = segments[segmentInd].points;\n                pointInd = points.length - 1;\n                while(currentLength < 0){\n                    currentLength += points[pointInd].partialLength;\n                    pointInd -= 1;\n                    if (pointInd < 0) {\n                        segmentInd -= 1;\n                        points = segments[segmentInd].points;\n                        pointInd = points.length - 1;\n                    }\n                }\n            }\n            points = segments[segmentInd].points;\n            prevPoint = points[pointInd - 1];\n            currentPoint = points[pointInd];\n            partialLength = currentPoint.partialLength;\n        }\n        len = letters.length;\n        xPos = 0;\n        yPos = 0;\n        var yOff = documentData.finalSize * 1.2 * 0.714;\n        var firstLine = true;\n        var animatorProps;\n        var animatorSelector;\n        var j;\n        var jLen;\n        var letterValue;\n        jLen = animators.length;\n        var mult;\n        var ind = -1;\n        var offf;\n        var xPathPos;\n        var yPathPos;\n        var initPathPos = currentLength;\n        var initSegmentInd = segmentInd;\n        var initPointInd = pointInd;\n        var currentLine = -1;\n        var elemOpacity;\n        var sc;\n        var sw;\n        var fc;\n        var k;\n        var letterSw;\n        var letterSc;\n        var letterFc;\n        var letterM = \"\";\n        var letterP = this.defaultPropsArray;\n        var letterO; //\n        if (documentData.j === 2 || documentData.j === 1) {\n            var animatorJustifyOffset = 0;\n            var animatorFirstCharOffset = 0;\n            var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;\n            var lastIndex = 0;\n            var isNewLine = true;\n            for(i = 0; i < len; i += 1){\n                if (letters[i].n) {\n                    if (animatorJustifyOffset) {\n                        animatorJustifyOffset += animatorFirstCharOffset;\n                    }\n                    while(lastIndex < i){\n                        letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;\n                        lastIndex += 1;\n                    }\n                    animatorJustifyOffset = 0;\n                    isNewLine = true;\n                } else {\n                    for(j = 0; j < jLen; j += 1){\n                        animatorProps = animators[j].a;\n                        if (animatorProps.t.propType) {\n                            if (isNewLine && documentData.j === 2) {\n                                animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;\n                            }\n                            animatorSelector = animators[j].s;\n                            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                            if (mult.length) {\n                                animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;\n                            } else {\n                                animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;\n                            }\n                        }\n                    }\n                    isNewLine = false;\n                }\n            }\n            if (animatorJustifyOffset) {\n                animatorJustifyOffset += animatorFirstCharOffset;\n            }\n            while(lastIndex < i){\n                letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;\n                lastIndex += 1;\n            }\n        } //\n        for(i = 0; i < len; i += 1){\n            matrixHelper.reset();\n            elemOpacity = 1;\n            if (letters[i].n) {\n                xPos = 0;\n                yPos += documentData.yOffset;\n                yPos += firstLine ? 1 : 0;\n                currentLength = initPathPos;\n                firstLine = false;\n                if (this._hasMaskedPath) {\n                    segmentInd = initSegmentInd;\n                    pointInd = initPointInd;\n                    points = segments[segmentInd].points;\n                    prevPoint = points[pointInd - 1];\n                    currentPoint = points[pointInd];\n                    partialLength = currentPoint.partialLength;\n                    segmentLength = 0;\n                }\n                letterM = \"\";\n                letterFc = \"\";\n                letterSw = \"\";\n                letterO = \"\";\n                letterP = this.defaultPropsArray;\n            } else {\n                if (this._hasMaskedPath) {\n                    if (currentLine !== letters[i].line) {\n                        switch(documentData.j){\n                            case 1:\n                                currentLength += totalLength - documentData.lineWidths[letters[i].line];\n                                break;\n                            case 2:\n                                currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2;\n                                break;\n                            default:\n                                break;\n                        }\n                        currentLine = letters[i].line;\n                    }\n                    if (ind !== letters[i].ind) {\n                        if (letters[ind]) {\n                            currentLength += letters[ind].extra;\n                        }\n                        currentLength += letters[i].an / 2;\n                        ind = letters[i].ind;\n                    }\n                    currentLength += alignment[0] * letters[i].an * 0.005;\n                    var animatorOffset = 0;\n                    for(j = 0; j < jLen; j += 1){\n                        animatorProps = animators[j].a;\n                        if (animatorProps.p.propType) {\n                            animatorSelector = animators[j].s;\n                            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                            if (mult.length) {\n                                animatorOffset += animatorProps.p.v[0] * mult[0];\n                            } else {\n                                animatorOffset += animatorProps.p.v[0] * mult;\n                            }\n                        }\n                        if (animatorProps.a.propType) {\n                            animatorSelector = animators[j].s;\n                            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                            if (mult.length) {\n                                animatorOffset += animatorProps.a.v[0] * mult[0];\n                            } else {\n                                animatorOffset += animatorProps.a.v[0] * mult;\n                            }\n                        }\n                    }\n                    flag = true; // Force alignment only works with a single line for now\n                    if (this._pathData.a.v) {\n                        currentLength = letters[0].an * 0.5 + (totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);\n                        currentLength += this._pathData.f.v;\n                    }\n                    while(flag){\n                        if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {\n                            perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;\n                            xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;\n                            yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;\n                            matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -(alignment[1] * yOff) * 0.01);\n                            flag = false;\n                        } else if (points) {\n                            segmentLength += currentPoint.partialLength;\n                            pointInd += 1;\n                            if (pointInd >= points.length) {\n                                pointInd = 0;\n                                segmentInd += 1;\n                                if (!segments[segmentInd]) {\n                                    if (mask.v.c) {\n                                        pointInd = 0;\n                                        segmentInd = 0;\n                                        points = segments[segmentInd].points;\n                                    } else {\n                                        segmentLength -= currentPoint.partialLength;\n                                        points = null;\n                                    }\n                                } else {\n                                    points = segments[segmentInd].points;\n                                }\n                            }\n                            if (points) {\n                                prevPoint = currentPoint;\n                                currentPoint = points[pointInd];\n                                partialLength = currentPoint.partialLength;\n                            }\n                        }\n                    }\n                    offf = letters[i].an / 2 - letters[i].add;\n                    matrixHelper.translate(-offf, 0, 0);\n                } else {\n                    offf = letters[i].an / 2 - letters[i].add;\n                    matrixHelper.translate(-offf, 0, 0); // Grouping alignment\n                    matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -alignment[1] * yOff * 0.01, 0);\n                }\n                for(j = 0; j < jLen; j += 1){\n                    animatorProps = animators[j].a;\n                    if (animatorProps.t.propType) {\n                        animatorSelector = animators[j].s;\n                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars); // This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean \"isNewLine\"\n                        if (xPos !== 0 || documentData.j !== 0) {\n                            if (this._hasMaskedPath) {\n                                if (mult.length) {\n                                    currentLength += animatorProps.t.v * mult[0];\n                                } else {\n                                    currentLength += animatorProps.t.v * mult;\n                                }\n                            } else if (mult.length) {\n                                xPos += animatorProps.t.v * mult[0];\n                            } else {\n                                xPos += animatorProps.t.v * mult;\n                            }\n                        }\n                    }\n                }\n                if (documentData.strokeWidthAnim) {\n                    sw = documentData.sw || 0;\n                }\n                if (documentData.strokeColorAnim) {\n                    if (documentData.sc) {\n                        sc = [\n                            documentData.sc[0],\n                            documentData.sc[1],\n                            documentData.sc[2]\n                        ];\n                    } else {\n                        sc = [\n                            0,\n                            0,\n                            0\n                        ];\n                    }\n                }\n                if (documentData.fillColorAnim && documentData.fc) {\n                    fc = [\n                        documentData.fc[0],\n                        documentData.fc[1],\n                        documentData.fc[2]\n                    ];\n                }\n                for(j = 0; j < jLen; j += 1){\n                    animatorProps = animators[j].a;\n                    if (animatorProps.a.propType) {\n                        animatorSelector = animators[j].s;\n                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                        if (mult.length) {\n                            matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);\n                        } else {\n                            matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);\n                        }\n                    }\n                }\n                for(j = 0; j < jLen; j += 1){\n                    animatorProps = animators[j].a;\n                    if (animatorProps.s.propType) {\n                        animatorSelector = animators[j].s;\n                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                        if (mult.length) {\n                            matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);\n                        } else {\n                            matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);\n                        }\n                    }\n                }\n                for(j = 0; j < jLen; j += 1){\n                    animatorProps = animators[j].a;\n                    animatorSelector = animators[j].s;\n                    mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                    if (animatorProps.sk.propType) {\n                        if (mult.length) {\n                            matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);\n                        } else {\n                            matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);\n                        }\n                    }\n                    if (animatorProps.r.propType) {\n                        if (mult.length) {\n                            matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);\n                        } else {\n                            matrixHelper.rotateZ(-animatorProps.r.v * mult);\n                        }\n                    }\n                    if (animatorProps.ry.propType) {\n                        if (mult.length) {\n                            matrixHelper.rotateY(animatorProps.ry.v * mult[1]);\n                        } else {\n                            matrixHelper.rotateY(animatorProps.ry.v * mult);\n                        }\n                    }\n                    if (animatorProps.rx.propType) {\n                        if (mult.length) {\n                            matrixHelper.rotateX(animatorProps.rx.v * mult[0]);\n                        } else {\n                            matrixHelper.rotateX(animatorProps.rx.v * mult);\n                        }\n                    }\n                    if (animatorProps.o.propType) {\n                        if (mult.length) {\n                            elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];\n                        } else {\n                            elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;\n                        }\n                    }\n                    if (documentData.strokeWidthAnim && animatorProps.sw.propType) {\n                        if (mult.length) {\n                            sw += animatorProps.sw.v * mult[0];\n                        } else {\n                            sw += animatorProps.sw.v * mult;\n                        }\n                    }\n                    if (documentData.strokeColorAnim && animatorProps.sc.propType) {\n                        for(k = 0; k < 3; k += 1){\n                            if (mult.length) {\n                                sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];\n                            } else {\n                                sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;\n                            }\n                        }\n                    }\n                    if (documentData.fillColorAnim && documentData.fc) {\n                        if (animatorProps.fc.propType) {\n                            for(k = 0; k < 3; k += 1){\n                                if (mult.length) {\n                                    fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];\n                                } else {\n                                    fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;\n                                }\n                            }\n                        }\n                        if (animatorProps.fh.propType) {\n                            if (mult.length) {\n                                fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);\n                            } else {\n                                fc = addHueToRGB(fc, animatorProps.fh.v * mult);\n                            }\n                        }\n                        if (animatorProps.fs.propType) {\n                            if (mult.length) {\n                                fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);\n                            } else {\n                                fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);\n                            }\n                        }\n                        if (animatorProps.fb.propType) {\n                            if (mult.length) {\n                                fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);\n                            } else {\n                                fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);\n                            }\n                        }\n                    }\n                }\n                for(j = 0; j < jLen; j += 1){\n                    animatorProps = animators[j].a;\n                    if (animatorProps.p.propType) {\n                        animatorSelector = animators[j].s;\n                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                        if (this._hasMaskedPath) {\n                            if (mult.length) {\n                                matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);\n                            } else {\n                                matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);\n                            }\n                        } else if (mult.length) {\n                            matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);\n                        } else {\n                            matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);\n                        }\n                    }\n                }\n                if (documentData.strokeWidthAnim) {\n                    letterSw = sw < 0 ? 0 : sw;\n                }\n                if (documentData.strokeColorAnim) {\n                    letterSc = \"rgb(\" + Math.round(sc[0] * 255) + \",\" + Math.round(sc[1] * 255) + \",\" + Math.round(sc[2] * 255) + \")\";\n                }\n                if (documentData.fillColorAnim && documentData.fc) {\n                    letterFc = \"rgb(\" + Math.round(fc[0] * 255) + \",\" + Math.round(fc[1] * 255) + \",\" + Math.round(fc[2] * 255) + \")\";\n                }\n                if (this._hasMaskedPath) {\n                    matrixHelper.translate(0, -documentData.ls);\n                    matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);\n                    if (this._pathData.p.v) {\n                        tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);\n                        var rot = Math.atan(tanAngle) * 180 / Math.PI;\n                        if (currentPoint.point[0] < prevPoint.point[0]) {\n                            rot += 180;\n                        }\n                        matrixHelper.rotate(-rot * Math.PI / 180);\n                    }\n                    matrixHelper.translate(xPathPos, yPathPos, 0);\n                    currentLength -= alignment[0] * letters[i].an * 0.005;\n                    if (letters[i + 1] && ind !== letters[i + 1].ind) {\n                        currentLength += letters[i].an / 2;\n                        currentLength += documentData.tr * 0.001 * documentData.finalSize;\n                    }\n                } else {\n                    matrixHelper.translate(xPos, yPos, 0);\n                    if (documentData.ps) {\n                        // matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);\n                        matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);\n                    }\n                    switch(documentData.j){\n                        case 1:\n                            matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);\n                            break;\n                        case 2:\n                            matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0);\n                            break;\n                        default:\n                            break;\n                    }\n                    matrixHelper.translate(0, -documentData.ls);\n                    matrixHelper.translate(offf, 0, 0);\n                    matrixHelper.translate(alignment[0] * letters[i].an * 0.005, alignment[1] * yOff * 0.01, 0);\n                    xPos += letters[i].l + documentData.tr * 0.001 * documentData.finalSize;\n                }\n                if (renderType === \"html\") {\n                    letterM = matrixHelper.toCSS();\n                } else if (renderType === \"svg\") {\n                    letterM = matrixHelper.to2dCSS();\n                } else {\n                    letterP = [\n                        matrixHelper.props[0],\n                        matrixHelper.props[1],\n                        matrixHelper.props[2],\n                        matrixHelper.props[3],\n                        matrixHelper.props[4],\n                        matrixHelper.props[5],\n                        matrixHelper.props[6],\n                        matrixHelper.props[7],\n                        matrixHelper.props[8],\n                        matrixHelper.props[9],\n                        matrixHelper.props[10],\n                        matrixHelper.props[11],\n                        matrixHelper.props[12],\n                        matrixHelper.props[13],\n                        matrixHelper.props[14],\n                        matrixHelper.props[15]\n                    ];\n                }\n                letterO = elemOpacity;\n            }\n            if (renderedLettersCount <= i) {\n                letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);\n                this.renderedLetters.push(letterValue);\n                renderedLettersCount += 1;\n                this.lettersChangedFlag = true;\n            } else {\n                letterValue = this.renderedLetters[i];\n                this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;\n            }\n        }\n    };\n    TextAnimatorProperty.prototype.getValue = function() {\n        if (this._elem.globalData.frameId === this._frameId) {\n            return;\n        }\n        this._frameId = this._elem.globalData.frameId;\n        this.iterateDynamicProperties();\n    };\n    TextAnimatorProperty.prototype.mHelper = new Matrix();\n    TextAnimatorProperty.prototype.defaultPropsArray = [];\n    extendPrototype([\n        DynamicPropertyContainer\n    ], TextAnimatorProperty);\n    function ITextElement() {}\n    ITextElement.prototype.initElement = function(data, globalData, comp) {\n        this.lettersChangedFlag = true;\n        this.initFrame();\n        this.initBaseData(data, globalData, comp);\n        this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);\n        this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);\n        this.initTransform(data, globalData, comp);\n        this.initHierarchy();\n        this.initRenderable();\n        this.initRendererElement();\n        this.createContainerElements();\n        this.createRenderableComponents();\n        this.createContent();\n        this.hide();\n        this.textAnimator.searchProperties(this.dynamicProperties);\n    };\n    ITextElement.prototype.prepareFrame = function(num) {\n        this._mdf = false;\n        this.prepareRenderableFrame(num);\n        this.prepareProperties(num, this.isInRange);\n    };\n    ITextElement.prototype.createPathShape = function(matrixHelper, shapes) {\n        var j;\n        var jLen = shapes.length;\n        var pathNodes;\n        var shapeStr = \"\";\n        for(j = 0; j < jLen; j += 1){\n            if (shapes[j].ty === \"sh\") {\n                pathNodes = shapes[j].ks.k;\n                shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);\n            }\n        }\n        return shapeStr;\n    };\n    ITextElement.prototype.updateDocumentData = function(newData, index) {\n        this.textProperty.updateDocumentData(newData, index);\n    };\n    ITextElement.prototype.canResizeFont = function(_canResize) {\n        this.textProperty.canResizeFont(_canResize);\n    };\n    ITextElement.prototype.setMinimumFontSize = function(_fontSize) {\n        this.textProperty.setMinimumFontSize(_fontSize);\n    };\n    ITextElement.prototype.applyTextPropertiesToMatrix = function(documentData, matrixHelper, lineNumber, xPos, yPos) {\n        if (documentData.ps) {\n            matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);\n        }\n        matrixHelper.translate(0, -documentData.ls, 0);\n        switch(documentData.j){\n            case 1:\n                matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);\n                break;\n            case 2:\n                matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);\n                break;\n            default:\n                break;\n        }\n        matrixHelper.translate(xPos, yPos, 0);\n    };\n    ITextElement.prototype.buildColor = function(colorData) {\n        return \"rgb(\" + Math.round(colorData[0] * 255) + \",\" + Math.round(colorData[1] * 255) + \",\" + Math.round(colorData[2] * 255) + \")\";\n    };\n    ITextElement.prototype.emptyProp = new LetterProps();\n    ITextElement.prototype.destroy = function() {};\n    ITextElement.prototype.validateText = function() {\n        if (this.textProperty._mdf || this.textProperty._isFirstFrame) {\n            this.buildNewText();\n            this.textProperty._isFirstFrame = false;\n            this.textProperty._mdf = false;\n        }\n    };\n    var emptyShapeData = {\n        shapes: []\n    };\n    function SVGTextLottieElement(data, globalData, comp) {\n        this.textSpans = [];\n        this.renderType = \"svg\";\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        SVGBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableDOMElement,\n        ITextElement\n    ], SVGTextLottieElement);\n    SVGTextLottieElement.prototype.createContent = function() {\n        if (this.data.singleShape && !this.globalData.fontManager.chars) {\n            this.textContainer = createNS(\"text\");\n        }\n    };\n    SVGTextLottieElement.prototype.buildTextContents = function(textArray) {\n        var i = 0;\n        var len = textArray.length;\n        var textContents = [];\n        var currentTextContent = \"\";\n        while(i < len){\n            if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {\n                textContents.push(currentTextContent);\n                currentTextContent = \"\";\n            } else {\n                currentTextContent += textArray[i];\n            }\n            i += 1;\n        }\n        textContents.push(currentTextContent);\n        return textContents;\n    };\n    SVGTextLottieElement.prototype.buildShapeData = function(data, scale) {\n        // data should probably be cloned to apply scale separately to each instance of a text on different layers\n        // but since text internal content gets only rendered once and then it's never rerendered,\n        // it's probably safe not to clone data and reuse always the same instance even if the object is mutated.\n        // Avoiding cloning is preferred since cloning each character shape data is expensive\n        if (data.shapes && data.shapes.length) {\n            var shape = data.shapes[0];\n            if (shape.it) {\n                var shapeItem = shape.it[shape.it.length - 1];\n                if (shapeItem.s) {\n                    shapeItem.s.k[0] = scale;\n                    shapeItem.s.k[1] = scale;\n                }\n            }\n        }\n        return data;\n    };\n    SVGTextLottieElement.prototype.buildNewText = function() {\n        this.addDynamicProperty(this);\n        var i;\n        var len;\n        var documentData = this.textProperty.currentData;\n        this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);\n        if (documentData.fc) {\n            this.layerElement.setAttribute(\"fill\", this.buildColor(documentData.fc));\n        } else {\n            this.layerElement.setAttribute(\"fill\", \"rgba(0,0,0,0)\");\n        }\n        if (documentData.sc) {\n            this.layerElement.setAttribute(\"stroke\", this.buildColor(documentData.sc));\n            this.layerElement.setAttribute(\"stroke-width\", documentData.sw);\n        }\n        this.layerElement.setAttribute(\"font-size\", documentData.finalSize);\n        var fontData = this.globalData.fontManager.getFontByName(documentData.f);\n        if (fontData.fClass) {\n            this.layerElement.setAttribute(\"class\", fontData.fClass);\n        } else {\n            this.layerElement.setAttribute(\"font-family\", fontData.fFamily);\n            var fWeight = documentData.fWeight;\n            var fStyle = documentData.fStyle;\n            this.layerElement.setAttribute(\"font-style\", fStyle);\n            this.layerElement.setAttribute(\"font-weight\", fWeight);\n        }\n        this.layerElement.setAttribute(\"aria-label\", documentData.t);\n        var letters = documentData.l || [];\n        var usesGlyphs = !!this.globalData.fontManager.chars;\n        len = letters.length;\n        var tSpan;\n        var matrixHelper = this.mHelper;\n        var shapeStr = \"\";\n        var singleShape = this.data.singleShape;\n        var xPos = 0;\n        var yPos = 0;\n        var firstLine = true;\n        var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;\n        if (singleShape && !usesGlyphs && !documentData.sz) {\n            var tElement = this.textContainer;\n            var justify = \"start\";\n            switch(documentData.j){\n                case 1:\n                    justify = \"end\";\n                    break;\n                case 2:\n                    justify = \"middle\";\n                    break;\n                default:\n                    justify = \"start\";\n                    break;\n            }\n            tElement.setAttribute(\"text-anchor\", justify);\n            tElement.setAttribute(\"letter-spacing\", trackingOffset);\n            var textContent = this.buildTextContents(documentData.finalText);\n            len = textContent.length;\n            yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;\n            for(i = 0; i < len; i += 1){\n                tSpan = this.textSpans[i].span || createNS(\"tspan\");\n                tSpan.textContent = textContent[i];\n                tSpan.setAttribute(\"x\", 0);\n                tSpan.setAttribute(\"y\", yPos);\n                tSpan.style.display = \"inherit\";\n                tElement.appendChild(tSpan);\n                if (!this.textSpans[i]) {\n                    this.textSpans[i] = {\n                        span: null,\n                        glyph: null\n                    };\n                }\n                this.textSpans[i].span = tSpan;\n                yPos += documentData.finalLineHeight;\n            }\n            this.layerElement.appendChild(tElement);\n        } else {\n            var cachedSpansLength = this.textSpans.length;\n            var charData;\n            for(i = 0; i < len; i += 1){\n                if (!this.textSpans[i]) {\n                    this.textSpans[i] = {\n                        span: null,\n                        childSpan: null,\n                        glyph: null\n                    };\n                }\n                if (!usesGlyphs || !singleShape || i === 0) {\n                    tSpan = cachedSpansLength > i ? this.textSpans[i].span : createNS(usesGlyphs ? \"g\" : \"text\");\n                    if (cachedSpansLength <= i) {\n                        tSpan.setAttribute(\"stroke-linecap\", \"butt\");\n                        tSpan.setAttribute(\"stroke-linejoin\", \"round\");\n                        tSpan.setAttribute(\"stroke-miterlimit\", \"4\");\n                        this.textSpans[i].span = tSpan;\n                        if (usesGlyphs) {\n                            var childSpan = createNS(\"g\");\n                            tSpan.appendChild(childSpan);\n                            this.textSpans[i].childSpan = childSpan;\n                        }\n                        this.textSpans[i].span = tSpan;\n                        this.layerElement.appendChild(tSpan);\n                    }\n                    tSpan.style.display = \"inherit\";\n                }\n                matrixHelper.reset();\n                if (singleShape) {\n                    if (letters[i].n) {\n                        xPos = -trackingOffset;\n                        yPos += documentData.yOffset;\n                        yPos += firstLine ? 1 : 0;\n                        firstLine = false;\n                    }\n                    this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);\n                    xPos += letters[i].l || 0; // xPos += letters[i].val === ' ' ? 0 : trackingOffset;\n                    xPos += trackingOffset;\n                }\n                if (usesGlyphs) {\n                    charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);\n                    var glyphElement; // t === 1 means the character has been replaced with an animated shaped\n                    if (charData.t === 1) {\n                        glyphElement = new SVGCompElement(charData.data, this.globalData, this);\n                    } else {\n                        var data = emptyShapeData;\n                        if (charData.data && charData.data.shapes) {\n                            data = this.buildShapeData(charData.data, documentData.finalSize);\n                        }\n                        glyphElement = new SVGShapeElement(data, this.globalData, this);\n                    }\n                    if (this.textSpans[i].glyph) {\n                        var glyph = this.textSpans[i].glyph;\n                        this.textSpans[i].childSpan.removeChild(glyph.layerElement);\n                        glyph.destroy();\n                    }\n                    this.textSpans[i].glyph = glyphElement;\n                    glyphElement._debug = true;\n                    glyphElement.prepareFrame(0);\n                    glyphElement.renderFrame();\n                    this.textSpans[i].childSpan.appendChild(glyphElement.layerElement); // when using animated shapes, the layer will be scaled instead of replacing the internal scale\n                    // this might have issues with strokes and might need a different solution\n                    if (charData.t === 1) {\n                        this.textSpans[i].childSpan.setAttribute(\"transform\", \"scale(\" + documentData.finalSize / 100 + \",\" + documentData.finalSize / 100 + \")\");\n                    }\n                } else {\n                    if (singleShape) {\n                        tSpan.setAttribute(\"transform\", \"translate(\" + matrixHelper.props[12] + \",\" + matrixHelper.props[13] + \")\");\n                    }\n                    tSpan.textContent = letters[i].val;\n                    tSpan.setAttributeNS(\"http://www.w3.org/XML/1998/namespace\", \"xml:space\", \"preserve\");\n                } //\n            }\n            if (singleShape && tSpan) {\n                tSpan.setAttribute(\"d\", shapeStr);\n            }\n        }\n        while(i < this.textSpans.length){\n            this.textSpans[i].span.style.display = \"none\";\n            i += 1;\n        }\n        this._sizeChanged = true;\n    };\n    SVGTextLottieElement.prototype.sourceRectAtTime = function() {\n        this.prepareFrame(this.comp.renderedFrame - this.data.st);\n        this.renderInnerContent();\n        if (this._sizeChanged) {\n            this._sizeChanged = false;\n            var textBox = this.layerElement.getBBox();\n            this.bbox = {\n                top: textBox.y,\n                left: textBox.x,\n                width: textBox.width,\n                height: textBox.height\n            };\n        }\n        return this.bbox;\n    };\n    SVGTextLottieElement.prototype.getValue = function() {\n        var i;\n        var len = this.textSpans.length;\n        var glyphElement;\n        this.renderedFrame = this.comp.renderedFrame;\n        for(i = 0; i < len; i += 1){\n            glyphElement = this.textSpans[i].glyph;\n            if (glyphElement) {\n                glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st);\n                if (glyphElement._mdf) {\n                    this._mdf = true;\n                }\n            }\n        }\n    };\n    SVGTextLottieElement.prototype.renderInnerContent = function() {\n        this.validateText();\n        if (!this.data.singleShape || this._mdf) {\n            this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);\n            if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {\n                this._sizeChanged = true;\n                var i;\n                var len;\n                var renderedLetters = this.textAnimator.renderedLetters;\n                var letters = this.textProperty.currentData.l;\n                len = letters.length;\n                var renderedLetter;\n                var textSpan;\n                var glyphElement;\n                for(i = 0; i < len; i += 1){\n                    if (!letters[i].n) {\n                        renderedLetter = renderedLetters[i];\n                        textSpan = this.textSpans[i].span;\n                        glyphElement = this.textSpans[i].glyph;\n                        if (glyphElement) {\n                            glyphElement.renderFrame();\n                        }\n                        if (renderedLetter._mdf.m) {\n                            textSpan.setAttribute(\"transform\", renderedLetter.m);\n                        }\n                        if (renderedLetter._mdf.o) {\n                            textSpan.setAttribute(\"opacity\", renderedLetter.o);\n                        }\n                        if (renderedLetter._mdf.sw) {\n                            textSpan.setAttribute(\"stroke-width\", renderedLetter.sw);\n                        }\n                        if (renderedLetter._mdf.sc) {\n                            textSpan.setAttribute(\"stroke\", renderedLetter.sc);\n                        }\n                        if (renderedLetter._mdf.fc) {\n                            textSpan.setAttribute(\"fill\", renderedLetter.fc);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    function ISolidElement(data, globalData, comp) {\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        IImageElement\n    ], ISolidElement);\n    ISolidElement.prototype.createContent = function() {\n        var rect = createNS(\"rect\"); /// /rect.style.width = this.data.sw;\n        /// /rect.style.height = this.data.sh;\n        /// /rect.style.fill = this.data.sc;\n        rect.setAttribute(\"width\", this.data.sw);\n        rect.setAttribute(\"height\", this.data.sh);\n        rect.setAttribute(\"fill\", this.data.sc);\n        this.layerElement.appendChild(rect);\n    };\n    function NullElement(data, globalData, comp) {\n        this.initFrame();\n        this.initBaseData(data, globalData, comp);\n        this.initFrame();\n        this.initTransform(data, globalData, comp);\n        this.initHierarchy();\n    }\n    NullElement.prototype.prepareFrame = function(num) {\n        this.prepareProperties(num, true);\n    };\n    NullElement.prototype.renderFrame = function() {};\n    NullElement.prototype.getBaseElement = function() {\n        return null;\n    };\n    NullElement.prototype.destroy = function() {};\n    NullElement.prototype.sourceRectAtTime = function() {};\n    NullElement.prototype.hide = function() {};\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        HierarchyElement,\n        FrameElement\n    ], NullElement);\n    function SVGRendererBase() {}\n    extendPrototype([\n        BaseRenderer\n    ], SVGRendererBase);\n    SVGRendererBase.prototype.createNull = function(data) {\n        return new NullElement(data, this.globalData, this);\n    };\n    SVGRendererBase.prototype.createShape = function(data) {\n        return new SVGShapeElement(data, this.globalData, this);\n    };\n    SVGRendererBase.prototype.createText = function(data) {\n        return new SVGTextLottieElement(data, this.globalData, this);\n    };\n    SVGRendererBase.prototype.createImage = function(data) {\n        return new IImageElement(data, this.globalData, this);\n    };\n    SVGRendererBase.prototype.createSolid = function(data) {\n        return new ISolidElement(data, this.globalData, this);\n    };\n    SVGRendererBase.prototype.configAnimation = function(animData) {\n        this.svgElement.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n        this.svgElement.setAttribute(\"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n        if (this.renderConfig.viewBoxSize) {\n            this.svgElement.setAttribute(\"viewBox\", this.renderConfig.viewBoxSize);\n        } else {\n            this.svgElement.setAttribute(\"viewBox\", \"0 0 \" + animData.w + \" \" + animData.h);\n        }\n        if (!this.renderConfig.viewBoxOnly) {\n            this.svgElement.setAttribute(\"width\", animData.w);\n            this.svgElement.setAttribute(\"height\", animData.h);\n            this.svgElement.style.width = \"100%\";\n            this.svgElement.style.height = \"100%\";\n            this.svgElement.style.transform = \"translate3d(0,0,0)\";\n            this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;\n        }\n        if (this.renderConfig.width) {\n            this.svgElement.setAttribute(\"width\", this.renderConfig.width);\n        }\n        if (this.renderConfig.height) {\n            this.svgElement.setAttribute(\"height\", this.renderConfig.height);\n        }\n        if (this.renderConfig.className) {\n            this.svgElement.setAttribute(\"class\", this.renderConfig.className);\n        }\n        if (this.renderConfig.id) {\n            this.svgElement.setAttribute(\"id\", this.renderConfig.id);\n        }\n        if (this.renderConfig.focusable !== undefined) {\n            this.svgElement.setAttribute(\"focusable\", this.renderConfig.focusable);\n        }\n        this.svgElement.setAttribute(\"preserveAspectRatio\", this.renderConfig.preserveAspectRatio); // this.layerElement.style.transform = 'translate3d(0,0,0)';\n        // this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = \"0px 0px 0px\";\n        this.animationItem.wrapper.appendChild(this.svgElement); // Mask animation\n        var defs = this.globalData.defs;\n        this.setupGlobalData(animData, defs);\n        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;\n        this.data = animData;\n        var maskElement = createNS(\"clipPath\");\n        var rect = createNS(\"rect\");\n        rect.setAttribute(\"width\", animData.w);\n        rect.setAttribute(\"height\", animData.h);\n        rect.setAttribute(\"x\", 0);\n        rect.setAttribute(\"y\", 0);\n        var maskId = createElementID();\n        maskElement.setAttribute(\"id\", maskId);\n        maskElement.appendChild(rect);\n        this.layerElement.setAttribute(\"clip-path\", \"url(\" + getLocationHref() + \"#\" + maskId + \")\");\n        defs.appendChild(maskElement);\n        this.layers = animData.layers;\n        this.elements = createSizedArray(animData.layers.length);\n    };\n    SVGRendererBase.prototype.destroy = function() {\n        if (this.animationItem.wrapper) {\n            this.animationItem.wrapper.innerText = \"\";\n        }\n        this.layerElement = null;\n        this.globalData.defs = null;\n        var i;\n        var len = this.layers ? this.layers.length : 0;\n        for(i = 0; i < len; i += 1){\n            if (this.elements[i] && this.elements[i].destroy) {\n                this.elements[i].destroy();\n            }\n        }\n        this.elements.length = 0;\n        this.destroyed = true;\n        this.animationItem = null;\n    };\n    SVGRendererBase.prototype.updateContainerSize = function() {};\n    SVGRendererBase.prototype.findIndexByInd = function(ind) {\n        var i = 0;\n        var len = this.layers.length;\n        for(i = 0; i < len; i += 1){\n            if (this.layers[i].ind === ind) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    SVGRendererBase.prototype.buildItem = function(pos) {\n        var elements = this.elements;\n        if (elements[pos] || this.layers[pos].ty === 99) {\n            return;\n        }\n        elements[pos] = true;\n        var element = this.createItem(this.layers[pos]);\n        elements[pos] = element;\n        if (getExpressionsPlugin()) {\n            if (this.layers[pos].ty === 0) {\n                this.globalData.projectInterface.registerComposition(element);\n            }\n            element.initExpressions();\n        }\n        this.appendElementInPos(element, pos);\n        if (this.layers[pos].tt) {\n            var elementIndex = \"tp\" in this.layers[pos] ? this.findIndexByInd(this.layers[pos].tp) : pos - 1;\n            if (elementIndex === -1) {\n                return;\n            }\n            if (!this.elements[elementIndex] || this.elements[elementIndex] === true) {\n                this.buildItem(elementIndex);\n                this.addPendingElement(element);\n            } else {\n                var matteElement = elements[elementIndex];\n                var matteMask = matteElement.getMatte(this.layers[pos].tt);\n                element.setMatte(matteMask);\n            }\n        }\n    };\n    SVGRendererBase.prototype.checkPendingElements = function() {\n        while(this.pendingElements.length){\n            var element = this.pendingElements.pop();\n            element.checkParenting();\n            if (element.data.tt) {\n                var i = 0;\n                var len = this.elements.length;\n                while(i < len){\n                    if (this.elements[i] === element) {\n                        var elementIndex = \"tp\" in element.data ? this.findIndexByInd(element.data.tp) : i - 1;\n                        var matteElement = this.elements[elementIndex];\n                        var matteMask = matteElement.getMatte(this.layers[i].tt);\n                        element.setMatte(matteMask);\n                        break;\n                    }\n                    i += 1;\n                }\n            }\n        }\n    };\n    SVGRendererBase.prototype.renderFrame = function(num) {\n        if (this.renderedFrame === num || this.destroyed) {\n            return;\n        }\n        if (num === null) {\n            num = this.renderedFrame;\n        } else {\n            this.renderedFrame = num;\n        } // console.log('-------');\n        // console.log('FRAME ',num);\n        this.globalData.frameNum = num;\n        this.globalData.frameId += 1;\n        this.globalData.projectInterface.currentFrame = num;\n        this.globalData._mdf = false;\n        var i;\n        var len = this.layers.length;\n        if (!this.completeLayers) {\n            this.checkLayers(num);\n        }\n        for(i = len - 1; i >= 0; i -= 1){\n            if (this.completeLayers || this.elements[i]) {\n                this.elements[i].prepareFrame(num - this.layers[i].st);\n            }\n        }\n        if (this.globalData._mdf) {\n            for(i = 0; i < len; i += 1){\n                if (this.completeLayers || this.elements[i]) {\n                    this.elements[i].renderFrame();\n                }\n            }\n        }\n    };\n    SVGRendererBase.prototype.appendElementInPos = function(element, pos) {\n        var newElement = element.getBaseElement();\n        if (!newElement) {\n            return;\n        }\n        var i = 0;\n        var nextElement;\n        while(i < pos){\n            if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) {\n                nextElement = this.elements[i].getBaseElement();\n            }\n            i += 1;\n        }\n        if (nextElement) {\n            this.layerElement.insertBefore(newElement, nextElement);\n        } else {\n            this.layerElement.appendChild(newElement);\n        }\n    };\n    SVGRendererBase.prototype.hide = function() {\n        this.layerElement.style.display = \"none\";\n    };\n    SVGRendererBase.prototype.show = function() {\n        this.layerElement.style.display = \"block\";\n    };\n    function ICompElement() {}\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableDOMElement\n    ], ICompElement);\n    ICompElement.prototype.initElement = function(data, globalData, comp) {\n        this.initFrame();\n        this.initBaseData(data, globalData, comp);\n        this.initTransform(data, globalData, comp);\n        this.initRenderable();\n        this.initHierarchy();\n        this.initRendererElement();\n        this.createContainerElements();\n        this.createRenderableComponents();\n        if (this.data.xt || !globalData.progressiveLoad) {\n            this.buildAllItems();\n        }\n        this.hide();\n    };\n    /* ICompElement.prototype.hide = function(){\r\n      if(!this.hidden){\r\n          this.hideElement();\r\n          var i,len = this.elements.length;\r\n          for( i = 0; i < len; i+=1 ){\r\n              if(this.elements[i]){\r\n                  this.elements[i].hide();\r\n              }\r\n          }\r\n      }\r\n  }; */ ICompElement.prototype.prepareFrame = function(num) {\n        this._mdf = false;\n        this.prepareRenderableFrame(num);\n        this.prepareProperties(num, this.isInRange);\n        if (!this.isInRange && !this.data.xt) {\n            return;\n        }\n        if (!this.tm._placeholder) {\n            var timeRemapped = this.tm.v;\n            if (timeRemapped === this.data.op) {\n                timeRemapped = this.data.op - 1;\n            }\n            this.renderedFrame = timeRemapped;\n        } else {\n            this.renderedFrame = num / this.data.sr;\n        }\n        var i;\n        var len = this.elements.length;\n        if (!this.completeLayers) {\n            this.checkLayers(this.renderedFrame);\n        } // This iteration needs to be backwards because of how expressions connect between each other\n        for(i = len - 1; i >= 0; i -= 1){\n            if (this.completeLayers || this.elements[i]) {\n                this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);\n                if (this.elements[i]._mdf) {\n                    this._mdf = true;\n                }\n            }\n        }\n    };\n    ICompElement.prototype.renderInnerContent = function() {\n        var i;\n        var len = this.layers.length;\n        for(i = 0; i < len; i += 1){\n            if (this.completeLayers || this.elements[i]) {\n                this.elements[i].renderFrame();\n            }\n        }\n    };\n    ICompElement.prototype.setElements = function(elems) {\n        this.elements = elems;\n    };\n    ICompElement.prototype.getElements = function() {\n        return this.elements;\n    };\n    ICompElement.prototype.destroyElements = function() {\n        var i;\n        var len = this.layers.length;\n        for(i = 0; i < len; i += 1){\n            if (this.elements[i]) {\n                this.elements[i].destroy();\n            }\n        }\n    };\n    ICompElement.prototype.destroy = function() {\n        this.destroyElements();\n        this.destroyBaseElement();\n    };\n    function SVGCompElement(data, globalData, comp) {\n        this.layers = data.layers;\n        this.supports3d = true;\n        this.completeLayers = false;\n        this.pendingElements = [];\n        this.elements = this.layers ? createSizedArray(this.layers.length) : [];\n        this.initElement(data, globalData, comp);\n        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n            _placeholder: true\n        };\n    }\n    extendPrototype([\n        SVGRendererBase,\n        ICompElement,\n        SVGBaseElement\n    ], SVGCompElement);\n    SVGCompElement.prototype.createComp = function(data) {\n        return new SVGCompElement(data, this.globalData, this);\n    };\n    function SVGRenderer(animationItem, config) {\n        this.animationItem = animationItem;\n        this.layers = null;\n        this.renderedFrame = -1;\n        this.svgElement = createNS(\"svg\");\n        var ariaLabel = \"\";\n        if (config && config.title) {\n            var titleElement = createNS(\"title\");\n            var titleId = createElementID();\n            titleElement.setAttribute(\"id\", titleId);\n            titleElement.textContent = config.title;\n            this.svgElement.appendChild(titleElement);\n            ariaLabel += titleId;\n        }\n        if (config && config.description) {\n            var descElement = createNS(\"desc\");\n            var descId = createElementID();\n            descElement.setAttribute(\"id\", descId);\n            descElement.textContent = config.description;\n            this.svgElement.appendChild(descElement);\n            ariaLabel += \" \" + descId;\n        }\n        if (ariaLabel) {\n            this.svgElement.setAttribute(\"aria-labelledby\", ariaLabel);\n        }\n        var defs = createNS(\"defs\");\n        this.svgElement.appendChild(defs);\n        var maskElement = createNS(\"g\");\n        this.svgElement.appendChild(maskElement);\n        this.layerElement = maskElement;\n        this.renderConfig = {\n            preserveAspectRatio: config && config.preserveAspectRatio || \"xMidYMid meet\",\n            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || \"xMidYMid slice\",\n            contentVisibility: config && config.contentVisibility || \"visible\",\n            progressiveLoad: config && config.progressiveLoad || false,\n            hideOnTransparent: !(config && config.hideOnTransparent === false),\n            viewBoxOnly: config && config.viewBoxOnly || false,\n            viewBoxSize: config && config.viewBoxSize || false,\n            className: config && config.className || \"\",\n            id: config && config.id || \"\",\n            focusable: config && config.focusable,\n            filterSize: {\n                width: config && config.filterSize && config.filterSize.width || \"100%\",\n                height: config && config.filterSize && config.filterSize.height || \"100%\",\n                x: config && config.filterSize && config.filterSize.x || \"0%\",\n                y: config && config.filterSize && config.filterSize.y || \"0%\"\n            },\n            width: config && config.width,\n            height: config && config.height,\n            runExpressions: !config || config.runExpressions === undefined || config.runExpressions\n        };\n        this.globalData = {\n            _mdf: false,\n            frameNum: -1,\n            defs: defs,\n            renderConfig: this.renderConfig\n        };\n        this.elements = [];\n        this.pendingElements = [];\n        this.destroyed = false;\n        this.rendererType = \"svg\";\n    }\n    extendPrototype([\n        SVGRendererBase\n    ], SVGRenderer);\n    SVGRenderer.prototype.createComp = function(data) {\n        return new SVGCompElement(data, this.globalData, this);\n    };\n    function ShapeTransformManager() {\n        this.sequences = {};\n        this.sequenceList = [];\n        this.transform_key_count = 0;\n    }\n    ShapeTransformManager.prototype = {\n        addTransformSequence: function addTransformSequence(transforms) {\n            var i;\n            var len = transforms.length;\n            var key = \"_\";\n            for(i = 0; i < len; i += 1){\n                key += transforms[i].transform.key + \"_\";\n            }\n            var sequence = this.sequences[key];\n            if (!sequence) {\n                sequence = {\n                    transforms: [].concat(transforms),\n                    finalTransform: new Matrix(),\n                    _mdf: false\n                };\n                this.sequences[key] = sequence;\n                this.sequenceList.push(sequence);\n            }\n            return sequence;\n        },\n        processSequence: function processSequence(sequence, isFirstFrame) {\n            var i = 0;\n            var len = sequence.transforms.length;\n            var _mdf = isFirstFrame;\n            while(i < len && !isFirstFrame){\n                if (sequence.transforms[i].transform.mProps._mdf) {\n                    _mdf = true;\n                    break;\n                }\n                i += 1;\n            }\n            if (_mdf) {\n                sequence.finalTransform.reset();\n                for(i = len - 1; i >= 0; i -= 1){\n                    sequence.finalTransform.multiply(sequence.transforms[i].transform.mProps.v);\n                }\n            }\n            sequence._mdf = _mdf;\n        },\n        processSequences: function processSequences(isFirstFrame) {\n            var i;\n            var len = this.sequenceList.length;\n            for(i = 0; i < len; i += 1){\n                this.processSequence(this.sequenceList[i], isFirstFrame);\n            }\n        },\n        getNewKey: function getNewKey() {\n            this.transform_key_count += 1;\n            return \"_\" + this.transform_key_count;\n        }\n    };\n    var lumaLoader = function lumaLoader() {\n        var id = \"__lottie_element_luma_buffer\";\n        var lumaBuffer = null;\n        var lumaBufferCtx = null;\n        var svg = null; // This alternate solution has a slight delay before the filter is applied, resulting in a flicker on the first frame.\n        // Keeping this here for reference, and in the future, if offscreen canvas supports url filters, this can be used.\n        // For now, neither of them work for offscreen canvas, so canvas workers can't support the luma track matte mask.\n        // Naming it solution 2 to mark the extra comment lines.\n        /*\r\n    var svgString = [\r\n      '<svg xmlns=\"http://www.w3.org/2000/svg\">',\r\n      '<filter id=\"' + id + '\">',\r\n      '<feColorMatrix type=\"matrix\" color-interpolation-filters=\"sRGB\" values=\"',\r\n      '0.3, 0.3, 0.3, 0, 0, ',\r\n      '0.3, 0.3, 0.3, 0, 0, ',\r\n      '0.3, 0.3, 0.3, 0, 0, ',\r\n      '0.3, 0.3, 0.3, 0, 0',\r\n      '\"/>',\r\n      '</filter>',\r\n      '</svg>',\r\n    ].join('');\r\n    var blob = new Blob([svgString], { type: 'image/svg+xml' });\r\n    var url = URL.createObjectURL(blob);\r\n    */ function createLumaSvgFilter() {\n            var _svg = createNS(\"svg\");\n            var fil = createNS(\"filter\");\n            var matrix = createNS(\"feColorMatrix\");\n            fil.setAttribute(\"id\", id);\n            matrix.setAttribute(\"type\", \"matrix\");\n            matrix.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n            matrix.setAttribute(\"values\", \"0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0\");\n            fil.appendChild(matrix);\n            _svg.appendChild(fil);\n            _svg.setAttribute(\"id\", id + \"_svg\");\n            if (featureSupport.svgLumaHidden) {\n                _svg.style.display = \"none\";\n            }\n            return _svg;\n        }\n        function loadLuma() {\n            if (!lumaBuffer) {\n                svg = createLumaSvgFilter();\n                document.body.appendChild(svg);\n                lumaBuffer = createTag(\"canvas\");\n                lumaBufferCtx = lumaBuffer.getContext(\"2d\"); // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2\n                lumaBufferCtx.filter = \"url(#\" + id + \")\";\n                lumaBufferCtx.fillStyle = \"rgba(0,0,0,0)\";\n                lumaBufferCtx.fillRect(0, 0, 1, 1);\n            }\n        }\n        function getLuma(canvas) {\n            if (!lumaBuffer) {\n                loadLuma();\n            }\n            lumaBuffer.width = canvas.width;\n            lumaBuffer.height = canvas.height; // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2\n            lumaBufferCtx.filter = \"url(#\" + id + \")\";\n            return lumaBuffer;\n        }\n        return {\n            load: loadLuma,\n            get: getLuma\n        };\n    };\n    function createCanvas(width, height) {\n        if (featureSupport.offscreenCanvas) {\n            return new OffscreenCanvas(width, height);\n        }\n        var canvas = createTag(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n    var assetLoader = function() {\n        return {\n            loadLumaCanvas: lumaLoader.load,\n            getLumaCanvas: lumaLoader.get,\n            createCanvas: createCanvas\n        };\n    }();\n    var registeredEffects = {};\n    function CVEffects(elem) {\n        var i;\n        var len = elem.data.ef ? elem.data.ef.length : 0;\n        this.filters = [];\n        var filterManager;\n        for(i = 0; i < len; i += 1){\n            filterManager = null;\n            var type = elem.data.ef[i].ty;\n            if (registeredEffects[type]) {\n                var Effect = registeredEffects[type].effect;\n                filterManager = new Effect(elem.effectsManager.effectElements[i], elem);\n            }\n            if (filterManager) {\n                this.filters.push(filterManager);\n            }\n        }\n        if (this.filters.length) {\n            elem.addRenderableComponent(this);\n        }\n    }\n    CVEffects.prototype.renderFrame = function(_isFirstFrame) {\n        var i;\n        var len = this.filters.length;\n        for(i = 0; i < len; i += 1){\n            this.filters[i].renderFrame(_isFirstFrame);\n        }\n    };\n    CVEffects.prototype.getEffects = function(type) {\n        var i;\n        var len = this.filters.length;\n        var effects = [];\n        for(i = 0; i < len; i += 1){\n            if (this.filters[i].type === type) {\n                effects.push(this.filters[i]);\n            }\n        }\n        return effects;\n    };\n    function registerEffect(id, effect) {\n        registeredEffects[id] = {\n            effect: effect\n        };\n    }\n    function CVMaskElement(data, element) {\n        this.data = data;\n        this.element = element;\n        this.masksProperties = this.data.masksProperties || [];\n        this.viewData = createSizedArray(this.masksProperties.length);\n        var i;\n        var len = this.masksProperties.length;\n        var hasMasks = false;\n        for(i = 0; i < len; i += 1){\n            if (this.masksProperties[i].mode !== \"n\") {\n                hasMasks = true;\n            }\n            this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);\n        }\n        this.hasMasks = hasMasks;\n        if (hasMasks) {\n            this.element.addRenderableComponent(this);\n        }\n    }\n    CVMaskElement.prototype.renderFrame = function() {\n        if (!this.hasMasks) {\n            return;\n        }\n        var transform = this.element.finalTransform.mat;\n        var ctx = this.element.canvasContext;\n        var i;\n        var len = this.masksProperties.length;\n        var pt;\n        var pts;\n        var data;\n        ctx.beginPath();\n        for(i = 0; i < len; i += 1){\n            if (this.masksProperties[i].mode !== \"n\") {\n                if (this.masksProperties[i].inv) {\n                    ctx.moveTo(0, 0);\n                    ctx.lineTo(this.element.globalData.compSize.w, 0);\n                    ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);\n                    ctx.lineTo(0, this.element.globalData.compSize.h);\n                    ctx.lineTo(0, 0);\n                }\n                data = this.viewData[i].v;\n                pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0);\n                ctx.moveTo(pt[0], pt[1]);\n                var j;\n                var jLen = data._length;\n                for(j = 1; j < jLen; j += 1){\n                    pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);\n                    ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);\n                }\n                pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);\n                ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);\n            }\n        }\n        this.element.globalData.renderer.save(true);\n        ctx.clip();\n    };\n    CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;\n    CVMaskElement.prototype.destroy = function() {\n        this.element = null;\n    };\n    function CVBaseElement() {}\n    var operationsMap = {\n        1: \"source-in\",\n        2: \"source-out\",\n        3: \"source-in\",\n        4: \"source-out\"\n    };\n    CVBaseElement.prototype = {\n        createElements: function createElements() {},\n        initRendererElement: function initRendererElement() {},\n        createContainerElements: function createContainerElements() {\n            // If the layer is masked we will use two buffers to store each different states of the drawing\n            // This solution is not ideal for several reason. But unfortunately, because of the recursive\n            // nature of the render tree, it's the only simple way to make sure one inner mask doesn't override an outer mask.\n            // TODO: try to reduce the size of these buffers to the size of the composition contaning the layer\n            // It might be challenging because the layer most likely is transformed in some way\n            if (this.data.tt >= 1) {\n                this.buffers = [];\n                var canvasContext = this.globalData.canvasContext;\n                var bufferCanvas = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);\n                this.buffers.push(bufferCanvas);\n                var bufferCanvas2 = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);\n                this.buffers.push(bufferCanvas2);\n                if (this.data.tt >= 3 && !document._isProxy) {\n                    assetLoader.loadLumaCanvas();\n                }\n            }\n            this.canvasContext = this.globalData.canvasContext;\n            this.transformCanvas = this.globalData.transformCanvas;\n            this.renderableEffectsManager = new CVEffects(this);\n            this.searchEffectTransforms();\n        },\n        createContent: function createContent() {},\n        setBlendMode: function setBlendMode() {\n            var globalData = this.globalData;\n            if (globalData.blendMode !== this.data.bm) {\n                globalData.blendMode = this.data.bm;\n                var blendModeValue = getBlendMode(this.data.bm);\n                globalData.canvasContext.globalCompositeOperation = blendModeValue;\n            }\n        },\n        createRenderableComponents: function createRenderableComponents() {\n            this.maskManager = new CVMaskElement(this.data, this);\n            this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);\n        },\n        hideElement: function hideElement() {\n            if (!this.hidden && (!this.isInRange || this.isTransparent)) {\n                this.hidden = true;\n            }\n        },\n        showElement: function showElement() {\n            if (this.isInRange && !this.isTransparent) {\n                this.hidden = false;\n                this._isFirstFrame = true;\n                this.maskManager._isFirstFrame = true;\n            }\n        },\n        clearCanvas: function clearCanvas(canvasContext) {\n            canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);\n        },\n        prepareLayer: function prepareLayer() {\n            if (this.data.tt >= 1) {\n                var buffer = this.buffers[0];\n                var bufferCtx = buffer.getContext(\"2d\");\n                this.clearCanvas(bufferCtx); // on the first buffer we store the current state of the global drawing\n                bufferCtx.drawImage(this.canvasContext.canvas, 0, 0); // The next four lines are to clear the canvas\n                // TODO: Check if there is a way to clear the canvas without resetting the transform\n                this.currentTransform = this.canvasContext.getTransform();\n                this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);\n                this.clearCanvas(this.canvasContext);\n                this.canvasContext.setTransform(this.currentTransform);\n            }\n        },\n        exitLayer: function exitLayer() {\n            if (this.data.tt >= 1) {\n                var buffer = this.buffers[1]; // On the second buffer we store the current state of the global drawing\n                // that only contains the content of this layer\n                // (if it is a composition, it also includes the nested layers)\n                var bufferCtx = buffer.getContext(\"2d\");\n                this.clearCanvas(bufferCtx);\n                bufferCtx.drawImage(this.canvasContext.canvas, 0, 0); // We clear the canvas again\n                this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);\n                this.clearCanvas(this.canvasContext);\n                this.canvasContext.setTransform(this.currentTransform); // We draw the mask\n                var mask = this.comp.getElementById(\"tp\" in this.data ? this.data.tp : this.data.ind - 1);\n                mask.renderFrame(true); // We draw the second buffer (that contains the content of this layer)\n                this.canvasContext.setTransform(1, 0, 0, 1, 0, 0); // If the mask is a Luma matte, we need to do two extra painting operations\n                // the _isProxy check is to avoid drawing a fake canvas in workers that will throw an error\n                if (this.data.tt >= 3 && !document._isProxy) {\n                    // We copy the painted mask to a buffer that has a color matrix filter applied to it\n                    // that applies the rgb values to the alpha channel\n                    var lumaBuffer = assetLoader.getLumaCanvas(this.canvasContext.canvas);\n                    var lumaBufferCtx = lumaBuffer.getContext(\"2d\");\n                    lumaBufferCtx.drawImage(this.canvasContext.canvas, 0, 0);\n                    this.clearCanvas(this.canvasContext); // we repaint the context with the mask applied to it\n                    this.canvasContext.drawImage(lumaBuffer, 0, 0);\n                }\n                this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt];\n                this.canvasContext.drawImage(buffer, 0, 0); // We finally draw the first buffer (that contains the content of the global drawing)\n                // We use destination-over to draw the global drawing below the current layer\n                this.canvasContext.globalCompositeOperation = \"destination-over\";\n                this.canvasContext.drawImage(this.buffers[0], 0, 0);\n                this.canvasContext.setTransform(this.currentTransform); // We reset the globalCompositeOperation to source-over, the standard type of operation\n                this.canvasContext.globalCompositeOperation = \"source-over\";\n            }\n        },\n        renderFrame: function renderFrame(forceRender) {\n            if (this.hidden || this.data.hd) {\n                return;\n            }\n            if (this.data.td === 1 && !forceRender) {\n                return;\n            }\n            this.renderTransform();\n            this.renderRenderable();\n            this.renderLocalTransform();\n            this.setBlendMode();\n            var forceRealStack = this.data.ty === 0;\n            this.prepareLayer();\n            this.globalData.renderer.save(forceRealStack);\n            this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props);\n            this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity);\n            this.renderInnerContent();\n            this.globalData.renderer.restore(forceRealStack);\n            this.exitLayer();\n            if (this.maskManager.hasMasks) {\n                this.globalData.renderer.restore(true);\n            }\n            if (this._isFirstFrame) {\n                this._isFirstFrame = false;\n            }\n        },\n        destroy: function destroy() {\n            this.canvasContext = null;\n            this.data = null;\n            this.globalData = null;\n            this.maskManager.destroy();\n        },\n        mHelper: new Matrix()\n    };\n    CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;\n    CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;\n    function CVShapeData(element, data, styles, transformsManager) {\n        this.styledShapes = [];\n        this.tr = [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        ];\n        var ty = 4;\n        if (data.ty === \"rc\") {\n            ty = 5;\n        } else if (data.ty === \"el\") {\n            ty = 6;\n        } else if (data.ty === \"sr\") {\n            ty = 7;\n        }\n        this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element);\n        var i;\n        var len = styles.length;\n        var styledShape;\n        for(i = 0; i < len; i += 1){\n            if (!styles[i].closed) {\n                styledShape = {\n                    transforms: transformsManager.addTransformSequence(styles[i].transforms),\n                    trNodes: []\n                };\n                this.styledShapes.push(styledShape);\n                styles[i].elements.push(styledShape);\n            }\n        }\n    }\n    CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;\n    function CVShapeElement(data, globalData, comp) {\n        this.shapes = [];\n        this.shapesData = data.shapes;\n        this.stylesList = [];\n        this.itemsData = [];\n        this.prevViewData = [];\n        this.shapeModifiers = [];\n        this.processedElements = [];\n        this.transformsManager = new ShapeTransformManager();\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        CVBaseElement,\n        IShapeElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableElement\n    ], CVShapeElement);\n    CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;\n    CVShapeElement.prototype.transformHelper = {\n        opacity: 1,\n        _opMdf: false\n    };\n    CVShapeElement.prototype.dashResetter = [];\n    CVShapeElement.prototype.createContent = function() {\n        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);\n    };\n    CVShapeElement.prototype.createStyleElement = function(data, transforms) {\n        var styleElem = {\n            data: data,\n            type: data.ty,\n            preTransforms: this.transformsManager.addTransformSequence(transforms),\n            transforms: [],\n            elements: [],\n            closed: data.hd === true\n        };\n        var elementData = {};\n        if (data.ty === \"fl\" || data.ty === \"st\") {\n            elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this);\n            if (!elementData.c.k) {\n                styleElem.co = \"rgb(\" + bmFloor(elementData.c.v[0]) + \",\" + bmFloor(elementData.c.v[1]) + \",\" + bmFloor(elementData.c.v[2]) + \")\";\n            }\n        } else if (data.ty === \"gf\" || data.ty === \"gs\") {\n            elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this);\n            elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this);\n            elementData.h = PropertyFactory.getProp(this, data.h || {\n                k: 0\n            }, 0, 0.01, this);\n            elementData.a = PropertyFactory.getProp(this, data.a || {\n                k: 0\n            }, 0, degToRads, this);\n            elementData.g = new GradientProperty(this, data.g, this);\n        }\n        elementData.o = PropertyFactory.getProp(this, data.o, 0, 0.01, this);\n        if (data.ty === \"st\" || data.ty === \"gs\") {\n            styleElem.lc = lineCapEnum[data.lc || 2];\n            styleElem.lj = lineJoinEnum[data.lj || 2];\n            if (data.lj == 1) {\n                // eslint-disable-line eqeqeq\n                styleElem.ml = data.ml;\n            }\n            elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this);\n            if (!elementData.w.k) {\n                styleElem.wi = elementData.w.v;\n            }\n            if (data.d) {\n                var d = new DashProperty(this, data.d, \"canvas\", this);\n                elementData.d = d;\n                if (!elementData.d.k) {\n                    styleElem.da = elementData.d.dashArray;\n                    styleElem[\"do\"] = elementData.d.dashoffset[0];\n                }\n            }\n        } else {\n            styleElem.r = data.r === 2 ? \"evenodd\" : \"nonzero\";\n        }\n        this.stylesList.push(styleElem);\n        elementData.style = styleElem;\n        return elementData;\n    };\n    CVShapeElement.prototype.createGroupElement = function() {\n        var elementData = {\n            it: [],\n            prevViewData: []\n        };\n        return elementData;\n    };\n    CVShapeElement.prototype.createTransformElement = function(data) {\n        var elementData = {\n            transform: {\n                opacity: 1,\n                _opMdf: false,\n                key: this.transformsManager.getNewKey(),\n                op: PropertyFactory.getProp(this, data.o, 0, 0.01, this),\n                mProps: TransformPropertyFactory.getTransformProperty(this, data, this)\n            }\n        };\n        return elementData;\n    };\n    CVShapeElement.prototype.createShapeElement = function(data) {\n        var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);\n        this.shapes.push(elementData);\n        this.addShapeToModifiers(elementData);\n        return elementData;\n    };\n    CVShapeElement.prototype.reloadShapes = function() {\n        this._isFirstFrame = true;\n        var i;\n        var len = this.itemsData.length;\n        for(i = 0; i < len; i += 1){\n            this.prevViewData[i] = this.itemsData[i];\n        }\n        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);\n        len = this.dynamicProperties.length;\n        for(i = 0; i < len; i += 1){\n            this.dynamicProperties[i].getValue();\n        }\n        this.renderModifiers();\n        this.transformsManager.processSequences(this._isFirstFrame);\n    };\n    CVShapeElement.prototype.addTransformToStyleList = function(transform) {\n        var i;\n        var len = this.stylesList.length;\n        for(i = 0; i < len; i += 1){\n            if (!this.stylesList[i].closed) {\n                this.stylesList[i].transforms.push(transform);\n            }\n        }\n    };\n    CVShapeElement.prototype.removeTransformFromStyleList = function() {\n        var i;\n        var len = this.stylesList.length;\n        for(i = 0; i < len; i += 1){\n            if (!this.stylesList[i].closed) {\n                this.stylesList[i].transforms.pop();\n            }\n        }\n    };\n    CVShapeElement.prototype.closeStyles = function(styles) {\n        var i;\n        var len = styles.length;\n        for(i = 0; i < len; i += 1){\n            styles[i].closed = true;\n        }\n    };\n    CVShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, shouldRender, transforms) {\n        var i;\n        var len = arr.length - 1;\n        var j;\n        var jLen;\n        var ownStyles = [];\n        var ownModifiers = [];\n        var processedPos;\n        var modifier;\n        var currentTransform;\n        var ownTransforms = [].concat(transforms);\n        for(i = len; i >= 0; i -= 1){\n            processedPos = this.searchProcessedElement(arr[i]);\n            if (!processedPos) {\n                arr[i]._shouldRender = shouldRender;\n            } else {\n                itemsData[i] = prevViewData[processedPos - 1];\n            }\n            if (arr[i].ty === \"fl\" || arr[i].ty === \"st\" || arr[i].ty === \"gf\" || arr[i].ty === \"gs\") {\n                if (!processedPos) {\n                    itemsData[i] = this.createStyleElement(arr[i], ownTransforms);\n                } else {\n                    itemsData[i].style.closed = false;\n                }\n                ownStyles.push(itemsData[i].style);\n            } else if (arr[i].ty === \"gr\") {\n                if (!processedPos) {\n                    itemsData[i] = this.createGroupElement(arr[i]);\n                } else {\n                    jLen = itemsData[i].it.length;\n                    for(j = 0; j < jLen; j += 1){\n                        itemsData[i].prevViewData[j] = itemsData[i].it[j];\n                    }\n                }\n                this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms);\n            } else if (arr[i].ty === \"tr\") {\n                if (!processedPos) {\n                    currentTransform = this.createTransformElement(arr[i]);\n                    itemsData[i] = currentTransform;\n                }\n                ownTransforms.push(itemsData[i]);\n                this.addTransformToStyleList(itemsData[i]);\n            } else if (arr[i].ty === \"sh\" || arr[i].ty === \"rc\" || arr[i].ty === \"el\" || arr[i].ty === \"sr\") {\n                if (!processedPos) {\n                    itemsData[i] = this.createShapeElement(arr[i]);\n                }\n            } else if (arr[i].ty === \"tm\" || arr[i].ty === \"rd\" || arr[i].ty === \"pb\" || arr[i].ty === \"zz\" || arr[i].ty === \"op\") {\n                if (!processedPos) {\n                    modifier = ShapeModifiers.getModifier(arr[i].ty);\n                    modifier.init(this, arr[i]);\n                    itemsData[i] = modifier;\n                    this.shapeModifiers.push(modifier);\n                } else {\n                    modifier = itemsData[i];\n                    modifier.closed = false;\n                }\n                ownModifiers.push(modifier);\n            } else if (arr[i].ty === \"rp\") {\n                if (!processedPos) {\n                    modifier = ShapeModifiers.getModifier(arr[i].ty);\n                    itemsData[i] = modifier;\n                    modifier.init(this, arr, i, itemsData);\n                    this.shapeModifiers.push(modifier);\n                    shouldRender = false;\n                } else {\n                    modifier = itemsData[i];\n                    modifier.closed = true;\n                }\n                ownModifiers.push(modifier);\n            }\n            this.addProcessedElement(arr[i], i + 1);\n        }\n        this.removeTransformFromStyleList();\n        this.closeStyles(ownStyles);\n        len = ownModifiers.length;\n        for(i = 0; i < len; i += 1){\n            ownModifiers[i].closed = true;\n        }\n    };\n    CVShapeElement.prototype.renderInnerContent = function() {\n        this.transformHelper.opacity = 1;\n        this.transformHelper._opMdf = false;\n        this.renderModifiers();\n        this.transformsManager.processSequences(this._isFirstFrame);\n        this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);\n    };\n    CVShapeElement.prototype.renderShapeTransform = function(parentTransform, groupTransform) {\n        if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {\n            groupTransform.opacity = parentTransform.opacity;\n            groupTransform.opacity *= groupTransform.op.v;\n            groupTransform._opMdf = true;\n        }\n    };\n    CVShapeElement.prototype.drawLayer = function() {\n        var i;\n        var len = this.stylesList.length;\n        var j;\n        var jLen;\n        var k;\n        var kLen;\n        var elems;\n        var nodes;\n        var renderer = this.globalData.renderer;\n        var ctx = this.globalData.canvasContext;\n        var type;\n        var currentStyle;\n        for(i = 0; i < len; i += 1){\n            currentStyle = this.stylesList[i];\n            type = currentStyle.type; // Skipping style when\n            // Stroke width equals 0\n            // style should not be rendered (extra unused repeaters)\n            // current opacity equals 0\n            // global opacity equals 0\n            if (!((type === \"st\" || type === \"gs\") && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {\n                renderer.save();\n                elems = currentStyle.elements;\n                if (type === \"st\" || type === \"gs\") {\n                    renderer.ctxStrokeStyle(type === \"st\" ? currentStyle.co : currentStyle.grd); // ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;\n                    renderer.ctxLineWidth(currentStyle.wi); // ctx.lineWidth = currentStyle.wi;\n                    renderer.ctxLineCap(currentStyle.lc); // ctx.lineCap = currentStyle.lc;\n                    renderer.ctxLineJoin(currentStyle.lj); // ctx.lineJoin = currentStyle.lj;\n                    renderer.ctxMiterLimit(currentStyle.ml || 0); // ctx.miterLimit = currentStyle.ml || 0;\n                } else {\n                    renderer.ctxFillStyle(type === \"fl\" ? currentStyle.co : currentStyle.grd); // ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;\n                }\n                renderer.ctxOpacity(currentStyle.coOp);\n                if (type !== \"st\" && type !== \"gs\") {\n                    ctx.beginPath();\n                }\n                renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);\n                jLen = elems.length;\n                for(j = 0; j < jLen; j += 1){\n                    if (type === \"st\" || type === \"gs\") {\n                        ctx.beginPath();\n                        if (currentStyle.da) {\n                            ctx.setLineDash(currentStyle.da);\n                            ctx.lineDashOffset = currentStyle[\"do\"];\n                        }\n                    }\n                    nodes = elems[j].trNodes;\n                    kLen = nodes.length;\n                    for(k = 0; k < kLen; k += 1){\n                        if (nodes[k].t === \"m\") {\n                            ctx.moveTo(nodes[k].p[0], nodes[k].p[1]);\n                        } else if (nodes[k].t === \"c\") {\n                            ctx.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]);\n                        } else {\n                            ctx.closePath();\n                        }\n                    }\n                    if (type === \"st\" || type === \"gs\") {\n                        // ctx.stroke();\n                        renderer.ctxStroke();\n                        if (currentStyle.da) {\n                            ctx.setLineDash(this.dashResetter);\n                        }\n                    }\n                }\n                if (type !== \"st\" && type !== \"gs\") {\n                    // ctx.fill(currentStyle.r);\n                    this.globalData.renderer.ctxFill(currentStyle.r);\n                }\n                renderer.restore();\n            }\n        }\n    };\n    CVShapeElement.prototype.renderShape = function(parentTransform, items, data, isMain) {\n        var i;\n        var len = items.length - 1;\n        var groupTransform;\n        groupTransform = parentTransform;\n        for(i = len; i >= 0; i -= 1){\n            if (items[i].ty === \"tr\") {\n                groupTransform = data[i].transform;\n                this.renderShapeTransform(parentTransform, groupTransform);\n            } else if (items[i].ty === \"sh\" || items[i].ty === \"el\" || items[i].ty === \"rc\" || items[i].ty === \"sr\") {\n                this.renderPath(items[i], data[i]);\n            } else if (items[i].ty === \"fl\") {\n                this.renderFill(items[i], data[i], groupTransform);\n            } else if (items[i].ty === \"st\") {\n                this.renderStroke(items[i], data[i], groupTransform);\n            } else if (items[i].ty === \"gf\" || items[i].ty === \"gs\") {\n                this.renderGradientFill(items[i], data[i], groupTransform);\n            } else if (items[i].ty === \"gr\") {\n                this.renderShape(groupTransform, items[i].it, data[i].it);\n            } else if (items[i].ty === \"tm\") {}\n        }\n        if (isMain) {\n            this.drawLayer();\n        }\n    };\n    CVShapeElement.prototype.renderStyledShape = function(styledShape, shape) {\n        if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {\n            var shapeNodes = styledShape.trNodes;\n            var paths = shape.paths;\n            var i;\n            var len;\n            var j;\n            var jLen = paths._length;\n            shapeNodes.length = 0;\n            var groupTransformMat = styledShape.transforms.finalTransform;\n            for(j = 0; j < jLen; j += 1){\n                var pathNodes = paths.shapes[j];\n                if (pathNodes && pathNodes.v) {\n                    len = pathNodes._length;\n                    for(i = 1; i < len; i += 1){\n                        if (i === 1) {\n                            shapeNodes.push({\n                                t: \"m\",\n                                p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)\n                            });\n                        }\n                        shapeNodes.push({\n                            t: \"c\",\n                            pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i])\n                        });\n                    }\n                    if (len === 1) {\n                        shapeNodes.push({\n                            t: \"m\",\n                            p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)\n                        });\n                    }\n                    if (pathNodes.c && len) {\n                        shapeNodes.push({\n                            t: \"c\",\n                            pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0])\n                        });\n                        shapeNodes.push({\n                            t: \"z\"\n                        });\n                    }\n                }\n            }\n            styledShape.trNodes = shapeNodes;\n        }\n    };\n    CVShapeElement.prototype.renderPath = function(pathData, itemData) {\n        if (pathData.hd !== true && pathData._shouldRender) {\n            var i;\n            var len = itemData.styledShapes.length;\n            for(i = 0; i < len; i += 1){\n                this.renderStyledShape(itemData.styledShapes[i], itemData.sh);\n            }\n        }\n    };\n    CVShapeElement.prototype.renderFill = function(styleData, itemData, groupTransform) {\n        var styleElem = itemData.style;\n        if (itemData.c._mdf || this._isFirstFrame) {\n            styleElem.co = \"rgb(\" + bmFloor(itemData.c.v[0]) + \",\" + bmFloor(itemData.c.v[1]) + \",\" + bmFloor(itemData.c.v[2]) + \")\";\n        }\n        if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {\n            styleElem.coOp = itemData.o.v * groupTransform.opacity;\n        }\n    };\n    CVShapeElement.prototype.renderGradientFill = function(styleData, itemData, groupTransform) {\n        var styleElem = itemData.style;\n        var grd;\n        if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {\n            var ctx = this.globalData.canvasContext;\n            var pt1 = itemData.s.v;\n            var pt2 = itemData.e.v;\n            if (styleData.t === 1) {\n                grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);\n            } else {\n                var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));\n                var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);\n                var percent = itemData.h.v;\n                if (percent >= 1) {\n                    percent = 0.99;\n                } else if (percent <= -1) {\n                    percent = -0.99;\n                }\n                var dist = rad * percent;\n                var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];\n                var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];\n                grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);\n            }\n            var i;\n            var len = styleData.g.p;\n            var cValues = itemData.g.c;\n            var opacity = 1;\n            for(i = 0; i < len; i += 1){\n                if (itemData.g._hasOpacity && itemData.g._collapsable) {\n                    opacity = itemData.g.o[i * 2 + 1];\n                }\n                grd.addColorStop(cValues[i * 4] / 100, \"rgba(\" + cValues[i * 4 + 1] + \",\" + cValues[i * 4 + 2] + \",\" + cValues[i * 4 + 3] + \",\" + opacity + \")\");\n            }\n            styleElem.grd = grd;\n        }\n        styleElem.coOp = itemData.o.v * groupTransform.opacity;\n    };\n    CVShapeElement.prototype.renderStroke = function(styleData, itemData, groupTransform) {\n        var styleElem = itemData.style;\n        var d = itemData.d;\n        if (d && (d._mdf || this._isFirstFrame)) {\n            styleElem.da = d.dashArray;\n            styleElem[\"do\"] = d.dashoffset[0];\n        }\n        if (itemData.c._mdf || this._isFirstFrame) {\n            styleElem.co = \"rgb(\" + bmFloor(itemData.c.v[0]) + \",\" + bmFloor(itemData.c.v[1]) + \",\" + bmFloor(itemData.c.v[2]) + \")\";\n        }\n        if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {\n            styleElem.coOp = itemData.o.v * groupTransform.opacity;\n        }\n        if (itemData.w._mdf || this._isFirstFrame) {\n            styleElem.wi = itemData.w.v;\n        }\n    };\n    CVShapeElement.prototype.destroy = function() {\n        this.shapesData = null;\n        this.globalData = null;\n        this.canvasContext = null;\n        this.stylesList.length = 0;\n        this.itemsData.length = 0;\n    };\n    function CVTextElement(data, globalData, comp) {\n        this.textSpans = [];\n        this.yOffset = 0;\n        this.fillColorAnim = false;\n        this.strokeColorAnim = false;\n        this.strokeWidthAnim = false;\n        this.stroke = false;\n        this.fill = false;\n        this.justifyOffset = 0;\n        this.currentRender = null;\n        this.renderType = \"canvas\";\n        this.values = {\n            fill: \"rgba(0,0,0,0)\",\n            stroke: \"rgba(0,0,0,0)\",\n            sWidth: 0,\n            fValue: \"\"\n        };\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        CVBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableElement,\n        ITextElement\n    ], CVTextElement);\n    CVTextElement.prototype.tHelper = createTag(\"canvas\").getContext(\"2d\");\n    CVTextElement.prototype.buildNewText = function() {\n        var documentData = this.textProperty.currentData;\n        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);\n        var hasFill = false;\n        if (documentData.fc) {\n            hasFill = true;\n            this.values.fill = this.buildColor(documentData.fc);\n        } else {\n            this.values.fill = \"rgba(0,0,0,0)\";\n        }\n        this.fill = hasFill;\n        var hasStroke = false;\n        if (documentData.sc) {\n            hasStroke = true;\n            this.values.stroke = this.buildColor(documentData.sc);\n            this.values.sWidth = documentData.sw;\n        }\n        var fontData = this.globalData.fontManager.getFontByName(documentData.f);\n        var i;\n        var len;\n        var letters = documentData.l;\n        var matrixHelper = this.mHelper;\n        this.stroke = hasStroke;\n        this.values.fValue = documentData.finalSize + \"px \" + this.globalData.fontManager.getFontByName(documentData.f).fFamily;\n        len = documentData.finalText.length; // this.tHelper.font = this.values.fValue;\n        var charData;\n        var shapeData;\n        var k;\n        var kLen;\n        var shapes;\n        var j;\n        var jLen;\n        var pathNodes;\n        var commands;\n        var pathArr;\n        var singleShape = this.data.singleShape;\n        var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;\n        var xPos = 0;\n        var yPos = 0;\n        var firstLine = true;\n        var cnt = 0;\n        for(i = 0; i < len; i += 1){\n            charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);\n            shapeData = charData && charData.data || {};\n            matrixHelper.reset();\n            if (singleShape && letters[i].n) {\n                xPos = -trackingOffset;\n                yPos += documentData.yOffset;\n                yPos += firstLine ? 1 : 0;\n                firstLine = false;\n            }\n            shapes = shapeData.shapes ? shapeData.shapes[0].it : [];\n            jLen = shapes.length;\n            matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);\n            if (singleShape) {\n                this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);\n            }\n            commands = createSizedArray(jLen - 1);\n            var commandsCounter = 0;\n            for(j = 0; j < jLen; j += 1){\n                if (shapes[j].ty === \"sh\") {\n                    kLen = shapes[j].ks.k.i.length;\n                    pathNodes = shapes[j].ks.k;\n                    pathArr = [];\n                    for(k = 1; k < kLen; k += 1){\n                        if (k === 1) {\n                            pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));\n                        }\n                        pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));\n                    }\n                    pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));\n                    commands[commandsCounter] = pathArr;\n                    commandsCounter += 1;\n                }\n            }\n            if (singleShape) {\n                xPos += letters[i].l;\n                xPos += trackingOffset;\n            }\n            if (this.textSpans[cnt]) {\n                this.textSpans[cnt].elem = commands;\n            } else {\n                this.textSpans[cnt] = {\n                    elem: commands\n                };\n            }\n            cnt += 1;\n        }\n    };\n    CVTextElement.prototype.renderInnerContent = function() {\n        this.validateText();\n        var ctx = this.canvasContext;\n        ctx.font = this.values.fValue;\n        this.globalData.renderer.ctxLineCap(\"butt\"); // ctx.lineCap = 'butt';\n        this.globalData.renderer.ctxLineJoin(\"miter\"); // ctx.lineJoin = 'miter';\n        this.globalData.renderer.ctxMiterLimit(4); // ctx.miterLimit = 4;\n        if (!this.data.singleShape) {\n            this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);\n        }\n        var i;\n        var len;\n        var j;\n        var jLen;\n        var k;\n        var kLen;\n        var renderedLetters = this.textAnimator.renderedLetters;\n        var letters = this.textProperty.currentData.l;\n        len = letters.length;\n        var renderedLetter;\n        var lastFill = null;\n        var lastStroke = null;\n        var lastStrokeW = null;\n        var commands;\n        var pathArr;\n        var renderer = this.globalData.renderer;\n        for(i = 0; i < len; i += 1){\n            if (!letters[i].n) {\n                renderedLetter = renderedLetters[i];\n                if (renderedLetter) {\n                    renderer.save();\n                    renderer.ctxTransform(renderedLetter.p);\n                    renderer.ctxOpacity(renderedLetter.o);\n                }\n                if (this.fill) {\n                    if (renderedLetter && renderedLetter.fc) {\n                        if (lastFill !== renderedLetter.fc) {\n                            renderer.ctxFillStyle(renderedLetter.fc);\n                            lastFill = renderedLetter.fc; // ctx.fillStyle = renderedLetter.fc;\n                        }\n                    } else if (lastFill !== this.values.fill) {\n                        lastFill = this.values.fill;\n                        renderer.ctxFillStyle(this.values.fill); // ctx.fillStyle = this.values.fill;\n                    }\n                    commands = this.textSpans[i].elem;\n                    jLen = commands.length;\n                    this.globalData.canvasContext.beginPath();\n                    for(j = 0; j < jLen; j += 1){\n                        pathArr = commands[j];\n                        kLen = pathArr.length;\n                        this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);\n                        for(k = 2; k < kLen; k += 6){\n                            this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);\n                        }\n                    }\n                    this.globalData.canvasContext.closePath();\n                    renderer.ctxFill(); // this.globalData.canvasContext.fill();\n                /// ctx.fillText(this.textSpans[i].val,0,0);\n                }\n                if (this.stroke) {\n                    if (renderedLetter && renderedLetter.sw) {\n                        if (lastStrokeW !== renderedLetter.sw) {\n                            lastStrokeW = renderedLetter.sw;\n                            renderer.ctxLineWidth(renderedLetter.sw); // ctx.lineWidth = renderedLetter.sw;\n                        }\n                    } else if (lastStrokeW !== this.values.sWidth) {\n                        lastStrokeW = this.values.sWidth;\n                        renderer.ctxLineWidth(this.values.sWidth); // ctx.lineWidth = this.values.sWidth;\n                    }\n                    if (renderedLetter && renderedLetter.sc) {\n                        if (lastStroke !== renderedLetter.sc) {\n                            lastStroke = renderedLetter.sc;\n                            renderer.ctxStrokeStyle(renderedLetter.sc); // ctx.strokeStyle = renderedLetter.sc;\n                        }\n                    } else if (lastStroke !== this.values.stroke) {\n                        lastStroke = this.values.stroke;\n                        renderer.ctxStrokeStyle(this.values.stroke); // ctx.strokeStyle = this.values.stroke;\n                    }\n                    commands = this.textSpans[i].elem;\n                    jLen = commands.length;\n                    this.globalData.canvasContext.beginPath();\n                    for(j = 0; j < jLen; j += 1){\n                        pathArr = commands[j];\n                        kLen = pathArr.length;\n                        this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);\n                        for(k = 2; k < kLen; k += 6){\n                            this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);\n                        }\n                    }\n                    this.globalData.canvasContext.closePath();\n                    renderer.ctxStroke(); // this.globalData.canvasContext.stroke();\n                /// ctx.strokeText(letters[i].val,0,0);\n                }\n                if (renderedLetter) {\n                    this.globalData.renderer.restore();\n                }\n            }\n        }\n    };\n    function CVImageElement(data, globalData, comp) {\n        this.assetData = globalData.getAssetData(data.refId);\n        this.img = globalData.imageLoader.getAsset(this.assetData);\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        CVBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableElement\n    ], CVImageElement);\n    CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;\n    CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;\n    CVImageElement.prototype.createContent = function() {\n        if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {\n            var canvas = createTag(\"canvas\");\n            canvas.width = this.assetData.w;\n            canvas.height = this.assetData.h;\n            var ctx = canvas.getContext(\"2d\");\n            var imgW = this.img.width;\n            var imgH = this.img.height;\n            var imgRel = imgW / imgH;\n            var canvasRel = this.assetData.w / this.assetData.h;\n            var widthCrop;\n            var heightCrop;\n            var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;\n            if (imgRel > canvasRel && par === \"xMidYMid slice\" || imgRel < canvasRel && par !== \"xMidYMid slice\") {\n                heightCrop = imgH;\n                widthCrop = heightCrop * canvasRel;\n            } else {\n                widthCrop = imgW;\n                heightCrop = widthCrop / canvasRel;\n            }\n            ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);\n            this.img = canvas;\n        }\n    };\n    CVImageElement.prototype.renderInnerContent = function() {\n        this.canvasContext.drawImage(this.img, 0, 0);\n    };\n    CVImageElement.prototype.destroy = function() {\n        this.img = null;\n    };\n    function CVSolidElement(data, globalData, comp) {\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        CVBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableElement\n    ], CVSolidElement);\n    CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;\n    CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;\n    CVSolidElement.prototype.renderInnerContent = function() {\n        // var ctx = this.canvasContext;\n        this.globalData.renderer.ctxFillStyle(this.data.sc); // ctx.fillStyle = this.data.sc;\n        this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh); // ctx.fillRect(0, 0, this.data.sw, this.data.sh);\n    //\n    };\n    function CanvasRendererBase() {}\n    extendPrototype([\n        BaseRenderer\n    ], CanvasRendererBase);\n    CanvasRendererBase.prototype.createShape = function(data) {\n        return new CVShapeElement(data, this.globalData, this);\n    };\n    CanvasRendererBase.prototype.createText = function(data) {\n        return new CVTextElement(data, this.globalData, this);\n    };\n    CanvasRendererBase.prototype.createImage = function(data) {\n        return new CVImageElement(data, this.globalData, this);\n    };\n    CanvasRendererBase.prototype.createSolid = function(data) {\n        return new CVSolidElement(data, this.globalData, this);\n    };\n    CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;\n    CanvasRendererBase.prototype.ctxTransform = function(props) {\n        if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {\n            return;\n        }\n        this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);\n    };\n    CanvasRendererBase.prototype.ctxOpacity = function(op) {\n        this.canvasContext.globalAlpha *= op < 0 ? 0 : op;\n    };\n    CanvasRendererBase.prototype.ctxFillStyle = function(value) {\n        this.canvasContext.fillStyle = value;\n    };\n    CanvasRendererBase.prototype.ctxStrokeStyle = function(value) {\n        this.canvasContext.strokeStyle = value;\n    };\n    CanvasRendererBase.prototype.ctxLineWidth = function(value) {\n        this.canvasContext.lineWidth = value;\n    };\n    CanvasRendererBase.prototype.ctxLineCap = function(value) {\n        this.canvasContext.lineCap = value;\n    };\n    CanvasRendererBase.prototype.ctxLineJoin = function(value) {\n        this.canvasContext.lineJoin = value;\n    };\n    CanvasRendererBase.prototype.ctxMiterLimit = function(value) {\n        this.canvasContext.miterLimit = value;\n    };\n    CanvasRendererBase.prototype.ctxFill = function(rule) {\n        this.canvasContext.fill(rule);\n    };\n    CanvasRendererBase.prototype.ctxFillRect = function(x, y, w, h) {\n        this.canvasContext.fillRect(x, y, w, h);\n    };\n    CanvasRendererBase.prototype.ctxStroke = function() {\n        this.canvasContext.stroke();\n    };\n    CanvasRendererBase.prototype.reset = function() {\n        if (!this.renderConfig.clearCanvas) {\n            this.canvasContext.restore();\n            return;\n        }\n        this.contextData.reset();\n    };\n    CanvasRendererBase.prototype.save = function() {\n        this.canvasContext.save();\n    };\n    CanvasRendererBase.prototype.restore = function(actionFlag) {\n        if (!this.renderConfig.clearCanvas) {\n            this.canvasContext.restore();\n            return;\n        }\n        if (actionFlag) {\n            this.globalData.blendMode = \"source-over\";\n        }\n        this.contextData.restore(actionFlag);\n    };\n    CanvasRendererBase.prototype.configAnimation = function(animData) {\n        if (this.animationItem.wrapper) {\n            this.animationItem.container = createTag(\"canvas\");\n            var containerStyle = this.animationItem.container.style;\n            containerStyle.width = \"100%\";\n            containerStyle.height = \"100%\";\n            var origin = \"0px 0px 0px\";\n            containerStyle.transformOrigin = origin;\n            containerStyle.mozTransformOrigin = origin;\n            containerStyle.webkitTransformOrigin = origin;\n            containerStyle[\"-webkit-transform\"] = origin;\n            containerStyle.contentVisibility = this.renderConfig.contentVisibility;\n            this.animationItem.wrapper.appendChild(this.animationItem.container);\n            this.canvasContext = this.animationItem.container.getContext(\"2d\");\n            if (this.renderConfig.className) {\n                this.animationItem.container.setAttribute(\"class\", this.renderConfig.className);\n            }\n            if (this.renderConfig.id) {\n                this.animationItem.container.setAttribute(\"id\", this.renderConfig.id);\n            }\n        } else {\n            this.canvasContext = this.renderConfig.context;\n        }\n        this.contextData.setContext(this.canvasContext);\n        this.data = animData;\n        this.layers = animData.layers;\n        this.transformCanvas = {\n            w: animData.w,\n            h: animData.h,\n            sx: 0,\n            sy: 0,\n            tx: 0,\n            ty: 0\n        };\n        this.setupGlobalData(animData, document.body);\n        this.globalData.canvasContext = this.canvasContext;\n        this.globalData.renderer = this;\n        this.globalData.isDashed = false;\n        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;\n        this.globalData.transformCanvas = this.transformCanvas;\n        this.elements = createSizedArray(animData.layers.length);\n        this.updateContainerSize();\n    };\n    CanvasRendererBase.prototype.updateContainerSize = function(width, height) {\n        this.reset();\n        var elementWidth;\n        var elementHeight;\n        if (width) {\n            elementWidth = width;\n            elementHeight = height;\n            this.canvasContext.canvas.width = elementWidth;\n            this.canvasContext.canvas.height = elementHeight;\n        } else {\n            if (this.animationItem.wrapper && this.animationItem.container) {\n                elementWidth = this.animationItem.wrapper.offsetWidth;\n                elementHeight = this.animationItem.wrapper.offsetHeight;\n            } else {\n                elementWidth = this.canvasContext.canvas.width;\n                elementHeight = this.canvasContext.canvas.height;\n            }\n            this.canvasContext.canvas.width = elementWidth * this.renderConfig.dpr;\n            this.canvasContext.canvas.height = elementHeight * this.renderConfig.dpr;\n        }\n        var elementRel;\n        var animationRel;\n        if (this.renderConfig.preserveAspectRatio.indexOf(\"meet\") !== -1 || this.renderConfig.preserveAspectRatio.indexOf(\"slice\") !== -1) {\n            var par = this.renderConfig.preserveAspectRatio.split(\" \");\n            var fillType = par[1] || \"meet\";\n            var pos = par[0] || \"xMidYMid\";\n            var xPos = pos.substr(0, 4);\n            var yPos = pos.substr(4);\n            elementRel = elementWidth / elementHeight;\n            animationRel = this.transformCanvas.w / this.transformCanvas.h;\n            if (animationRel > elementRel && fillType === \"meet\" || animationRel < elementRel && fillType === \"slice\") {\n                this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);\n                this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);\n            } else {\n                this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);\n                this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);\n            }\n            if (xPos === \"xMid\" && (animationRel < elementRel && fillType === \"meet\" || animationRel > elementRel && fillType === \"slice\")) {\n                this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr;\n            } else if (xPos === \"xMax\" && (animationRel < elementRel && fillType === \"meet\" || animationRel > elementRel && fillType === \"slice\")) {\n                this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;\n            } else {\n                this.transformCanvas.tx = 0;\n            }\n            if (yPos === \"YMid\" && (animationRel > elementRel && fillType === \"meet\" || animationRel < elementRel && fillType === \"slice\")) {\n                this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr;\n            } else if (yPos === \"YMax\" && (animationRel > elementRel && fillType === \"meet\" || animationRel < elementRel && fillType === \"slice\")) {\n                this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr;\n            } else {\n                this.transformCanvas.ty = 0;\n            }\n        } else if (this.renderConfig.preserveAspectRatio === \"none\") {\n            this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);\n            this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);\n            this.transformCanvas.tx = 0;\n            this.transformCanvas.ty = 0;\n        } else {\n            this.transformCanvas.sx = this.renderConfig.dpr;\n            this.transformCanvas.sy = this.renderConfig.dpr;\n            this.transformCanvas.tx = 0;\n            this.transformCanvas.ty = 0;\n        }\n        this.transformCanvas.props = [\n            this.transformCanvas.sx,\n            0,\n            0,\n            0,\n            0,\n            this.transformCanvas.sy,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            this.transformCanvas.tx,\n            this.transformCanvas.ty,\n            0,\n            1\n        ];\n        /* var i, len = this.elements.length;\r\n      for(i=0;i<len;i+=1){\r\n          if(this.elements[i] && this.elements[i].data.ty === 0){\r\n              this.elements[i].resize(this.globalData.transformCanvas);\r\n          }\r\n      } */ this.ctxTransform(this.transformCanvas.props);\n        this.canvasContext.beginPath();\n        this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);\n        this.canvasContext.closePath();\n        this.canvasContext.clip();\n        this.renderFrame(this.renderedFrame, true);\n    };\n    CanvasRendererBase.prototype.destroy = function() {\n        if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {\n            this.animationItem.wrapper.innerText = \"\";\n        }\n        var i;\n        var len = this.layers ? this.layers.length : 0;\n        for(i = len - 1; i >= 0; i -= 1){\n            if (this.elements[i] && this.elements[i].destroy) {\n                this.elements[i].destroy();\n            }\n        }\n        this.elements.length = 0;\n        this.globalData.canvasContext = null;\n        this.animationItem.container = null;\n        this.destroyed = true;\n    };\n    CanvasRendererBase.prototype.renderFrame = function(num, forceRender) {\n        if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) {\n            return;\n        }\n        this.renderedFrame = num;\n        this.globalData.frameNum = num - this.animationItem._isFirstFrame;\n        this.globalData.frameId += 1;\n        this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;\n        this.globalData.projectInterface.currentFrame = num; // console.log('--------');\n        // console.log('NEW: ',num);\n        var i;\n        var len = this.layers.length;\n        if (!this.completeLayers) {\n            this.checkLayers(num);\n        }\n        for(i = len - 1; i >= 0; i -= 1){\n            if (this.completeLayers || this.elements[i]) {\n                this.elements[i].prepareFrame(num - this.layers[i].st);\n            }\n        }\n        if (this.globalData._mdf) {\n            if (this.renderConfig.clearCanvas === true) {\n                this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);\n            } else {\n                this.save();\n            }\n            for(i = len - 1; i >= 0; i -= 1){\n                if (this.completeLayers || this.elements[i]) {\n                    this.elements[i].renderFrame();\n                }\n            }\n            if (this.renderConfig.clearCanvas !== true) {\n                this.restore();\n            }\n        }\n    };\n    CanvasRendererBase.prototype.buildItem = function(pos) {\n        var elements = this.elements;\n        if (elements[pos] || this.layers[pos].ty === 99) {\n            return;\n        }\n        var element = this.createItem(this.layers[pos], this, this.globalData);\n        elements[pos] = element;\n        element.initExpressions();\n    /* if(this.layers[pos].ty === 0){\r\n          element.resize(this.globalData.transformCanvas);\r\n      } */ };\n    CanvasRendererBase.prototype.checkPendingElements = function() {\n        while(this.pendingElements.length){\n            var element = this.pendingElements.pop();\n            element.checkParenting();\n        }\n    };\n    CanvasRendererBase.prototype.hide = function() {\n        this.animationItem.container.style.display = \"none\";\n    };\n    CanvasRendererBase.prototype.show = function() {\n        this.animationItem.container.style.display = \"block\";\n    };\n    function CanvasContext() {\n        this.opacity = -1;\n        this.transform = createTypedArray(\"float32\", 16);\n        this.fillStyle = \"\";\n        this.strokeStyle = \"\";\n        this.lineWidth = \"\";\n        this.lineCap = \"\";\n        this.lineJoin = \"\";\n        this.miterLimit = \"\";\n        this.id = Math.random();\n    }\n    function CVContextData() {\n        this.stack = [];\n        this.cArrPos = 0;\n        this.cTr = new Matrix();\n        var i;\n        var len = 15;\n        for(i = 0; i < len; i += 1){\n            var canvasContext = new CanvasContext();\n            this.stack[i] = canvasContext;\n        }\n        this._length = len;\n        this.nativeContext = null;\n        this.transformMat = new Matrix();\n        this.currentOpacity = 1; //\n        this.currentFillStyle = \"\";\n        this.appliedFillStyle = \"\"; //\n        this.currentStrokeStyle = \"\";\n        this.appliedStrokeStyle = \"\"; //\n        this.currentLineWidth = \"\";\n        this.appliedLineWidth = \"\"; //\n        this.currentLineCap = \"\";\n        this.appliedLineCap = \"\"; //\n        this.currentLineJoin = \"\";\n        this.appliedLineJoin = \"\"; //\n        this.appliedMiterLimit = \"\";\n        this.currentMiterLimit = \"\";\n    }\n    CVContextData.prototype.duplicate = function() {\n        var newLength = this._length * 2;\n        var i = 0;\n        for(i = this._length; i < newLength; i += 1){\n            this.stack[i] = new CanvasContext();\n        }\n        this._length = newLength;\n    };\n    CVContextData.prototype.reset = function() {\n        this.cArrPos = 0;\n        this.cTr.reset();\n        this.stack[this.cArrPos].opacity = 1;\n    };\n    CVContextData.prototype.restore = function(forceRestore) {\n        this.cArrPos -= 1;\n        var currentContext = this.stack[this.cArrPos];\n        var transform = currentContext.transform;\n        var i;\n        var arr = this.cTr.props;\n        for(i = 0; i < 16; i += 1){\n            arr[i] = transform[i];\n        }\n        if (forceRestore) {\n            this.nativeContext.restore();\n            var prevStack = this.stack[this.cArrPos + 1];\n            this.appliedFillStyle = prevStack.fillStyle;\n            this.appliedStrokeStyle = prevStack.strokeStyle;\n            this.appliedLineWidth = prevStack.lineWidth;\n            this.appliedLineCap = prevStack.lineCap;\n            this.appliedLineJoin = prevStack.lineJoin;\n            this.appliedMiterLimit = prevStack.miterLimit;\n        }\n        this.nativeContext.setTransform(transform[0], transform[1], transform[4], transform[5], transform[12], transform[13]);\n        if (forceRestore || currentContext.opacity !== -1 && this.currentOpacity !== currentContext.opacity) {\n            this.nativeContext.globalAlpha = currentContext.opacity;\n            this.currentOpacity = currentContext.opacity;\n        }\n        this.currentFillStyle = currentContext.fillStyle;\n        this.currentStrokeStyle = currentContext.strokeStyle;\n        this.currentLineWidth = currentContext.lineWidth;\n        this.currentLineCap = currentContext.lineCap;\n        this.currentLineJoin = currentContext.lineJoin;\n        this.currentMiterLimit = currentContext.miterLimit;\n    };\n    CVContextData.prototype.save = function(saveOnNativeFlag) {\n        if (saveOnNativeFlag) {\n            this.nativeContext.save();\n        }\n        var props = this.cTr.props;\n        if (this._length <= this.cArrPos) {\n            this.duplicate();\n        }\n        var currentStack = this.stack[this.cArrPos];\n        var i;\n        for(i = 0; i < 16; i += 1){\n            currentStack.transform[i] = props[i];\n        }\n        this.cArrPos += 1;\n        var newStack = this.stack[this.cArrPos];\n        newStack.opacity = currentStack.opacity;\n        newStack.fillStyle = currentStack.fillStyle;\n        newStack.strokeStyle = currentStack.strokeStyle;\n        newStack.lineWidth = currentStack.lineWidth;\n        newStack.lineCap = currentStack.lineCap;\n        newStack.lineJoin = currentStack.lineJoin;\n        newStack.miterLimit = currentStack.miterLimit;\n    };\n    CVContextData.prototype.setOpacity = function(value) {\n        this.stack[this.cArrPos].opacity = value;\n    };\n    CVContextData.prototype.setContext = function(value) {\n        this.nativeContext = value;\n    };\n    CVContextData.prototype.fillStyle = function(value) {\n        if (this.stack[this.cArrPos].fillStyle !== value) {\n            this.currentFillStyle = value;\n            this.stack[this.cArrPos].fillStyle = value;\n        }\n    };\n    CVContextData.prototype.strokeStyle = function(value) {\n        if (this.stack[this.cArrPos].strokeStyle !== value) {\n            this.currentStrokeStyle = value;\n            this.stack[this.cArrPos].strokeStyle = value;\n        }\n    };\n    CVContextData.prototype.lineWidth = function(value) {\n        if (this.stack[this.cArrPos].lineWidth !== value) {\n            this.currentLineWidth = value;\n            this.stack[this.cArrPos].lineWidth = value;\n        }\n    };\n    CVContextData.prototype.lineCap = function(value) {\n        if (this.stack[this.cArrPos].lineCap !== value) {\n            this.currentLineCap = value;\n            this.stack[this.cArrPos].lineCap = value;\n        }\n    };\n    CVContextData.prototype.lineJoin = function(value) {\n        if (this.stack[this.cArrPos].lineJoin !== value) {\n            this.currentLineJoin = value;\n            this.stack[this.cArrPos].lineJoin = value;\n        }\n    };\n    CVContextData.prototype.miterLimit = function(value) {\n        if (this.stack[this.cArrPos].miterLimit !== value) {\n            this.currentMiterLimit = value;\n            this.stack[this.cArrPos].miterLimit = value;\n        }\n    };\n    CVContextData.prototype.transform = function(props) {\n        this.transformMat.cloneFromProps(props); // Taking the last transform value from the stored stack of transforms\n        var currentTransform = this.cTr; // Applying the last transform value after the new transform to respect the order of transformations\n        this.transformMat.multiply(currentTransform); // Storing the new transformed value in the stored transform\n        currentTransform.cloneFromProps(this.transformMat.props);\n        var trProps = currentTransform.props; // Applying the new transform to the canvas\n        this.nativeContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);\n    };\n    CVContextData.prototype.opacity = function(op) {\n        var currentOpacity = this.stack[this.cArrPos].opacity;\n        currentOpacity *= op < 0 ? 0 : op;\n        if (this.stack[this.cArrPos].opacity !== currentOpacity) {\n            if (this.currentOpacity !== op) {\n                this.nativeContext.globalAlpha = op;\n                this.currentOpacity = op;\n            }\n            this.stack[this.cArrPos].opacity = currentOpacity;\n        }\n    };\n    CVContextData.prototype.fill = function(rule) {\n        if (this.appliedFillStyle !== this.currentFillStyle) {\n            this.appliedFillStyle = this.currentFillStyle;\n            this.nativeContext.fillStyle = this.appliedFillStyle;\n        }\n        this.nativeContext.fill(rule);\n    };\n    CVContextData.prototype.fillRect = function(x, y, w, h) {\n        if (this.appliedFillStyle !== this.currentFillStyle) {\n            this.appliedFillStyle = this.currentFillStyle;\n            this.nativeContext.fillStyle = this.appliedFillStyle;\n        }\n        this.nativeContext.fillRect(x, y, w, h);\n    };\n    CVContextData.prototype.stroke = function() {\n        if (this.appliedStrokeStyle !== this.currentStrokeStyle) {\n            this.appliedStrokeStyle = this.currentStrokeStyle;\n            this.nativeContext.strokeStyle = this.appliedStrokeStyle;\n        }\n        if (this.appliedLineWidth !== this.currentLineWidth) {\n            this.appliedLineWidth = this.currentLineWidth;\n            this.nativeContext.lineWidth = this.appliedLineWidth;\n        }\n        if (this.appliedLineCap !== this.currentLineCap) {\n            this.appliedLineCap = this.currentLineCap;\n            this.nativeContext.lineCap = this.appliedLineCap;\n        }\n        if (this.appliedLineJoin !== this.currentLineJoin) {\n            this.appliedLineJoin = this.currentLineJoin;\n            this.nativeContext.lineJoin = this.appliedLineJoin;\n        }\n        if (this.appliedMiterLimit !== this.currentMiterLimit) {\n            this.appliedMiterLimit = this.currentMiterLimit;\n            this.nativeContext.miterLimit = this.appliedMiterLimit;\n        }\n        this.nativeContext.stroke();\n    };\n    function CVCompElement(data, globalData, comp) {\n        this.completeLayers = false;\n        this.layers = data.layers;\n        this.pendingElements = [];\n        this.elements = createSizedArray(this.layers.length);\n        this.initElement(data, globalData, comp);\n        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n            _placeholder: true\n        };\n    }\n    extendPrototype([\n        CanvasRendererBase,\n        ICompElement,\n        CVBaseElement\n    ], CVCompElement);\n    CVCompElement.prototype.renderInnerContent = function() {\n        var ctx = this.canvasContext;\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(this.data.w, 0);\n        ctx.lineTo(this.data.w, this.data.h);\n        ctx.lineTo(0, this.data.h);\n        ctx.lineTo(0, 0);\n        ctx.clip();\n        var i;\n        var len = this.layers.length;\n        for(i = len - 1; i >= 0; i -= 1){\n            if (this.completeLayers || this.elements[i]) {\n                this.elements[i].renderFrame();\n            }\n        }\n    };\n    CVCompElement.prototype.destroy = function() {\n        var i;\n        var len = this.layers.length;\n        for(i = len - 1; i >= 0; i -= 1){\n            if (this.elements[i]) {\n                this.elements[i].destroy();\n            }\n        }\n        this.layers = null;\n        this.elements = null;\n    };\n    CVCompElement.prototype.createComp = function(data) {\n        return new CVCompElement(data, this.globalData, this);\n    };\n    function CanvasRenderer(animationItem, config) {\n        this.animationItem = animationItem;\n        this.renderConfig = {\n            clearCanvas: config && config.clearCanvas !== undefined ? config.clearCanvas : true,\n            context: config && config.context || null,\n            progressiveLoad: config && config.progressiveLoad || false,\n            preserveAspectRatio: config && config.preserveAspectRatio || \"xMidYMid meet\",\n            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || \"xMidYMid slice\",\n            contentVisibility: config && config.contentVisibility || \"visible\",\n            className: config && config.className || \"\",\n            id: config && config.id || \"\",\n            runExpressions: !config || config.runExpressions === undefined || config.runExpressions\n        };\n        this.renderConfig.dpr = config && config.dpr || 1;\n        if (this.animationItem.wrapper) {\n            this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;\n        }\n        this.renderedFrame = -1;\n        this.globalData = {\n            frameNum: -1,\n            _mdf: false,\n            renderConfig: this.renderConfig,\n            currentGlobalAlpha: -1\n        };\n        this.contextData = new CVContextData();\n        this.elements = [];\n        this.pendingElements = [];\n        this.transformMat = new Matrix();\n        this.completeLayers = false;\n        this.rendererType = \"canvas\";\n        if (this.renderConfig.clearCanvas) {\n            this.ctxTransform = this.contextData.transform.bind(this.contextData);\n            this.ctxOpacity = this.contextData.opacity.bind(this.contextData);\n            this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData);\n            this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData);\n            this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData);\n            this.ctxLineCap = this.contextData.lineCap.bind(this.contextData);\n            this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData);\n            this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData);\n            this.ctxFill = this.contextData.fill.bind(this.contextData);\n            this.ctxFillRect = this.contextData.fillRect.bind(this.contextData);\n            this.ctxStroke = this.contextData.stroke.bind(this.contextData);\n            this.save = this.contextData.save.bind(this.contextData);\n        }\n    }\n    extendPrototype([\n        CanvasRendererBase\n    ], CanvasRenderer);\n    CanvasRenderer.prototype.createComp = function(data) {\n        return new CVCompElement(data, this.globalData, this);\n    };\n    function HBaseElement() {}\n    HBaseElement.prototype = {\n        checkBlendMode: function checkBlendMode() {},\n        initRendererElement: function initRendererElement() {\n            this.baseElement = createTag(this.data.tg || \"div\");\n            if (this.data.hasMask) {\n                this.svgElement = createNS(\"svg\");\n                this.layerElement = createNS(\"g\");\n                this.maskedElement = this.layerElement;\n                this.svgElement.appendChild(this.layerElement);\n                this.baseElement.appendChild(this.svgElement);\n            } else {\n                this.layerElement = this.baseElement;\n            }\n            styleDiv(this.baseElement);\n        },\n        createContainerElements: function createContainerElements() {\n            this.renderableEffectsManager = new CVEffects(this);\n            this.transformedElement = this.baseElement;\n            this.maskedElement = this.layerElement;\n            if (this.data.ln) {\n                this.layerElement.setAttribute(\"id\", this.data.ln);\n            }\n            if (this.data.cl) {\n                this.layerElement.setAttribute(\"class\", this.data.cl);\n            }\n            if (this.data.bm !== 0) {\n                this.setBlendMode();\n            }\n        },\n        renderElement: function renderElement() {\n            var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};\n            if (this.finalTransform._matMdf) {\n                var matrixValue = this.finalTransform.mat.toCSS();\n                transformedElementStyle.transform = matrixValue;\n                transformedElementStyle.webkitTransform = matrixValue;\n            }\n            if (this.finalTransform._opMdf) {\n                transformedElementStyle.opacity = this.finalTransform.mProp.o.v;\n            }\n        },\n        renderFrame: function renderFrame() {\n            // If it is exported as hidden (data.hd === true) no need to render\n            // If it is not visible no need to render\n            if (this.data.hd || this.hidden) {\n                return;\n            }\n            this.renderTransform();\n            this.renderRenderable();\n            this.renderElement();\n            this.renderInnerContent();\n            if (this._isFirstFrame) {\n                this._isFirstFrame = false;\n            }\n        },\n        destroy: function destroy() {\n            this.layerElement = null;\n            this.transformedElement = null;\n            if (this.matteElement) {\n                this.matteElement = null;\n            }\n            if (this.maskManager) {\n                this.maskManager.destroy();\n                this.maskManager = null;\n            }\n        },\n        createRenderableComponents: function createRenderableComponents() {\n            this.maskManager = new MaskElement(this.data, this, this.globalData);\n        },\n        addEffects: function addEffects() {},\n        setMatte: function setMatte() {}\n    };\n    HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;\n    HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;\n    HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;\n    function HSolidElement(data, globalData, comp) {\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        HBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableDOMElement\n    ], HSolidElement);\n    HSolidElement.prototype.createContent = function() {\n        var rect;\n        if (this.data.hasMask) {\n            rect = createNS(\"rect\");\n            rect.setAttribute(\"width\", this.data.sw);\n            rect.setAttribute(\"height\", this.data.sh);\n            rect.setAttribute(\"fill\", this.data.sc);\n            this.svgElement.setAttribute(\"width\", this.data.sw);\n            this.svgElement.setAttribute(\"height\", this.data.sh);\n        } else {\n            rect = createTag(\"div\");\n            rect.style.width = this.data.sw + \"px\";\n            rect.style.height = this.data.sh + \"px\";\n            rect.style.backgroundColor = this.data.sc;\n        }\n        this.layerElement.appendChild(rect);\n    };\n    function HShapeElement(data, globalData, comp) {\n        // List of drawable elements\n        this.shapes = []; // Full shape data\n        this.shapesData = data.shapes; // List of styles that will be applied to shapes\n        this.stylesList = []; // List of modifiers that will be applied to shapes\n        this.shapeModifiers = []; // List of items in shape tree\n        this.itemsData = []; // List of items in previous shape tree\n        this.processedElements = []; // List of animated components\n        this.animatedContents = [];\n        this.shapesContainer = createNS(\"g\");\n        this.initElement(data, globalData, comp); // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\n        // List of elements that have been created\n        this.prevViewData = [];\n        this.currentBBox = {\n            x: 999999,\n            y: -999999,\n            h: 0,\n            w: 0\n        };\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        HSolidElement,\n        SVGShapeElement,\n        HBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableElement\n    ], HShapeElement);\n    HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;\n    HShapeElement.prototype.createContent = function() {\n        var cont;\n        this.baseElement.style.fontSize = 0;\n        if (this.data.hasMask) {\n            this.layerElement.appendChild(this.shapesContainer);\n            cont = this.svgElement;\n        } else {\n            cont = createNS(\"svg\");\n            var size = this.comp.data ? this.comp.data : this.globalData.compSize;\n            cont.setAttribute(\"width\", size.w);\n            cont.setAttribute(\"height\", size.h);\n            cont.appendChild(this.shapesContainer);\n            this.layerElement.appendChild(cont);\n        }\n        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);\n        this.filterUniqueShapes();\n        this.shapeCont = cont;\n    };\n    HShapeElement.prototype.getTransformedPoint = function(transformers, point) {\n        var i;\n        var len = transformers.length;\n        for(i = 0; i < len; i += 1){\n            point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);\n        }\n        return point;\n    };\n    HShapeElement.prototype.calculateShapeBoundingBox = function(item, boundingBox) {\n        var shape = item.sh.v;\n        var transformers = item.transformers;\n        var i;\n        var len = shape._length;\n        var vPoint;\n        var oPoint;\n        var nextIPoint;\n        var nextVPoint;\n        if (len <= 1) {\n            return;\n        }\n        for(i = 0; i < len - 1; i += 1){\n            vPoint = this.getTransformedPoint(transformers, shape.v[i]);\n            oPoint = this.getTransformedPoint(transformers, shape.o[i]);\n            nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);\n            nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);\n            this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);\n        }\n        if (shape.c) {\n            vPoint = this.getTransformedPoint(transformers, shape.v[i]);\n            oPoint = this.getTransformedPoint(transformers, shape.o[i]);\n            nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);\n            nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);\n            this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);\n        }\n    };\n    HShapeElement.prototype.checkBounds = function(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {\n        this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);\n        var bounds = this.shapeBoundingBox;\n        boundingBox.x = bmMin(bounds.left, boundingBox.x);\n        boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);\n        boundingBox.y = bmMin(bounds.top, boundingBox.y);\n        boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);\n    };\n    HShapeElement.prototype.shapeBoundingBox = {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n    };\n    HShapeElement.prototype.tempBoundingBox = {\n        x: 0,\n        xMax: 0,\n        y: 0,\n        yMax: 0,\n        width: 0,\n        height: 0\n    };\n    HShapeElement.prototype.getBoundsOfCurve = function(p0, p1, p2, p3) {\n        var bounds = [\n            [\n                p0[0],\n                p3[0]\n            ],\n            [\n                p0[1],\n                p3[1]\n            ]\n        ];\n        for(var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i){\n            // eslint-disable-line no-plusplus\n            b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\n            a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\n            c = 3 * p1[i] - 3 * p0[i];\n            b |= 0; // eslint-disable-line no-bitwise\n            a |= 0; // eslint-disable-line no-bitwise\n            c |= 0; // eslint-disable-line no-bitwise\n            if (a === 0 && b === 0) {} else if (a === 0) {\n                t = -c / b;\n                if (t > 0 && t < 1) {\n                    bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));\n                }\n            } else {\n                b2ac = b * b - 4 * c * a;\n                if (b2ac >= 0) {\n                    t1 = (-b + bmSqrt(b2ac)) / (2 * a);\n                    if (t1 > 0 && t1 < 1) bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));\n                    t2 = (-b - bmSqrt(b2ac)) / (2 * a);\n                    if (t2 > 0 && t2 < 1) bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));\n                }\n            }\n        }\n        this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);\n        this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);\n        this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);\n        this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);\n    };\n    HShapeElement.prototype.calculateF = function(t, p0, p1, p2, p3, i) {\n        return bmPow(1 - t, 3) * p0[i] + 3 * bmPow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * bmPow(t, 2) * p2[i] + bmPow(t, 3) * p3[i];\n    };\n    HShapeElement.prototype.calculateBoundingBox = function(itemsData, boundingBox) {\n        var i;\n        var len = itemsData.length;\n        for(i = 0; i < len; i += 1){\n            if (itemsData[i] && itemsData[i].sh) {\n                this.calculateShapeBoundingBox(itemsData[i], boundingBox);\n            } else if (itemsData[i] && itemsData[i].it) {\n                this.calculateBoundingBox(itemsData[i].it, boundingBox);\n            } else if (itemsData[i] && itemsData[i].style && itemsData[i].w) {\n                this.expandStrokeBoundingBox(itemsData[i].w, boundingBox);\n            }\n        }\n    };\n    HShapeElement.prototype.expandStrokeBoundingBox = function(widthProperty, boundingBox) {\n        var width = 0;\n        if (widthProperty.keyframes) {\n            for(var i = 0; i < widthProperty.keyframes.length; i += 1){\n                var kfw = widthProperty.keyframes[i].s;\n                if (kfw > width) {\n                    width = kfw;\n                }\n            }\n            width *= widthProperty.mult;\n        } else {\n            width = widthProperty.v * widthProperty.mult;\n        }\n        boundingBox.x -= width;\n        boundingBox.xMax += width;\n        boundingBox.y -= width;\n        boundingBox.yMax += width;\n    };\n    HShapeElement.prototype.currentBoxContains = function(box) {\n        return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;\n    };\n    HShapeElement.prototype.renderInnerContent = function() {\n        this._renderShapeFrame();\n        if (!this.hidden && (this._isFirstFrame || this._mdf)) {\n            var tempBoundingBox = this.tempBoundingBox;\n            var max = 999999;\n            tempBoundingBox.x = max;\n            tempBoundingBox.xMax = -max;\n            tempBoundingBox.y = max;\n            tempBoundingBox.yMax = -max;\n            this.calculateBoundingBox(this.itemsData, tempBoundingBox);\n            tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;\n            tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y; // var tempBoundingBox = this.shapeCont.getBBox();\n            if (this.currentBoxContains(tempBoundingBox)) {\n                return;\n            }\n            var changed = false;\n            if (this.currentBBox.w !== tempBoundingBox.width) {\n                this.currentBBox.w = tempBoundingBox.width;\n                this.shapeCont.setAttribute(\"width\", tempBoundingBox.width);\n                changed = true;\n            }\n            if (this.currentBBox.h !== tempBoundingBox.height) {\n                this.currentBBox.h = tempBoundingBox.height;\n                this.shapeCont.setAttribute(\"height\", tempBoundingBox.height);\n                changed = true;\n            }\n            if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {\n                this.currentBBox.w = tempBoundingBox.width;\n                this.currentBBox.h = tempBoundingBox.height;\n                this.currentBBox.x = tempBoundingBox.x;\n                this.currentBBox.y = tempBoundingBox.y;\n                this.shapeCont.setAttribute(\"viewBox\", this.currentBBox.x + \" \" + this.currentBBox.y + \" \" + this.currentBBox.w + \" \" + this.currentBBox.h);\n                var shapeStyle = this.shapeCont.style;\n                var shapeTransform = \"translate(\" + this.currentBBox.x + \"px,\" + this.currentBBox.y + \"px)\";\n                shapeStyle.transform = shapeTransform;\n                shapeStyle.webkitTransform = shapeTransform;\n            }\n        }\n    };\n    function HTextElement(data, globalData, comp) {\n        this.textSpans = [];\n        this.textPaths = [];\n        this.currentBBox = {\n            x: 999999,\n            y: -999999,\n            h: 0,\n            w: 0\n        };\n        this.renderType = \"svg\";\n        this.isMasked = false;\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        HBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableDOMElement,\n        ITextElement\n    ], HTextElement);\n    HTextElement.prototype.createContent = function() {\n        this.isMasked = this.checkMasks();\n        if (this.isMasked) {\n            this.renderType = \"svg\";\n            this.compW = this.comp.data.w;\n            this.compH = this.comp.data.h;\n            this.svgElement.setAttribute(\"width\", this.compW);\n            this.svgElement.setAttribute(\"height\", this.compH);\n            var g = createNS(\"g\");\n            this.maskedElement.appendChild(g);\n            this.innerElem = g;\n        } else {\n            this.renderType = \"html\";\n            this.innerElem = this.layerElement;\n        }\n        this.checkParenting();\n    };\n    HTextElement.prototype.buildNewText = function() {\n        var documentData = this.textProperty.currentData;\n        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);\n        var innerElemStyle = this.innerElem.style;\n        var textColor = documentData.fc ? this.buildColor(documentData.fc) : \"rgba(0,0,0,0)\";\n        innerElemStyle.fill = textColor;\n        innerElemStyle.color = textColor;\n        if (documentData.sc) {\n            innerElemStyle.stroke = this.buildColor(documentData.sc);\n            innerElemStyle.strokeWidth = documentData.sw + \"px\";\n        }\n        var fontData = this.globalData.fontManager.getFontByName(documentData.f);\n        if (!this.globalData.fontManager.chars) {\n            innerElemStyle.fontSize = documentData.finalSize + \"px\";\n            innerElemStyle.lineHeight = documentData.finalSize + \"px\";\n            if (fontData.fClass) {\n                this.innerElem.className = fontData.fClass;\n            } else {\n                innerElemStyle.fontFamily = fontData.fFamily;\n                var fWeight = documentData.fWeight;\n                var fStyle = documentData.fStyle;\n                innerElemStyle.fontStyle = fStyle;\n                innerElemStyle.fontWeight = fWeight;\n            }\n        }\n        var i;\n        var len;\n        var letters = documentData.l;\n        len = letters.length;\n        var tSpan;\n        var tParent;\n        var tCont;\n        var matrixHelper = this.mHelper;\n        var shapes;\n        var shapeStr = \"\";\n        var cnt = 0;\n        for(i = 0; i < len; i += 1){\n            if (this.globalData.fontManager.chars) {\n                if (!this.textPaths[cnt]) {\n                    tSpan = createNS(\"path\");\n                    tSpan.setAttribute(\"stroke-linecap\", lineCapEnum[1]);\n                    tSpan.setAttribute(\"stroke-linejoin\", lineJoinEnum[2]);\n                    tSpan.setAttribute(\"stroke-miterlimit\", \"4\");\n                } else {\n                    tSpan = this.textPaths[cnt];\n                }\n                if (!this.isMasked) {\n                    if (this.textSpans[cnt]) {\n                        tParent = this.textSpans[cnt];\n                        tCont = tParent.children[0];\n                    } else {\n                        tParent = createTag(\"div\");\n                        tParent.style.lineHeight = 0;\n                        tCont = createNS(\"svg\");\n                        tCont.appendChild(tSpan);\n                        styleDiv(tParent);\n                    }\n                }\n            } else if (!this.isMasked) {\n                if (this.textSpans[cnt]) {\n                    tParent = this.textSpans[cnt];\n                    tSpan = this.textPaths[cnt];\n                } else {\n                    tParent = createTag(\"span\");\n                    styleDiv(tParent);\n                    tSpan = createTag(\"span\");\n                    styleDiv(tSpan);\n                    tParent.appendChild(tSpan);\n                }\n            } else {\n                tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS(\"text\");\n            } // tSpan.setAttribute('visibility', 'hidden');\n            if (this.globalData.fontManager.chars) {\n                var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);\n                var shapeData;\n                if (charData) {\n                    shapeData = charData.data;\n                } else {\n                    shapeData = null;\n                }\n                matrixHelper.reset();\n                if (shapeData && shapeData.shapes && shapeData.shapes.length) {\n                    shapes = shapeData.shapes[0].it;\n                    matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);\n                    shapeStr = this.createPathShape(matrixHelper, shapes);\n                    tSpan.setAttribute(\"d\", shapeStr);\n                }\n                if (!this.isMasked) {\n                    this.innerElem.appendChild(tParent);\n                    if (shapeData && shapeData.shapes) {\n                        // document.body.appendChild is needed to get exact measure of shape\n                        document.body.appendChild(tCont);\n                        var boundingBox = tCont.getBBox();\n                        tCont.setAttribute(\"width\", boundingBox.width + 2);\n                        tCont.setAttribute(\"height\", boundingBox.height + 2);\n                        tCont.setAttribute(\"viewBox\", boundingBox.x - 1 + \" \" + (boundingBox.y - 1) + \" \" + (boundingBox.width + 2) + \" \" + (boundingBox.height + 2));\n                        var tContStyle = tCont.style;\n                        var tContTranslation = \"translate(\" + (boundingBox.x - 1) + \"px,\" + (boundingBox.y - 1) + \"px)\";\n                        tContStyle.transform = tContTranslation;\n                        tContStyle.webkitTransform = tContTranslation;\n                        letters[i].yOffset = boundingBox.y - 1;\n                    } else {\n                        tCont.setAttribute(\"width\", 1);\n                        tCont.setAttribute(\"height\", 1);\n                    }\n                    tParent.appendChild(tCont);\n                } else {\n                    this.innerElem.appendChild(tSpan);\n                }\n            } else {\n                tSpan.textContent = letters[i].val;\n                tSpan.setAttributeNS(\"http://www.w3.org/XML/1998/namespace\", \"xml:space\", \"preserve\");\n                if (!this.isMasked) {\n                    this.innerElem.appendChild(tParent); //\n                    var tStyle = tSpan.style;\n                    var tSpanTranslation = \"translate3d(0,\" + -documentData.finalSize / 1.2 + \"px,0)\";\n                    tStyle.transform = tSpanTranslation;\n                    tStyle.webkitTransform = tSpanTranslation;\n                } else {\n                    this.innerElem.appendChild(tSpan);\n                }\n            } //\n            if (!this.isMasked) {\n                this.textSpans[cnt] = tParent;\n            } else {\n                this.textSpans[cnt] = tSpan;\n            }\n            this.textSpans[cnt].style.display = \"block\";\n            this.textPaths[cnt] = tSpan;\n            cnt += 1;\n        }\n        while(cnt < this.textSpans.length){\n            this.textSpans[cnt].style.display = \"none\";\n            cnt += 1;\n        }\n    };\n    HTextElement.prototype.renderInnerContent = function() {\n        this.validateText();\n        var svgStyle;\n        if (this.data.singleShape) {\n            if (!this._isFirstFrame && !this.lettersChangedFlag) {\n                return;\n            }\n            if (this.isMasked && this.finalTransform._matMdf) {\n                // Todo Benchmark if using this is better than getBBox\n                this.svgElement.setAttribute(\"viewBox\", -this.finalTransform.mProp.p.v[0] + \" \" + -this.finalTransform.mProp.p.v[1] + \" \" + this.compW + \" \" + this.compH);\n                svgStyle = this.svgElement.style;\n                var translation = \"translate(\" + -this.finalTransform.mProp.p.v[0] + \"px,\" + -this.finalTransform.mProp.p.v[1] + \"px)\";\n                svgStyle.transform = translation;\n                svgStyle.webkitTransform = translation;\n            }\n        }\n        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);\n        if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {\n            return;\n        }\n        var i;\n        var len;\n        var count = 0;\n        var renderedLetters = this.textAnimator.renderedLetters;\n        var letters = this.textProperty.currentData.l;\n        len = letters.length;\n        var renderedLetter;\n        var textSpan;\n        var textPath;\n        for(i = 0; i < len; i += 1){\n            if (letters[i].n) {\n                count += 1;\n            } else {\n                textSpan = this.textSpans[i];\n                textPath = this.textPaths[i];\n                renderedLetter = renderedLetters[count];\n                count += 1;\n                if (renderedLetter._mdf.m) {\n                    if (!this.isMasked) {\n                        textSpan.style.webkitTransform = renderedLetter.m;\n                        textSpan.style.transform = renderedLetter.m;\n                    } else {\n                        textSpan.setAttribute(\"transform\", renderedLetter.m);\n                    }\n                } /// /textSpan.setAttribute('opacity',renderedLetter.o);\n                textSpan.style.opacity = renderedLetter.o;\n                if (renderedLetter.sw && renderedLetter._mdf.sw) {\n                    textPath.setAttribute(\"stroke-width\", renderedLetter.sw);\n                }\n                if (renderedLetter.sc && renderedLetter._mdf.sc) {\n                    textPath.setAttribute(\"stroke\", renderedLetter.sc);\n                }\n                if (renderedLetter.fc && renderedLetter._mdf.fc) {\n                    textPath.setAttribute(\"fill\", renderedLetter.fc);\n                    textPath.style.color = renderedLetter.fc;\n                }\n            }\n        }\n        if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {\n            var boundingBox = this.innerElem.getBBox();\n            if (this.currentBBox.w !== boundingBox.width) {\n                this.currentBBox.w = boundingBox.width;\n                this.svgElement.setAttribute(\"width\", boundingBox.width);\n            }\n            if (this.currentBBox.h !== boundingBox.height) {\n                this.currentBBox.h = boundingBox.height;\n                this.svgElement.setAttribute(\"height\", boundingBox.height);\n            }\n            var margin = 1;\n            if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {\n                this.currentBBox.w = boundingBox.width + margin * 2;\n                this.currentBBox.h = boundingBox.height + margin * 2;\n                this.currentBBox.x = boundingBox.x - margin;\n                this.currentBBox.y = boundingBox.y - margin;\n                this.svgElement.setAttribute(\"viewBox\", this.currentBBox.x + \" \" + this.currentBBox.y + \" \" + this.currentBBox.w + \" \" + this.currentBBox.h);\n                svgStyle = this.svgElement.style;\n                var svgTransform = \"translate(\" + this.currentBBox.x + \"px,\" + this.currentBBox.y + \"px)\";\n                svgStyle.transform = svgTransform;\n                svgStyle.webkitTransform = svgTransform;\n            }\n        }\n    };\n    function HCameraElement(data, globalData, comp) {\n        this.initFrame();\n        this.initBaseData(data, globalData, comp);\n        this.initHierarchy();\n        var getProp = PropertyFactory.getProp;\n        this.pe = getProp(this, data.pe, 0, 0, this);\n        if (data.ks.p.s) {\n            this.px = getProp(this, data.ks.p.x, 1, 0, this);\n            this.py = getProp(this, data.ks.p.y, 1, 0, this);\n            this.pz = getProp(this, data.ks.p.z, 1, 0, this);\n        } else {\n            this.p = getProp(this, data.ks.p, 1, 0, this);\n        }\n        if (data.ks.a) {\n            this.a = getProp(this, data.ks.a, 1, 0, this);\n        }\n        if (data.ks.or.k.length && data.ks.or.k[0].to) {\n            var i;\n            var len = data.ks.or.k.length;\n            for(i = 0; i < len; i += 1){\n                data.ks.or.k[i].to = null;\n                data.ks.or.k[i].ti = null;\n            }\n        }\n        this.or = getProp(this, data.ks.or, 1, degToRads, this);\n        this.or.sh = true;\n        this.rx = getProp(this, data.ks.rx, 0, degToRads, this);\n        this.ry = getProp(this, data.ks.ry, 0, degToRads, this);\n        this.rz = getProp(this, data.ks.rz, 0, degToRads, this);\n        this.mat = new Matrix();\n        this._prevMat = new Matrix();\n        this._isFirstFrame = true; // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.\n        this.finalTransform = {\n            mProp: this\n        };\n    }\n    extendPrototype([\n        BaseElement,\n        FrameElement,\n        HierarchyElement\n    ], HCameraElement);\n    HCameraElement.prototype.setup = function() {\n        var i;\n        var len = this.comp.threeDElements.length;\n        var comp;\n        var perspectiveStyle;\n        var containerStyle;\n        for(i = 0; i < len; i += 1){\n            // [perspectiveElem,container]\n            comp = this.comp.threeDElements[i];\n            if (comp.type === \"3d\") {\n                perspectiveStyle = comp.perspectiveElem.style;\n                containerStyle = comp.container.style;\n                var perspective = this.pe.v + \"px\";\n                var origin = \"0px 0px 0px\";\n                var matrix = \"matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)\";\n                perspectiveStyle.perspective = perspective;\n                perspectiveStyle.webkitPerspective = perspective;\n                containerStyle.transformOrigin = origin;\n                containerStyle.mozTransformOrigin = origin;\n                containerStyle.webkitTransformOrigin = origin;\n                perspectiveStyle.transform = matrix;\n                perspectiveStyle.webkitTransform = matrix;\n            }\n        }\n    };\n    HCameraElement.prototype.createElements = function() {};\n    HCameraElement.prototype.hide = function() {};\n    HCameraElement.prototype.renderFrame = function() {\n        var _mdf = this._isFirstFrame;\n        var i;\n        var len;\n        if (this.hierarchy) {\n            len = this.hierarchy.length;\n            for(i = 0; i < len; i += 1){\n                _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;\n            }\n        }\n        if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {\n            this.mat.reset();\n            if (this.hierarchy) {\n                len = this.hierarchy.length - 1;\n                for(i = len; i >= 0; i -= 1){\n                    var mTransf = this.hierarchy[i].finalTransform.mProp;\n                    this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);\n                    this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);\n                    this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);\n                    this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);\n                    this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);\n                }\n            }\n            if (this.p) {\n                this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);\n            } else {\n                this.mat.translate(-this.px.v, -this.py.v, this.pz.v);\n            }\n            if (this.a) {\n                var diffVector;\n                if (this.p) {\n                    diffVector = [\n                        this.p.v[0] - this.a.v[0],\n                        this.p.v[1] - this.a.v[1],\n                        this.p.v[2] - this.a.v[2]\n                    ];\n                } else {\n                    diffVector = [\n                        this.px.v - this.a.v[0],\n                        this.py.v - this.a.v[1],\n                        this.pz.v - this.a.v[2]\n                    ];\n                }\n                var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2)); // var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));\n                var lookDir = [\n                    diffVector[0] / mag,\n                    diffVector[1] / mag,\n                    diffVector[2] / mag\n                ];\n                var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);\n                var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);\n                var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);\n                this.mat.rotateY(mRotationY).rotateX(-mRotationX);\n            }\n            this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);\n            this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);\n            this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);\n            this.mat.translate(0, 0, this.pe.v);\n            var hasMatrixChanged = !this._prevMat.equals(this.mat);\n            if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {\n                len = this.comp.threeDElements.length;\n                var comp;\n                var perspectiveStyle;\n                var containerStyle;\n                for(i = 0; i < len; i += 1){\n                    comp = this.comp.threeDElements[i];\n                    if (comp.type === \"3d\") {\n                        if (hasMatrixChanged) {\n                            var matValue = this.mat.toCSS();\n                            containerStyle = comp.container.style;\n                            containerStyle.transform = matValue;\n                            containerStyle.webkitTransform = matValue;\n                        }\n                        if (this.pe._mdf) {\n                            perspectiveStyle = comp.perspectiveElem.style;\n                            perspectiveStyle.perspective = this.pe.v + \"px\";\n                            perspectiveStyle.webkitPerspective = this.pe.v + \"px\";\n                        }\n                    }\n                }\n                this.mat.clone(this._prevMat);\n            }\n        }\n        this._isFirstFrame = false;\n    };\n    HCameraElement.prototype.prepareFrame = function(num) {\n        this.prepareProperties(num, true);\n    };\n    HCameraElement.prototype.destroy = function() {};\n    HCameraElement.prototype.getBaseElement = function() {\n        return null;\n    };\n    function HImageElement(data, globalData, comp) {\n        this.assetData = globalData.getAssetData(data.refId);\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        HBaseElement,\n        HSolidElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableElement\n    ], HImageElement);\n    HImageElement.prototype.createContent = function() {\n        var assetPath = this.globalData.getAssetsPath(this.assetData);\n        var img = new Image();\n        if (this.data.hasMask) {\n            this.imageElem = createNS(\"image\");\n            this.imageElem.setAttribute(\"width\", this.assetData.w + \"px\");\n            this.imageElem.setAttribute(\"height\", this.assetData.h + \"px\");\n            this.imageElem.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", assetPath);\n            this.layerElement.appendChild(this.imageElem);\n            this.baseElement.setAttribute(\"width\", this.assetData.w);\n            this.baseElement.setAttribute(\"height\", this.assetData.h);\n        } else {\n            this.layerElement.appendChild(img);\n        }\n        img.crossOrigin = \"anonymous\";\n        img.src = assetPath;\n        if (this.data.ln) {\n            this.baseElement.setAttribute(\"id\", this.data.ln);\n        }\n    };\n    function HybridRendererBase(animationItem, config) {\n        this.animationItem = animationItem;\n        this.layers = null;\n        this.renderedFrame = -1;\n        this.renderConfig = {\n            className: config && config.className || \"\",\n            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || \"xMidYMid slice\",\n            hideOnTransparent: !(config && config.hideOnTransparent === false),\n            filterSize: {\n                width: config && config.filterSize && config.filterSize.width || \"400%\",\n                height: config && config.filterSize && config.filterSize.height || \"400%\",\n                x: config && config.filterSize && config.filterSize.x || \"-100%\",\n                y: config && config.filterSize && config.filterSize.y || \"-100%\"\n            }\n        };\n        this.globalData = {\n            _mdf: false,\n            frameNum: -1,\n            renderConfig: this.renderConfig\n        };\n        this.pendingElements = [];\n        this.elements = [];\n        this.threeDElements = [];\n        this.destroyed = false;\n        this.camera = null;\n        this.supports3d = true;\n        this.rendererType = \"html\";\n    }\n    extendPrototype([\n        BaseRenderer\n    ], HybridRendererBase);\n    HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem;\n    HybridRendererBase.prototype.checkPendingElements = function() {\n        while(this.pendingElements.length){\n            var element = this.pendingElements.pop();\n            element.checkParenting();\n        }\n    };\n    HybridRendererBase.prototype.appendElementInPos = function(element, pos) {\n        var newDOMElement = element.getBaseElement();\n        if (!newDOMElement) {\n            return;\n        }\n        var layer = this.layers[pos];\n        if (!layer.ddd || !this.supports3d) {\n            if (this.threeDElements) {\n                this.addTo3dContainer(newDOMElement, pos);\n            } else {\n                var i = 0;\n                var nextDOMElement;\n                var nextLayer;\n                var tmpDOMElement;\n                while(i < pos){\n                    if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement) {\n                        nextLayer = this.elements[i];\n                        tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();\n                        nextDOMElement = tmpDOMElement || nextDOMElement;\n                    }\n                    i += 1;\n                }\n                if (nextDOMElement) {\n                    if (!layer.ddd || !this.supports3d) {\n                        this.layerElement.insertBefore(newDOMElement, nextDOMElement);\n                    }\n                } else if (!layer.ddd || !this.supports3d) {\n                    this.layerElement.appendChild(newDOMElement);\n                }\n            }\n        } else {\n            this.addTo3dContainer(newDOMElement, pos);\n        }\n    };\n    HybridRendererBase.prototype.createShape = function(data) {\n        if (!this.supports3d) {\n            return new SVGShapeElement(data, this.globalData, this);\n        }\n        return new HShapeElement(data, this.globalData, this);\n    };\n    HybridRendererBase.prototype.createText = function(data) {\n        if (!this.supports3d) {\n            return new SVGTextLottieElement(data, this.globalData, this);\n        }\n        return new HTextElement(data, this.globalData, this);\n    };\n    HybridRendererBase.prototype.createCamera = function(data) {\n        this.camera = new HCameraElement(data, this.globalData, this);\n        return this.camera;\n    };\n    HybridRendererBase.prototype.createImage = function(data) {\n        if (!this.supports3d) {\n            return new IImageElement(data, this.globalData, this);\n        }\n        return new HImageElement(data, this.globalData, this);\n    };\n    HybridRendererBase.prototype.createSolid = function(data) {\n        if (!this.supports3d) {\n            return new ISolidElement(data, this.globalData, this);\n        }\n        return new HSolidElement(data, this.globalData, this);\n    };\n    HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;\n    HybridRendererBase.prototype.getThreeDContainerByPos = function(pos) {\n        var i = 0;\n        var len = this.threeDElements.length;\n        while(i < len){\n            if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {\n                return this.threeDElements[i].perspectiveElem;\n            }\n            i += 1;\n        }\n        return null;\n    };\n    HybridRendererBase.prototype.createThreeDContainer = function(pos, type) {\n        var perspectiveElem = createTag(\"div\");\n        var style;\n        var containerStyle;\n        styleDiv(perspectiveElem);\n        var container = createTag(\"div\");\n        styleDiv(container);\n        if (type === \"3d\") {\n            style = perspectiveElem.style;\n            style.width = this.globalData.compSize.w + \"px\";\n            style.height = this.globalData.compSize.h + \"px\";\n            var center = \"50% 50%\";\n            style.webkitTransformOrigin = center;\n            style.mozTransformOrigin = center;\n            style.transformOrigin = center;\n            containerStyle = container.style;\n            var matrix = \"matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)\";\n            containerStyle.transform = matrix;\n            containerStyle.webkitTransform = matrix;\n        }\n        perspectiveElem.appendChild(container); // this.resizerElem.appendChild(perspectiveElem);\n        var threeDContainerData = {\n            container: container,\n            perspectiveElem: perspectiveElem,\n            startPos: pos,\n            endPos: pos,\n            type: type\n        };\n        this.threeDElements.push(threeDContainerData);\n        return threeDContainerData;\n    };\n    HybridRendererBase.prototype.build3dContainers = function() {\n        var i;\n        var len = this.layers.length;\n        var lastThreeDContainerData;\n        var currentContainer = \"\";\n        for(i = 0; i < len; i += 1){\n            if (this.layers[i].ddd && this.layers[i].ty !== 3) {\n                if (currentContainer !== \"3d\") {\n                    currentContainer = \"3d\";\n                    lastThreeDContainerData = this.createThreeDContainer(i, \"3d\");\n                }\n                lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);\n            } else {\n                if (currentContainer !== \"2d\") {\n                    currentContainer = \"2d\";\n                    lastThreeDContainerData = this.createThreeDContainer(i, \"2d\");\n                }\n                lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);\n            }\n        }\n        len = this.threeDElements.length;\n        for(i = len - 1; i >= 0; i -= 1){\n            this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);\n        }\n    };\n    HybridRendererBase.prototype.addTo3dContainer = function(elem, pos) {\n        var i = 0;\n        var len = this.threeDElements.length;\n        while(i < len){\n            if (pos <= this.threeDElements[i].endPos) {\n                var j = this.threeDElements[i].startPos;\n                var nextElement;\n                while(j < pos){\n                    if (this.elements[j] && this.elements[j].getBaseElement) {\n                        nextElement = this.elements[j].getBaseElement();\n                    }\n                    j += 1;\n                }\n                if (nextElement) {\n                    this.threeDElements[i].container.insertBefore(elem, nextElement);\n                } else {\n                    this.threeDElements[i].container.appendChild(elem);\n                }\n                break;\n            }\n            i += 1;\n        }\n    };\n    HybridRendererBase.prototype.configAnimation = function(animData) {\n        var resizerElem = createTag(\"div\");\n        var wrapper = this.animationItem.wrapper;\n        var style = resizerElem.style;\n        style.width = animData.w + \"px\";\n        style.height = animData.h + \"px\";\n        this.resizerElem = resizerElem;\n        styleDiv(resizerElem);\n        style.transformStyle = \"flat\";\n        style.mozTransformStyle = \"flat\";\n        style.webkitTransformStyle = \"flat\";\n        if (this.renderConfig.className) {\n            resizerElem.setAttribute(\"class\", this.renderConfig.className);\n        }\n        wrapper.appendChild(resizerElem);\n        style.overflow = \"hidden\";\n        var svg = createNS(\"svg\");\n        svg.setAttribute(\"width\", \"1\");\n        svg.setAttribute(\"height\", \"1\");\n        styleDiv(svg);\n        this.resizerElem.appendChild(svg);\n        var defs = createNS(\"defs\");\n        svg.appendChild(defs);\n        this.data = animData; // Mask animation\n        this.setupGlobalData(animData, svg);\n        this.globalData.defs = defs;\n        this.layers = animData.layers;\n        this.layerElement = this.resizerElem;\n        this.build3dContainers();\n        this.updateContainerSize();\n    };\n    HybridRendererBase.prototype.destroy = function() {\n        if (this.animationItem.wrapper) {\n            this.animationItem.wrapper.innerText = \"\";\n        }\n        this.animationItem.container = null;\n        this.globalData.defs = null;\n        var i;\n        var len = this.layers ? this.layers.length : 0;\n        for(i = 0; i < len; i += 1){\n            if (this.elements[i] && this.elements[i].destroy) {\n                this.elements[i].destroy();\n            }\n        }\n        this.elements.length = 0;\n        this.destroyed = true;\n        this.animationItem = null;\n    };\n    HybridRendererBase.prototype.updateContainerSize = function() {\n        var elementWidth = this.animationItem.wrapper.offsetWidth;\n        var elementHeight = this.animationItem.wrapper.offsetHeight;\n        var elementRel = elementWidth / elementHeight;\n        var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;\n        var sx;\n        var sy;\n        var tx;\n        var ty;\n        if (animationRel > elementRel) {\n            sx = elementWidth / this.globalData.compSize.w;\n            sy = elementWidth / this.globalData.compSize.w;\n            tx = 0;\n            ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;\n        } else {\n            sx = elementHeight / this.globalData.compSize.h;\n            sy = elementHeight / this.globalData.compSize.h;\n            tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;\n            ty = 0;\n        }\n        var style = this.resizerElem.style;\n        style.webkitTransform = \"matrix3d(\" + sx + \",0,0,0,0,\" + sy + \",0,0,0,0,1,0,\" + tx + \",\" + ty + \",0,1)\";\n        style.transform = style.webkitTransform;\n    };\n    HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame;\n    HybridRendererBase.prototype.hide = function() {\n        this.resizerElem.style.display = \"none\";\n    };\n    HybridRendererBase.prototype.show = function() {\n        this.resizerElem.style.display = \"block\";\n    };\n    HybridRendererBase.prototype.initItems = function() {\n        this.buildAllItems();\n        if (this.camera) {\n            this.camera.setup();\n        } else {\n            var cWidth = this.globalData.compSize.w;\n            var cHeight = this.globalData.compSize.h;\n            var i;\n            var len = this.threeDElements.length;\n            for(i = 0; i < len; i += 1){\n                var style = this.threeDElements[i].perspectiveElem.style;\n                style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + \"px\";\n                style.perspective = style.webkitPerspective;\n            }\n        }\n    };\n    HybridRendererBase.prototype.searchExtraCompositions = function(assets) {\n        var i;\n        var len = assets.length;\n        var floatingContainer = createTag(\"div\");\n        for(i = 0; i < len; i += 1){\n            if (assets[i].xt) {\n                var comp = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);\n                comp.initExpressions();\n                this.globalData.projectInterface.registerComposition(comp);\n            }\n        }\n    };\n    function HCompElement(data, globalData, comp) {\n        this.layers = data.layers;\n        this.supports3d = !data.hasMask;\n        this.completeLayers = false;\n        this.pendingElements = [];\n        this.elements = this.layers ? createSizedArray(this.layers.length) : [];\n        this.initElement(data, globalData, comp);\n        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n            _placeholder: true\n        };\n    }\n    extendPrototype([\n        HybridRendererBase,\n        ICompElement,\n        HBaseElement\n    ], HCompElement);\n    HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;\n    HCompElement.prototype.createContainerElements = function() {\n        this._createBaseContainerElements(); // divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';\n        if (this.data.hasMask) {\n            this.svgElement.setAttribute(\"width\", this.data.w);\n            this.svgElement.setAttribute(\"height\", this.data.h);\n            this.transformedElement = this.baseElement;\n        } else {\n            this.transformedElement = this.layerElement;\n        }\n    };\n    HCompElement.prototype.addTo3dContainer = function(elem, pos) {\n        var j = 0;\n        var nextElement;\n        while(j < pos){\n            if (this.elements[j] && this.elements[j].getBaseElement) {\n                nextElement = this.elements[j].getBaseElement();\n            }\n            j += 1;\n        }\n        if (nextElement) {\n            this.layerElement.insertBefore(elem, nextElement);\n        } else {\n            this.layerElement.appendChild(elem);\n        }\n    };\n    HCompElement.prototype.createComp = function(data) {\n        if (!this.supports3d) {\n            return new SVGCompElement(data, this.globalData, this);\n        }\n        return new HCompElement(data, this.globalData, this);\n    };\n    function HybridRenderer(animationItem, config) {\n        this.animationItem = animationItem;\n        this.layers = null;\n        this.renderedFrame = -1;\n        this.renderConfig = {\n            className: config && config.className || \"\",\n            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || \"xMidYMid slice\",\n            hideOnTransparent: !(config && config.hideOnTransparent === false),\n            filterSize: {\n                width: config && config.filterSize && config.filterSize.width || \"400%\",\n                height: config && config.filterSize && config.filterSize.height || \"400%\",\n                x: config && config.filterSize && config.filterSize.x || \"-100%\",\n                y: config && config.filterSize && config.filterSize.y || \"-100%\"\n            },\n            runExpressions: !config || config.runExpressions === undefined || config.runExpressions\n        };\n        this.globalData = {\n            _mdf: false,\n            frameNum: -1,\n            renderConfig: this.renderConfig\n        };\n        this.pendingElements = [];\n        this.elements = [];\n        this.threeDElements = [];\n        this.destroyed = false;\n        this.camera = null;\n        this.supports3d = true;\n        this.rendererType = \"html\";\n    }\n    extendPrototype([\n        HybridRendererBase\n    ], HybridRenderer);\n    HybridRenderer.prototype.createComp = function(data) {\n        if (!this.supports3d) {\n            return new SVGCompElement(data, this.globalData, this);\n        }\n        return new HCompElement(data, this.globalData, this);\n    };\n    var CompExpressionInterface = function() {\n        return function(comp) {\n            function _thisLayerFunction(name) {\n                var i = 0;\n                var len = comp.layers.length;\n                while(i < len){\n                    if (comp.layers[i].nm === name || comp.layers[i].ind === name) {\n                        return comp.elements[i].layerInterface;\n                    }\n                    i += 1;\n                }\n                return null; // return {active:false};\n            }\n            Object.defineProperty(_thisLayerFunction, \"_name\", {\n                value: comp.data.nm\n            });\n            _thisLayerFunction.layer = _thisLayerFunction;\n            _thisLayerFunction.pixelAspect = 1;\n            _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;\n            _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;\n            _thisLayerFunction.pixelAspect = 1;\n            _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;\n            _thisLayerFunction.displayStartTime = 0;\n            _thisLayerFunction.numLayers = comp.layers.length;\n            return _thisLayerFunction;\n        };\n    }();\n    function _typeof$2(obj) {\n        \"@babel/helpers - typeof\";\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof$2 = function _typeof(obj) {\n                return typeof obj;\n            };\n        } else {\n            _typeof$2 = function _typeof(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n        }\n        return _typeof$2(obj);\n    }\n    /* eslint-disable */ /*\r\n   Copyright 2014 David Bau.\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining\r\n   a copy of this software and associated documentation files (the\r\n   \"Software\"), to deal in the Software without restriction, including\r\n   without limitation the rights to use, copy, modify, merge, publish,\r\n   distribute, sublicense, and/or sell copies of the Software, and to\r\n   permit persons to whom the Software is furnished to do so, subject to\r\n   the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be\r\n   included in all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   */ function seedRandom(pool, math) {\n        //\n        // The following constants are related to IEEE 754 limits.\n        //\n        var global = this, width = 256, // each RC4 output is 0 <= x < 256\n        chunks = 6, // at least six RC4 outputs for each double\n        digits = 52, // there are 52 significant digits in a double\n        rngname = \"random\", // rngname: name for Math.random and Math.seedrandom\n        startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto; // node.js crypto module, initialized at the bottom.\n        //\n        // seedrandom()\n        // This is the seedrandom function described above.\n        //\n        function seedrandom(seed, options, callback) {\n            var key = [];\n            options = options === true ? {\n                entropy: true\n            } : options || {}; // Flatten the seed string or build one from local entropy if needed.\n            var shortseed = mixkey(flatten(options.entropy ? [\n                seed,\n                tostring(pool)\n            ] : seed === null ? autoseed() : seed, 3), key); // Use the seed to initialize an ARC4 generator.\n            var arc4 = new ARC4(key); // This function returns a random double in [0, 1) that contains\n            // randomness in every bit of the mantissa of the IEEE 754 value.\n            var prng = function prng() {\n                var n = arc4.g(chunks), // Start with a numerator n < 2 ^ 48\n                d = startdenom, //   and denominator d = 2 ^ 48.\n                x = 0; //   and no 'extra last byte'.\n                while(n < significance){\n                    // Fill up all significant digits by\n                    n = (n + x) * width; //   shifting numerator and\n                    d *= width; //   denominator and generating a\n                    x = arc4.g(1); //   new least-significant-byte.\n                }\n                while(n >= overflow){\n                    // To avoid rounding up, before adding\n                    n /= 2; //   last byte, shift everything\n                    d /= 2; //   right using integer math until\n                    x >>>= 1; //   we have exactly the desired bits.\n                }\n                return (n + x) / d; // Form the number within [0, 1).\n            };\n            prng.int32 = function() {\n                return arc4.g(4) | 0;\n            };\n            prng.quick = function() {\n                return arc4.g(4) / 0x100000000;\n            };\n            prng[\"double\"] = prng; // Mix the randomness into accumulated entropy.\n            mixkey(tostring(arc4.S), pool); // Calling convention: what to return as a function of prng, seed, is_math.\n            return (options.pass || callback || function(prng, seed, is_math_call, state) {\n                if (state) {\n                    // Load the arc4 state from the given state if it has an S array.\n                    if (state.S) {\n                        copy(state, arc4);\n                    } // Only provide the .state method if requested via options.state.\n                    prng.state = function() {\n                        return copy(arc4, {});\n                    };\n                } // If called as a method of Math (Math.seedrandom()), mutate\n                // Math.random because that is how seedrandom.js has worked since v1.0.\n                if (is_math_call) {\n                    math[rngname] = prng;\n                    return seed;\n                } else return prng;\n            })(prng, shortseed, \"global\" in options ? options.global : this == math, options.state);\n        }\n        math[\"seed\" + rngname] = seedrandom; //\n        // ARC4\n        //\n        // An ARC4 implementation.  The constructor takes a key in the form of\n        // an array of at most (width) integers that should be 0 <= x < (width).\n        //\n        // The g(count) method returns a pseudorandom integer that concatenates\n        // the next (count) outputs from ARC4.  Its return value is a number x\n        // that is in the range 0 <= x < (width ^ count).\n        //\n        function ARC4(key) {\n            var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = []; // The empty key [] is treated as [0].\n            if (!keylen) {\n                key = [\n                    keylen++\n                ];\n            } // Set up S using the standard key scheduling algorithm.\n            while(i < width){\n                s[i] = i++;\n            }\n            for(i = 0; i < width; i++){\n                s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];\n                s[j] = t;\n            } // The \"g\" method returns the next (count) outputs as one number.\n            me.g = function(count) {\n                // Using instance members instead of closure state nearly doubles speed.\n                var t, r = 0, i = me.i, j = me.j, s = me.S;\n                while(count--){\n                    t = s[i = mask & i + 1];\n                    r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];\n                }\n                me.i = i;\n                me.j = j;\n                return r; // For robust unpredictability, the function call below automatically\n            // discards an initial batch of values.  This is called RC4-drop[256].\n            // See http://google.com/search?q=rsa+fluhrer+response&btnI\n            };\n        } //\n        // copy()\n        // Copies internal state of ARC4 to or from a plain object.\n        //\n        function copy(f, t) {\n            t.i = f.i;\n            t.j = f.j;\n            t.S = f.S.slice();\n            return t;\n        } //\n        // flatten()\n        // Converts an object tree to nested arrays of strings.\n        //\n        function flatten(obj, depth) {\n            var result = [], typ = _typeof$2(obj), prop;\n            if (depth && typ == \"object\") {\n                for(prop in obj){\n                    try {\n                        result.push(flatten(obj[prop], depth - 1));\n                    } catch (e) {}\n                }\n            }\n            return result.length ? result : typ == \"string\" ? obj : obj + \"\\x00\";\n        } //\n        // mixkey()\n        // Mixes a string seed into a key that is an array of integers, and\n        // returns a shortened string seed that is equivalent to the result key.\n        //\n        function mixkey(seed, key) {\n            var stringseed = seed + \"\", smear, j = 0;\n            while(j < stringseed.length){\n                key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);\n            }\n            return tostring(key);\n        } //\n        // autoseed()\n        // Returns an object for autoseeding, using window.crypto and Node crypto\n        // module if available.\n        //\n        function autoseed() {\n            try {\n                if (nodecrypto) {\n                    return tostring(nodecrypto.randomBytes(width));\n                }\n                var out = new Uint8Array(width);\n                (global.crypto || global.msCrypto).getRandomValues(out);\n                return tostring(out);\n            } catch (e) {\n                var browser = global.navigator, plugins = browser && browser.plugins;\n                return [\n                    +new Date(),\n                    global,\n                    plugins,\n                    global.screen,\n                    tostring(pool)\n                ];\n            }\n        } //\n        // tostring()\n        // Converts an array of charcodes to a string\n        //\n        function tostring(a) {\n            return String.fromCharCode.apply(0, a);\n        } //\n        // When seedrandom.js is loaded, we immediately mix a few bits\n        // from the built-in RNG into the entropy pool.  Because we do\n        // not want to interfere with deterministic PRNG state later,\n        // seedrandom will not call math.random on its own again after\n        // initialization.\n        //\n        mixkey(math.random(), pool); //\n    // Nodejs and AMD support: export the implementation as a module using\n    // either convention.\n    //\n    // End anonymous scope, and pass initial values.\n    }\n    ;\n    function initialize$2(BMMath) {\n        seedRandom([], BMMath);\n    }\n    var propTypes = {\n        SHAPE: \"shape\"\n    };\n    function _typeof$1(obj) {\n        \"@babel/helpers - typeof\";\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof$1 = function _typeof(obj) {\n                return typeof obj;\n            };\n        } else {\n            _typeof$1 = function _typeof(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n        }\n        return _typeof$1(obj);\n    }\n    var ExpressionManager = function() {\n        \"use strict\";\n        var ob = {};\n        var Math = BMMath;\n        var window = null;\n        var document = null;\n        var XMLHttpRequest = null;\n        var fetch = null;\n        var frames = null;\n        var _lottieGlobal = {};\n        initialize$2(BMMath);\n        function resetFrame() {\n            _lottieGlobal = {};\n        }\n        function $bm_isInstanceOfArray(arr) {\n            return arr.constructor === Array || arr.constructor === Float32Array;\n        }\n        function isNumerable(tOfV, v) {\n            return tOfV === \"number\" || v instanceof Number || tOfV === \"boolean\" || tOfV === \"string\";\n        }\n        function $bm_neg(a) {\n            var tOfA = _typeof$1(a);\n            if (tOfA === \"number\" || a instanceof Number || tOfA === \"boolean\") {\n                return -a;\n            }\n            if ($bm_isInstanceOfArray(a)) {\n                var i;\n                var lenA = a.length;\n                var retArr = [];\n                for(i = 0; i < lenA; i += 1){\n                    retArr[i] = -a[i];\n                }\n                return retArr;\n            }\n            if (a.propType) {\n                return a.v;\n            }\n            return -a;\n        }\n        var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, \"easeIn\").get;\n        var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, \"easeOut\").get;\n        var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, \"easeInOut\").get;\n        function sum(a, b) {\n            var tOfA = _typeof$1(a);\n            var tOfB = _typeof$1(b);\n            if (isNumerable(tOfA, a) && isNumerable(tOfB, b) || tOfA === \"string\" || tOfB === \"string\") {\n                return a + b;\n            }\n            if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n                a = a.slice(0);\n                a[0] += b;\n                return a;\n            }\n            if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n                b = b.slice(0);\n                b[0] = a + b[0];\n                return b;\n            }\n            if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {\n                var i = 0;\n                var lenA = a.length;\n                var lenB = b.length;\n                var retArr = [];\n                while(i < lenA || i < lenB){\n                    if ((typeof a[i] === \"number\" || a[i] instanceof Number) && (typeof b[i] === \"number\" || b[i] instanceof Number)) {\n                        retArr[i] = a[i] + b[i];\n                    } else {\n                        retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];\n                    }\n                    i += 1;\n                }\n                return retArr;\n            }\n            return 0;\n        }\n        var add = sum;\n        function sub(a, b) {\n            var tOfA = _typeof$1(a);\n            var tOfB = _typeof$1(b);\n            if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n                if (tOfA === \"string\") {\n                    a = parseInt(a, 10);\n                }\n                if (tOfB === \"string\") {\n                    b = parseInt(b, 10);\n                }\n                return a - b;\n            }\n            if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n                a = a.slice(0);\n                a[0] -= b;\n                return a;\n            }\n            if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n                b = b.slice(0);\n                b[0] = a - b[0];\n                return b;\n            }\n            if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {\n                var i = 0;\n                var lenA = a.length;\n                var lenB = b.length;\n                var retArr = [];\n                while(i < lenA || i < lenB){\n                    if ((typeof a[i] === \"number\" || a[i] instanceof Number) && (typeof b[i] === \"number\" || b[i] instanceof Number)) {\n                        retArr[i] = a[i] - b[i];\n                    } else {\n                        retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];\n                    }\n                    i += 1;\n                }\n                return retArr;\n            }\n            return 0;\n        }\n        function mul(a, b) {\n            var tOfA = _typeof$1(a);\n            var tOfB = _typeof$1(b);\n            var arr;\n            if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n                return a * b;\n            }\n            var i;\n            var len;\n            if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n                len = a.length;\n                arr = createTypedArray(\"float32\", len);\n                for(i = 0; i < len; i += 1){\n                    arr[i] = a[i] * b;\n                }\n                return arr;\n            }\n            if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n                len = b.length;\n                arr = createTypedArray(\"float32\", len);\n                for(i = 0; i < len; i += 1){\n                    arr[i] = a * b[i];\n                }\n                return arr;\n            }\n            return 0;\n        }\n        function div(a, b) {\n            var tOfA = _typeof$1(a);\n            var tOfB = _typeof$1(b);\n            var arr;\n            if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n                return a / b;\n            }\n            var i;\n            var len;\n            if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n                len = a.length;\n                arr = createTypedArray(\"float32\", len);\n                for(i = 0; i < len; i += 1){\n                    arr[i] = a[i] / b;\n                }\n                return arr;\n            }\n            if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n                len = b.length;\n                arr = createTypedArray(\"float32\", len);\n                for(i = 0; i < len; i += 1){\n                    arr[i] = a / b[i];\n                }\n                return arr;\n            }\n            return 0;\n        }\n        function mod(a, b) {\n            if (typeof a === \"string\") {\n                a = parseInt(a, 10);\n            }\n            if (typeof b === \"string\") {\n                b = parseInt(b, 10);\n            }\n            return a % b;\n        }\n        var $bm_sum = sum;\n        var $bm_sub = sub;\n        var $bm_mul = mul;\n        var $bm_div = div;\n        var $bm_mod = mod;\n        function clamp(num, min, max) {\n            if (min > max) {\n                var mm = max;\n                max = min;\n                min = mm;\n            }\n            return Math.min(Math.max(num, min), max);\n        }\n        function radiansToDegrees(val) {\n            return val / degToRads;\n        }\n        var radians_to_degrees = radiansToDegrees;\n        function degreesToRadians(val) {\n            return val * degToRads;\n        }\n        var degrees_to_radians = radiansToDegrees;\n        var helperLengthArray = [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        ];\n        function length(arr1, arr2) {\n            if (typeof arr1 === \"number\" || arr1 instanceof Number) {\n                arr2 = arr2 || 0;\n                return Math.abs(arr1 - arr2);\n            }\n            if (!arr2) {\n                arr2 = helperLengthArray;\n            }\n            var i;\n            var len = Math.min(arr1.length, arr2.length);\n            var addedLength = 0;\n            for(i = 0; i < len; i += 1){\n                addedLength += Math.pow(arr2[i] - arr1[i], 2);\n            }\n            return Math.sqrt(addedLength);\n        }\n        function normalize(vec) {\n            return div(vec, length(vec));\n        }\n        function rgbToHsl(val) {\n            var r = val[0];\n            var g = val[1];\n            var b = val[2];\n            var max = Math.max(r, g, b);\n            var min = Math.min(r, g, b);\n            var h;\n            var s;\n            var l = (max + min) / 2;\n            if (max === min) {\n                h = 0; // achromatic\n                s = 0; // achromatic\n            } else {\n                var d = max - min;\n                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                switch(max){\n                    case r:\n                        h = (g - b) / d + (g < b ? 6 : 0);\n                        break;\n                    case g:\n                        h = (b - r) / d + 2;\n                        break;\n                    case b:\n                        h = (r - g) / d + 4;\n                        break;\n                    default:\n                        break;\n                }\n                h /= 6;\n            }\n            return [\n                h,\n                s,\n                l,\n                val[3]\n            ];\n        }\n        function hue2rgb(p, q, t) {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        }\n        function hslToRgb(val) {\n            var h = val[0];\n            var s = val[1];\n            var l = val[2];\n            var r;\n            var g;\n            var b;\n            if (s === 0) {\n                r = l; // achromatic\n                b = l; // achromatic\n                g = l; // achromatic\n            } else {\n                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n                var p = 2 * l - q;\n                r = hue2rgb(p, q, h + 1 / 3);\n                g = hue2rgb(p, q, h);\n                b = hue2rgb(p, q, h - 1 / 3);\n            }\n            return [\n                r,\n                g,\n                b,\n                val[3]\n            ];\n        }\n        function linear(t, tMin, tMax, value1, value2) {\n            if (value1 === undefined || value2 === undefined) {\n                value1 = tMin;\n                value2 = tMax;\n                tMin = 0;\n                tMax = 1;\n            }\n            if (tMax < tMin) {\n                var _tMin = tMax;\n                tMax = tMin;\n                tMin = _tMin;\n            }\n            if (t <= tMin) {\n                return value1;\n            }\n            if (t >= tMax) {\n                return value2;\n            }\n            var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);\n            if (!value1.length) {\n                return value1 + (value2 - value1) * perc;\n            }\n            var i;\n            var len = value1.length;\n            var arr = createTypedArray(\"float32\", len);\n            for(i = 0; i < len; i += 1){\n                arr[i] = value1[i] + (value2[i] - value1[i]) * perc;\n            }\n            return arr;\n        }\n        function random(min, max) {\n            if (max === undefined) {\n                if (min === undefined) {\n                    min = 0;\n                    max = 1;\n                } else {\n                    max = min;\n                    min = undefined;\n                }\n            }\n            if (max.length) {\n                var i;\n                var len = max.length;\n                if (!min) {\n                    min = createTypedArray(\"float32\", len);\n                }\n                var arr = createTypedArray(\"float32\", len);\n                var rnd = BMMath.random();\n                for(i = 0; i < len; i += 1){\n                    arr[i] = min[i] + rnd * (max[i] - min[i]);\n                }\n                return arr;\n            }\n            if (min === undefined) {\n                min = 0;\n            }\n            var rndm = BMMath.random();\n            return min + rndm * (max - min);\n        }\n        function createPath(points, inTangents, outTangents, closed) {\n            var i;\n            var len = points.length;\n            var path = shapePool.newElement();\n            path.setPathData(!!closed, len);\n            var arrPlaceholder = [\n                0,\n                0\n            ];\n            var inVertexPoint;\n            var outVertexPoint;\n            for(i = 0; i < len; i += 1){\n                inVertexPoint = inTangents && inTangents[i] ? inTangents[i] : arrPlaceholder;\n                outVertexPoint = outTangents && outTangents[i] ? outTangents[i] : arrPlaceholder;\n                path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, true);\n            }\n            return path;\n        }\n        function initiateExpression(elem, data, property) {\n            // Bail out if we don't want expressions\n            function noOp(_value) {\n                return _value;\n            }\n            if (!elem.globalData.renderConfig.runExpressions) {\n                return noOp;\n            }\n            var val = data.x;\n            var needsVelocity = /velocity(?![\\w\\d])/.test(val);\n            var _needsRandom = val.indexOf(\"random\") !== -1;\n            var elemType = elem.data.ty;\n            var transform;\n            var $bm_transform;\n            var content;\n            var effect;\n            var thisProperty = property;\n            thisProperty.valueAtTime = thisProperty.getValueAtTime;\n            Object.defineProperty(thisProperty, \"value\", {\n                get: function get() {\n                    return thisProperty.v;\n                }\n            });\n            elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;\n            elem.comp.displayStartTime = 0;\n            var inPoint = elem.data.ip / elem.comp.globalData.frameRate;\n            var outPoint = elem.data.op / elem.comp.globalData.frameRate;\n            var width = elem.data.sw ? elem.data.sw : 0;\n            var height = elem.data.sh ? elem.data.sh : 0;\n            var name = elem.data.nm;\n            var loopIn;\n            var loop_in;\n            var loopOut;\n            var loop_out;\n            var smooth;\n            var toWorld;\n            var fromWorld;\n            var fromComp;\n            var toComp;\n            var fromCompToSurface;\n            var position;\n            var rotation;\n            var anchorPoint;\n            var scale;\n            var thisLayer;\n            var thisComp;\n            var mask;\n            var valueAtTime;\n            var velocityAtTime;\n            var scoped_bm_rt; // val = val.replace(/(\\\\?\"|')((http)(s)?(:\\/))?\\/.*?(\\\\?\"|')/g, \"\\\"\\\"\"); // deter potential network calls\n            var expression_function = eval(\"[function _expression_function(){\" + val + \";scoped_bm_rt=$bm_rt}]\")[0]; // eslint-disable-line no-eval\n            var numKeys = property.kf ? data.k.length : 0;\n            var active = !this.data || this.data.hd !== true;\n            var wiggle = (function wiggle(freq, amp) {\n                var iWiggle;\n                var j;\n                var lenWiggle = this.pv.length ? this.pv.length : 1;\n                var addedAmps = createTypedArray(\"float32\", lenWiggle);\n                freq = 5;\n                var iterations = Math.floor(time * freq);\n                iWiggle = 0;\n                j = 0;\n                while(iWiggle < iterations){\n                    // var rnd = BMMath.random();\n                    for(j = 0; j < lenWiggle; j += 1){\n                        addedAmps[j] += -amp + amp * 2 * BMMath.random(); // addedAmps[j] += -amp + amp*2*rnd;\n                    }\n                    iWiggle += 1;\n                } // var rnd2 = BMMath.random();\n                var periods = time * freq;\n                var perc = periods - Math.floor(periods);\n                var arr = createTypedArray(\"float32\", lenWiggle);\n                if (lenWiggle > 1) {\n                    for(j = 0; j < lenWiggle; j += 1){\n                        arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc; // arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;\n                    // arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);\n                    }\n                    return arr;\n                }\n                return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;\n            }).bind(this);\n            if (thisProperty.loopIn) {\n                loopIn = thisProperty.loopIn.bind(thisProperty);\n                loop_in = loopIn;\n            }\n            if (thisProperty.loopOut) {\n                loopOut = thisProperty.loopOut.bind(thisProperty);\n                loop_out = loopOut;\n            }\n            if (thisProperty.smooth) {\n                smooth = thisProperty.smooth.bind(thisProperty);\n            }\n            function loopInDuration(type, duration) {\n                return loopIn(type, duration, true);\n            }\n            function loopOutDuration(type, duration) {\n                return loopOut(type, duration, true);\n            }\n            if (this.getValueAtTime) {\n                valueAtTime = this.getValueAtTime.bind(this);\n            }\n            if (this.getVelocityAtTime) {\n                velocityAtTime = this.getVelocityAtTime.bind(this);\n            }\n            var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);\n            function lookAt(elem1, elem2) {\n                var fVec = [\n                    elem2[0] - elem1[0],\n                    elem2[1] - elem1[1],\n                    elem2[2] - elem1[2]\n                ];\n                var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;\n                var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;\n                return [\n                    yaw,\n                    pitch,\n                    0\n                ];\n            }\n            function easeOut(t, tMin, tMax, val1, val2) {\n                return applyEase(easeOutBez, t, tMin, tMax, val1, val2);\n            }\n            function easeIn(t, tMin, tMax, val1, val2) {\n                return applyEase(easeInBez, t, tMin, tMax, val1, val2);\n            }\n            function ease(t, tMin, tMax, val1, val2) {\n                return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);\n            }\n            function applyEase(fn, t, tMin, tMax, val1, val2) {\n                if (val1 === undefined) {\n                    val1 = tMin;\n                    val2 = tMax;\n                } else {\n                    t = (t - tMin) / (tMax - tMin);\n                }\n                if (t > 1) {\n                    t = 1;\n                } else if (t < 0) {\n                    t = 0;\n                }\n                var mult = fn(t);\n                if ($bm_isInstanceOfArray(val1)) {\n                    var iKey;\n                    var lenKey = val1.length;\n                    var arr = createTypedArray(\"float32\", lenKey);\n                    for(iKey = 0; iKey < lenKey; iKey += 1){\n                        arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];\n                    }\n                    return arr;\n                }\n                return (val2 - val1) * mult + val1;\n            }\n            function nearestKey(time) {\n                var iKey;\n                var lenKey = data.k.length;\n                var index;\n                var keyTime;\n                if (!data.k.length || typeof data.k[0] === \"number\") {\n                    index = 0;\n                    keyTime = 0;\n                } else {\n                    index = -1;\n                    time *= elem.comp.globalData.frameRate;\n                    if (time < data.k[0].t) {\n                        index = 1;\n                        keyTime = data.k[0].t;\n                    } else {\n                        for(iKey = 0; iKey < lenKey - 1; iKey += 1){\n                            if (time === data.k[iKey].t) {\n                                index = iKey + 1;\n                                keyTime = data.k[iKey].t;\n                                break;\n                            } else if (time > data.k[iKey].t && time < data.k[iKey + 1].t) {\n                                if (time - data.k[iKey].t > data.k[iKey + 1].t - time) {\n                                    index = iKey + 2;\n                                    keyTime = data.k[iKey + 1].t;\n                                } else {\n                                    index = iKey + 1;\n                                    keyTime = data.k[iKey].t;\n                                }\n                                break;\n                            }\n                        }\n                        if (index === -1) {\n                            index = iKey + 1;\n                            keyTime = data.k[iKey].t;\n                        }\n                    }\n                }\n                var obKey = {};\n                obKey.index = index;\n                obKey.time = keyTime / elem.comp.globalData.frameRate;\n                return obKey;\n            }\n            function key(ind) {\n                var obKey;\n                var iKey;\n                var lenKey;\n                if (!data.k.length || typeof data.k[0] === \"number\") {\n                    throw new Error(\"The property has no keyframe at index \" + ind);\n                }\n                ind -= 1;\n                obKey = {\n                    time: data.k[ind].t / elem.comp.globalData.frameRate,\n                    value: []\n                };\n                var arr = Object.prototype.hasOwnProperty.call(data.k[ind], \"s\") ? data.k[ind].s : data.k[ind - 1].e;\n                lenKey = arr.length;\n                for(iKey = 0; iKey < lenKey; iKey += 1){\n                    obKey[iKey] = arr[iKey];\n                    obKey.value[iKey] = arr[iKey];\n                }\n                return obKey;\n            }\n            function framesToTime(fr, fps) {\n                if (!fps) {\n                    fps = elem.comp.globalData.frameRate;\n                }\n                return fr / fps;\n            }\n            function timeToFrames(t, fps) {\n                if (!t && t !== 0) {\n                    t = time;\n                }\n                if (!fps) {\n                    fps = elem.comp.globalData.frameRate;\n                }\n                return t * fps;\n            }\n            function seedRandom(seed) {\n                BMMath.seedrandom(randSeed + seed);\n            }\n            function sourceRectAtTime() {\n                return elem.sourceRectAtTime();\n            }\n            function substring(init, end) {\n                if (typeof value === \"string\") {\n                    if (end === undefined) {\n                        return value.substring(init);\n                    }\n                    return value.substring(init, end);\n                }\n                return \"\";\n            }\n            function substr(init, end) {\n                if (typeof value === \"string\") {\n                    if (end === undefined) {\n                        return value.substr(init);\n                    }\n                    return value.substr(init, end);\n                }\n                return \"\";\n            }\n            function posterizeTime(framesPerSecond) {\n                time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;\n                value = valueAtTime(time);\n            }\n            var time;\n            var velocity;\n            var value;\n            var text;\n            var textIndex;\n            var textTotal;\n            var selectorValue;\n            var index = elem.data.ind;\n            var hasParent = !!(elem.hierarchy && elem.hierarchy.length);\n            var parent;\n            var randSeed = Math.floor(Math.random() * 1000000);\n            var globalData = elem.globalData;\n            function executeExpression(_value) {\n                // globalData.pushExpression();\n                value = _value;\n                if (this.frameExpressionId === elem.globalData.frameId && this.propType !== \"textSelector\") {\n                    return value;\n                }\n                if (this.propType === \"textSelector\") {\n                    textIndex = this.textIndex;\n                    textTotal = this.textTotal;\n                    selectorValue = this.selectorValue;\n                }\n                if (!thisLayer) {\n                    text = elem.layerInterface.text;\n                    thisLayer = elem.layerInterface;\n                    thisComp = elem.comp.compInterface;\n                    toWorld = thisLayer.toWorld.bind(thisLayer);\n                    fromWorld = thisLayer.fromWorld.bind(thisLayer);\n                    fromComp = thisLayer.fromComp.bind(thisLayer);\n                    toComp = thisLayer.toComp.bind(thisLayer);\n                    mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;\n                    fromCompToSurface = fromComp;\n                }\n                if (!transform) {\n                    transform = elem.layerInterface(\"ADBE Transform Group\");\n                    $bm_transform = transform;\n                    if (transform) {\n                        anchorPoint = transform.anchorPoint;\n                    /* position = transform.position;\r\n                      rotation = transform.rotation;\r\n                      scale = transform.scale; */ }\n                }\n                if (elemType === 4 && !content) {\n                    content = thisLayer(\"ADBE Root Vectors Group\");\n                }\n                if (!effect) {\n                    effect = thisLayer(4);\n                }\n                hasParent = !!(elem.hierarchy && elem.hierarchy.length);\n                if (hasParent && !parent) {\n                    parent = elem.hierarchy[0].layerInterface;\n                }\n                time = this.comp.renderedFrame / this.comp.globalData.frameRate;\n                if (_needsRandom) {\n                    seedRandom(randSeed + time);\n                }\n                if (needsVelocity) {\n                    velocity = velocityAtTime(time);\n                }\n                expression_function();\n                this.frameExpressionId = elem.globalData.frameId; // TODO: Check if it's possible to return on ShapeInterface the .v value\n                // Changed this to a ternary operation because Rollup failed compiling it correctly\n                scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt;\n                return scoped_bm_rt;\n            } // Bundlers will see these as dead code and unless we reference them\n            executeExpression.__preventDeadCodeRemoval = [\n                $bm_transform,\n                anchorPoint,\n                time,\n                velocity,\n                inPoint,\n                outPoint,\n                width,\n                height,\n                name,\n                loop_in,\n                loop_out,\n                smooth,\n                toComp,\n                fromCompToSurface,\n                toWorld,\n                fromWorld,\n                mask,\n                position,\n                rotation,\n                scale,\n                thisComp,\n                numKeys,\n                active,\n                wiggle,\n                loopInDuration,\n                loopOutDuration,\n                comp,\n                lookAt,\n                easeOut,\n                easeIn,\n                ease,\n                nearestKey,\n                key,\n                text,\n                textIndex,\n                textTotal,\n                selectorValue,\n                framesToTime,\n                timeToFrames,\n                sourceRectAtTime,\n                substring,\n                substr,\n                posterizeTime,\n                index,\n                globalData\n            ];\n            return executeExpression;\n        }\n        ob.initiateExpression = initiateExpression;\n        ob.__preventDeadCodeRemoval = [\n            window,\n            document,\n            XMLHttpRequest,\n            fetch,\n            frames,\n            $bm_neg,\n            add,\n            $bm_sum,\n            $bm_sub,\n            $bm_mul,\n            $bm_div,\n            $bm_mod,\n            clamp,\n            radians_to_degrees,\n            degreesToRadians,\n            degrees_to_radians,\n            normalize,\n            rgbToHsl,\n            hslToRgb,\n            linear,\n            random,\n            createPath,\n            _lottieGlobal\n        ];\n        ob.resetFrame = resetFrame;\n        return ob;\n    }();\n    var Expressions = function() {\n        var ob = {};\n        ob.initExpressions = initExpressions;\n        ob.resetFrame = ExpressionManager.resetFrame;\n        function initExpressions(animation) {\n            var stackCount = 0;\n            var registers = [];\n            function pushExpression() {\n                stackCount += 1;\n            }\n            function popExpression() {\n                stackCount -= 1;\n                if (stackCount === 0) {\n                    releaseInstances();\n                }\n            }\n            function registerExpressionProperty(expression) {\n                if (registers.indexOf(expression) === -1) {\n                    registers.push(expression);\n                }\n            }\n            function releaseInstances() {\n                var i;\n                var len = registers.length;\n                for(i = 0; i < len; i += 1){\n                    registers[i].release();\n                }\n                registers.length = 0;\n            }\n            animation.renderer.compInterface = CompExpressionInterface(animation.renderer);\n            animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);\n            animation.renderer.globalData.pushExpression = pushExpression;\n            animation.renderer.globalData.popExpression = popExpression;\n            animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;\n        }\n        return ob;\n    }();\n    var MaskManagerInterface = function() {\n        function MaskInterface(mask, data) {\n            this._mask = mask;\n            this._data = data;\n        }\n        Object.defineProperty(MaskInterface.prototype, \"maskPath\", {\n            get: function get() {\n                if (this._mask.prop.k) {\n                    this._mask.prop.getValue();\n                }\n                return this._mask.prop;\n            }\n        });\n        Object.defineProperty(MaskInterface.prototype, \"maskOpacity\", {\n            get: function get() {\n                if (this._mask.op.k) {\n                    this._mask.op.getValue();\n                }\n                return this._mask.op.v * 100;\n            }\n        });\n        var MaskManager = function MaskManager(maskManager) {\n            var _masksInterfaces = createSizedArray(maskManager.viewData.length);\n            var i;\n            var len = maskManager.viewData.length;\n            for(i = 0; i < len; i += 1){\n                _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);\n            }\n            var maskFunction = function maskFunction(name) {\n                i = 0;\n                while(i < len){\n                    if (maskManager.masksProperties[i].nm === name) {\n                        return _masksInterfaces[i];\n                    }\n                    i += 1;\n                }\n                return null;\n            };\n            return maskFunction;\n        };\n        return MaskManager;\n    }();\n    var ExpressionPropertyInterface = function() {\n        var defaultUnidimensionalValue = {\n            pv: 0,\n            v: 0,\n            mult: 1\n        };\n        var defaultMultidimensionalValue = {\n            pv: [\n                0,\n                0,\n                0\n            ],\n            v: [\n                0,\n                0,\n                0\n            ],\n            mult: 1\n        };\n        function completeProperty(expressionValue, property, type) {\n            Object.defineProperty(expressionValue, \"velocity\", {\n                get: function get() {\n                    return property.getVelocityAtTime(property.comp.currentFrame);\n                }\n            });\n            expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;\n            expressionValue.key = function(pos) {\n                if (!expressionValue.numKeys) {\n                    return 0;\n                }\n                var value = \"\";\n                if (\"s\" in property.keyframes[pos - 1]) {\n                    value = property.keyframes[pos - 1].s;\n                } else if (\"e\" in property.keyframes[pos - 2]) {\n                    value = property.keyframes[pos - 2].e;\n                } else {\n                    value = property.keyframes[pos - 2].s;\n                }\n                var valueProp = type === \"unidimensional\" ? new Number(value) : Object.assign({}, value); // eslint-disable-line no-new-wrappers\n                valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate;\n                valueProp.value = type === \"unidimensional\" ? value[0] : value;\n                return valueProp;\n            };\n            expressionValue.valueAtTime = property.getValueAtTime;\n            expressionValue.speedAtTime = property.getSpeedAtTime;\n            expressionValue.velocityAtTime = property.getVelocityAtTime;\n            expressionValue.propertyGroup = property.propertyGroup;\n        }\n        function UnidimensionalPropertyInterface(property) {\n            if (!property || !(\"pv\" in property)) {\n                property = defaultUnidimensionalValue;\n            }\n            var mult = 1 / property.mult;\n            var val = property.pv * mult;\n            var expressionValue = new Number(val); // eslint-disable-line no-new-wrappers\n            expressionValue.value = val;\n            completeProperty(expressionValue, property, \"unidimensional\");\n            return function() {\n                if (property.k) {\n                    property.getValue();\n                }\n                val = property.v * mult;\n                if (expressionValue.value !== val) {\n                    expressionValue = new Number(val); // eslint-disable-line no-new-wrappers\n                    expressionValue.value = val;\n                    completeProperty(expressionValue, property, \"unidimensional\");\n                }\n                return expressionValue;\n            };\n        }\n        function MultidimensionalPropertyInterface(property) {\n            if (!property || !(\"pv\" in property)) {\n                property = defaultMultidimensionalValue;\n            }\n            var mult = 1 / property.mult;\n            var len = property.data && property.data.l || property.pv.length;\n            var expressionValue = createTypedArray(\"float32\", len);\n            var arrValue = createTypedArray(\"float32\", len);\n            expressionValue.value = arrValue;\n            completeProperty(expressionValue, property, \"multidimensional\");\n            return function() {\n                if (property.k) {\n                    property.getValue();\n                }\n                for(var i = 0; i < len; i += 1){\n                    arrValue[i] = property.v[i] * mult;\n                    expressionValue[i] = arrValue[i];\n                }\n                return expressionValue;\n            };\n        } // TODO: try to avoid using this getter\n        function defaultGetter() {\n            return defaultUnidimensionalValue;\n        }\n        return function(property) {\n            if (!property) {\n                return defaultGetter;\n            }\n            if (property.propType === \"unidimensional\") {\n                return UnidimensionalPropertyInterface(property);\n            }\n            return MultidimensionalPropertyInterface(property);\n        };\n    }();\n    var TransformExpressionInterface = function() {\n        return function(transform) {\n            function _thisFunction(name) {\n                switch(name){\n                    case \"scale\":\n                    case \"Scale\":\n                    case \"ADBE Scale\":\n                    case 6:\n                        return _thisFunction.scale;\n                    case \"rotation\":\n                    case \"Rotation\":\n                    case \"ADBE Rotation\":\n                    case \"ADBE Rotate Z\":\n                    case 10:\n                        return _thisFunction.rotation;\n                    case \"ADBE Rotate X\":\n                        return _thisFunction.xRotation;\n                    case \"ADBE Rotate Y\":\n                        return _thisFunction.yRotation;\n                    case \"position\":\n                    case \"Position\":\n                    case \"ADBE Position\":\n                    case 2:\n                        return _thisFunction.position;\n                    case \"ADBE Position_0\":\n                        return _thisFunction.xPosition;\n                    case \"ADBE Position_1\":\n                        return _thisFunction.yPosition;\n                    case \"ADBE Position_2\":\n                        return _thisFunction.zPosition;\n                    case \"anchorPoint\":\n                    case \"AnchorPoint\":\n                    case \"Anchor Point\":\n                    case \"ADBE AnchorPoint\":\n                    case 1:\n                        return _thisFunction.anchorPoint;\n                    case \"opacity\":\n                    case \"Opacity\":\n                    case 11:\n                        return _thisFunction.opacity;\n                    default:\n                        return null;\n                }\n            }\n            Object.defineProperty(_thisFunction, \"rotation\", {\n                get: ExpressionPropertyInterface(transform.r || transform.rz)\n            });\n            Object.defineProperty(_thisFunction, \"zRotation\", {\n                get: ExpressionPropertyInterface(transform.rz || transform.r)\n            });\n            Object.defineProperty(_thisFunction, \"xRotation\", {\n                get: ExpressionPropertyInterface(transform.rx)\n            });\n            Object.defineProperty(_thisFunction, \"yRotation\", {\n                get: ExpressionPropertyInterface(transform.ry)\n            });\n            Object.defineProperty(_thisFunction, \"scale\", {\n                get: ExpressionPropertyInterface(transform.s)\n            });\n            var _px;\n            var _py;\n            var _pz;\n            var _transformFactory;\n            if (transform.p) {\n                _transformFactory = ExpressionPropertyInterface(transform.p);\n            } else {\n                _px = ExpressionPropertyInterface(transform.px);\n                _py = ExpressionPropertyInterface(transform.py);\n                if (transform.pz) {\n                    _pz = ExpressionPropertyInterface(transform.pz);\n                }\n            }\n            Object.defineProperty(_thisFunction, \"position\", {\n                get: function get() {\n                    if (transform.p) {\n                        return _transformFactory();\n                    }\n                    return [\n                        _px(),\n                        _py(),\n                        _pz ? _pz() : 0\n                    ];\n                }\n            });\n            Object.defineProperty(_thisFunction, \"xPosition\", {\n                get: ExpressionPropertyInterface(transform.px)\n            });\n            Object.defineProperty(_thisFunction, \"yPosition\", {\n                get: ExpressionPropertyInterface(transform.py)\n            });\n            Object.defineProperty(_thisFunction, \"zPosition\", {\n                get: ExpressionPropertyInterface(transform.pz)\n            });\n            Object.defineProperty(_thisFunction, \"anchorPoint\", {\n                get: ExpressionPropertyInterface(transform.a)\n            });\n            Object.defineProperty(_thisFunction, \"opacity\", {\n                get: ExpressionPropertyInterface(transform.o)\n            });\n            Object.defineProperty(_thisFunction, \"skew\", {\n                get: ExpressionPropertyInterface(transform.sk)\n            });\n            Object.defineProperty(_thisFunction, \"skewAxis\", {\n                get: ExpressionPropertyInterface(transform.sa)\n            });\n            Object.defineProperty(_thisFunction, \"orientation\", {\n                get: ExpressionPropertyInterface(transform.or)\n            });\n            return _thisFunction;\n        };\n    }();\n    var LayerExpressionInterface = function() {\n        function getMatrix(time) {\n            var toWorldMat = new Matrix();\n            if (time !== undefined) {\n                var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time);\n                propMatrix.clone(toWorldMat);\n            } else {\n                var transformMat = this._elem.finalTransform.mProp;\n                transformMat.applyToMatrix(toWorldMat);\n            }\n            return toWorldMat;\n        }\n        function toWorldVec(arr, time) {\n            var toWorldMat = this.getMatrix(time);\n            toWorldMat.props[12] = 0;\n            toWorldMat.props[13] = 0;\n            toWorldMat.props[14] = 0;\n            return this.applyPoint(toWorldMat, arr);\n        }\n        function toWorld(arr, time) {\n            var toWorldMat = this.getMatrix(time);\n            return this.applyPoint(toWorldMat, arr);\n        }\n        function fromWorldVec(arr, time) {\n            var toWorldMat = this.getMatrix(time);\n            toWorldMat.props[12] = 0;\n            toWorldMat.props[13] = 0;\n            toWorldMat.props[14] = 0;\n            return this.invertPoint(toWorldMat, arr);\n        }\n        function fromWorld(arr, time) {\n            var toWorldMat = this.getMatrix(time);\n            return this.invertPoint(toWorldMat, arr);\n        }\n        function applyPoint(matrix, arr) {\n            if (this._elem.hierarchy && this._elem.hierarchy.length) {\n                var i;\n                var len = this._elem.hierarchy.length;\n                for(i = 0; i < len; i += 1){\n                    this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);\n                }\n            }\n            return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);\n        }\n        function invertPoint(matrix, arr) {\n            if (this._elem.hierarchy && this._elem.hierarchy.length) {\n                var i;\n                var len = this._elem.hierarchy.length;\n                for(i = 0; i < len; i += 1){\n                    this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);\n                }\n            }\n            return matrix.inversePoint(arr);\n        }\n        function fromComp(arr) {\n            var toWorldMat = new Matrix();\n            toWorldMat.reset();\n            this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);\n            if (this._elem.hierarchy && this._elem.hierarchy.length) {\n                var i;\n                var len = this._elem.hierarchy.length;\n                for(i = 0; i < len; i += 1){\n                    this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);\n                }\n                return toWorldMat.inversePoint(arr);\n            }\n            return toWorldMat.inversePoint(arr);\n        }\n        function sampleImage() {\n            return [\n                1,\n                1,\n                1,\n                1\n            ];\n        }\n        return function(elem) {\n            var transformInterface;\n            function _registerMaskInterface(maskManager) {\n                _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);\n            }\n            function _registerEffectsInterface(effects) {\n                _thisLayerFunction.effect = effects;\n            }\n            function _thisLayerFunction(name) {\n                switch(name){\n                    case \"ADBE Root Vectors Group\":\n                    case \"Contents\":\n                    case 2:\n                        return _thisLayerFunction.shapeInterface;\n                    case 1:\n                    case 6:\n                    case \"Transform\":\n                    case \"transform\":\n                    case \"ADBE Transform Group\":\n                        return transformInterface;\n                    case 4:\n                    case \"ADBE Effect Parade\":\n                    case \"effects\":\n                    case \"Effects\":\n                        return _thisLayerFunction.effect;\n                    case \"ADBE Text Properties\":\n                        return _thisLayerFunction.textInterface;\n                    default:\n                        return null;\n                }\n            }\n            _thisLayerFunction.getMatrix = getMatrix;\n            _thisLayerFunction.invertPoint = invertPoint;\n            _thisLayerFunction.applyPoint = applyPoint;\n            _thisLayerFunction.toWorld = toWorld;\n            _thisLayerFunction.toWorldVec = toWorldVec;\n            _thisLayerFunction.fromWorld = fromWorld;\n            _thisLayerFunction.fromWorldVec = fromWorldVec;\n            _thisLayerFunction.toComp = toWorld;\n            _thisLayerFunction.fromComp = fromComp;\n            _thisLayerFunction.sampleImage = sampleImage;\n            _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);\n            _thisLayerFunction._elem = elem;\n            transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);\n            var anchorPointDescriptor = getDescriptor(transformInterface, \"anchorPoint\");\n            Object.defineProperties(_thisLayerFunction, {\n                hasParent: {\n                    get: function get() {\n                        return elem.hierarchy.length;\n                    }\n                },\n                parent: {\n                    get: function get() {\n                        return elem.hierarchy[0].layerInterface;\n                    }\n                },\n                rotation: getDescriptor(transformInterface, \"rotation\"),\n                scale: getDescriptor(transformInterface, \"scale\"),\n                position: getDescriptor(transformInterface, \"position\"),\n                opacity: getDescriptor(transformInterface, \"opacity\"),\n                anchorPoint: anchorPointDescriptor,\n                anchor_point: anchorPointDescriptor,\n                transform: {\n                    get: function get() {\n                        return transformInterface;\n                    }\n                },\n                active: {\n                    get: function get() {\n                        return elem.isInRange;\n                    }\n                }\n            });\n            _thisLayerFunction.startTime = elem.data.st;\n            _thisLayerFunction.index = elem.data.ind;\n            _thisLayerFunction.source = elem.data.refId;\n            _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;\n            _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;\n            _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate;\n            _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate;\n            _thisLayerFunction._name = elem.data.nm;\n            _thisLayerFunction.registerMaskInterface = _registerMaskInterface;\n            _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;\n            return _thisLayerFunction;\n        };\n    }();\n    var propertyGroupFactory = function() {\n        return function(interfaceFunction, parentPropertyGroup) {\n            return function(val) {\n                val = val === undefined ? 1 : val;\n                if (val <= 0) {\n                    return interfaceFunction;\n                }\n                return parentPropertyGroup(val - 1);\n            };\n        };\n    }();\n    var PropertyInterface = function() {\n        return function(propertyName, propertyGroup) {\n            var interfaceFunction = {\n                _name: propertyName\n            };\n            function _propertyGroup(val) {\n                val = val === undefined ? 1 : val;\n                if (val <= 0) {\n                    return interfaceFunction;\n                }\n                return propertyGroup(val - 1);\n            }\n            return _propertyGroup;\n        };\n    }();\n    var EffectsExpressionInterface = function() {\n        var ob = {\n            createEffectsInterface: createEffectsInterface\n        };\n        function createEffectsInterface(elem, propertyGroup) {\n            if (elem.effectsManager) {\n                var effectElements = [];\n                var effectsData = elem.data.ef;\n                var i;\n                var len = elem.effectsManager.effectElements.length;\n                for(i = 0; i < len; i += 1){\n                    effectElements.push(createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem));\n                }\n                var effects = elem.data.ef || [];\n                var groupInterface = function groupInterface(name) {\n                    i = 0;\n                    len = effects.length;\n                    while(i < len){\n                        if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {\n                            return effectElements[i];\n                        }\n                        i += 1;\n                    }\n                    return null;\n                };\n                Object.defineProperty(groupInterface, \"numProperties\", {\n                    get: function get() {\n                        return effects.length;\n                    }\n                });\n                return groupInterface;\n            }\n            return null;\n        }\n        function createGroupInterface(data, elements, propertyGroup, elem) {\n            function groupInterface(name) {\n                var effects = data.ef;\n                var i = 0;\n                var len = effects.length;\n                while(i < len){\n                    if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {\n                        if (effects[i].ty === 5) {\n                            return effectElements[i];\n                        }\n                        return effectElements[i]();\n                    }\n                    i += 1;\n                }\n                throw new Error();\n            }\n            var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);\n            var effectElements = [];\n            var i;\n            var len = data.ef.length;\n            for(i = 0; i < len; i += 1){\n                if (data.ef[i].ty === 5) {\n                    effectElements.push(createGroupInterface(data.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem));\n                } else {\n                    effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup));\n                }\n            }\n            if (data.mn === \"ADBE Color Control\") {\n                Object.defineProperty(groupInterface, \"color\", {\n                    get: function get() {\n                        return effectElements[0]();\n                    }\n                });\n            }\n            Object.defineProperties(groupInterface, {\n                numProperties: {\n                    get: function get() {\n                        return data.np;\n                    }\n                },\n                _name: {\n                    value: data.nm\n                },\n                propertyGroup: {\n                    value: _propertyGroup\n                }\n            });\n            groupInterface.enabled = data.en !== 0;\n            groupInterface.active = groupInterface.enabled;\n            return groupInterface;\n        }\n        function createValueInterface(element, type, elem, propertyGroup) {\n            var expressionProperty = ExpressionPropertyInterface(element.p);\n            function interfaceFunction() {\n                if (type === 10) {\n                    return elem.comp.compInterface(element.p.v);\n                }\n                return expressionProperty();\n            }\n            if (element.p.setGroupProperty) {\n                element.p.setGroupProperty(PropertyInterface(\"\", propertyGroup));\n            }\n            return interfaceFunction;\n        }\n        return ob;\n    }();\n    var ShapePathInterface = function() {\n        return function pathInterfaceFactory(shape, view, propertyGroup) {\n            var prop = view.sh;\n            function interfaceFunction(val) {\n                if (val === \"Shape\" || val === \"shape\" || val === \"Path\" || val === \"path\" || val === \"ADBE Vector Shape\" || val === 2) {\n                    return interfaceFunction.path;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            prop.setGroupProperty(PropertyInterface(\"Path\", _propertyGroup));\n            Object.defineProperties(interfaceFunction, {\n                path: {\n                    get: function get() {\n                        if (prop.k) {\n                            prop.getValue();\n                        }\n                        return prop;\n                    }\n                },\n                shape: {\n                    get: function get() {\n                        if (prop.k) {\n                            prop.getValue();\n                        }\n                        return prop;\n                    }\n                },\n                _name: {\n                    value: shape.nm\n                },\n                ix: {\n                    value: shape.ix\n                },\n                propertyIndex: {\n                    value: shape.ix\n                },\n                mn: {\n                    value: shape.mn\n                },\n                propertyGroup: {\n                    value: propertyGroup\n                }\n            });\n            return interfaceFunction;\n        };\n    }();\n    var ShapeExpressionInterface = function() {\n        function iterateElements(shapes, view, propertyGroup) {\n            var arr = [];\n            var i;\n            var len = shapes ? shapes.length : 0;\n            for(i = 0; i < len; i += 1){\n                if (shapes[i].ty === \"gr\") {\n                    arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"fl\") {\n                    arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"st\") {\n                    arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"tm\") {\n                    arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"tr\") {} else if (shapes[i].ty === \"el\") {\n                    arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"sr\") {\n                    arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"sh\") {\n                    arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"rc\") {\n                    arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"rd\") {\n                    arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"rp\") {\n                    arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"gf\") {\n                    arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else {\n                    arr.push(defaultInterfaceFactory(shapes[i], view[i], propertyGroup));\n                }\n            }\n            return arr;\n        }\n        function contentsInterfaceFactory(shape, view, propertyGroup) {\n            var interfaces;\n            var interfaceFunction = function _interfaceFunction(value) {\n                var i = 0;\n                var len = interfaces.length;\n                while(i < len){\n                    if (interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value) {\n                        return interfaces[i];\n                    }\n                    i += 1;\n                }\n                if (typeof value === \"number\") {\n                    return interfaces[value - 1];\n                }\n                return null;\n            };\n            interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);\n            interfaceFunction.numProperties = interfaces.length;\n            var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);\n            interfaceFunction.transform = transformInterface;\n            interfaceFunction.propertyIndex = shape.cix;\n            interfaceFunction._name = shape.nm;\n            return interfaceFunction;\n        }\n        function groupInterfaceFactory(shape, view, propertyGroup) {\n            var interfaceFunction = function _interfaceFunction(value) {\n                switch(value){\n                    case \"ADBE Vectors Group\":\n                    case \"Contents\":\n                    case 2:\n                        return interfaceFunction.content;\n                    // Not necessary for now. Keeping them here in case a new case appears\n                    // case 'ADBE Vector Transform Group':\n                    // case 3:\n                    default:\n                        return interfaceFunction.transform;\n                }\n            };\n            interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            var content = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);\n            var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);\n            interfaceFunction.content = content;\n            interfaceFunction.transform = transformInterface;\n            Object.defineProperty(interfaceFunction, \"_name\", {\n                get: function get() {\n                    return shape.nm;\n                }\n            }); // interfaceFunction.content = interfaceFunction;\n            interfaceFunction.numProperties = shape.np;\n            interfaceFunction.propertyIndex = shape.ix;\n            interfaceFunction.nm = shape.nm;\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        function fillInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(val) {\n                if (val === \"Color\" || val === \"color\") {\n                    return interfaceFunction.color;\n                }\n                if (val === \"Opacity\" || val === \"opacity\") {\n                    return interfaceFunction.opacity;\n                }\n                return null;\n            }\n            Object.defineProperties(interfaceFunction, {\n                color: {\n                    get: ExpressionPropertyInterface(view.c)\n                },\n                opacity: {\n                    get: ExpressionPropertyInterface(view.o)\n                },\n                _name: {\n                    value: shape.nm\n                },\n                mn: {\n                    value: shape.mn\n                }\n            });\n            view.c.setGroupProperty(PropertyInterface(\"Color\", propertyGroup));\n            view.o.setGroupProperty(PropertyInterface(\"Opacity\", propertyGroup));\n            return interfaceFunction;\n        }\n        function gradientFillInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(val) {\n                if (val === \"Start Point\" || val === \"start point\") {\n                    return interfaceFunction.startPoint;\n                }\n                if (val === \"End Point\" || val === \"end point\") {\n                    return interfaceFunction.endPoint;\n                }\n                if (val === \"Opacity\" || val === \"opacity\") {\n                    return interfaceFunction.opacity;\n                }\n                return null;\n            }\n            Object.defineProperties(interfaceFunction, {\n                startPoint: {\n                    get: ExpressionPropertyInterface(view.s)\n                },\n                endPoint: {\n                    get: ExpressionPropertyInterface(view.e)\n                },\n                opacity: {\n                    get: ExpressionPropertyInterface(view.o)\n                },\n                type: {\n                    get: function get() {\n                        return \"a\";\n                    }\n                },\n                _name: {\n                    value: shape.nm\n                },\n                mn: {\n                    value: shape.mn\n                }\n            });\n            view.s.setGroupProperty(PropertyInterface(\"Start Point\", propertyGroup));\n            view.e.setGroupProperty(PropertyInterface(\"End Point\", propertyGroup));\n            view.o.setGroupProperty(PropertyInterface(\"Opacity\", propertyGroup));\n            return interfaceFunction;\n        }\n        function defaultInterfaceFactory() {\n            function interfaceFunction() {\n                return null;\n            }\n            return interfaceFunction;\n        }\n        function strokeInterfaceFactory(shape, view, propertyGroup) {\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);\n            function addPropertyToDashOb(i) {\n                Object.defineProperty(dashOb, shape.d[i].nm, {\n                    get: ExpressionPropertyInterface(view.d.dataProps[i].p)\n                });\n            }\n            var i;\n            var len = shape.d ? shape.d.length : 0;\n            var dashOb = {};\n            for(i = 0; i < len; i += 1){\n                addPropertyToDashOb(i);\n                view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);\n            }\n            function interfaceFunction(val) {\n                if (val === \"Color\" || val === \"color\") {\n                    return interfaceFunction.color;\n                }\n                if (val === \"Opacity\" || val === \"opacity\") {\n                    return interfaceFunction.opacity;\n                }\n                if (val === \"Stroke Width\" || val === \"stroke width\") {\n                    return interfaceFunction.strokeWidth;\n                }\n                return null;\n            }\n            Object.defineProperties(interfaceFunction, {\n                color: {\n                    get: ExpressionPropertyInterface(view.c)\n                },\n                opacity: {\n                    get: ExpressionPropertyInterface(view.o)\n                },\n                strokeWidth: {\n                    get: ExpressionPropertyInterface(view.w)\n                },\n                dash: {\n                    get: function get() {\n                        return dashOb;\n                    }\n                },\n                _name: {\n                    value: shape.nm\n                },\n                mn: {\n                    value: shape.mn\n                }\n            });\n            view.c.setGroupProperty(PropertyInterface(\"Color\", _propertyGroup));\n            view.o.setGroupProperty(PropertyInterface(\"Opacity\", _propertyGroup));\n            view.w.setGroupProperty(PropertyInterface(\"Stroke Width\", _propertyGroup));\n            return interfaceFunction;\n        }\n        function trimInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(val) {\n                if (val === shape.e.ix || val === \"End\" || val === \"end\") {\n                    return interfaceFunction.end;\n                }\n                if (val === shape.s.ix) {\n                    return interfaceFunction.start;\n                }\n                if (val === shape.o.ix) {\n                    return interfaceFunction.offset;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            interfaceFunction.propertyIndex = shape.ix;\n            view.s.setGroupProperty(PropertyInterface(\"Start\", _propertyGroup));\n            view.e.setGroupProperty(PropertyInterface(\"End\", _propertyGroup));\n            view.o.setGroupProperty(PropertyInterface(\"Offset\", _propertyGroup));\n            interfaceFunction.propertyIndex = shape.ix;\n            interfaceFunction.propertyGroup = propertyGroup;\n            Object.defineProperties(interfaceFunction, {\n                start: {\n                    get: ExpressionPropertyInterface(view.s)\n                },\n                end: {\n                    get: ExpressionPropertyInterface(view.e)\n                },\n                offset: {\n                    get: ExpressionPropertyInterface(view.o)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        function transformInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(value) {\n                if (shape.a.ix === value || value === \"Anchor Point\") {\n                    return interfaceFunction.anchorPoint;\n                }\n                if (shape.o.ix === value || value === \"Opacity\") {\n                    return interfaceFunction.opacity;\n                }\n                if (shape.p.ix === value || value === \"Position\") {\n                    return interfaceFunction.position;\n                }\n                if (shape.r.ix === value || value === \"Rotation\" || value === \"ADBE Vector Rotation\") {\n                    return interfaceFunction.rotation;\n                }\n                if (shape.s.ix === value || value === \"Scale\") {\n                    return interfaceFunction.scale;\n                }\n                if (shape.sk && shape.sk.ix === value || value === \"Skew\") {\n                    return interfaceFunction.skew;\n                }\n                if (shape.sa && shape.sa.ix === value || value === \"Skew Axis\") {\n                    return interfaceFunction.skewAxis;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            view.transform.mProps.o.setGroupProperty(PropertyInterface(\"Opacity\", _propertyGroup));\n            view.transform.mProps.p.setGroupProperty(PropertyInterface(\"Position\", _propertyGroup));\n            view.transform.mProps.a.setGroupProperty(PropertyInterface(\"Anchor Point\", _propertyGroup));\n            view.transform.mProps.s.setGroupProperty(PropertyInterface(\"Scale\", _propertyGroup));\n            view.transform.mProps.r.setGroupProperty(PropertyInterface(\"Rotation\", _propertyGroup));\n            if (view.transform.mProps.sk) {\n                view.transform.mProps.sk.setGroupProperty(PropertyInterface(\"Skew\", _propertyGroup));\n                view.transform.mProps.sa.setGroupProperty(PropertyInterface(\"Skew Angle\", _propertyGroup));\n            }\n            view.transform.op.setGroupProperty(PropertyInterface(\"Opacity\", _propertyGroup));\n            Object.defineProperties(interfaceFunction, {\n                opacity: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.o)\n                },\n                position: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.p)\n                },\n                anchorPoint: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.a)\n                },\n                scale: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.s)\n                },\n                rotation: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.r)\n                },\n                skew: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.sk)\n                },\n                skewAxis: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.sa)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.ty = \"tr\";\n            interfaceFunction.mn = shape.mn;\n            interfaceFunction.propertyGroup = propertyGroup;\n            return interfaceFunction;\n        }\n        function ellipseInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(value) {\n                if (shape.p.ix === value) {\n                    return interfaceFunction.position;\n                }\n                if (shape.s.ix === value) {\n                    return interfaceFunction.size;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            interfaceFunction.propertyIndex = shape.ix;\n            var prop = view.sh.ty === \"tm\" ? view.sh.prop : view.sh;\n            prop.s.setGroupProperty(PropertyInterface(\"Size\", _propertyGroup));\n            prop.p.setGroupProperty(PropertyInterface(\"Position\", _propertyGroup));\n            Object.defineProperties(interfaceFunction, {\n                size: {\n                    get: ExpressionPropertyInterface(prop.s)\n                },\n                position: {\n                    get: ExpressionPropertyInterface(prop.p)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        function starInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(value) {\n                if (shape.p.ix === value) {\n                    return interfaceFunction.position;\n                }\n                if (shape.r.ix === value) {\n                    return interfaceFunction.rotation;\n                }\n                if (shape.pt.ix === value) {\n                    return interfaceFunction.points;\n                }\n                if (shape.or.ix === value || value === \"ADBE Vector Star Outer Radius\") {\n                    return interfaceFunction.outerRadius;\n                }\n                if (shape.os.ix === value) {\n                    return interfaceFunction.outerRoundness;\n                }\n                if (shape.ir && (shape.ir.ix === value || value === \"ADBE Vector Star Inner Radius\")) {\n                    return interfaceFunction.innerRadius;\n                }\n                if (shape.is && shape.is.ix === value) {\n                    return interfaceFunction.innerRoundness;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            var prop = view.sh.ty === \"tm\" ? view.sh.prop : view.sh;\n            interfaceFunction.propertyIndex = shape.ix;\n            prop.or.setGroupProperty(PropertyInterface(\"Outer Radius\", _propertyGroup));\n            prop.os.setGroupProperty(PropertyInterface(\"Outer Roundness\", _propertyGroup));\n            prop.pt.setGroupProperty(PropertyInterface(\"Points\", _propertyGroup));\n            prop.p.setGroupProperty(PropertyInterface(\"Position\", _propertyGroup));\n            prop.r.setGroupProperty(PropertyInterface(\"Rotation\", _propertyGroup));\n            if (shape.ir) {\n                prop.ir.setGroupProperty(PropertyInterface(\"Inner Radius\", _propertyGroup));\n                prop.is.setGroupProperty(PropertyInterface(\"Inner Roundness\", _propertyGroup));\n            }\n            Object.defineProperties(interfaceFunction, {\n                position: {\n                    get: ExpressionPropertyInterface(prop.p)\n                },\n                rotation: {\n                    get: ExpressionPropertyInterface(prop.r)\n                },\n                points: {\n                    get: ExpressionPropertyInterface(prop.pt)\n                },\n                outerRadius: {\n                    get: ExpressionPropertyInterface(prop.or)\n                },\n                outerRoundness: {\n                    get: ExpressionPropertyInterface(prop.os)\n                },\n                innerRadius: {\n                    get: ExpressionPropertyInterface(prop.ir)\n                },\n                innerRoundness: {\n                    get: ExpressionPropertyInterface(prop.is)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        function rectInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(value) {\n                if (shape.p.ix === value) {\n                    return interfaceFunction.position;\n                }\n                if (shape.r.ix === value) {\n                    return interfaceFunction.roundness;\n                }\n                if (shape.s.ix === value || value === \"Size\" || value === \"ADBE Vector Rect Size\") {\n                    return interfaceFunction.size;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            var prop = view.sh.ty === \"tm\" ? view.sh.prop : view.sh;\n            interfaceFunction.propertyIndex = shape.ix;\n            prop.p.setGroupProperty(PropertyInterface(\"Position\", _propertyGroup));\n            prop.s.setGroupProperty(PropertyInterface(\"Size\", _propertyGroup));\n            prop.r.setGroupProperty(PropertyInterface(\"Rotation\", _propertyGroup));\n            Object.defineProperties(interfaceFunction, {\n                position: {\n                    get: ExpressionPropertyInterface(prop.p)\n                },\n                roundness: {\n                    get: ExpressionPropertyInterface(prop.r)\n                },\n                size: {\n                    get: ExpressionPropertyInterface(prop.s)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        function roundedInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(value) {\n                if (shape.r.ix === value || value === \"Round Corners 1\") {\n                    return interfaceFunction.radius;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            var prop = view;\n            interfaceFunction.propertyIndex = shape.ix;\n            prop.rd.setGroupProperty(PropertyInterface(\"Radius\", _propertyGroup));\n            Object.defineProperties(interfaceFunction, {\n                radius: {\n                    get: ExpressionPropertyInterface(prop.rd)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        function repeaterInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(value) {\n                if (shape.c.ix === value || value === \"Copies\") {\n                    return interfaceFunction.copies;\n                }\n                if (shape.o.ix === value || value === \"Offset\") {\n                    return interfaceFunction.offset;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            var prop = view;\n            interfaceFunction.propertyIndex = shape.ix;\n            prop.c.setGroupProperty(PropertyInterface(\"Copies\", _propertyGroup));\n            prop.o.setGroupProperty(PropertyInterface(\"Offset\", _propertyGroup));\n            Object.defineProperties(interfaceFunction, {\n                copies: {\n                    get: ExpressionPropertyInterface(prop.c)\n                },\n                offset: {\n                    get: ExpressionPropertyInterface(prop.o)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        return function(shapes, view, propertyGroup) {\n            var interfaces;\n            function _interfaceFunction(value) {\n                if (typeof value === \"number\") {\n                    value = value === undefined ? 1 : value;\n                    if (value === 0) {\n                        return propertyGroup;\n                    }\n                    return interfaces[value - 1];\n                }\n                var i = 0;\n                var len = interfaces.length;\n                while(i < len){\n                    if (interfaces[i]._name === value) {\n                        return interfaces[i];\n                    }\n                    i += 1;\n                }\n                return null;\n            }\n            function parentGroupWrapper() {\n                return propertyGroup;\n            }\n            _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);\n            interfaces = iterateElements(shapes, view, _interfaceFunction.propertyGroup);\n            _interfaceFunction.numProperties = interfaces.length;\n            _interfaceFunction._name = \"Contents\";\n            return _interfaceFunction;\n        };\n    }();\n    var TextExpressionInterface = function() {\n        return function(elem) {\n            var _sourceText;\n            function _thisLayerFunction(name) {\n                switch(name){\n                    case \"ADBE Text Document\":\n                        return _thisLayerFunction.sourceText;\n                    default:\n                        return null;\n                }\n            }\n            Object.defineProperty(_thisLayerFunction, \"sourceText\", {\n                get: function get() {\n                    elem.textProperty.getValue();\n                    var stringValue = elem.textProperty.currentData.t;\n                    if (!_sourceText || stringValue !== _sourceText.value) {\n                        _sourceText = new String(stringValue); // eslint-disable-line no-new-wrappers\n                        // If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive\n                        _sourceText.value = stringValue || new String(stringValue); // eslint-disable-line no-new-wrappers\n                        Object.defineProperty(_sourceText, \"style\", {\n                            get: function get() {\n                                return {\n                                    fillColor: elem.textProperty.currentData.fc\n                                };\n                            }\n                        });\n                    }\n                    return _sourceText;\n                }\n            });\n            return _thisLayerFunction;\n        };\n    }();\n    function _typeof(obj) {\n        \"@babel/helpers - typeof\";\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n                return typeof obj;\n            };\n        } else {\n            _typeof = function _typeof(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n        }\n        return _typeof(obj);\n    }\n    var FootageInterface = function() {\n        var outlineInterfaceFactory = function outlineInterfaceFactory(elem) {\n            var currentPropertyName = \"\";\n            var currentProperty = elem.getFootageData();\n            function init() {\n                currentPropertyName = \"\";\n                currentProperty = elem.getFootageData();\n                return searchProperty;\n            }\n            function searchProperty(value) {\n                if (currentProperty[value]) {\n                    currentPropertyName = value;\n                    currentProperty = currentProperty[value];\n                    if (_typeof(currentProperty) === \"object\") {\n                        return searchProperty;\n                    }\n                    return currentProperty;\n                }\n                var propertyNameIndex = value.indexOf(currentPropertyName);\n                if (propertyNameIndex !== -1) {\n                    var index = parseInt(value.substr(propertyNameIndex + currentPropertyName.length), 10);\n                    currentProperty = currentProperty[index];\n                    if (_typeof(currentProperty) === \"object\") {\n                        return searchProperty;\n                    }\n                    return currentProperty;\n                }\n                return \"\";\n            }\n            return init;\n        };\n        var dataInterfaceFactory = function dataInterfaceFactory(elem) {\n            function interfaceFunction(value) {\n                if (value === \"Outline\") {\n                    return interfaceFunction.outlineInterface();\n                }\n                return null;\n            }\n            interfaceFunction._name = \"Outline\";\n            interfaceFunction.outlineInterface = outlineInterfaceFactory(elem);\n            return interfaceFunction;\n        };\n        return function(elem) {\n            function _interfaceFunction(value) {\n                if (value === \"Data\") {\n                    return _interfaceFunction.dataInterface;\n                }\n                return null;\n            }\n            _interfaceFunction._name = \"Data\";\n            _interfaceFunction.dataInterface = dataInterfaceFactory(elem);\n            return _interfaceFunction;\n        };\n    }();\n    var interfaces = {\n        layer: LayerExpressionInterface,\n        effects: EffectsExpressionInterface,\n        comp: CompExpressionInterface,\n        shape: ShapeExpressionInterface,\n        text: TextExpressionInterface,\n        footage: FootageInterface\n    };\n    function getInterface(type) {\n        return interfaces[type] || null;\n    }\n    var expressionHelpers = function() {\n        function searchExpressions(elem, data, prop) {\n            if (data.x) {\n                prop.k = true;\n                prop.x = true;\n                prop.initiateExpression = ExpressionManager.initiateExpression;\n                prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop));\n            }\n        }\n        function getValueAtTime(frameNum) {\n            frameNum *= this.elem.globalData.frameRate;\n            frameNum -= this.offsetTime;\n            if (frameNum !== this._cachingAtTime.lastFrame) {\n                this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;\n                this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);\n                this._cachingAtTime.lastFrame = frameNum;\n            }\n            return this._cachingAtTime.value;\n        }\n        function getSpeedAtTime(frameNum) {\n            var delta = -0.01;\n            var v1 = this.getValueAtTime(frameNum);\n            var v2 = this.getValueAtTime(frameNum + delta);\n            var speed = 0;\n            if (v1.length) {\n                var i;\n                for(i = 0; i < v1.length; i += 1){\n                    speed += Math.pow(v2[i] - v1[i], 2);\n                }\n                speed = Math.sqrt(speed) * 100;\n            } else {\n                speed = 0;\n            }\n            return speed;\n        }\n        function getVelocityAtTime(frameNum) {\n            if (this.vel !== undefined) {\n                return this.vel;\n            }\n            var delta = -0.001; // frameNum += this.elem.data.st;\n            var v1 = this.getValueAtTime(frameNum);\n            var v2 = this.getValueAtTime(frameNum + delta);\n            var velocity;\n            if (v1.length) {\n                velocity = createTypedArray(\"float32\", v1.length);\n                var i;\n                for(i = 0; i < v1.length; i += 1){\n                    // removing frameRate\n                    // if needed, don't add it here\n                    // velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);\n                    velocity[i] = (v2[i] - v1[i]) / delta;\n                }\n            } else {\n                velocity = (v2 - v1) / delta;\n            }\n            return velocity;\n        }\n        function getStaticValueAtTime() {\n            return this.pv;\n        }\n        function setGroupProperty(propertyGroup) {\n            this.propertyGroup = propertyGroup;\n        }\n        return {\n            searchExpressions: searchExpressions,\n            getSpeedAtTime: getSpeedAtTime,\n            getVelocityAtTime: getVelocityAtTime,\n            getValueAtTime: getValueAtTime,\n            getStaticValueAtTime: getStaticValueAtTime,\n            setGroupProperty: setGroupProperty\n        };\n    }();\n    function addPropertyDecorator() {\n        function loopOut(type, duration, durationFlag) {\n            if (!this.k || !this.keyframes) {\n                return this.pv;\n            }\n            type = type ? type.toLowerCase() : \"\";\n            var currentFrame = this.comp.renderedFrame;\n            var keyframes = this.keyframes;\n            var lastKeyFrame = keyframes[keyframes.length - 1].t;\n            if (currentFrame <= lastKeyFrame) {\n                return this.pv;\n            }\n            var cycleDuration;\n            var firstKeyFrame;\n            if (!durationFlag) {\n                if (!duration || duration > keyframes.length - 1) {\n                    duration = keyframes.length - 1;\n                }\n                firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;\n                cycleDuration = lastKeyFrame - firstKeyFrame;\n            } else {\n                if (!duration) {\n                    cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);\n                } else {\n                    cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);\n                }\n                firstKeyFrame = lastKeyFrame - cycleDuration;\n            }\n            var i;\n            var len;\n            var ret;\n            if (type === \"pingpong\") {\n                var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);\n                if (iterations % 2 !== 0) {\n                    return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n                }\n            } else if (type === \"offset\") {\n                var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);\n                var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);\n                var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n                var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);\n                if (this.pv.length) {\n                    ret = new Array(initV.length);\n                    len = ret.length;\n                    for(i = 0; i < len; i += 1){\n                        ret[i] = (endV[i] - initV[i]) * repeats + current[i];\n                    }\n                    return ret;\n                }\n                return (endV - initV) * repeats + current;\n            } else if (type === \"continue\") {\n                var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);\n                var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);\n                if (this.pv.length) {\n                    ret = new Array(lastValue.length);\n                    len = ret.length;\n                    for(i = 0; i < len; i += 1){\n                        ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 0.0005; // eslint-disable-line\n                    }\n                    return ret;\n                }\n                return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / 0.001);\n            }\n            return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n        }\n        function loopIn(type, duration, durationFlag) {\n            if (!this.k) {\n                return this.pv;\n            }\n            type = type ? type.toLowerCase() : \"\";\n            var currentFrame = this.comp.renderedFrame;\n            var keyframes = this.keyframes;\n            var firstKeyFrame = keyframes[0].t;\n            if (currentFrame >= firstKeyFrame) {\n                return this.pv;\n            }\n            var cycleDuration;\n            var lastKeyFrame;\n            if (!durationFlag) {\n                if (!duration || duration > keyframes.length - 1) {\n                    duration = keyframes.length - 1;\n                }\n                lastKeyFrame = keyframes[duration].t;\n                cycleDuration = lastKeyFrame - firstKeyFrame;\n            } else {\n                if (!duration) {\n                    cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);\n                } else {\n                    cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);\n                }\n                lastKeyFrame = firstKeyFrame + cycleDuration;\n            }\n            var i;\n            var len;\n            var ret;\n            if (type === \"pingpong\") {\n                var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);\n                if (iterations % 2 === 0) {\n                    return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n                }\n            } else if (type === \"offset\") {\n                var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);\n                var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);\n                var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);\n                var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;\n                if (this.pv.length) {\n                    ret = new Array(initV.length);\n                    len = ret.length;\n                    for(i = 0; i < len; i += 1){\n                        ret[i] = current[i] - (endV[i] - initV[i]) * repeats;\n                    }\n                    return ret;\n                }\n                return current - (endV - initV) * repeats;\n            } else if (type === \"continue\") {\n                var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);\n                var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);\n                if (this.pv.length) {\n                    ret = new Array(firstValue.length);\n                    len = ret.length;\n                    for(i = 0; i < len; i += 1){\n                        ret[i] = firstValue[i] + (firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame) / 0.001;\n                    }\n                    return ret;\n                }\n                return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / 0.001;\n            }\n            return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n        }\n        function smooth(width, samples) {\n            if (!this.k) {\n                return this.pv;\n            }\n            width = (width || 0.4) * 0.5;\n            samples = Math.floor(samples || 5);\n            if (samples <= 1) {\n                return this.pv;\n            }\n            var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;\n            var initFrame = currentTime - width;\n            var endFrame = currentTime + width;\n            var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;\n            var i = 0;\n            var j = 0;\n            var value;\n            if (this.pv.length) {\n                value = createTypedArray(\"float32\", this.pv.length);\n            } else {\n                value = 0;\n            }\n            var sampleValue;\n            while(i < samples){\n                sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);\n                if (this.pv.length) {\n                    for(j = 0; j < this.pv.length; j += 1){\n                        value[j] += sampleValue[j];\n                    }\n                } else {\n                    value += sampleValue;\n                }\n                i += 1;\n            }\n            if (this.pv.length) {\n                for(j = 0; j < this.pv.length; j += 1){\n                    value[j] /= samples;\n                }\n            } else {\n                value /= samples;\n            }\n            return value;\n        }\n        function getTransformValueAtTime(time) {\n            if (!this._transformCachingAtTime) {\n                this._transformCachingAtTime = {\n                    v: new Matrix()\n                };\n            } /// /\n            var matrix = this._transformCachingAtTime.v;\n            matrix.cloneFromProps(this.pre.props);\n            if (this.appliedTransformations < 1) {\n                var anchor = this.a.getValueAtTime(time);\n                matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult);\n            }\n            if (this.appliedTransformations < 2) {\n                var scale = this.s.getValueAtTime(time);\n                matrix.scale(scale[0] * this.s.mult, scale[1] * this.s.mult, scale[2] * this.s.mult);\n            }\n            if (this.sk && this.appliedTransformations < 3) {\n                var skew = this.sk.getValueAtTime(time);\n                var skewAxis = this.sa.getValueAtTime(time);\n                matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);\n            }\n            if (this.r && this.appliedTransformations < 4) {\n                var rotation = this.r.getValueAtTime(time);\n                matrix.rotate(-rotation * this.r.mult);\n            } else if (!this.r && this.appliedTransformations < 4) {\n                var rotationZ = this.rz.getValueAtTime(time);\n                var rotationY = this.ry.getValueAtTime(time);\n                var rotationX = this.rx.getValueAtTime(time);\n                var orientation = this.or.getValueAtTime(time);\n                matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult);\n            }\n            if (this.data.p && this.data.p.s) {\n                var positionX = this.px.getValueAtTime(time);\n                var positionY = this.py.getValueAtTime(time);\n                if (this.data.p.z) {\n                    var positionZ = this.pz.getValueAtTime(time);\n                    matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult);\n                } else {\n                    matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);\n                }\n            } else {\n                var position = this.p.getValueAtTime(time);\n                matrix.translate(position[0] * this.p.mult, position[1] * this.p.mult, -position[2] * this.p.mult);\n            }\n            return matrix; /// /\n        }\n        function getTransformStaticValueAtTime() {\n            return this.v.clone(new Matrix());\n        }\n        var getTransformProperty = TransformPropertyFactory.getTransformProperty;\n        TransformPropertyFactory.getTransformProperty = function(elem, data, container) {\n            var prop = getTransformProperty(elem, data, container);\n            if (prop.dynamicProperties.length) {\n                prop.getValueAtTime = getTransformValueAtTime.bind(prop);\n            } else {\n                prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);\n            }\n            prop.setGroupProperty = expressionHelpers.setGroupProperty;\n            return prop;\n        };\n        var propertyGetProp = PropertyFactory.getProp;\n        PropertyFactory.getProp = function(elem, data, type, mult, container) {\n            var prop = propertyGetProp(elem, data, type, mult, container); // prop.getVelocityAtTime = getVelocityAtTime;\n            // prop.loopOut = loopOut;\n            // prop.loopIn = loopIn;\n            if (prop.kf) {\n                prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);\n            } else {\n                prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);\n            }\n            prop.setGroupProperty = expressionHelpers.setGroupProperty;\n            prop.loopOut = loopOut;\n            prop.loopIn = loopIn;\n            prop.smooth = smooth;\n            prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);\n            prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);\n            prop.numKeys = data.a === 1 ? data.k.length : 0;\n            prop.propertyIndex = data.ix;\n            var value = 0;\n            if (type !== 0) {\n                value = createTypedArray(\"float32\", data.a === 1 ? data.k[0].s.length : data.k.length);\n            }\n            prop._cachingAtTime = {\n                lastFrame: initialDefaultFrame,\n                lastIndex: 0,\n                value: value\n            };\n            expressionHelpers.searchExpressions(elem, data, prop);\n            if (prop.k) {\n                container.addDynamicProperty(prop);\n            }\n            return prop;\n        };\n        function getShapeValueAtTime(frameNum) {\n            // For now this caching object is created only when needed instead of creating it when the shape is initialized.\n            if (!this._cachingAtTime) {\n                this._cachingAtTime = {\n                    shapeValue: shapePool.clone(this.pv),\n                    lastIndex: 0,\n                    lastTime: initialDefaultFrame\n                };\n            }\n            frameNum *= this.elem.globalData.frameRate;\n            frameNum -= this.offsetTime;\n            if (frameNum !== this._cachingAtTime.lastTime) {\n                this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;\n                this._cachingAtTime.lastTime = frameNum;\n                this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);\n            }\n            return this._cachingAtTime.shapeValue;\n        }\n        var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();\n        var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();\n        function ShapeExpressions() {}\n        ShapeExpressions.prototype = {\n            vertices: function vertices(prop, time) {\n                if (this.k) {\n                    this.getValue();\n                }\n                var shapePath = this.v;\n                if (time !== undefined) {\n                    shapePath = this.getValueAtTime(time, 0);\n                }\n                var i;\n                var len = shapePath._length;\n                var vertices = shapePath[prop];\n                var points = shapePath.v;\n                var arr = createSizedArray(len);\n                for(i = 0; i < len; i += 1){\n                    if (prop === \"i\" || prop === \"o\") {\n                        arr[i] = [\n                            vertices[i][0] - points[i][0],\n                            vertices[i][1] - points[i][1]\n                        ];\n                    } else {\n                        arr[i] = [\n                            vertices[i][0],\n                            vertices[i][1]\n                        ];\n                    }\n                }\n                return arr;\n            },\n            points: function points(time) {\n                return this.vertices(\"v\", time);\n            },\n            inTangents: function inTangents(time) {\n                return this.vertices(\"i\", time);\n            },\n            outTangents: function outTangents(time) {\n                return this.vertices(\"o\", time);\n            },\n            isClosed: function isClosed() {\n                return this.v.c;\n            },\n            pointOnPath: function pointOnPath(perc, time) {\n                var shapePath = this.v;\n                if (time !== undefined) {\n                    shapePath = this.getValueAtTime(time, 0);\n                }\n                if (!this._segmentsLength) {\n                    this._segmentsLength = bez.getSegmentsLength(shapePath);\n                }\n                var segmentsLength = this._segmentsLength;\n                var lengths = segmentsLength.lengths;\n                var lengthPos = segmentsLength.totalLength * perc;\n                var i = 0;\n                var len = lengths.length;\n                var accumulatedLength = 0;\n                var pt;\n                while(i < len){\n                    if (accumulatedLength + lengths[i].addedLength > lengthPos) {\n                        var initIndex = i;\n                        var endIndex = shapePath.c && i === len - 1 ? 0 : i + 1;\n                        var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;\n                        pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);\n                        break;\n                    } else {\n                        accumulatedLength += lengths[i].addedLength;\n                    }\n                    i += 1;\n                }\n                if (!pt) {\n                    pt = shapePath.c ? [\n                        shapePath.v[0][0],\n                        shapePath.v[0][1]\n                    ] : [\n                        shapePath.v[shapePath._length - 1][0],\n                        shapePath.v[shapePath._length - 1][1]\n                    ];\n                }\n                return pt;\n            },\n            vectorOnPath: function vectorOnPath(perc, time, vectorType) {\n                // perc doesn't use triple equality because it can be a Number object as well as a primitive.\n                if (perc == 1) {\n                    // eslint-disable-line eqeqeq\n                    perc = this.v.c;\n                } else if (perc == 0) {\n                    // eslint-disable-line eqeqeq\n                    perc = 0.999;\n                }\n                var pt1 = this.pointOnPath(perc, time);\n                var pt2 = this.pointOnPath(perc + 0.001, time);\n                var xLength = pt2[0] - pt1[0];\n                var yLength = pt2[1] - pt1[1];\n                var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));\n                if (magnitude === 0) {\n                    return [\n                        0,\n                        0\n                    ];\n                }\n                var unitVector = vectorType === \"tangent\" ? [\n                    xLength / magnitude,\n                    yLength / magnitude\n                ] : [\n                    -yLength / magnitude,\n                    xLength / magnitude\n                ];\n                return unitVector;\n            },\n            tangentOnPath: function tangentOnPath(perc, time) {\n                return this.vectorOnPath(perc, time, \"tangent\");\n            },\n            normalOnPath: function normalOnPath(perc, time) {\n                return this.vectorOnPath(perc, time, \"normal\");\n            },\n            setGroupProperty: expressionHelpers.setGroupProperty,\n            getValueAtTime: expressionHelpers.getStaticValueAtTime\n        };\n        extendPrototype([\n            ShapeExpressions\n        ], ShapePropertyConstructorFunction);\n        extendPrototype([\n            ShapeExpressions\n        ], KeyframedShapePropertyConstructorFunction);\n        KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;\n        KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;\n        var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;\n        ShapePropertyFactory.getShapeProp = function(elem, data, type, arr, trims) {\n            var prop = propertyGetShapeProp(elem, data, type, arr, trims);\n            prop.propertyIndex = data.ix;\n            prop.lock = false;\n            if (type === 3) {\n                expressionHelpers.searchExpressions(elem, data.pt, prop);\n            } else if (type === 4) {\n                expressionHelpers.searchExpressions(elem, data.ks, prop);\n            }\n            if (prop.k) {\n                elem.addDynamicProperty(prop);\n            }\n            return prop;\n        };\n    }\n    function initialize$1() {\n        addPropertyDecorator();\n    }\n    function addDecorator() {\n        function searchExpressions() {\n            if (this.data.d.x) {\n                this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);\n                this.addEffect(this.getExpressionValue.bind(this));\n                return true;\n            }\n            return null;\n        }\n        TextProperty.prototype.getExpressionValue = function(currentValue, text) {\n            var newValue = this.calculateExpression(text);\n            if (currentValue.t !== newValue) {\n                var newData = {};\n                this.copyData(newData, currentValue);\n                newData.t = newValue.toString();\n                newData.__complete = false;\n                return newData;\n            }\n            return currentValue;\n        };\n        TextProperty.prototype.searchProperty = function() {\n            var isKeyframed = this.searchKeyframes();\n            var hasExpressions = this.searchExpressions();\n            this.kf = isKeyframed || hasExpressions;\n            return this.kf;\n        };\n        TextProperty.prototype.searchExpressions = searchExpressions;\n    }\n    function initialize() {\n        addDecorator();\n    }\n    function SVGComposableEffect() {}\n    SVGComposableEffect.prototype = {\n        createMergeNode: function createMergeNode(resultId, ins) {\n            var feMerge = createNS(\"feMerge\");\n            feMerge.setAttribute(\"result\", resultId);\n            var feMergeNode;\n            var i;\n            for(i = 0; i < ins.length; i += 1){\n                feMergeNode = createNS(\"feMergeNode\");\n                feMergeNode.setAttribute(\"in\", ins[i]);\n                feMerge.appendChild(feMergeNode);\n                feMerge.appendChild(feMergeNode);\n            }\n            return feMerge;\n        }\n    };\n    var linearFilterValue = \"0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0\";\n    function SVGTintFilter(filter, filterManager, elem, id, source) {\n        this.filterManager = filterManager;\n        var feColorMatrix = createNS(\"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"color-interpolation-filters\", \"linearRGB\");\n        feColorMatrix.setAttribute(\"values\", linearFilterValue + \" 1 0\");\n        this.linearFilter = feColorMatrix;\n        feColorMatrix.setAttribute(\"result\", id + \"_tint_1\");\n        filter.appendChild(feColorMatrix);\n        feColorMatrix = createNS(\"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n        feColorMatrix.setAttribute(\"values\", \"1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0\");\n        feColorMatrix.setAttribute(\"result\", id + \"_tint_2\");\n        filter.appendChild(feColorMatrix);\n        this.matrixFilter = feColorMatrix;\n        var feMerge = this.createMergeNode(id, [\n            source,\n            id + \"_tint_1\",\n            id + \"_tint_2\"\n        ]);\n        filter.appendChild(feMerge);\n    }\n    extendPrototype([\n        SVGComposableEffect\n    ], SVGTintFilter);\n    SVGTintFilter.prototype.renderFrame = function(forceRender) {\n        if (forceRender || this.filterManager._mdf) {\n            var colorBlack = this.filterManager.effectElements[0].p.v;\n            var colorWhite = this.filterManager.effectElements[1].p.v;\n            var opacity = this.filterManager.effectElements[2].p.v / 100;\n            this.linearFilter.setAttribute(\"values\", linearFilterValue + \" \" + opacity + \" 0\");\n            this.matrixFilter.setAttribute(\"values\", colorWhite[0] - colorBlack[0] + \" 0 0 0 \" + colorBlack[0] + \" \" + (colorWhite[1] - colorBlack[1]) + \" 0 0 0 \" + colorBlack[1] + \" \" + (colorWhite[2] - colorBlack[2]) + \" 0 0 0 \" + colorBlack[2] + \" 0 0 0 1 0\");\n        }\n    };\n    function SVGFillFilter(filter, filterManager, elem, id) {\n        this.filterManager = filterManager;\n        var feColorMatrix = createNS(\"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n        feColorMatrix.setAttribute(\"values\", \"1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0\");\n        feColorMatrix.setAttribute(\"result\", id);\n        filter.appendChild(feColorMatrix);\n        this.matrixFilter = feColorMatrix;\n    }\n    SVGFillFilter.prototype.renderFrame = function(forceRender) {\n        if (forceRender || this.filterManager._mdf) {\n            var color = this.filterManager.effectElements[2].p.v;\n            var opacity = this.filterManager.effectElements[6].p.v;\n            this.matrixFilter.setAttribute(\"values\", \"0 0 0 0 \" + color[0] + \" 0 0 0 0 \" + color[1] + \" 0 0 0 0 \" + color[2] + \" 0 0 0 \" + opacity + \" 0\");\n        }\n    };\n    function SVGStrokeEffect(fil, filterManager, elem) {\n        this.initialized = false;\n        this.filterManager = filterManager;\n        this.elem = elem;\n        this.paths = [];\n    }\n    SVGStrokeEffect.prototype.initialize = function() {\n        var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;\n        var path;\n        var groupPath;\n        var i;\n        var len;\n        if (this.filterManager.effectElements[1].p.v === 1) {\n            len = this.elem.maskManager.masksProperties.length;\n            i = 0;\n        } else {\n            i = this.filterManager.effectElements[0].p.v - 1;\n            len = i + 1;\n        }\n        groupPath = createNS(\"g\");\n        groupPath.setAttribute(\"fill\", \"none\");\n        groupPath.setAttribute(\"stroke-linecap\", \"round\");\n        groupPath.setAttribute(\"stroke-dashoffset\", 1);\n        for(i; i < len; i += 1){\n            path = createNS(\"path\");\n            groupPath.appendChild(path);\n            this.paths.push({\n                p: path,\n                m: i\n            });\n        }\n        if (this.filterManager.effectElements[10].p.v === 3) {\n            var mask = createNS(\"mask\");\n            var id = createElementID();\n            mask.setAttribute(\"id\", id);\n            mask.setAttribute(\"mask-type\", \"alpha\");\n            mask.appendChild(groupPath);\n            this.elem.globalData.defs.appendChild(mask);\n            var g = createNS(\"g\");\n            g.setAttribute(\"mask\", \"url(\" + getLocationHref() + \"#\" + id + \")\");\n            while(elemChildren[0]){\n                g.appendChild(elemChildren[0]);\n            }\n            this.elem.layerElement.appendChild(g);\n            this.masker = mask;\n            groupPath.setAttribute(\"stroke\", \"#fff\");\n        } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {\n            if (this.filterManager.effectElements[10].p.v === 2) {\n                elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;\n                while(elemChildren.length){\n                    this.elem.layerElement.removeChild(elemChildren[0]);\n                }\n            }\n            this.elem.layerElement.appendChild(groupPath);\n            this.elem.layerElement.removeAttribute(\"mask\");\n            groupPath.setAttribute(\"stroke\", \"#fff\");\n        }\n        this.initialized = true;\n        this.pathMasker = groupPath;\n    };\n    SVGStrokeEffect.prototype.renderFrame = function(forceRender) {\n        if (!this.initialized) {\n            this.initialize();\n        }\n        var i;\n        var len = this.paths.length;\n        var mask;\n        var path;\n        for(i = 0; i < len; i += 1){\n            if (this.paths[i].m !== -1) {\n                mask = this.elem.maskManager.viewData[this.paths[i].m];\n                path = this.paths[i].p;\n                if (forceRender || this.filterManager._mdf || mask.prop._mdf) {\n                    path.setAttribute(\"d\", mask.lastPath);\n                }\n                if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {\n                    var dasharrayValue;\n                    if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {\n                        var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;\n                        var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;\n                        var l = path.getTotalLength();\n                        dasharrayValue = \"0 0 0 \" + l * s + \" \";\n                        var lineLength = l * (e - s);\n                        var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;\n                        var units = Math.floor(lineLength / segment);\n                        var j;\n                        for(j = 0; j < units; j += 1){\n                            dasharrayValue += \"1 \" + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + \" \";\n                        }\n                        dasharrayValue += \"0 \" + l * 10 + \" 0 0\";\n                    } else {\n                        dasharrayValue = \"1 \" + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;\n                    }\n                    path.setAttribute(\"stroke-dasharray\", dasharrayValue);\n                }\n            }\n        }\n        if (forceRender || this.filterManager.effectElements[4].p._mdf) {\n            this.pathMasker.setAttribute(\"stroke-width\", this.filterManager.effectElements[4].p.v * 2);\n        }\n        if (forceRender || this.filterManager.effectElements[6].p._mdf) {\n            this.pathMasker.setAttribute(\"opacity\", this.filterManager.effectElements[6].p.v);\n        }\n        if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {\n            if (forceRender || this.filterManager.effectElements[3].p._mdf) {\n                var color = this.filterManager.effectElements[3].p.v;\n                this.pathMasker.setAttribute(\"stroke\", \"rgb(\" + bmFloor(color[0] * 255) + \",\" + bmFloor(color[1] * 255) + \",\" + bmFloor(color[2] * 255) + \")\");\n            }\n        }\n    };\n    function SVGTritoneFilter(filter, filterManager, elem, id) {\n        this.filterManager = filterManager;\n        var feColorMatrix = createNS(\"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"color-interpolation-filters\", \"linearRGB\");\n        feColorMatrix.setAttribute(\"values\", \"0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\");\n        filter.appendChild(feColorMatrix);\n        var feComponentTransfer = createNS(\"feComponentTransfer\");\n        feComponentTransfer.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n        feComponentTransfer.setAttribute(\"result\", id);\n        this.matrixFilter = feComponentTransfer;\n        var feFuncR = createNS(\"feFuncR\");\n        feFuncR.setAttribute(\"type\", \"table\");\n        feComponentTransfer.appendChild(feFuncR);\n        this.feFuncR = feFuncR;\n        var feFuncG = createNS(\"feFuncG\");\n        feFuncG.setAttribute(\"type\", \"table\");\n        feComponentTransfer.appendChild(feFuncG);\n        this.feFuncG = feFuncG;\n        var feFuncB = createNS(\"feFuncB\");\n        feFuncB.setAttribute(\"type\", \"table\");\n        feComponentTransfer.appendChild(feFuncB);\n        this.feFuncB = feFuncB;\n        filter.appendChild(feComponentTransfer);\n    }\n    SVGTritoneFilter.prototype.renderFrame = function(forceRender) {\n        if (forceRender || this.filterManager._mdf) {\n            var color1 = this.filterManager.effectElements[0].p.v;\n            var color2 = this.filterManager.effectElements[1].p.v;\n            var color3 = this.filterManager.effectElements[2].p.v;\n            var tableR = color3[0] + \" \" + color2[0] + \" \" + color1[0];\n            var tableG = color3[1] + \" \" + color2[1] + \" \" + color1[1];\n            var tableB = color3[2] + \" \" + color2[2] + \" \" + color1[2];\n            this.feFuncR.setAttribute(\"tableValues\", tableR);\n            this.feFuncG.setAttribute(\"tableValues\", tableG);\n            this.feFuncB.setAttribute(\"tableValues\", tableB);\n        }\n    };\n    function SVGProLevelsFilter(filter, filterManager, elem, id) {\n        this.filterManager = filterManager;\n        var effectElements = this.filterManager.effectElements;\n        var feComponentTransfer = createNS(\"feComponentTransfer\"); // Red\n        if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {\n            this.feFuncR = this.createFeFunc(\"feFuncR\", feComponentTransfer);\n        } // Green\n        if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {\n            this.feFuncG = this.createFeFunc(\"feFuncG\", feComponentTransfer);\n        } // Blue\n        if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {\n            this.feFuncB = this.createFeFunc(\"feFuncB\", feComponentTransfer);\n        } // Alpha\n        if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {\n            this.feFuncA = this.createFeFunc(\"feFuncA\", feComponentTransfer);\n        } // RGB\n        if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {\n            feComponentTransfer.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n            filter.appendChild(feComponentTransfer);\n        }\n        if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {\n            feComponentTransfer = createNS(\"feComponentTransfer\");\n            feComponentTransfer.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n            feComponentTransfer.setAttribute(\"result\", id);\n            filter.appendChild(feComponentTransfer);\n            this.feFuncRComposed = this.createFeFunc(\"feFuncR\", feComponentTransfer);\n            this.feFuncGComposed = this.createFeFunc(\"feFuncG\", feComponentTransfer);\n            this.feFuncBComposed = this.createFeFunc(\"feFuncB\", feComponentTransfer);\n        }\n    }\n    SVGProLevelsFilter.prototype.createFeFunc = function(type, feComponentTransfer) {\n        var feFunc = createNS(type);\n        feFunc.setAttribute(\"type\", \"table\");\n        feComponentTransfer.appendChild(feFunc);\n        return feFunc;\n    };\n    SVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma, outputBlack, outputWhite) {\n        var cnt = 0;\n        var segments = 256;\n        var perc;\n        var min = Math.min(inputBlack, inputWhite);\n        var max = Math.max(inputBlack, inputWhite);\n        var table = Array.call(null, {\n            length: segments\n        });\n        var colorValue;\n        var pos = 0;\n        var outputDelta = outputWhite - outputBlack;\n        var inputDelta = inputWhite - inputBlack;\n        while(cnt <= 256){\n            perc = cnt / 256;\n            if (perc <= min) {\n                colorValue = inputDelta < 0 ? outputWhite : outputBlack;\n            } else if (perc >= max) {\n                colorValue = inputDelta < 0 ? outputBlack : outputWhite;\n            } else {\n                colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);\n            }\n            table[pos] = colorValue;\n            pos += 1;\n            cnt += 256 / (segments - 1);\n        }\n        return table.join(\" \");\n    };\n    SVGProLevelsFilter.prototype.renderFrame = function(forceRender) {\n        if (forceRender || this.filterManager._mdf) {\n            var val;\n            var effectElements = this.filterManager.effectElements;\n            if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {\n                val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);\n                this.feFuncRComposed.setAttribute(\"tableValues\", val);\n                this.feFuncGComposed.setAttribute(\"tableValues\", val);\n                this.feFuncBComposed.setAttribute(\"tableValues\", val);\n            }\n            if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {\n                val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);\n                this.feFuncR.setAttribute(\"tableValues\", val);\n            }\n            if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {\n                val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);\n                this.feFuncG.setAttribute(\"tableValues\", val);\n            }\n            if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {\n                val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);\n                this.feFuncB.setAttribute(\"tableValues\", val);\n            }\n            if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {\n                val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);\n                this.feFuncA.setAttribute(\"tableValues\", val);\n            }\n        }\n    };\n    function SVGDropShadowEffect(filter, filterManager, elem, id, source) {\n        var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize;\n        var filterSize = filterManager.data.fs || globalFilterSize;\n        filter.setAttribute(\"x\", filterSize.x || globalFilterSize.x);\n        filter.setAttribute(\"y\", filterSize.y || globalFilterSize.y);\n        filter.setAttribute(\"width\", filterSize.width || globalFilterSize.width);\n        filter.setAttribute(\"height\", filterSize.height || globalFilterSize.height);\n        this.filterManager = filterManager;\n        var feGaussianBlur = createNS(\"feGaussianBlur\");\n        feGaussianBlur.setAttribute(\"in\", \"SourceAlpha\");\n        feGaussianBlur.setAttribute(\"result\", id + \"_drop_shadow_1\");\n        feGaussianBlur.setAttribute(\"stdDeviation\", \"0\");\n        this.feGaussianBlur = feGaussianBlur;\n        filter.appendChild(feGaussianBlur);\n        var feOffset = createNS(\"feOffset\");\n        feOffset.setAttribute(\"dx\", \"25\");\n        feOffset.setAttribute(\"dy\", \"0\");\n        feOffset.setAttribute(\"in\", id + \"_drop_shadow_1\");\n        feOffset.setAttribute(\"result\", id + \"_drop_shadow_2\");\n        this.feOffset = feOffset;\n        filter.appendChild(feOffset);\n        var feFlood = createNS(\"feFlood\");\n        feFlood.setAttribute(\"flood-color\", \"#00ff00\");\n        feFlood.setAttribute(\"flood-opacity\", \"1\");\n        feFlood.setAttribute(\"result\", id + \"_drop_shadow_3\");\n        this.feFlood = feFlood;\n        filter.appendChild(feFlood);\n        var feComposite = createNS(\"feComposite\");\n        feComposite.setAttribute(\"in\", id + \"_drop_shadow_3\");\n        feComposite.setAttribute(\"in2\", id + \"_drop_shadow_2\");\n        feComposite.setAttribute(\"operator\", \"in\");\n        feComposite.setAttribute(\"result\", id + \"_drop_shadow_4\");\n        filter.appendChild(feComposite);\n        var feMerge = this.createMergeNode(id, [\n            id + \"_drop_shadow_4\",\n            source\n        ]);\n        filter.appendChild(feMerge); //\n    }\n    extendPrototype([\n        SVGComposableEffect\n    ], SVGDropShadowEffect);\n    SVGDropShadowEffect.prototype.renderFrame = function(forceRender) {\n        if (forceRender || this.filterManager._mdf) {\n            if (forceRender || this.filterManager.effectElements[4].p._mdf) {\n                this.feGaussianBlur.setAttribute(\"stdDeviation\", this.filterManager.effectElements[4].p.v / 4);\n            }\n            if (forceRender || this.filterManager.effectElements[0].p._mdf) {\n                var col = this.filterManager.effectElements[0].p.v;\n                this.feFlood.setAttribute(\"flood-color\", rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));\n            }\n            if (forceRender || this.filterManager.effectElements[1].p._mdf) {\n                this.feFlood.setAttribute(\"flood-opacity\", this.filterManager.effectElements[1].p.v / 255);\n            }\n            if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {\n                var distance = this.filterManager.effectElements[3].p.v;\n                var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;\n                var x = distance * Math.cos(angle);\n                var y = distance * Math.sin(angle);\n                this.feOffset.setAttribute(\"dx\", x);\n                this.feOffset.setAttribute(\"dy\", y);\n            }\n        }\n    };\n    var _svgMatteSymbols = [];\n    function SVGMatte3Effect(filterElem, filterManager, elem) {\n        this.initialized = false;\n        this.filterManager = filterManager;\n        this.filterElem = filterElem;\n        this.elem = elem;\n        elem.matteElement = createNS(\"g\");\n        elem.matteElement.appendChild(elem.layerElement);\n        elem.matteElement.appendChild(elem.transformedElement);\n        elem.baseElement = elem.matteElement;\n    }\n    SVGMatte3Effect.prototype.findSymbol = function(mask) {\n        var i = 0;\n        var len = _svgMatteSymbols.length;\n        while(i < len){\n            if (_svgMatteSymbols[i] === mask) {\n                return _svgMatteSymbols[i];\n            }\n            i += 1;\n        }\n        return null;\n    };\n    SVGMatte3Effect.prototype.replaceInParent = function(mask, symbolId) {\n        var parentNode = mask.layerElement.parentNode;\n        if (!parentNode) {\n            return;\n        }\n        var children = parentNode.children;\n        var i = 0;\n        var len = children.length;\n        while(i < len){\n            if (children[i] === mask.layerElement) {\n                break;\n            }\n            i += 1;\n        }\n        var nextChild;\n        if (i <= len - 2) {\n            nextChild = children[i + 1];\n        }\n        var useElem = createNS(\"use\");\n        useElem.setAttribute(\"href\", \"#\" + symbolId);\n        if (nextChild) {\n            parentNode.insertBefore(useElem, nextChild);\n        } else {\n            parentNode.appendChild(useElem);\n        }\n    };\n    SVGMatte3Effect.prototype.setElementAsMask = function(elem, mask) {\n        if (!this.findSymbol(mask)) {\n            var symbolId = createElementID();\n            var masker = createNS(\"mask\");\n            masker.setAttribute(\"id\", mask.layerId);\n            masker.setAttribute(\"mask-type\", \"alpha\");\n            _svgMatteSymbols.push(mask);\n            var defs = elem.globalData.defs;\n            defs.appendChild(masker);\n            var symbol = createNS(\"symbol\");\n            symbol.setAttribute(\"id\", symbolId);\n            this.replaceInParent(mask, symbolId);\n            symbol.appendChild(mask.layerElement);\n            defs.appendChild(symbol);\n            var useElem = createNS(\"use\");\n            useElem.setAttribute(\"href\", \"#\" + symbolId);\n            masker.appendChild(useElem);\n            mask.data.hd = false;\n            mask.show();\n        }\n        elem.setMatte(mask.layerId);\n    };\n    SVGMatte3Effect.prototype.initialize = function() {\n        var ind = this.filterManager.effectElements[0].p.v;\n        var elements = this.elem.comp.elements;\n        var i = 0;\n        var len = elements.length;\n        while(i < len){\n            if (elements[i] && elements[i].data.ind === ind) {\n                this.setElementAsMask(this.elem, elements[i]);\n            }\n            i += 1;\n        }\n        this.initialized = true;\n    };\n    SVGMatte3Effect.prototype.renderFrame = function() {\n        if (!this.initialized) {\n            this.initialize();\n        }\n    };\n    function SVGGaussianBlurEffect(filter, filterManager, elem, id) {\n        // Outset the filter region by 100% on all sides to accommodate blur expansion.\n        filter.setAttribute(\"x\", \"-100%\");\n        filter.setAttribute(\"y\", \"-100%\");\n        filter.setAttribute(\"width\", \"300%\");\n        filter.setAttribute(\"height\", \"300%\");\n        this.filterManager = filterManager;\n        var feGaussianBlur = createNS(\"feGaussianBlur\");\n        feGaussianBlur.setAttribute(\"result\", id);\n        filter.appendChild(feGaussianBlur);\n        this.feGaussianBlur = feGaussianBlur;\n    }\n    SVGGaussianBlurEffect.prototype.renderFrame = function(forceRender) {\n        if (forceRender || this.filterManager._mdf) {\n            // Empirical value, matching AE's blur appearance.\n            var kBlurrinessToSigma = 0.3;\n            var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma; // Dimensions mapping:\n            //\n            //   1 -> horizontal & vertical\n            //   2 -> horizontal only\n            //   3 -> vertical only\n            //\n            var dimensions = this.filterManager.effectElements[1].p.v;\n            var sigmaX = dimensions == 3 ? 0 : sigma; // eslint-disable-line eqeqeq\n            var sigmaY = dimensions == 2 ? 0 : sigma; // eslint-disable-line eqeqeq\n            this.feGaussianBlur.setAttribute(\"stdDeviation\", sigmaX + \" \" + sigmaY); // Repeat edges mapping:\n            //\n            //   0 -> off -> duplicate\n            //   1 -> on  -> wrap\n            var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? \"wrap\" : \"duplicate\"; // eslint-disable-line eqeqeq\n            this.feGaussianBlur.setAttribute(\"edgeMode\", edgeMode);\n        }\n    };\n    function TransformEffect() {}\n    TransformEffect.prototype.init = function(effectsManager) {\n        this.effectsManager = effectsManager;\n        this.type = effectTypes.TRANSFORM_EFFECT;\n        this.matrix = new Matrix();\n        this.opacity = -1;\n        this._mdf = false;\n        this._opMdf = false;\n    };\n    TransformEffect.prototype.renderFrame = function(forceFrame) {\n        this._opMdf = false;\n        this._mdf = false;\n        if (forceFrame || this.effectsManager._mdf) {\n            var effectElements = this.effectsManager.effectElements;\n            var anchor = effectElements[0].p.v;\n            var position = effectElements[1].p.v;\n            var isUniformScale = effectElements[2].p.v === 1;\n            var scaleHeight = effectElements[3].p.v;\n            var scaleWidth = isUniformScale ? scaleHeight : effectElements[4].p.v;\n            var skew = effectElements[5].p.v;\n            var skewAxis = effectElements[6].p.v;\n            var rotation = effectElements[7].p.v;\n            this.matrix.reset();\n            this.matrix.translate(-anchor[0], -anchor[1], anchor[2]);\n            this.matrix.scale(scaleWidth * 0.01, scaleHeight * 0.01, 1);\n            this.matrix.rotate(-rotation * degToRads);\n            this.matrix.skewFromAxis(-skew * degToRads, (skewAxis + 90) * degToRads);\n            this.matrix.translate(position[0], position[1], 0);\n            this._mdf = true;\n            if (this.opacity !== effectElements[8].p.v) {\n                this.opacity = effectElements[8].p.v;\n                this._opMdf = true;\n            }\n        }\n    };\n    function SVGTransformEffect(_, filterManager) {\n        this.init(filterManager);\n    }\n    extendPrototype([\n        TransformEffect\n    ], SVGTransformEffect);\n    function CVTransformEffect(effectsManager) {\n        this.init(effectsManager);\n    }\n    extendPrototype([\n        TransformEffect\n    ], CVTransformEffect);\n    registerRenderer(\"canvas\", CanvasRenderer);\n    registerRenderer(\"html\", HybridRenderer);\n    registerRenderer(\"svg\", SVGRenderer); // Registering shape modifiers\n    ShapeModifiers.registerModifier(\"tm\", TrimModifier);\n    ShapeModifiers.registerModifier(\"pb\", PuckerAndBloatModifier);\n    ShapeModifiers.registerModifier(\"rp\", RepeaterModifier);\n    ShapeModifiers.registerModifier(\"rd\", RoundCornersModifier);\n    ShapeModifiers.registerModifier(\"zz\", ZigZagModifier);\n    ShapeModifiers.registerModifier(\"op\", OffsetPathModifier); // Registering expression plugin\n    setExpressionsPlugin(Expressions);\n    setExpressionInterfaces(getInterface);\n    initialize$1();\n    initialize(); // Registering svg effects\n    registerEffect$1(20, SVGTintFilter, true);\n    registerEffect$1(21, SVGFillFilter, true);\n    registerEffect$1(22, SVGStrokeEffect, false);\n    registerEffect$1(23, SVGTritoneFilter, true);\n    registerEffect$1(24, SVGProLevelsFilter, true);\n    registerEffect$1(25, SVGDropShadowEffect, true);\n    registerEffect$1(28, SVGMatte3Effect, false);\n    registerEffect$1(29, SVGGaussianBlurEffect, true);\n    registerEffect$1(35, SVGTransformEffect, false);\n    registerEffect(35, CVTransformEffect);\n    return lottie;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbG90dGllLXdlYi9idWlsZC9wbGF5ZXIvbG90dGllLmpzIiwibWFwcGluZ3MiOiI7QUFBQyxPQUFPQSxjQUFjLGVBQWdCLFNBQVdDLE1BQU0sRUFBRUMsT0FBTztJQUM5RCxLQUFpRCxHQUFjRSxPQUFPRCxPQUFPLEdBQUdELFlBQ2hGLENBQ29HO0FBQ3RHLEVBQUcsUUFBTztJQUFjO0lBRXRCLElBQUlRLFFBQVE7SUFDWixJQUFJQyxlQUFlO0lBQ25CLElBQUlDLGdCQUFnQjtJQUNwQixJQUFJQyxzQkFBc0IsQ0FBQztJQUUzQixJQUFJQyxlQUFlLFNBQVNBLGFBQWFDLElBQUk7UUFDM0NILGdCQUFnQixDQUFDLENBQUNHO0lBQ3BCO0lBRUEsSUFBSUMsZUFBZSxTQUFTQTtRQUMxQixPQUFPSjtJQUNUO0lBRUEsSUFBSUssa0JBQWtCLFNBQVNBLGdCQUFnQkMsS0FBSztRQUNsRFAsZUFBZU87SUFDakI7SUFFQSxJQUFJQyxrQkFBa0IsU0FBU0E7UUFDN0IsT0FBT1I7SUFDVDtJQUVBLFNBQVNTLFVBQVVDLElBQUk7UUFDckIsdUVBQXVFO1FBQ3ZFLE9BQU9DLFNBQVNDLGFBQWEsQ0FBQ0Y7SUFDaEM7SUFFQSxTQUFTRyxnQkFBZ0JDLE9BQU8sRUFBRUMsV0FBVztRQUMzQyxJQUFJQztRQUNKLElBQUlDLE1BQU1ILFFBQVFJLE1BQU07UUFDeEIsSUFBSUM7UUFFSixJQUFLSCxJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQkcsa0JBQWtCTCxPQUFPLENBQUNFLEVBQUUsQ0FBQ0ksU0FBUztZQUV0QyxJQUFLLElBQUlDLFFBQVFGLGdCQUFpQjtnQkFDaEMsSUFBSUcsT0FBT0YsU0FBUyxDQUFDRyxjQUFjLENBQUNDLElBQUksQ0FBQ0wsaUJBQWlCRSxPQUFPTixZQUFZSyxTQUFTLENBQUNDLEtBQUssR0FBR0YsZUFBZSxDQUFDRSxLQUFLO1lBQ3RIO1FBQ0Y7SUFDRjtJQUVBLFNBQVNJLGNBQWNDLE1BQU0s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U0FBUyxDQUFDaUMsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEdBQUcsRUFBRUEsV0FBVyxDQUFDLEdBQUcsRUFBRUEsV0FBVyxDQUFDLEdBQUcsRUFBRUEsV0FBVyxDQUFDLEdBQUcsRUFBRUEsV0FBVyxDQUFDLEdBQUcsRUFBRUEsV0FBVyxDQUFDLEdBQUc7UUFDNVI7UUFFQSxTQUFTQztZQUNQLElBQUksQ0FBQyxJQUFJLENBQUNsQixtQkFBbUIsRUFBRTtnQkFDN0IsSUFBSSxDQUFDbUIsU0FBUyxHQUFHLENBQUUsS0FBSSxDQUFDdkQsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEdBQUcsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEdBQUcsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEdBQUcsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEdBQUcsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEdBQUcsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEdBQUcsS0FBSztnQkFDcFksSUFBSSxDQUFDb0MsbUJBQW1CLEdBQUc7WUFDN0I7WUFFQSxPQUFPLElBQUksQ0FBQ21CLFNBQVM7UUFDdkI7UUFFQSxTQUFTQyxPQUFPQyxJQUFJO1lBQ2xCLElBQUl0OEIsSUFBSTtZQUVSLE1BQU9BLElBQUksR0FBSTtnQkFDYixJQUFJczhCLEtBQUt6RCxLQUFLLENBQUM3NEIsRUFBRSxLQUFLLElBQUksQ0FBQzY0QixLQUFLLENBQUM3NEIsRUFBRSxFQUFFO29CQUNuQyxPQUFPO2dCQUNUO2dCQUVBQSxLQUFLO1lBQ1A7WUFFQSxPQUFPO1FBQ1Q7UUFFQSxTQUFTazBCLE1BQU1vSSxJQUFJO1lBQ2pCLElBQUl0OEI7WUFFSixJQUFLQSxJQUFJLEdBQUdBLElBQUksSUFBSUEsS0FBSyxFQUFHO2dCQUMxQnM4QixLQUFLekQsS0FBSyxDQUFDNzRCLEVBQUUsR0FBRyxJQUFJLENBQUM2NEIsS0FBSyxDQUFDNzRCLEVBQUU7WUFDL0I7WUFFQSxPQUFPczhCO1FBQ1Q7UUFFQSxTQUFTQyxlQUFlMUQsS0FBSztZQUMzQixJQUFJNzRCO1lBRUosSUFBS0EsSUFBSSxHQUFHQSxJQUFJLElBQUlBLEtBQUssRUFBRztnQkFDMUIsSUFBSSxDQUFDNjRCLEtBQUssQ0FBQzc0QixFQUFFLEdBQUc2NEIsS0FBSyxDQUFDNzRCLEVBQUU7WUFDMUI7UUFDRjtRQUVBLFNBQVN3OEIsYUFBYTVYLENBQUMsRUFBRXNJLENBQUMsRUFBRXNELENBQUM7WUFDM0IsT0FBTztnQkFDTDVMLEdBQUdBLElBQUksSUFBSSxDQUFDaVUsS0FBSyxDQUFDLEVBQUUsR0FBRzNMLElBQUksSUFBSSxDQUFDMkwsS0FBSyxDQUFDLEVBQUUsR0FBR3JJLElBQUksSUFBSSxDQUFDcUksS0FBSyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUNBLEtBQUssQ0FBQyxHQUFHO2dCQUM3RTNMLEdBQUd0SSxJQUFJLElBQUksQ0FBQ2lVLEtBQUssQ0FBQyxFQUFFLEdBQUczTCxJQUFJLElBQUksQ0FBQzJMLEtBQUssQ0FBQyxFQUFFLEdBQUdySSxJQUFJLElBQUksQ0FBQ3FJLEtBQUssQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDQSxLQUFLLENBQUMsR0FBRztnQkFDN0VySSxHQUFHNUwsSUFBSSxJQUFJLENBQUNpVSxLQUFLLENBQUMsRUFBRSxHQUFHM0wsSUFBSSxJQUFJLENBQUMyTCxLQUFLLENBQUMsRUFBRSxHQUFHckksSUFBSSxJQUFJLENBQUNxSSxLQUFLLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEdBQUc7WUFDaEY7UUFDQTs7O2NBR1EsR0FDVjtRQUVBLFNBQVM0RCxTQUFTN1gsQ0FBQyxFQUFFc0ksQ0FBQyxFQUFFc0QsQ0FBQztZQUN2QixPQUFPNUwsSUFBSSxJQUFJLENBQUNpVSxLQUFLLENBQUMsRUFBRSxHQUFHM0wsSUFBSSxJQUFJLENBQUMyTCxLQUFLLENBQUMsRUFBRSxHQUFHckksSUFBSSxJQUFJLENBQUNxSSxLQUFLLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEdBQUc7UUFDbkY7UUFFQSxTQUFTNkQsU0FBUzlYLENBQUMsRUFBRXNJLENBQUMsRUFBRXNELENBQUM7WUFDdkIsT0FBTzVMLElBQUksSUFBSSxDQUFDaVUsS0FBSyxDQUFDLEVBQUUsR0FBRzNMLElBQUksSUFBSSxDQUFDMkwsS0FBSyxDQUFDLEVBQUUsR0FBR3JJLElBQUksSUFBSSxDQUFDcUksS0FBSyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUNBLEtBQUssQ0FBQyxHQUFHO1FBQ25GO1FBRUEsU0FBUzhELFNBQVMvWCxDQUFDLEVBQUVzSSxDQUFDLEVBQUVzRCxDQUFDO1lBQ3ZCLE9BQU81TCxJQUFJLElBQUksQ0FBQ2lVLEtBQUssQ0FBQyxFQUFFLEdBQUczTCxJQUFJLElBQUksQ0FBQzJMLEtBQUssQ0FBQyxFQUFFLEdBQUdySSxJQUFJLElBQUksQ0FBQ3FJLEtBQUssQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDQSxLQUFLLENBQUMsR0FBRztRQUNwRjtRQUVBLFNBQVMrRDtZQUNQLElBQUlDLGNBQWMsSUFBSSxDQUFDaEUsS0FBSyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUNBLEtBQUssQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDQSxLQUFLLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUU7WUFDL0UsSUFBSTdwQixJQUFJLElBQUksQ0FBQzZwQixLQUFLLENBQUMsRUFBRSxHQUFHZ0U7WUFDeEIsSUFBSXIwQixJQUFJLENBQUMsSUFBSSxDQUFDcXdCLEtBQUssQ0FBQyxFQUFFLEdBQUdnRTtZQUN6QixJQUFJdHRCLElBQUksQ0FBQyxJQUFJLENBQUNzcEIsS0FBSyxDQUFDLEVBQUUsR0FBR2dFO1lBQ3pCLElBQUkvekIsSUFBSSxJQUFJLENBQUMrdkIsS0FBSyxDQUFDLEVBQUUsR0FBR2dFO1lBQ3hCLElBQUlseEIsSUFBSSxDQUFDLElBQUksQ0FBQ2t0QixLQUFLLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUNBLEtBQUssQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDQSxLQUFLLENBQUMsR0FBRyxJQUFJZ0U7WUFDNUUsSUFBSXAwQixJQUFJLENBQUUsS0FBSSxDQUFDb3dCLEtBQUssQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDQSxLQUFLLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUNBLEtBQUssQ0FBQyxHQUFHLElBQUlnRTtZQUM3RSxJQUFJQyxnQkFBZ0IsSUFBSXZFO1lBQ3hCdUUsY0FBY2pFLEtBQUssQ0FBQyxFQUFFLEdBQUc3cEI7WUFDekI4dEIsY0FBY2pFLEtBQUssQ0FBQyxFQUFFLEdBQUdyd0I7WUFDekJzMEIsY0FBY2pFLEtBQUssQ0FBQyxFQUFFLEdBQUd0cEI7WUFDekJ1dEIsY0FBY2pFLEtBQUssQ0FBQyxFQUFFLEdBQUcvdkI7WUFDekJnMEIsY0FBY2pFLEtBQUssQ0FBQyxHQUFHLEdBQUdsdEI7WUFDMUJteEIsY0FBY2pFLEtBQUssQ0FBQyxHQUFHLEdBQUdwd0I7WUFDMUIsT0FBT3EwQjtRQUNUO1FBRUEsU0FBU0MsYUFBYXR3QixFQUFFO1lBQ3RCLElBQUlxd0IsZ0JBQWdCLElBQUksQ0FBQ0YsZ0JBQWdCO1lBQ3pDLE9BQU9FLGNBQWNFLGlCQUFpQixDQUFDdndCLEVBQUUsQ0FBQyxFQUFFLEVBQUVBLEVBQUUsQ0FBQyxFQUFFLEVBQUVBLEVBQUUsQ0FBQyxFQUFFLElBQUk7UUFDaEU7UUFFQSxTQUFTd3dCLGNBQWNDLEdBQUc7WUFDeEIsSUFBSWw5QjtZQUNKLElBQUlDLE1BQU1pOUIsSUFBSWg5QixNQUFNO1lBQ3BCLElBQUlpOUIsU0FBUyxFQUFFO1lBRWYsSUFBS245QixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztnQkFDM0JtOUIsTUFBTSxDQUFDbjlCLEVBQUUsR0FBRys4QixhQUFhRyxHQUFHLENBQUNsOUIsRUFBRTtZQUNqQztZQUVBLE9BQU9tOUI7UUFDVDtRQUVBLFNBQVNDLG9CQUFvQnRWLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHO1lBQ3hDLElBQUlqbEIsTUFBTUYsaUJBQWlCLFdBQVc7WUFFdEMsSUFBSSxJQUFJLENBQUNzNUIsVUFBVSxJQUFJO2dCQUNyQnA1QixHQUFHLENBQUMsRUFBRSxHQUFHK2tCLEdBQUcsQ0FBQyxFQUFFO2dCQUNmL2tCLEdBQUcsQ0FBQyxFQUFFLEdBQUcra0IsR0FBRyxDQUFDLEVBQUU7Z0JBQ2Yva0IsR0FBRyxDQUFDLEVBQUUsR0FBR2dsQixHQUFHLENBQUMsRUFBRTtnQkFDZmhsQixHQUFHLENBQUMsRUFBRSxHQUFHZ2xCLEdBQUcsQ0FBQyxFQUFFO2dCQUNmaGxCLEdBQUcsQ0FBQyxFQUFFLEdBQUdpbEIsR0FBRyxDQUFDLEVBQUU7Z0JBQ2ZqbEIsR0FBRyxDQUFDLEVBQUUsR0FBR2lsQixHQUFHLENBQUMsRUFBRTtZQUNqQixPQUFPO2dCQUNMLElBQUlnTyxLQUFLLElBQUksQ0FBQzZDLEtBQUssQ0FBQyxFQUFFO2dCQUN0QixJQUFJNUMsS0FBSyxJQUFJLENBQUM0QyxLQUFLLENBQUMsRUFBRTtnQkFDdEIsSUFBSXdFLEtBQUssSUFBSSxDQUFDeEUsS0FBSyxDQUFDLEVBQUU7Z0JBQ3RCLElBQUl5RSxLQUFLLElBQUksQ0FBQ3pFLEtBQUssQ0FBQyxFQUFFO2dCQUN0QixJQUFJMEUsTUFBTSxJQUFJLENBQUMxRSxLQUFLLENBQUMsR0FBRztnQkFDeEIsSUFBSTJFLE1BQU0sSUFBSSxDQUFDM0UsS0FBSyxDQUFDLEdBQUc7Z0JBQ3hCOTFCLEdBQUcsQ0FBQyxFQUFFLEdBQUcra0IsR0FBRyxDQUFDLEVBQUUsR0FBR2tPLEtBQUtsTyxHQUFHLENBQUMsRUFBRSxHQUFHdVYsS0FBS0U7Z0JBQ3JDeDZCLEdBQUcsQ0FBQyxFQUFFLEdBQUcra0IsR0FBRyxDQUFDLEVBQUUsR0FBR21PLEtBQUtuTyxHQUFHLENBQUMsRUFBRSxHQUFHd1YsS0FBS0U7Z0JBQ3JDejZCLEdBQUcsQ0FBQyxFQUFFLEdBQUdnbEIsR0FBRyxDQUFDLEVBQUUsR0FBR2lPLEtBQUtqTyxHQUFHLENBQUMsRUFBRSxHQUFHc1YsS0FBS0U7Z0JBQ3JDeDZCLEdBQUcsQ0FBQyxFQUFFLEdBQUdnbEIsR0FBRyxDQUFDLEVBQUUsR0FBR2tPLEtBQUtsTyxHQUFHLENBQUMsRUFBRSxHQUFHdVYsS0FBS0U7Z0JBQ3JDejZCLEdBQUcsQ0FBQyxFQUFFLEdBQUdpbEIsR0FBRyxDQUFDLEVBQUUsR0FBR2dPLEtBQUtoTyxHQUFHLENBQUMsRUFBRSxHQUFHcVYsS0FBS0U7Z0JBQ3JDeDZCLEdBQUcsQ0FBQyxFQUFFLEdBQUdpbEIsR0FBRyxDQUFDLEVBQUUsR0FBR2lPLEtBQUtqTyxHQUFHLENBQUMsRUFBRSxHQUFHc1YsS0FBS0U7WUFDdkM7WUFFQSxPQUFPejZCO1FBQ1Q7UUFFQSxTQUFTaTZCLGtCQUFrQnBZLENBQUMsRUFBRXNJLENBQUMsRUFBRXNELENBQUM7WUFDaEMsSUFBSXp0QjtZQUVKLElBQUksSUFBSSxDQUFDbzVCLFVBQVUsSUFBSTtnQkFDckJwNUIsTUFBTTtvQkFBQzZoQjtvQkFBR3NJO29CQUFHc0Q7aUJBQUU7WUFDakIsT0FBTztnQkFDTHp0QixNQUFNO29CQUFDNmhCLElBQUksSUFBSSxDQUFDaVUsS0FBSyxDQUFDLEVBQUUsR0FBRzNMLElBQUksSUFBSSxDQUFDMkwsS0FBSyxDQUFDLEVBQUUsR0FBR3JJLElBQUksSUFBSSxDQUFDcUksS0FBSyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUNBLEtBQUssQ0FBQyxHQUFHO29CQUFFalUsSUFBSSxJQUFJLENBQUNpVSxLQUFLLENBQUMsRUFBRSxHQUFHM0wsSUFBSSxJQUFJLENBQUMyTCxLQUFLLENBQUMsRUFBRSxHQUFHckksSUFBSSxJQUFJLENBQUNxSSxLQUFLLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEdBQUc7b0JBQUVqVSxJQUFJLElBQUksQ0FBQ2lVLEtBQUssQ0FBQyxFQUFFLEdBQUczTCxJQUFJLElBQUksQ0FBQzJMLEtBQUssQ0FBQyxFQUFFLEdBQUdySSxJQUFJLElBQUksQ0FBQ3FJLEtBQUssQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDQSxLQUFLLENBQUMsR0FBRztpQkFBQztZQUM3TztZQUVBLE9BQU85MUI7UUFDVDtRQUVBLFNBQVMwNkIsd0JBQXdCN1ksQ0FBQyxFQUFFc0ksQ0FBQztZQUNuQyxJQUFJLElBQUksQ0FBQ2lQLFVBQVUsSUFBSTtnQkFDckIsT0FBT3ZYLElBQUksTUFBTXNJO1lBQ25CO1lBRUEsSUFBSTFJLEtBQUssSUFBSSxDQUFDcVUsS0FBSztZQUNuQixPQUFPdjBCLEtBQUt3QixLQUFLLENBQUMsQ0FBQzhlLElBQUlKLEVBQUUsQ0FBQyxFQUFFLEdBQUcwSSxJQUFJMUksRUFBRSxDQUFDLEVBQUUsR0FBR0EsRUFBRSxDQUFDLEdBQUcsSUFBSSxPQUFPLE1BQU0sTUFBTWxnQixLQUFLd0IsS0FBSyxDQUFDLENBQUM4ZSxJQUFJSixFQUFFLENBQUMsRUFBRSxHQUFHMEksSUFBSTFJLEVBQUUsQ0FBQyxFQUFFLEdBQUdBLEVBQUUsQ0FBQyxHQUFHLElBQUksT0FBTztRQUMvSDtRQUVBLFNBQVNrWjtZQUNQLDhKQUE4SjtZQUU5Sjs7WUFFTSxHQUNOLElBQUkxOUIsSUFBSTtZQUNSLElBQUk2NEIsUUFBUSxJQUFJLENBQUNBLEtBQUs7WUFDdEIsSUFBSThFLFdBQVc7WUFDZixJQUFJdDFCLElBQUk7WUFFUixNQUFPckksSUFBSSxHQUFJO2dCQUNiMjlCLFlBQVkvRSxLQUFLQyxLQUFLLENBQUM3NEIsRUFBRSxHQUFHcUksS0FBS0E7Z0JBQ2pDczFCLFlBQVkzOUIsTUFBTSxLQUFLLE1BQU07Z0JBQzdCQSxLQUFLO1lBQ1A7WUFFQSxPQUFPMjlCO1FBQ1Q7UUFFQSxTQUFTQyxvQkFBb0J2NEIsR0FBRztZQUM5QixJQUFJZ0QsSUFBSTtZQUVSLElBQUloRCxNQUFNLFlBQVlBLE1BQU0sS0FBS0EsTUFBTSxDQUFDLFlBQVlBLE1BQU0sR0FBRztnQkFDM0QsT0FBT3V6QixLQUFLdnpCLE1BQU1nRCxLQUFLQTtZQUN6QjtZQUVBLE9BQU9oRDtRQUNUO1FBRUEsU0FBU3c0QjtZQUNQLDhKQUE4SjtZQUU5Sjs7WUFFTSxHQUNOLElBQUloRixRQUFRLElBQUksQ0FBQ0EsS0FBSztZQUV0QixJQUFJaUYsS0FBS0Ysb0JBQW9CL0UsS0FBSyxDQUFDLEVBQUU7WUFFckMsSUFBSWtGLEtBQUtILG9CQUFvQi9FLEtBQUssQ0FBQyxFQUFFO1lBRXJDLElBQUltRixLQUFLSixvQkFBb0IvRSxLQUFLLENBQUMsRUFBRTtZQUVyQyxJQUFJb0YsS0FBS0wsb0JBQW9CL0UsS0FBSyxDQUFDLEVBQUU7WUFFckMsSUFBSXFGLEtBQUtOLG9CQUFvQi9FLEtBQUssQ0FBQyxHQUFHO1lBRXRDLElBQUlzRixLQUFLUCxvQkFBb0IvRSxLQUFLLENBQUMsR0FBRztZQUV0QyxPQUFPLFlBQVlpRixLQUFLLE1BQU1DLEtBQUssTUFBTUMsS0FBSyxNQUFNQyxLQUFLLE1BQU1DLEtBQUssTUFBTUMsS0FBSztRQUNqRjtRQUVBLE9BQU87WUFDTCxJQUFJLENBQUN6SSxLQUFLLEdBQUdBO1lBQ2IsSUFBSSxDQUFDb0QsTUFBTSxHQUFHQTtZQUNkLElBQUksQ0FBQ0ksT0FBTyxHQUFHQTtZQUNmLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtZQUNmLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtZQUNmLElBQUksQ0FBQ0csSUFBSSxHQUFHQTtZQUNaLElBQUksQ0FBQ0MsWUFBWSxHQUFHQTtZQUNwQixJQUFJLENBQUNILEtBQUssR0FBR0E7WUFDYixJQUFJLENBQUNJLEtBQUssR0FBR0E7WUFDYixJQUFJLENBQUNFLFlBQVksR0FBR0E7WUFDcEIsSUFBSSxDQUFDRyxTQUFTLEdBQUdBO1lBQ2pCLElBQUksQ0FBQ0csU0FBUyxHQUFHQTtZQUNqQixJQUFJLENBQUMrQixRQUFRLEdBQUdBO1lBQ2hCLElBQUksQ0FBQ1EsWUFBWSxHQUFHQTtZQUNwQixJQUFJLENBQUNDLFFBQVEsR0FBR0E7WUFDaEIsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO1lBQ2hCLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtZQUNoQixJQUFJLENBQUNLLGlCQUFpQixHQUFHQTtZQUN6QixJQUFJLENBQUNJLG1CQUFtQixHQUFHQTtZQUMzQixJQUFJLENBQUNLLHVCQUF1QixHQUFHQTtZQUMvQixJQUFJLENBQUNDLEtBQUssR0FBR0E7WUFDYixJQUFJLENBQUNHLE9BQU8sR0FBR0E7WUFDZixJQUFJLENBQUMzSixLQUFLLEdBQUdBO1lBQ2IsSUFBSSxDQUFDcUksY0FBYyxHQUFHQTtZQUN0QixJQUFJLENBQUNGLE1BQU0sR0FBR0E7WUFDZCxJQUFJLENBQUNZLGFBQWEsR0FBR0E7WUFDckIsSUFBSSxDQUFDRixZQUFZLEdBQUdBO1lBQ3BCLElBQUksQ0FBQ0gsZ0JBQWdCLEdBQUdBO1lBQ3hCLElBQUksQ0FBQzNELEVBQUUsR0FBRyxJQUFJLENBQUNnQixTQUFTO1lBQ3hCLElBQUksQ0FBQ2tDLFVBQVUsR0FBR0E7WUFDbEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7WUFDakIsSUFBSSxDQUFDbkIsbUJBQW1CLEdBQUc7WUFDM0IsSUFBSSxDQUFDcEMsS0FBSyxHQUFHaDJCLGlCQUFpQixXQUFXO1lBQ3pDLElBQUksQ0FBQzZ5QixLQUFLO1FBQ1o7SUFDRjtJQUVBLFNBQVMwSSxVQUFVNTZCLEdBQUc7UUFBSTtRQUEyQixJQUFJLE9BQU9DLFdBQVcsY0FBYyxPQUFPQSxPQUFPQyxRQUFRLEtBQUssVUFBVTtZQUFFMDZCLFlBQVksU0FBU3o2QixRQUFRSCxHQUFHO2dCQUFJLE9BQU8sT0FBT0E7WUFBSztRQUFHLE9BQU87WUFBRTQ2QixZQUFZLFNBQVN6NkIsUUFBUUgsR0FBRztnQkFBSSxPQUFPQSxPQUFPLE9BQU9DLFdBQVcsY0FBY0QsSUFBSUksV0FBVyxLQUFLSCxVQUFVRCxRQUFRQyxPQUFPckQsU0FBUyxHQUFHLFdBQVcsT0FBT29EO1lBQUs7UUFBRztRQUFFLE9BQU80NkIsVUFBVTU2QjtJQUFNO0lBQ2pZLElBQUkxRSxTQUFTLENBQUM7SUFDZCxJQUFJNGlCLGFBQWE7SUFDakIsSUFBSWpULGdCQUFnQjtJQUNwQixJQUFJMEssV0FBVztJQUVmLFNBQVNrbEIsWUFBWUMsSUFBSTtRQUN2QmgvQixnQkFBZ0JnL0I7SUFDbEI7SUFFQSxTQUFTN2M7UUFDUCxJQUFJQyxlQUFlLE1BQU07WUFDdkJ0QixpQkFBaUJxQixnQkFBZ0IsQ0FBQ2hULGVBQWVpVCxZQUFZdkk7UUFDL0QsT0FBTztZQUNMaUgsaUJBQWlCcUIsZ0JBQWdCO1FBQ25DO0lBQ0Y7SUFFQSxTQUFTOGMscUJBQXFCbi9CLElBQUk7UUFDaENxSyxtQkFBbUJySztJQUNyQjtJQUVBLFNBQVNvL0IsVUFBVUMsTUFBTTtRQUN2QngwQixZQUFZdzBCO0lBQ2Q7SUFFQSxTQUFTNXNCLGNBQWNzSSxNQUFNO1FBQzNCLElBQUl1SCxlQUFlLE1BQU07WUFDdkJ2SCxPQUFPMUwsYUFBYSxHQUFHakIsS0FBS0MsS0FBSyxDQUFDZ0I7UUFDcEM7UUFFQSxPQUFPMlIsaUJBQWlCdk8sYUFBYSxDQUFDc0k7SUFDeEM7SUFFQSxTQUFTdWtCLFdBQVduL0IsS0FBSztRQUN2QixJQUFJLE9BQU9BLFVBQVUsVUFBVTtZQUM3QixPQUFRQTtnQkFDTixLQUFLO29CQUNId0ssd0JBQXdCO29CQUN4QjtnQkFFRjtnQkFDQSxLQUFLO29CQUNIQSx3QkFBd0I7b0JBQ3hCO2dCQUVGLEtBQUs7b0JBQ0hBLHdCQUF3QjtvQkFDeEI7WUFDSjtRQUNGLE9BQU8sSUFBSSxDQUFDc1UsTUFBTTllLFVBQVVBLFFBQVEsR0FBRztZQUNyQ3dLLHdCQUF3QnhLO1FBQzFCO1FBRUEsSUFBSXlLLDZCQUE2QixJQUFJO1lBQ25DcEUsWUFBWTtRQUNkLE9BQU87WUFDTEEsWUFBWTtRQUNkO0lBQ0Y7SUFFQSxTQUFTKzRCO1FBQ1AsT0FBTyxPQUFPdGdDLGNBQWM7SUFDOUI7SUFFQSxTQUFTdWdDLGNBQWNsL0IsSUFBSSxFQUFFbS9CLE1BQU07UUFDakMsSUFBSW4vQixTQUFTLGVBQWU7WUFDMUJpSyxxQkFBcUJrMUI7UUFDdkI7SUFDRjtJQUVBLFNBQVNDLFdBQVd0bkIsSUFBSTtRQUN0QixPQUFRQTtZQUNOLEtBQUs7Z0JBQ0gsT0FBTzJhO1lBRVQsS0FBSztnQkFDSCxPQUFPd0M7WUFFVCxLQUFLO2dCQUNILE9BQU80RDtZQUVUO2dCQUNFLE9BQU87UUFDWDtJQUNGO0lBRUF6NUIsT0FBT29ELElBQUksR0FBR2tlLGlCQUFpQmxlLElBQUk7SUFDbkNwRCxPQUFPMEMsS0FBSyxHQUFHNGUsaUJBQWlCNWUsS0FBSztJQUNyQzFDLE9BQU9RLGVBQWUsR0FBRysrQjtJQUN6QnYvQixPQUFPNmUsV0FBVyxHQUFHeUMsaUJBQWlCekMsV0FBVztJQUNqRDdlLE9BQU9nZ0IsUUFBUSxHQUFHc0IsaUJBQWlCdEIsUUFBUTtJQUMzQ2hnQixPQUFPaWdCLFlBQVksR0FBR3FCLGlCQUFpQnJCLFlBQVk7SUFDbkRqZ0IsT0FBTzhlLElBQUksR0FBR3dDLGlCQUFpQnhDLElBQUk7SUFDbkM5ZSxPQUFPMmlCLGdCQUFnQixHQUFHQTtJQUMxQjNpQixPQUFPZ2lCLGlCQUFpQixHQUFHVixpQkFBaUJVLGlCQUFpQjtJQUM3RGhpQixPQUFPK1MsYUFBYSxHQUFHQTtJQUN2Qi9TLE9BQU95L0Isb0JBQW9CLEdBQUdBO0lBQzlCei9CLE9BQU9xZSxNQUFNLEdBQUdpRCxpQkFBaUJqRCxNQUFNLEVBQUUsd0JBQXdCO0lBRWpFcmUsT0FBT21mLFdBQVcsR0FBR21DLGlCQUFpQm5DLFdBQVc7SUFDakRuZixPQUFPeVcsT0FBTyxHQUFHNkssaUJBQWlCN0ssT0FBTztJQUN6Q3pXLE9BQU80L0IsVUFBVSxHQUFHQTtJQUNwQjUvQixPQUFPNi9CLFNBQVMsR0FBR0E7SUFDbkI3L0IsT0FBTzgvQixhQUFhLEdBQUdBO0lBQ3ZCOS9CLE9BQU9zakIsTUFBTSxHQUFHaEMsaUJBQWlCZ0MsTUFBTTtJQUN2Q3RqQixPQUFPdWpCLFFBQVEsR0FBR2pDLGlCQUFpQmlDLFFBQVE7SUFDM0N2akIsT0FBT3dELFNBQVMsR0FBRzhkLGlCQUFpQjlkLFNBQVM7SUFDN0N4RCxPQUFPMkQsSUFBSSxHQUFHMmQsaUJBQWlCM2QsSUFBSTtJQUNuQzNELE9BQU80RCxNQUFNLEdBQUcwZCxpQkFBaUIxZCxNQUFNO0lBQ3ZDNUQsT0FBT2tpQix1QkFBdUIsR0FBR1osaUJBQWlCWSx1QkFBdUI7SUFDekVsaUIsT0FBT2lnQyxZQUFZLEdBQUc1L0I7SUFDdEJMLE9BQU9rZ0MsV0FBVyxHQUFHUjtJQUNyQjEvQixPQUFPbWdDLFlBQVksR0FBR0g7SUFDdEJoZ0MsT0FBT29nQyxPQUFPLEdBQUc7SUFFakIsU0FBU0M7UUFDUCxJQUFJeC9CLFNBQVNvUixVQUFVLEtBQUssWUFBWTtZQUN0Q21ELGNBQWNrckI7WUFDZDNkO1FBQ0Y7SUFDRjtJQUVBLFNBQVM0ZCxpQkFBaUJDLFFBQVE7UUFDaEMsSUFBSUMsT0FBT0MsWUFBWXR4QixLQUFLLENBQUM7UUFFN0IsSUFBSyxJQUFJbE8sSUFBSSxHQUFHQSxJQUFJdS9CLEtBQUtyL0IsTUFBTSxFQUFFRixLQUFLLEVBQUc7WUFDdkMsSUFBSXkvQixPQUFPRixJQUFJLENBQUN2L0IsRUFBRSxDQUFDa08sS0FBSyxDQUFDO1lBRXpCLElBQUl3eEIsbUJBQW1CRCxJQUFJLENBQUMsRUFBRSxLQUFLSCxVQUFVO2dCQUMzQyw2QkFBNkI7Z0JBQzdCLE9BQU9JLG1CQUFtQkQsSUFBSSxDQUFDLEVBQUU7WUFDbkM7UUFDRjtRQUVBLE9BQU87SUFDVDtJQUVBLElBQUlELGNBQWM7SUFFbEIsSUFBSTlkLFlBQVk7UUFDZCxJQUFJaWUsVUFBVWhnQyxTQUFTc2lCLG9CQUFvQixDQUFDO1FBQzVDLElBQUkvQixRQUFReWYsUUFBUXovQixNQUFNLEdBQUc7UUFDN0IsSUFBSTAvQixXQUFXRCxPQUFPLENBQUN6ZixNQUFNLElBQUk7WUFDL0JsZSxLQUFLO1FBQ1A7UUFDQXc5QixjQUFjSSxTQUFTNTlCLEdBQUcsR0FBRzQ5QixTQUFTNTlCLEdBQUcsQ0FBQzBnQixPQUFPLENBQUMsY0FBYyxNQUFNLElBQUksd0NBQXdDO1FBRWxIdkosV0FBV2ttQixpQkFBaUI7SUFDOUI7SUFFQSxJQUFJRCwwQkFBMEJ0ckIsWUFBWXFyQixZQUFZLE1BQU0sdUVBQXVFO0lBRW5JLElBQUk7UUFDRixJQUFJLENBQUUsRUFBQyxNQUE4QixHQUFHLENBQVcsR0FBR2YsVUFBVTUvQixRQUFPLE1BQU8sWUFBWSxRQUFhQyxLQUFLLFdBQVUsS0FBTSxDQUFFLE1BQWtCLElBQWNDLHdCQUFVLENBQUUsK0JBQStCO1FBQWxDLEdBQ3JLLEVBRUQ7SUFDSCxFQUFFLE9BQU9tUyxLQUFLLENBQ2Q7SUFFQSxJQUFJaXZCLGlCQUFpQjtRQUNuQixJQUFJeHJCLEtBQUssQ0FBQztRQUNWLElBQUl5ckIsWUFBWSxDQUFDO1FBQ2pCenJCLEdBQUcwckIsZ0JBQWdCLEdBQUdBO1FBQ3RCMXJCLEdBQUcyckIsV0FBVyxHQUFHQTtRQUVqQixTQUFTRCxpQkFBaUJub0IsRUFBRSxFQUFFdFosT0FBTztZQUNuQyxJQUFJLENBQUN3aEMsU0FBUyxDQUFDbG9CLEdBQUcsRUFBRTtnQkFDbEJrb0IsU0FBUyxDQUFDbG9CLEdBQUcsR0FBR3RaO1lBQ2xCO1FBQ0Y7UUFFQSxTQUFTMGhDLFlBQVlwb0IsRUFBRSxFQUFFa0osSUFBSSxFQUFFaFcsSUFBSTtZQUNqQyxPQUFPLElBQUlnMUIsU0FBUyxDQUFDbG9CLEdBQUcsQ0FBQ2tKLE1BQU1oVztRQUNqQztRQUVBLE9BQU91SjtJQUNUO0lBRUEsU0FBUzRyQixpQkFBaUI7SUFFMUJBLGNBQWM5L0IsU0FBUyxDQUFDKy9CLHNCQUFzQixHQUFHLFlBQWE7SUFFOURELGNBQWM5L0IsU0FBUyxDQUFDZ2dDLGtCQUFrQixHQUFHLFlBQWE7SUFFMURGLGNBQWM5L0IsU0FBUyxDQUFDazBCLFFBQVEsR0FBRyxTQUFVdnBCLElBQUk7UUFDL0MsSUFBSSxDQUFDLElBQUksQ0FBQzJFLE1BQU0sRUFBRTtZQUNoQix1SUFBdUk7WUFDdkkzRSxLQUFLZ2pCLEVBQUUsQ0FBQzFULFNBQVMsQ0FBQ3NYLGtCQUFrQixDQUFDNW1CLEtBQUtnakIsRUFBRTtZQUM1QyxJQUFJckYsWUFBWTtnQkFDZHlMLE9BQU9wcEIsS0FBS2dqQixFQUFFO2dCQUNkaGpCLE1BQU1BO2dCQUNOc3FCLHNCQUFzQmIsb0JBQW9CQyxrQkFBa0I7WUFDOUQ7WUFDQSxJQUFJLENBQUMxbkIsTUFBTSxDQUFDeEwsSUFBSSxDQUFDbW5CO1lBQ2pCLElBQUksQ0FBQzBYLGtCQUFrQixDQUFDMVg7WUFFeEIsSUFBSSxJQUFJLENBQUMrSixXQUFXLEVBQUU7Z0JBQ3BCMW5CLEtBQUtzMUIsYUFBYTtZQUNwQjtRQUNGO0lBQ0Y7SUFFQUgsY0FBYzkvQixTQUFTLENBQUM2ZSxJQUFJLEdBQUcsU0FBVThCLElBQUksRUFBRWhXLElBQUk7UUFDakQsSUFBSSxDQUFDZ0MsTUFBTSxHQUFHLEVBQUU7UUFDaEIsSUFBSSxDQUFDZ1UsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQzRSLDRCQUE0QixDQUFDNVI7UUFDbEMsSUFBSSxDQUFDb2Ysc0JBQXNCLENBQUNwZixNQUFNaFc7UUFDbEMsSUFBSSxDQUFDb21CLE9BQU8sR0FBR2p5QjtRQUNmLElBQUksQ0FBQ3dRLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ3ZELENBQUMsR0FBRztRQUVULElBQUksSUFBSSxDQUFDcW1CLGlCQUFpQixDQUFDdHlCLE1BQU0sRUFBRTtZQUNqQyxJQUFJLENBQUNpTSxDQUFDLEdBQUc7UUFDWCxPQUFPO1lBQ0wsSUFBSSxDQUFDMmxCLFFBQVEsQ0FBQztRQUNoQjtJQUNGO0lBRUFvTyxjQUFjOS9CLFNBQVMsQ0FBQ2tnQyxXQUFXLEdBQUc7UUFDcEMsSUFBSSxJQUFJLENBQUN2ZixJQUFJLENBQUN0RyxVQUFVLENBQUMwVyxPQUFPLEtBQUssSUFBSSxDQUFDQSxPQUFPLEVBQUU7WUFDakQ7UUFDRjtRQUVBLElBQUksQ0FBQ0EsT0FBTyxHQUFHLElBQUksQ0FBQ3BRLElBQUksQ0FBQ3RHLFVBQVUsQ0FBQzBXLE9BQU87UUFDM0MsSUFBSSxDQUFDdUIsd0JBQXdCO0lBQy9CO0lBRUE3eUIsZ0JBQWdCO1FBQUMweUI7S0FBeUIsRUFBRTJOO0lBRTVDLFNBQVNLLGdCQUFnQjtJQUV6QjFnQyxnQkFBZ0I7UUFBQ3FnQztLQUFjLEVBQUVLO0lBRWpDQSxhQUFhbmdDLFNBQVMsQ0FBQysvQixzQkFBc0IsR0FBRyxTQUFVcGYsSUFBSSxFQUFFaFcsSUFBSTtRQUNsRSxJQUFJLENBQUMzQyxDQUFDLEdBQUcrcEIsZ0JBQWdCQyxPQUFPLENBQUNyUixNQUFNaFcsS0FBSzNDLENBQUMsRUFBRSxHQUFHLE1BQU0sSUFBSTtRQUM1RCxJQUFJLENBQUN1RCxDQUFDLEdBQUd3bUIsZ0JBQWdCQyxPQUFPLENBQUNyUixNQUFNaFcsS0FBS1ksQ0FBQyxFQUFFLEdBQUcsTUFBTSxJQUFJO1FBQzVELElBQUksQ0FBQ2tDLENBQUMsR0FBR3NrQixnQkFBZ0JDLE9BQU8sQ0FBQ3JSLE1BQU1oVyxLQUFLOEMsQ0FBQyxFQUFFLEdBQUcsR0FBRyxJQUFJO1FBQ3pELElBQUksQ0FBQzJ5QixNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQzNPLFFBQVEsR0FBRyxJQUFJLENBQUN3TyxXQUFXO1FBQ2hDLElBQUksQ0FBQ3pHLENBQUMsR0FBRzl1QixLQUFLOHVCLENBQUM7UUFDZixJQUFJLENBQUNwSCxXQUFXLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQ3JxQixDQUFDLENBQUNncEIsZUFBZSxDQUFDbHhCLE1BQU0sSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDeUwsQ0FBQyxDQUFDeWxCLGVBQWUsQ0FBQ2x4QixNQUFNLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQzJOLENBQUMsQ0FBQ3VqQixlQUFlLENBQUNseEIsTUFBTTtJQUMxSDtJQUVBcWdDLGFBQWFuZ0MsU0FBUyxDQUFDZ2dDLGtCQUFrQixHQUFHLFNBQVUxWCxTQUFTO1FBQzdEQSxVQUFVZ1ksU0FBUyxHQUFHLEVBQUU7SUFDMUI7SUFFQUgsYUFBYW5nQyxTQUFTLENBQUN1Z0MsbUJBQW1CLEdBQUcsU0FBVXY0QixDQUFDLEVBQUV1RCxDQUFDLEVBQUVpMUIsV0FBVyxFQUFFdGEsV0FBVyxFQUFFdWEsbUJBQW1CO1FBQ3hHLElBQUlybkIsV0FBVyxFQUFFO1FBRWpCLElBQUk3TixLQUFLLEdBQUc7WUFDVjZOLFNBQVNqWSxJQUFJLENBQUM7Z0JBQ1o2RyxHQUFHQTtnQkFDSHVELEdBQUdBO1lBQ0w7UUFDRixPQUFPLElBQUl2RCxLQUFLLEdBQUc7WUFDakJvUixTQUFTalksSUFBSSxDQUFDO2dCQUNaNkcsR0FBR0EsSUFBSTtnQkFDUHVELEdBQUdBLElBQUk7WUFDVDtRQUNGLE9BQU87WUFDTDZOLFNBQVNqWSxJQUFJLENBQUM7Z0JBQ1o2RyxHQUFHQTtnQkFDSHVELEdBQUc7WUFDTDtZQUNBNk4sU0FBU2pZLElBQUksQ0FBQztnQkFDWjZHLEdBQUc7Z0JBQ0h1RCxHQUFHQSxJQUFJO1lBQ1Q7UUFDRjtRQUVBLElBQUltMUIsZ0JBQWdCLEVBQUU7UUFDdEIsSUFBSTlnQztRQUNKLElBQUlDLE1BQU11WixTQUFTdFosTUFBTTtRQUN6QixJQUFJNmdDO1FBRUosSUFBSy9nQyxJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQitnQyxZQUFZdm5CLFFBQVEsQ0FBQ3haLEVBQUU7WUFFdkIsSUFBSSxDQUFFK2dDLENBQUFBLFVBQVVwMUIsQ0FBQyxHQUFHazFCLHNCQUFzQnZhLGVBQWV5YSxVQUFVMzRCLENBQUMsR0FBR3k0QixzQkFBc0J2YSxjQUFjc2EsV0FBVSxHQUFJO2dCQUN2SCxJQUFJSTtnQkFDSixJQUFJQztnQkFFSixJQUFJRixVQUFVMzRCLENBQUMsR0FBR3k0Qix1QkFBdUJ2YSxhQUFhO29CQUNwRDBhLFNBQVM7Z0JBQ1gsT0FBTztvQkFDTEEsU0FBUyxDQUFDRCxVQUFVMzRCLENBQUMsR0FBR3k0QixzQkFBc0J2YSxXQUFVLElBQUtzYTtnQkFDL0Q7Z0JBRUEsSUFBSUcsVUFBVXAxQixDQUFDLEdBQUdrMUIsdUJBQXVCdmEsY0FBY3NhLGFBQWE7b0JBQ2xFSyxTQUFTO2dCQUNYLE9BQU87b0JBQ0xBLFNBQVMsQ0FBQ0YsVUFBVXAxQixDQUFDLEdBQUdrMUIsc0JBQXNCdmEsV0FBVSxJQUFLc2E7Z0JBQy9EO2dCQUVBRSxjQUFjdi9CLElBQUksQ0FBQztvQkFBQ3kvQjtvQkFBUUM7aUJBQU87WUFDckM7UUFDRjtRQUVBLElBQUksQ0FBQ0gsY0FBYzVnQyxNQUFNLEVBQUU7WUFDekI0Z0MsY0FBY3YvQixJQUFJLENBQUM7Z0JBQUM7Z0JBQUc7YUFBRTtRQUMzQjtRQUVBLE9BQU91L0I7SUFDVDtJQUVBUCxhQUFhbmdDLFNBQVMsQ0FBQzhnQyxnQkFBZ0IsR0FBRyxTQUFVUixTQUFTO1FBQzNELElBQUkxZ0M7UUFDSixJQUFJQyxNQUFNeWdDLFVBQVV4Z0MsTUFBTTtRQUUxQixJQUFLRixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQnltQixtQkFBbUJOLE9BQU8sQ0FBQ3VhLFNBQVMsQ0FBQzFnQyxFQUFFO1FBQ3pDO1FBRUEwZ0MsVUFBVXhnQyxNQUFNLEdBQUc7UUFDbkIsT0FBT3dnQztJQUNUO0lBRUFILGFBQWFuZ0MsU0FBUyxDQUFDK2dDLGFBQWEsR0FBRyxTQUFVN1AsYUFBYTtRQUM1RCxJQUFJbHBCO1FBQ0osSUFBSXVEO1FBRUosSUFBSSxJQUFJLENBQUNzbEIsSUFBSSxJQUFJSyxlQUFlO1lBQzlCLElBQUl6akIsSUFBSSxJQUFJLENBQUNBLENBQUMsQ0FBQ3hGLENBQUMsR0FBRyxNQUFNO1lBRXpCLElBQUl3RixJQUFJLEdBQUc7Z0JBQ1RBLEtBQUs7WUFDUDtZQUVBLElBQUksSUFBSSxDQUFDekYsQ0FBQyxDQUFDQyxDQUFDLEdBQUcsR0FBRztnQkFDaEJELElBQUksSUFBSXlGO1lBQ1YsT0FBTyxJQUFJLElBQUksQ0FBQ3pGLENBQUMsQ0FBQ0MsQ0FBQyxHQUFHLEdBQUc7Z0JBQ3ZCRCxJQUFJLElBQUl5RjtZQUNWLE9BQU87Z0JBQ0x6RixJQUFJLElBQUksQ0FBQ0EsQ0FBQyxDQUFDQyxDQUFDLEdBQUd3RjtZQUNqQjtZQUVBLElBQUksSUFBSSxDQUFDbEMsQ0FBQyxDQUFDdEQsQ0FBQyxHQUFHLEdBQUc7Z0JBQ2hCc0QsSUFBSSxJQUFJa0M7WUFDVixPQUFPLElBQUksSUFBSSxDQUFDbEMsQ0FBQyxDQUFDdEQsQ0FBQyxHQUFHLEdBQUc7Z0JBQ3ZCc0QsSUFBSSxJQUFJa0M7WUFDVixPQUFPO2dCQUNMbEMsSUFBSSxJQUFJLENBQUNBLENBQUMsQ0FBQ3RELENBQUMsR0FBR3dGO1lBQ2pCO1lBRUEsSUFBSXpGLElBQUl1RCxHQUFHO2dCQUNULElBQUl5MUIsS0FBS2g1QjtnQkFDVEEsSUFBSXVEO2dCQUNKQSxJQUFJeTFCO1lBQ047WUFFQWg1QixJQUFJOUQsS0FBS3dCLEtBQUssQ0FBQ3NDLElBQUksU0FBUztZQUM1QnVELElBQUlySCxLQUFLd0IsS0FBSyxDQUFDNkYsSUFBSSxTQUFTO1lBQzVCLElBQUksQ0FBQzYwQixNQUFNLEdBQUdwNEI7WUFDZCxJQUFJLENBQUNxNEIsTUFBTSxHQUFHOTBCO1FBQ2hCLE9BQU87WUFDTHZELElBQUksSUFBSSxDQUFDbzRCLE1BQU07WUFDZjcwQixJQUFJLElBQUksQ0FBQzgwQixNQUFNO1FBQ2pCO1FBRUEsSUFBSVk7UUFDSixJQUFJcmhDO1FBQ0osSUFBSUMsTUFBTSxJQUFJLENBQUM4TSxNQUFNLENBQUM3TSxNQUFNO1FBQzVCLElBQUkrTDtRQUNKLElBQUlDO1FBQ0osSUFBSXcwQjtRQUNKLElBQUl0eEI7UUFDSixJQUFJa3lCO1FBQ0osSUFBSVQsc0JBQXNCO1FBRTFCLElBQUlsMUIsTUFBTXZELEdBQUc7WUFDWCxJQUFLcEksSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7Z0JBQzNCLElBQUksQ0FBQytNLE1BQU0sQ0FBQy9NLEVBQUUsQ0FBQ3ExQixvQkFBb0IsQ0FBQ2QsYUFBYTtnQkFDakQsSUFBSSxDQUFDeG5CLE1BQU0sQ0FBQy9NLEVBQUUsQ0FBQ20wQixLQUFLLENBQUNsRCxJQUFJLEdBQUc7Z0JBQzVCLElBQUksQ0FBQ2xrQixNQUFNLENBQUMvTSxFQUFFLENBQUNtMEIsS0FBSyxDQUFDaUIsS0FBSyxHQUFHLElBQUksQ0FBQ3JvQixNQUFNLENBQUMvTSxFQUFFLENBQUNxMUIsb0JBQW9CO2dCQUVoRSxJQUFJLElBQUksQ0FBQ3BFLElBQUksRUFBRTtvQkFDYixJQUFJLENBQUNsa0IsTUFBTSxDQUFDL00sRUFBRSxDQUFDMGdDLFNBQVMsQ0FBQ3hnQyxNQUFNLEdBQUc7Z0JBQ3BDO1lBQ0Y7UUFDRixPQUFPLElBQUksQ0FBRXlMLENBQUFBLE1BQU0sS0FBS3ZELE1BQU0sS0FBS3VELE1BQU0sS0FBS3ZELE1BQU0sSUFBSTtZQUN0RCxJQUFJb1IsV0FBVyxFQUFFO1lBQ2pCLElBQUlrUDtZQUNKLElBQUkyTTtZQUVKLElBQUtyMUIsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7Z0JBQzNCMG9CLFlBQVksSUFBSSxDQUFDM2IsTUFBTSxDQUFDL00sRUFBRSxFQUFFLGdHQUFnRztnQkFFNUgsSUFBSSxDQUFDMG9CLFVBQVV5TCxLQUFLLENBQUNsRCxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUNBLElBQUksSUFBSSxDQUFDSyxpQkFBaUIsSUFBSSxDQUFDdUksQ0FBQyxLQUFLLEdBQUc7b0JBQ3pFblIsVUFBVXlMLEtBQUssQ0FBQ2lCLEtBQUssR0FBRzFNLFVBQVUyTSxvQkFBb0I7Z0JBQ3hELE9BQU87b0JBQ0xnTSxhQUFhM1ksVUFBVXlMLEtBQUssQ0FBQ2lCLEtBQUs7b0JBQ2xDbHBCLE9BQU9tMUIsV0FBV3RiLE9BQU87b0JBQ3pCdWIsbUJBQW1CO29CQUVuQixJQUFJLENBQUM1WSxVQUFVeUwsS0FBSyxDQUFDbEQsSUFBSSxJQUFJdkksVUFBVWdZLFNBQVMsQ0FBQ3hnQyxNQUFNLEVBQUU7d0JBQ3ZEb2hDLG1CQUFtQjVZLFVBQVU0WSxnQkFBZ0I7b0JBQy9DLE9BQU87d0JBQ0xaLFlBQVksSUFBSSxDQUFDUSxnQkFBZ0IsQ0FBQ3hZLFVBQVVnWSxTQUFTO3dCQUVyRCxJQUFLejBCLElBQUksR0FBR0EsSUFBSUMsTUFBTUQsS0FBSyxFQUFHOzRCQUM1Qm1ELFdBQVdxYyxJQUFJaEQsaUJBQWlCLENBQUM0WSxXQUFXdDBCLE1BQU0sQ0FBQ2QsRUFBRTs0QkFDckR5MEIsVUFBVW4vQixJQUFJLENBQUM2Tjs0QkFDZmt5QixvQkFBb0JseUIsU0FBU3NYLFdBQVc7d0JBQzFDO3dCQUVBZ0MsVUFBVTRZLGdCQUFnQixHQUFHQTt3QkFDN0I1WSxVQUFVZ1ksU0FBUyxHQUFHQTtvQkFDeEI7b0JBRUFHLHVCQUF1QlM7b0JBQ3ZCNVksVUFBVXlMLEtBQUssQ0FBQ2xELElBQUksR0FBRztnQkFDekI7WUFDRjtZQUVBLElBQUkrUCxTQUFTNTRCO1lBQ2IsSUFBSTY0QixTQUFTdDFCO1lBQ2IsSUFBSTJhLGNBQWM7WUFDbEIsSUFBSWliO1lBRUosSUFBS3ZoQyxJQUFJQyxNQUFNLEdBQUdELEtBQUssR0FBR0EsS0FBSyxFQUFHO2dCQUNoQzBvQixZQUFZLElBQUksQ0FBQzNiLE1BQU0sQ0FBQy9NLEVBQUU7Z0JBRTFCLElBQUkwb0IsVUFBVXlMLEtBQUssQ0FBQ2xELElBQUksRUFBRTtvQkFDeEJvRSx1QkFBdUIzTSxVQUFVMk0sb0JBQW9CO29CQUNyREEscUJBQXFCZCxhQUFhLElBQUksNEhBQTRIO29CQUVsSyxJQUFJLElBQUksQ0FBQ3NGLENBQUMsS0FBSyxLQUFLNTVCLE1BQU0sR0FBRzt3QkFDM0JzaEMsUUFBUSxJQUFJLENBQUNaLG1CQUFtQixDQUFDdjRCLEdBQUd1RCxHQUFHK2MsVUFBVTRZLGdCQUFnQixFQUFFaGIsYUFBYXVhO3dCQUNoRnZhLGVBQWVvQyxVQUFVNFksZ0JBQWdCO29CQUMzQyxPQUFPO3dCQUNMQyxRQUFROzRCQUFDO2dDQUFDUDtnQ0FBUUM7NkJBQU87eUJBQUM7b0JBQzVCO29CQUVBLzBCLE9BQU9xMUIsTUFBTXJoQyxNQUFNO29CQUVuQixJQUFLK0wsSUFBSSxHQUFHQSxJQUFJQyxNQUFNRCxLQUFLLEVBQUc7d0JBQzVCKzBCLFNBQVNPLEtBQUssQ0FBQ3QxQixFQUFFLENBQUMsRUFBRTt3QkFDcEJnMUIsU0FBU00sS0FBSyxDQUFDdDFCLEVBQUUsQ0FBQyxFQUFFO3dCQUNwQnVOLFNBQVN0WixNQUFNLEdBQUc7d0JBRWxCLElBQUkrZ0MsVUFBVSxHQUFHOzRCQUNmem5CLFNBQVNqWSxJQUFJLENBQUM7Z0NBQ1o2RyxHQUFHc2dCLFVBQVU0WSxnQkFBZ0IsR0FBR047Z0NBQ2hDcjFCLEdBQUcrYyxVQUFVNFksZ0JBQWdCLEdBQUdMOzRCQUNsQzt3QkFDRixPQUFPLElBQUlELFVBQVUsR0FBRzs0QkFDdEJ4bkIsU0FBU2pZLElBQUksQ0FBQztnQ0FDWjZHLEdBQUdzZ0IsVUFBVTRZLGdCQUFnQixHQUFJTixDQUFBQSxTQUFTO2dDQUMxQ3IxQixHQUFHK2MsVUFBVTRZLGdCQUFnQixHQUFJTCxDQUFBQSxTQUFTOzRCQUM1Qzt3QkFDRixPQUFPOzRCQUNMem5CLFNBQVNqWSxJQUFJLENBQUM7Z0NBQ1o2RyxHQUFHc2dCLFVBQVU0WSxnQkFBZ0IsR0FBR047Z0NBQ2hDcjFCLEdBQUcrYyxVQUFVNFksZ0JBQWdCOzRCQUMvQjs0QkFDQTluQixTQUFTalksSUFBSSxDQUFDO2dDQUNaNkcsR0FBRztnQ0FDSHVELEdBQUcrYyxVQUFVNFksZ0JBQWdCLEdBQUlMLENBQUFBLFNBQVM7NEJBQzVDO3dCQUNGO3dCQUVBLElBQUlPLGdCQUFnQixJQUFJLENBQUNDLFNBQVMsQ0FBQy9ZLFdBQVdsUCxRQUFRLENBQUMsRUFBRTt3QkFFekQsSUFBSUEsUUFBUSxDQUFDLEVBQUUsQ0FBQ3BSLENBQUMsS0FBS29SLFFBQVEsQ0FBQyxFQUFFLENBQUM3TixDQUFDLEVBQUU7NEJBQ25DLElBQUk2TixTQUFTdFosTUFBTSxHQUFHLEdBQUc7Z0NBQ3ZCLElBQUl3aEMsd0JBQXdCaFosVUFBVXlMLEtBQUssQ0FBQ2lCLEtBQUssQ0FBQ3JvQixNQUFNLENBQUMyYixVQUFVeUwsS0FBSyxDQUFDaUIsS0FBSyxDQUFDclAsT0FBTyxHQUFHLEVBQUU7Z0NBRTNGLElBQUkyYixzQkFBc0JueUIsQ0FBQyxFQUFFO29DQUMzQixJQUFJb3lCLFlBQVlILGNBQWNJLEdBQUc7b0NBQ2pDLElBQUksQ0FBQ0MsUUFBUSxDQUFDTCxlQUFlbk07b0NBQzdCbU0sZ0JBQWdCLElBQUksQ0FBQ0MsU0FBUyxDQUFDL1ksV0FBV2xQLFFBQVEsQ0FBQyxFQUFFLEVBQUVtb0I7Z0NBQ3pELE9BQU87b0NBQ0wsSUFBSSxDQUFDRSxRQUFRLENBQUNMLGVBQWVuTTtvQ0FDN0JtTSxnQkFBZ0IsSUFBSSxDQUFDQyxTQUFTLENBQUMvWSxXQUFXbFAsUUFBUSxDQUFDLEVBQUU7Z0NBQ3ZEOzRCQUNGOzRCQUVBLElBQUksQ0FBQ3FvQixRQUFRLENBQUNMLGVBQWVuTTt3QkFDL0I7b0JBQ0Y7b0JBRUEzTSxVQUFVeUwsS0FBSyxDQUFDaUIsS0FBSyxHQUFHQztnQkFDMUI7WUFDRjtRQUNGLE9BQU8sSUFBSSxJQUFJLENBQUNwRSxJQUFJLEVBQUU7WUFDcEIsSUFBS2p4QixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztnQkFDM0IsK0ZBQStGO2dCQUMvRixxREFBcUQ7Z0JBQ3JELElBQUksQ0FBQytNLE1BQU0sQ0FBQy9NLEVBQUUsQ0FBQzBnQyxTQUFTLENBQUN4Z0MsTUFBTSxHQUFHO2dCQUNsQyxJQUFJLENBQUM2TSxNQUFNLENBQUMvTSxFQUFFLENBQUNtMEIsS0FBSyxDQUFDbEQsSUFBSSxHQUFHO1lBQzlCO1FBQ0Y7SUFDRjtJQUVBc1AsYUFBYW5nQyxTQUFTLENBQUN5aEMsUUFBUSxHQUFHLFNBQVVDLFFBQVEsRUFBRXpNLG9CQUFvQjtRQUN4RSxJQUFJcjFCO1FBQ0osSUFBSUMsTUFBTTZoQyxTQUFTNWhDLE1BQU07UUFFekIsSUFBS0YsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDM0JxMUIscUJBQXFCZixRQUFRLENBQUN3TixRQUFRLENBQUM5aEMsRUFBRTtRQUMzQztJQUNGO0lBRUF1Z0MsYUFBYW5nQyxTQUFTLENBQUMyaEMsVUFBVSxHQUFHLFNBQVVqYSxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVnTSxTQUFTLEVBQUVmLEdBQUcsRUFBRThPLFFBQVE7UUFDeEYvTixVQUFVaEIsT0FBTyxDQUFDbEwsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUUsRUFBRSxLQUFLbUw7UUFDdkNlLFVBQVVoQixPQUFPLENBQUNqTCxHQUFHLENBQUMsRUFBRSxFQUFFQSxHQUFHLENBQUMsRUFBRSxFQUFFLEtBQUtrTCxNQUFNO1FBRTdDLElBQUk4TyxVQUFVO1lBQ1ovTixVQUFVaEIsT0FBTyxDQUFDbkwsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUUsRUFBRSxLQUFLb0w7UUFDekM7UUFFQWUsVUFBVWhCLE9BQU8sQ0FBQ2hMLEdBQUcsQ0FBQyxFQUFFLEVBQUVBLEdBQUcsQ0FBQyxFQUFFLEVBQUUsS0FBS2lMLE1BQU07SUFDL0M7SUFFQXFOLGFBQWFuZ0MsU0FBUyxDQUFDNmhDLG1CQUFtQixHQUFHLFNBQVUxZCxNQUFNLEVBQUUwUCxTQUFTLEVBQUVmLEdBQUcsRUFBRThPLFFBQVE7UUFDckYvTixVQUFVaEIsT0FBTyxDQUFDMU8sTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRSxLQUFLMk87UUFDN0NlLFVBQVVoQixPQUFPLENBQUMxTyxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFLEtBQUsyTyxNQUFNO1FBRW5ELElBQUk4TyxVQUFVO1lBQ1ovTixVQUFVaEIsT0FBTyxDQUFDMU8sTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRSxLQUFLMk87UUFDL0M7UUFFQWUsVUFBVWhCLE9BQU8sQ0FBQzFPLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSzJPLE1BQU07SUFDckQ7SUFFQXFOLGFBQWFuZ0MsU0FBUyxDQUFDcWhDLFNBQVMsR0FBRyxTQUFVL1ksU0FBUyxFQUFFd1osWUFBWSxFQUFFak8sU0FBUztRQUM3RSxJQUFJeU0sWUFBWWhZLFVBQVVnWSxTQUFTO1FBQ25DLElBQUlXLGFBQWEzWSxVQUFVeUwsS0FBSyxDQUFDaUIsS0FBSyxDQUFDcm9CLE1BQU07UUFDN0MsSUFBSS9NO1FBQ0osSUFBSUMsTUFBTXlvQixVQUFVeUwsS0FBSyxDQUFDaUIsS0FBSyxDQUFDclAsT0FBTztRQUN2QyxJQUFJOVo7UUFDSixJQUFJQztRQUNKLElBQUlvYSxjQUFjO1FBQ2xCLElBQUk2YjtRQUNKLElBQUlDO1FBQ0osSUFBSTViO1FBQ0osSUFBSXRLO1FBQ0osSUFBSW5QLFNBQVMsRUFBRTtRQUNmLElBQUkwYztRQUNKLElBQUl1WSxXQUFXO1FBRWYsSUFBSSxDQUFDL04sV0FBVztZQUNkQSxZQUFZRCxVQUFVOU4sVUFBVTtZQUNoQ2tjLGVBQWU7WUFDZjNZLFVBQVU7UUFDWixPQUFPO1lBQ0wyWSxlQUFlbk8sVUFBVWxPLE9BQU87WUFDaEMwRCxVQUFVd0ssVUFBVWxPLE9BQU87UUFDN0I7UUFFQWhaLE9BQU94TCxJQUFJLENBQUMweUI7UUFFWixJQUFLajBCLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCd21CLFVBQVVrYSxTQUFTLENBQUMxZ0MsRUFBRSxDQUFDd21CLE9BQU87WUFDOUJ5TixVQUFVMWtCLENBQUMsR0FBRzh4QixVQUFVLENBQUNyaEMsRUFBRSxDQUFDdVAsQ0FBQztZQUM3QnJELE9BQU9tMUIsVUFBVSxDQUFDcmhDLEVBQUUsQ0FBQ3VQLENBQUMsR0FBR2lYLFFBQVF0bUIsTUFBTSxHQUFHc21CLFFBQVF0bUIsTUFBTSxHQUFHO1lBRTNELElBQUsrTCxJQUFJLEdBQUdBLElBQUlDLE1BQU1ELEtBQUssRUFBRztnQkFDNUJrMkIsb0JBQW9CM2IsT0FBTyxDQUFDdmEsSUFBSSxFQUFFO2dCQUVsQyxJQUFJcWEsY0FBYzZiLGtCQUFrQjdiLFdBQVcsR0FBRzRiLGFBQWE5NUIsQ0FBQyxFQUFFO29CQUNoRWtlLGVBQWU2YixrQkFBa0I3YixXQUFXO29CQUM1QzJOLFVBQVUxa0IsQ0FBQyxHQUFHO2dCQUNoQixPQUFPLElBQUkrVyxjQUFjNGIsYUFBYXYyQixDQUFDLEVBQUU7b0JBQ3ZDc29CLFVBQVUxa0IsQ0FBQyxHQUFHO29CQUNkO2dCQUNGLE9BQU87b0JBQ0wsSUFBSTJ5QixhQUFhOTVCLENBQUMsSUFBSWtlLGVBQWU0YixhQUFhdjJCLENBQUMsSUFBSTJhLGNBQWM2YixrQkFBa0I3YixXQUFXLEVBQUU7d0JBQ2xHLElBQUksQ0FBQ3liLFVBQVUsQ0FBQ1YsVUFBVSxDQUFDcmhDLEVBQUUsQ0FBQ3FJLENBQUMsQ0FBQzRELElBQUksRUFBRSxFQUFFbzFCLFVBQVUsQ0FBQ3JoQyxFQUFFLENBQUM2TixDQUFDLENBQUM1QixJQUFJLEVBQUUsRUFBRW8xQixVQUFVLENBQUNyaEMsRUFBRSxDQUFDQSxDQUFDLENBQUNpTSxFQUFFLEVBQUVvMUIsVUFBVSxDQUFDcmhDLEVBQUUsQ0FBQ3FJLENBQUMsQ0FBQzRELEVBQUUsRUFBRWdvQixXQUFXbU8sY0FBY0o7d0JBQ2pJQSxXQUFXO29CQUNiLE9BQU87d0JBQ0w5bEIsVUFBVXVQLElBQUlyQixhQUFhLENBQUNpWCxVQUFVLENBQUNyaEMsRUFBRSxDQUFDcUksQ0FBQyxDQUFDNEQsSUFBSSxFQUFFLEVBQUVvMUIsVUFBVSxDQUFDcmhDLEVBQUUsQ0FBQ3FJLENBQUMsQ0FBQzRELEVBQUUsRUFBRW8xQixVQUFVLENBQUNyaEMsRUFBRSxDQUFDNk4sQ0FBQyxDQUFDNUIsSUFBSSxFQUFFLEVBQUVvMUIsVUFBVSxDQUFDcmhDLEVBQUUsQ0FBQ0EsQ0FBQyxDQUFDaU0sRUFBRSxFQUFFLENBQUNpMkIsYUFBYTk1QixDQUFDLEdBQUdrZSxXQUFVLElBQUs2YixrQkFBa0I3YixXQUFXLEVBQUUsQ0FBQzRiLGFBQWF2MkIsQ0FBQyxHQUFHMmEsV0FBVSxJQUFLNmIsa0JBQWtCN2IsV0FBVyxFQUFFRSxPQUFPLENBQUN2YSxJQUFJLEVBQUU7d0JBQ2xRLElBQUksQ0FBQ2cyQixtQkFBbUIsQ0FBQy9sQixTQUFTK1gsV0FBV21PLGNBQWNKLFdBQVcsMEdBQTBHO3dCQUVoTEEsV0FBVzt3QkFDWC9OLFVBQVUxa0IsQ0FBQyxHQUFHO29CQUNoQjtvQkFFQStXLGVBQWU2YixrQkFBa0I3YixXQUFXO29CQUM1QzhiLGdCQUFnQjtnQkFDbEI7WUFDRjtZQUVBLElBQUlmLFVBQVUsQ0FBQ3JoQyxFQUFFLENBQUN1UCxDQUFDLElBQUlpWCxRQUFRdG1CLE1BQU0sRUFBRTtnQkFDckNpaUMsb0JBQW9CM2IsT0FBTyxDQUFDdmEsSUFBSSxFQUFFO2dCQUVsQyxJQUFJcWEsZUFBZTRiLGFBQWF2MkIsQ0FBQyxFQUFFO29CQUNqQyxJQUFJcWQsZ0JBQWdCeEMsT0FBTyxDQUFDdmEsSUFBSSxFQUFFLENBQUNxYSxXQUFXO29CQUU5QyxJQUFJNGIsYUFBYTk1QixDQUFDLElBQUlrZSxlQUFlNGIsYUFBYXYyQixDQUFDLElBQUkyYSxjQUFjMEMsZUFBZTt3QkFDbEYsSUFBSSxDQUFDK1ksVUFBVSxDQUFDVixVQUFVLENBQUNyaEMsRUFBRSxDQUFDcUksQ0FBQyxDQUFDNEQsSUFBSSxFQUFFLEVBQUVvMUIsVUFBVSxDQUFDcmhDLEVBQUUsQ0FBQzZOLENBQUMsQ0FBQzVCLElBQUksRUFBRSxFQUFFbzFCLFVBQVUsQ0FBQ3JoQyxFQUFFLENBQUNBLENBQUMsQ0FBQyxFQUFFLEVBQUVxaEMsVUFBVSxDQUFDcmhDLEVBQUUsQ0FBQ3FJLENBQUMsQ0FBQyxFQUFFLEVBQUU0ckIsV0FBV21PLGNBQWNKO3dCQUNqSUEsV0FBVztvQkFDYixPQUFPO3dCQUNMOWxCLFVBQVV1UCxJQUFJckIsYUFBYSxDQUFDaVgsVUFBVSxDQUFDcmhDLEVBQUUsQ0FBQ3FJLENBQUMsQ0FBQzRELElBQUksRUFBRSxFQUFFbzFCLFVBQVUsQ0FBQ3JoQyxFQUFFLENBQUNxSSxDQUFDLENBQUMsRUFBRSxFQUFFZzVCLFVBQVUsQ0FBQ3JoQyxFQUFFLENBQUM2TixDQUFDLENBQUM1QixJQUFJLEVBQUUsRUFBRW8xQixVQUFVLENBQUNyaEMsRUFBRSxDQUFDQSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUNraUMsYUFBYTk1QixDQUFDLEdBQUdrZSxXQUFVLElBQUswQyxlQUFlLENBQUNrWixhQUFhdjJCLENBQUMsR0FBRzJhLFdBQVUsSUFBSzBDLGVBQWV4QyxPQUFPLENBQUN2YSxJQUFJLEVBQUU7d0JBQ2xPLElBQUksQ0FBQ2cyQixtQkFBbUIsQ0FBQy9sQixTQUFTK1gsV0FBV21PLGNBQWNKLFdBQVcsMEdBQTBHO3dCQUVoTEEsV0FBVzt3QkFDWC9OLFVBQVUxa0IsQ0FBQyxHQUFHO29CQUNoQjtnQkFDRixPQUFPO29CQUNMMGtCLFVBQVUxa0IsQ0FBQyxHQUFHO2dCQUNoQjtnQkFFQStXLGVBQWU2YixrQkFBa0I3YixXQUFXO2dCQUM1QzhiLGdCQUFnQjtZQUNsQjtZQUVBLElBQUluTyxVQUFVbE8sT0FBTyxFQUFFO2dCQUNyQmtPLFVBQVVoQixPQUFPLENBQUNnQixVQUFVNXJCLENBQUMsQ0FBQ29oQixRQUFRLENBQUMsRUFBRSxFQUFFd0ssVUFBVTVyQixDQUFDLENBQUNvaEIsUUFBUSxDQUFDLEVBQUUsRUFBRSxLQUFLQTtnQkFDekV3SyxVQUFVaEIsT0FBTyxDQUFDZ0IsVUFBVTVyQixDQUFDLENBQUM0ckIsVUFBVWxPLE9BQU8sR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFa08sVUFBVTVyQixDQUFDLENBQUM0ckIsVUFBVWxPLE9BQU8sR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEtBQUtrTyxVQUFVbE8sT0FBTyxHQUFHO1lBQzNIO1lBRUEsSUFBSU8sY0FBYzRiLGFBQWF2MkIsQ0FBQyxFQUFFO2dCQUNoQztZQUNGO1lBRUEsSUFBSTNMLElBQUlDLE1BQU0sR0FBRztnQkFDZmcwQixZQUFZRCxVQUFVOU4sVUFBVTtnQkFDaEM4YixXQUFXO2dCQUNYajFCLE9BQU94TCxJQUFJLENBQUMweUI7Z0JBQ1ptTyxlQUFlO1lBQ2pCO1FBQ0Y7UUFFQSxPQUFPcjFCO0lBQ1Q7SUFFQSxTQUFTczFCLDBCQUEwQjtJQUVuQ3hpQyxnQkFBZ0I7UUFBQ3FnQztLQUFjLEVBQUVtQztJQUVqQ0EsdUJBQXVCamlDLFNBQVMsQ0FBQysvQixzQkFBc0IsR0FBRyxTQUFVcGYsSUFBSSxFQUFFaFcsSUFBSTtRQUM1RSxJQUFJLENBQUMrbUIsUUFBUSxHQUFHLElBQUksQ0FBQ3dPLFdBQVc7UUFDaEMsSUFBSSxDQUFDZ0MsTUFBTSxHQUFHblEsZ0JBQWdCQyxPQUFPLENBQUNyUixNQUFNaFcsS0FBS2lFLENBQUMsRUFBRSxHQUFHLE1BQU0sSUFBSTtRQUNqRSxJQUFJLENBQUN5akIsV0FBVyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUM2UCxNQUFNLENBQUNsUixlQUFlLENBQUNseEIsTUFBTTtJQUN6RDtJQUVBbWlDLHVCQUF1QmppQyxTQUFTLENBQUNtaUMsV0FBVyxHQUFHLFNBQVV6M0IsSUFBSSxFQUFFdzNCLE1BQU07UUFDbkUsSUFBSXhZLFVBQVV3WSxTQUFTO1FBQ3ZCLElBQUlFLGNBQWM7WUFBQztZQUFHO1NBQUU7UUFDeEIsSUFBSUMsYUFBYTMzQixLQUFLaWIsT0FBTztRQUM3QixJQUFJL2xCLElBQUk7UUFFUixJQUFLQSxJQUFJLEdBQUdBLElBQUl5aUMsWUFBWXppQyxLQUFLLEVBQUc7WUFDbEN3aUMsV0FBVyxDQUFDLEVBQUUsSUFBSTEzQixLQUFLekMsQ0FBQyxDQUFDckksRUFBRSxDQUFDLEVBQUU7WUFDOUJ3aUMsV0FBVyxDQUFDLEVBQUUsSUFBSTEzQixLQUFLekMsQ0FBQyxDQUFDckksRUFBRSxDQUFDLEVBQUU7UUFDaEM7UUFFQXdpQyxXQUFXLENBQUMsRUFBRSxJQUFJQztRQUNsQkQsV0FBVyxDQUFDLEVBQUUsSUFBSUM7UUFDbEIsSUFBSUMsYUFBYTFPLFVBQVU5TixVQUFVO1FBQ3JDd2MsV0FBV256QixDQUFDLEdBQUd6RSxLQUFLeUUsQ0FBQztRQUNyQixJQUFJNmpCO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUVKLElBQUt6ekIsSUFBSSxHQUFHQSxJQUFJeWlDLFlBQVl6aUMsS0FBSyxFQUFHO1lBQ2xDb3pCLEtBQUt0b0IsS0FBS3pDLENBQUMsQ0FBQ3JJLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQ3dpQyxXQUFXLENBQUMsRUFBRSxHQUFHMTNCLEtBQUt6QyxDQUFDLENBQUNySSxFQUFFLENBQUMsRUFBRSxJQUFJOHBCO1lBQ3REdUosS0FBS3ZvQixLQUFLekMsQ0FBQyxDQUFDckksRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDd2lDLFdBQVcsQ0FBQyxFQUFFLEdBQUcxM0IsS0FBS3pDLENBQUMsQ0FBQ3JJLEVBQUUsQ0FBQyxFQUFFLElBQUk4cEI7WUFDdER3SixLQUFLeG9CLEtBQUsrQyxDQUFDLENBQUM3TixFQUFFLENBQUMsRUFBRSxHQUFHLENBQUN3aUMsV0FBVyxDQUFDLEVBQUUsR0FBRzEzQixLQUFLK0MsQ0FBQyxDQUFDN04sRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDOHBCO1lBQ3ZEeUosS0FBS3pvQixLQUFLK0MsQ0FBQyxDQUFDN04sRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDd2lDLFdBQVcsQ0FBQyxFQUFFLEdBQUcxM0IsS0FBSytDLENBQUMsQ0FBQzdOLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQzhwQjtZQUN2RDBKLEtBQUsxb0IsS0FBSzlLLENBQUMsQ0FBQ0EsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDd2lDLFdBQVcsQ0FBQyxFQUFFLEdBQUcxM0IsS0FBSzlLLENBQUMsQ0FBQ0EsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDOHBCO1lBQ3ZEMkosS0FBSzNvQixLQUFLOUssQ0FBQyxDQUFDQSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUN3aUMsV0FBVyxDQUFDLEVBQUUsR0FBRzEzQixLQUFLOUssQ0FBQyxDQUFDQSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUM4cEI7WUFDdkQ0WSxXQUFXdlAsV0FBVyxDQUFDQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJenpCO1FBQ2pEO1FBRUEsT0FBTzBpQztJQUNUO0lBRUFMLHVCQUF1QmppQyxTQUFTLENBQUMrZ0MsYUFBYSxHQUFHLFNBQVU3UCxhQUFhO1FBQ3RFLElBQUkrUDtRQUNKLElBQUlyaEM7UUFDSixJQUFJQyxNQUFNLElBQUksQ0FBQzhNLE1BQU0sQ0FBQzdNLE1BQU07UUFDNUIsSUFBSStMO1FBQ0osSUFBSUM7UUFDSixJQUFJbzJCLFNBQVMsSUFBSSxDQUFDQSxNQUFNLENBQUNqNkIsQ0FBQztRQUUxQixJQUFJaTZCLFdBQVcsR0FBRztZQUNoQixJQUFJNVo7WUFDSixJQUFJMk07WUFFSixJQUFLcjFCLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO2dCQUMzQjBvQixZQUFZLElBQUksQ0FBQzNiLE1BQU0sQ0FBQy9NLEVBQUU7Z0JBQzFCcTFCLHVCQUF1QjNNLFVBQVUyTSxvQkFBb0I7Z0JBRXJELElBQUksQ0FBRSxFQUFDM00sVUFBVXlMLEtBQUssQ0FBQ2xELElBQUksSUFBSSxDQUFDLElBQUksQ0FBQ0EsSUFBSSxJQUFJLENBQUNLLGFBQVksR0FBSTtvQkFDNUQrRCxxQkFBcUJkLGFBQWE7b0JBQ2xDN0wsVUFBVXlMLEtBQUssQ0FBQ2xELElBQUksR0FBRztvQkFDdkJvUSxhQUFhM1ksVUFBVXlMLEtBQUssQ0FBQ2lCLEtBQUssQ0FBQ3JvQixNQUFNO29CQUN6Q2IsT0FBT3djLFVBQVV5TCxLQUFLLENBQUNpQixLQUFLLENBQUNyUCxPQUFPO29CQUVwQyxJQUFLOVosSUFBSSxHQUFHQSxJQUFJQyxNQUFNRCxLQUFLLEVBQUc7d0JBQzVCb3BCLHFCQUFxQmYsUUFBUSxDQUFDLElBQUksQ0FBQ2lPLFdBQVcsQ0FBQ2xCLFVBQVUsQ0FBQ3AxQixFQUFFLEVBQUVxMkI7b0JBQ2hFO2dCQUNGO2dCQUVBNVosVUFBVXlMLEtBQUssQ0FBQ2lCLEtBQUssR0FBRzFNLFVBQVUyTSxvQkFBb0I7WUFDeEQ7UUFDRjtRQUVBLElBQUksQ0FBQyxJQUFJLENBQUM3QyxpQkFBaUIsQ0FBQ3R5QixNQUFNLEVBQUU7WUFDbEMsSUFBSSxDQUFDK3dCLElBQUksR0FBRztRQUNkO0lBQ0Y7SUFFQSxJQUFJMFIsMkJBQTJCO1FBQzdCLElBQUlDLGdCQUFnQjtZQUFDO1lBQUc7U0FBRTtRQUUxQixTQUFTQyxjQUFjQyxHQUFHO1lBQ3hCLElBQUk3UixPQUFPLElBQUksQ0FBQ0EsSUFBSTtZQUNwQixJQUFJLENBQUN5Qix3QkFBd0I7WUFDN0IsSUFBSSxDQUFDekIsSUFBSSxHQUFHLElBQUksQ0FBQ0EsSUFBSSxJQUFJQTtZQUV6QixJQUFJLElBQUksQ0FBQ2ppQixDQUFDLEVBQUU7Z0JBQ1Y4ekIsSUFBSWhKLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQzlxQixDQUFDLENBQUMzRyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDMkcsQ0FBQyxDQUFDM0csQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMyRyxDQUFDLENBQUMzRyxDQUFDLENBQUMsRUFBRTtZQUN2RDtZQUVBLElBQUksSUFBSSxDQUFDRCxDQUFDLEVBQUU7Z0JBQ1YwNkIsSUFBSXJKLEtBQUssQ0FBQyxJQUFJLENBQUNyeEIsQ0FBQyxDQUFDQyxDQUFDLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQ0QsQ0FBQyxDQUFDQyxDQUFDLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQ0QsQ0FBQyxDQUFDQyxDQUFDLENBQUMsRUFBRTtZQUNqRDtZQUVBLElBQUksSUFBSSxDQUFDNEcsRUFBRSxFQUFFO2dCQUNYNnpCLElBQUl0SixZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUN2cUIsRUFBRSxDQUFDNUcsQ0FBQyxFQUFFLElBQUksQ0FBQzZHLEVBQUUsQ0FBQzdHLENBQUM7WUFDeEM7WUFFQSxJQUFJLElBQUksQ0FBQ0MsQ0FBQyxFQUFFO2dCQUNWdzZCLElBQUloSyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUN4d0IsQ0FBQyxDQUFDRCxDQUFDO1lBQ3RCLE9BQU87Z0JBQ0x5NkIsSUFBSTFKLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQzJKLEVBQUUsQ0FBQzE2QixDQUFDLEVBQUU4d0IsT0FBTyxDQUFDLElBQUksQ0FBQzZKLEVBQUUsQ0FBQzM2QixDQUFDLEVBQUU2d0IsT0FBTyxDQUFDLElBQUksQ0FBQytKLEVBQUUsQ0FBQzU2QixDQUFDLEVBQUUrd0IsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDdkMsRUFBRSxDQUFDeHVCLENBQUMsQ0FBQyxFQUFFLEVBQUU4d0IsT0FBTyxDQUFDLElBQUksQ0FBQ3RDLEVBQUUsQ0FBQ3h1QixDQUFDLENBQUMsRUFBRSxFQUFFNndCLE9BQU8sQ0FBQyxJQUFJLENBQUNyQyxFQUFFLENBQUN4dUIsQ0FBQyxDQUFDLEVBQUU7WUFDakk7WUFFQSxJQUFJLElBQUksQ0FBQzBDLElBQUksQ0FBQ3JDLENBQUMsQ0FBQ04sQ0FBQyxFQUFFO2dCQUNqQixJQUFJLElBQUksQ0FBQzJDLElBQUksQ0FBQ3JDLENBQUMsQ0FBQzhuQixDQUFDLEVBQUU7b0JBQ2pCc1MsSUFBSWhKLFNBQVMsQ0FBQyxJQUFJLENBQUNvSixFQUFFLENBQUM3NkIsQ0FBQyxFQUFFLElBQUksQ0FBQzg2QixFQUFFLENBQUM5NkIsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDKzZCLEVBQUUsQ0FBQy82QixDQUFDO2dCQUNoRCxPQUFPO29CQUNMeTZCLElBQUloSixTQUFTLENBQUMsSUFBSSxDQUFDb0osRUFBRSxDQUFDNzZCLENBQUMsRUFBRSxJQUFJLENBQUM4NkIsRUFBRSxDQUFDOTZCLENBQUMsRUFBRTtnQkFDdEM7WUFDRixPQUFPO2dCQUNMeTZCLElBQUloSixTQUFTLENBQUMsSUFBSSxDQUFDcHhCLENBQUMsQ0FBQ0wsQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUNLLENBQUMsQ0FBQ0wsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQ0ssQ0FBQyxDQUFDTCxDQUFDLENBQUMsRUFBRTtZQUN0RDtRQUNGO1FBRUEsU0FBU2k0QixZQUFZK0MsV0FBVztZQUM5QixJQUFJLElBQUksQ0FBQ3RpQixJQUFJLENBQUN0RyxVQUFVLENBQUMwVyxPQUFPLEtBQUssSUFBSSxDQUFDQSxPQUFPLEVBQUU7Z0JBQ2pEO1lBQ0Y7WUFFQSxJQUFJLElBQUksQ0FBQ21TLFFBQVEsRUFBRTtnQkFDakIsSUFBSSxDQUFDQyxrQkFBa0I7Z0JBQ3ZCLElBQUksQ0FBQ0QsUUFBUSxHQUFHO1lBQ2xCO1lBRUEsSUFBSSxDQUFDNVEsd0JBQXdCO1lBRTdCLElBQUksSUFBSSxDQUFDekIsSUFBSSxJQUFJb1MsYUFBYTtnQkFDNUIsSUFBSTFxQjtnQkFDSixJQUFJLENBQUN0USxDQUFDLENBQUNrMEIsY0FBYyxDQUFDLElBQUksQ0FBQ2lILEdBQUcsQ0FBQzNLLEtBQUs7Z0JBRXBDLElBQUksSUFBSSxDQUFDNEssc0JBQXNCLEdBQUcsR0FBRztvQkFDbkMsSUFBSSxDQUFDcDdCLENBQUMsQ0FBQ3l4QixTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUM5cUIsQ0FBQyxDQUFDM0csQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQzJHLENBQUMsQ0FBQzNHLENBQUMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDMkcsQ0FBQyxDQUFDM0csQ0FBQyxDQUFDLEVBQUU7Z0JBQzFEO2dCQUVBLElBQUksSUFBSSxDQUFDbzdCLHNCQUFzQixHQUFHLEdBQUc7b0JBQ25DLElBQUksQ0FBQ3A3QixDQUFDLENBQUNveEIsS0FBSyxDQUFDLElBQUksQ0FBQ3J4QixDQUFDLENBQUNDLENBQUMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDRCxDQUFDLENBQUNDLENBQUMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDRCxDQUFDLENBQUNDLENBQUMsQ0FBQyxFQUFFO2dCQUNwRDtnQkFFQSxJQUFJLElBQUksQ0FBQzRHLEVBQUUsSUFBSSxJQUFJLENBQUN3MEIsc0JBQXNCLEdBQUcsR0FBRztvQkFDOUMsSUFBSSxDQUFDcDdCLENBQUMsQ0FBQ214QixZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUN2cUIsRUFBRSxDQUFDNUcsQ0FBQyxFQUFFLElBQUksQ0FBQzZHLEVBQUUsQ0FBQzdHLENBQUM7Z0JBQzNDO2dCQUVBLElBQUksSUFBSSxDQUFDQyxDQUFDLElBQUksSUFBSSxDQUFDbTdCLHNCQUFzQixHQUFHLEdBQUc7b0JBQzdDLElBQUksQ0FBQ3A3QixDQUFDLENBQUN5d0IsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDeHdCLENBQUMsQ0FBQ0QsQ0FBQztnQkFDekIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDQyxDQUFDLElBQUksSUFBSSxDQUFDbTdCLHNCQUFzQixHQUFHLEdBQUc7b0JBQ3JELElBQUksQ0FBQ3A3QixDQUFDLENBQUMrd0IsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDMkosRUFBRSxDQUFDMTZCLENBQUMsRUFBRTh3QixPQUFPLENBQUMsSUFBSSxDQUFDNkosRUFBRSxDQUFDMzZCLENBQUMsRUFBRTZ3QixPQUFPLENBQUMsSUFBSSxDQUFDK0osRUFBRSxDQUFDNTZCLENBQUMsRUFBRSt3QixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUN2QyxFQUFFLENBQUN4dUIsQ0FBQyxDQUFDLEVBQUUsRUFBRTh3QixPQUFPLENBQUMsSUFBSSxDQUFDdEMsRUFBRSxDQUFDeHVCLENBQUMsQ0FBQyxFQUFFLEVBQUU2d0IsT0FBTyxDQUFDLElBQUksQ0FBQ3JDLEVBQUUsQ0FBQ3h1QixDQUFDLENBQUMsRUFBRTtnQkFDcEk7Z0JBRUEsSUFBSSxJQUFJLENBQUNxN0IsWUFBWSxFQUFFO29CQUNyQixJQUFJeEw7b0JBQ0osSUFBSXlMO29CQUNKaHJCLFlBQVksSUFBSSxDQUFDb0ksSUFBSSxDQUFDdEcsVUFBVSxDQUFDOUIsU0FBUztvQkFFMUMsSUFBSSxJQUFJLENBQUNqUSxDQUFDLElBQUksSUFBSSxDQUFDQSxDQUFDLENBQUMyakIsU0FBUyxJQUFJLElBQUksQ0FBQzNqQixDQUFDLENBQUNrN0IsY0FBYyxFQUFFO3dCQUN2RCxJQUFJLElBQUksQ0FBQ2w3QixDQUFDLENBQUNrb0IsUUFBUSxDQUFDdEQsU0FBUyxHQUFHLElBQUksQ0FBQzVrQixDQUFDLENBQUNxakIsVUFBVSxJQUFJLElBQUksQ0FBQ3JqQixDQUFDLENBQUMyakIsU0FBUyxDQUFDLEVBQUUsQ0FBQ3pqQixDQUFDLEVBQUU7NEJBQzFFc3ZCLEtBQUssSUFBSSxDQUFDeHZCLENBQUMsQ0FBQ2s3QixjQUFjLENBQUMsQ0FBQyxJQUFJLENBQUNsN0IsQ0FBQyxDQUFDMmpCLFNBQVMsQ0FBQyxFQUFFLENBQUN6akIsQ0FBQyxHQUFHLElBQUcsSUFBSytQLFdBQVc7NEJBQ3ZFZ3JCLEtBQUssSUFBSSxDQUFDajdCLENBQUMsQ0FBQ2s3QixjQUFjLENBQUMsSUFBSSxDQUFDbDdCLENBQUMsQ0FBQzJqQixTQUFTLENBQUMsRUFBRSxDQUFDempCLENBQUMsR0FBRytQLFdBQVc7d0JBQ2hFLE9BQU8sSUFBSSxJQUFJLENBQUNqUSxDQUFDLENBQUNrb0IsUUFBUSxDQUFDdEQsU0FBUyxHQUFHLElBQUksQ0FBQzVrQixDQUFDLENBQUNxakIsVUFBVSxJQUFJLElBQUksQ0FBQ3JqQixDQUFDLENBQUMyakIsU0FBUyxDQUFDLElBQUksQ0FBQzNqQixDQUFDLENBQUMyakIsU0FBUyxDQUFDbnNCLE1BQU0sR0FBRyxFQUFFLENBQUMwSSxDQUFDLEVBQUU7NEJBQzNHc3ZCLEtBQUssSUFBSSxDQUFDeHZCLENBQUMsQ0FBQ2s3QixjQUFjLENBQUMsSUFBSSxDQUFDbDdCLENBQUMsQ0FBQzJqQixTQUFTLENBQUMsSUFBSSxDQUFDM2pCLENBQUMsQ0FBQzJqQixTQUFTLENBQUNuc0IsTUFBTSxHQUFHLEVBQUUsQ0FBQzBJLENBQUMsR0FBRytQLFdBQVc7NEJBQ3hGZ3JCLEtBQUssSUFBSSxDQUFDajdCLENBQUMsQ0FBQ2s3QixjQUFjLENBQUMsQ0FBQyxJQUFJLENBQUNsN0IsQ0FBQyxDQUFDMmpCLFNBQVMsQ0FBQyxJQUFJLENBQUMzakIsQ0FBQyxDQUFDMmpCLFNBQVMsQ0FBQ25zQixNQUFNLEdBQUcsRUFBRSxDQUFDMEksQ0FBQyxHQUFHLElBQUcsSUFBSytQLFdBQVc7d0JBQ25HLE9BQU87NEJBQ0x1ZixLQUFLLElBQUksQ0FBQ3h2QixDQUFDLENBQUN3akIsRUFBRTs0QkFDZHlYLEtBQUssSUFBSSxDQUFDajdCLENBQUMsQ0FBQ2s3QixjQUFjLENBQUMsQ0FBQyxJQUFJLENBQUNsN0IsQ0FBQyxDQUFDa29CLFFBQVEsQ0FBQ3RELFNBQVMsR0FBRyxJQUFJLENBQUM1a0IsQ0FBQyxDQUFDcWpCLFVBQVUsR0FBRyxJQUFHLElBQUtwVCxXQUFXLElBQUksQ0FBQ2pRLENBQUMsQ0FBQ3FqQixVQUFVO3dCQUNsSDtvQkFDRixPQUFPLElBQUksSUFBSSxDQUFDbVgsRUFBRSxJQUFJLElBQUksQ0FBQ0EsRUFBRSxDQUFDN1csU0FBUyxJQUFJLElBQUksQ0FBQzhXLEVBQUUsQ0FBQzlXLFNBQVMsSUFBSSxJQUFJLENBQUM2VyxFQUFFLENBQUNVLGNBQWMsSUFBSSxJQUFJLENBQUNULEVBQUUsQ0FBQ1MsY0FBYyxFQUFFO3dCQUNoSDFMLEtBQUssRUFBRTt3QkFDUHlMLEtBQUssRUFBRTt3QkFDUCxJQUFJVCxLQUFLLElBQUksQ0FBQ0EsRUFBRTt3QkFDaEIsSUFBSUMsS0FBSyxJQUFJLENBQUNBLEVBQUU7d0JBRWhCLElBQUlELEdBQUd0UyxRQUFRLENBQUN0RCxTQUFTLEdBQUc0VixHQUFHblgsVUFBVSxJQUFJbVgsR0FBRzdXLFNBQVMsQ0FBQyxFQUFFLENBQUN6akIsQ0FBQyxFQUFFOzRCQUM5RHN2QixFQUFFLENBQUMsRUFBRSxHQUFHZ0wsR0FBR1UsY0FBYyxDQUFDLENBQUNWLEdBQUc3VyxTQUFTLENBQUMsRUFBRSxDQUFDempCLENBQUMsR0FBRyxJQUFHLElBQUsrUCxXQUFXOzRCQUNsRXVmLEVBQUUsQ0FBQyxFQUFFLEdBQUdpTCxHQUFHUyxjQUFjLENBQUMsQ0FBQ1QsR0FBRzlXLFNBQVMsQ0FBQyxFQUFFLENBQUN6akIsQ0FBQyxHQUFHLElBQUcsSUFBSytQLFdBQVc7NEJBQ2xFZ3JCLEVBQUUsQ0FBQyxFQUFFLEdBQUdULEdBQUdVLGNBQWMsQ0FBQ1YsR0FBRzdXLFNBQVMsQ0FBQyxFQUFFLENBQUN6akIsQ0FBQyxHQUFHK1AsV0FBVzs0QkFDekRnckIsRUFBRSxDQUFDLEVBQUUsR0FBR1IsR0FBR1MsY0FBYyxDQUFDVCxHQUFHOVcsU0FBUyxDQUFDLEVBQUUsQ0FBQ3pqQixDQUFDLEdBQUcrUCxXQUFXO3dCQUMzRCxPQUFPLElBQUl1cUIsR0FBR3RTLFFBQVEsQ0FBQ3RELFNBQVMsR0FBRzRWLEdBQUduWCxVQUFVLElBQUltWCxHQUFHN1csU0FBUyxDQUFDNlcsR0FBRzdXLFNBQVMsQ0FBQ25zQixNQUFNLEdBQUcsRUFBRSxDQUFDMEksQ0FBQyxFQUFFOzRCQUMzRnN2QixFQUFFLENBQUMsRUFBRSxHQUFHZ0wsR0FBR1UsY0FBYyxDQUFDVixHQUFHN1csU0FBUyxDQUFDNlcsR0FBRzdXLFNBQVMsQ0FBQ25zQixNQUFNLEdBQUcsRUFBRSxDQUFDMEksQ0FBQyxHQUFHK1AsV0FBVzs0QkFDL0V1ZixFQUFFLENBQUMsRUFBRSxHQUFHaUwsR0FBR1MsY0FBYyxDQUFDVCxHQUFHOVcsU0FBUyxDQUFDOFcsR0FBRzlXLFNBQVMsQ0FBQ25zQixNQUFNLEdBQUcsRUFBRSxDQUFDMEksQ0FBQyxHQUFHK1AsV0FBVzs0QkFDL0VnckIsRUFBRSxDQUFDLEVBQUUsR0FBR1QsR0FBR1UsY0FBYyxDQUFDLENBQUNWLEdBQUc3VyxTQUFTLENBQUM2VyxHQUFHN1csU0FBUyxDQUFDbnNCLE1BQU0sR0FBRyxFQUFFLENBQUMwSSxDQUFDLEdBQUcsSUFBRyxJQUFLK1AsV0FBVzs0QkFDeEZnckIsRUFBRSxDQUFDLEVBQUUsR0FBR1IsR0FBR1MsY0FBYyxDQUFDLENBQUNULEdBQUc5VyxTQUFTLENBQUM4VyxHQUFHOVcsU0FBUyxDQUFDbnNCLE1BQU0sR0FBRyxFQUFFLENBQUMwSSxDQUFDLEdBQUcsSUFBRyxJQUFLK1AsV0FBVzt3QkFDMUYsT0FBTzs0QkFDTHVmLEtBQUs7Z0NBQUNnTCxHQUFHaFgsRUFBRTtnQ0FBRWlYLEdBQUdqWCxFQUFFOzZCQUFDOzRCQUNuQnlYLEVBQUUsQ0FBQyxFQUFFLEdBQUdULEdBQUdVLGNBQWMsQ0FBQyxDQUFDVixHQUFHdFMsUUFBUSxDQUFDdEQsU0FBUyxHQUFHNFYsR0FBR25YLFVBQVUsR0FBRyxJQUFHLElBQUtwVCxXQUFXdXFCLEdBQUduWCxVQUFVOzRCQUNuRzRYLEVBQUUsQ0FBQyxFQUFFLEdBQUdSLEdBQUdTLGNBQWMsQ0FBQyxDQUFDVCxHQUFHdlMsUUFBUSxDQUFDdEQsU0FBUyxHQUFHNlYsR0FBR3BYLFVBQVUsR0FBRyxJQUFHLElBQUtwVCxXQUFXd3FCLEdBQUdwWCxVQUFVO3dCQUNyRztvQkFDRixPQUFPO3dCQUNMNFgsS0FBS2Y7d0JBQ0wxSyxLQUFLeUw7b0JBQ1A7b0JBRUEsSUFBSSxDQUFDdDdCLENBQUMsQ0FBQ3l3QixNQUFNLENBQUMsQ0FBQ3gwQixLQUFLcXJCLEtBQUssQ0FBQ3VJLEVBQUUsQ0FBQyxFQUFFLEdBQUd5TCxFQUFFLENBQUMsRUFBRSxFQUFFekwsRUFBRSxDQUFDLEVBQUUsR0FBR3lMLEVBQUUsQ0FBQyxFQUFFO2dCQUN4RDtnQkFFQSxJQUFJLElBQUksQ0FBQzU0QixJQUFJLENBQUNyQyxDQUFDLElBQUksSUFBSSxDQUFDcUMsSUFBSSxDQUFDckMsQ0FBQyxDQUFDTixDQUFDLEVBQUU7b0JBQ2hDLElBQUksSUFBSSxDQUFDMkMsSUFBSSxDQUFDckMsQ0FBQyxDQUFDOG5CLENBQUMsRUFBRTt3QkFDakIsSUFBSSxDQUFDbm9CLENBQUMsQ0FBQ3l4QixTQUFTLENBQUMsSUFBSSxDQUFDb0osRUFBRSxDQUFDNzZCLENBQUMsRUFBRSxJQUFJLENBQUM4NkIsRUFBRSxDQUFDOTZCLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQys2QixFQUFFLENBQUMvNkIsQ0FBQztvQkFDbkQsT0FBTzt3QkFDTCxJQUFJLENBQUNBLENBQUMsQ0FBQ3l4QixTQUFTLENBQUMsSUFBSSxDQUFDb0osRUFBRSxDQUFDNzZCLENBQUMsRUFBRSxJQUFJLENBQUM4NkIsRUFBRSxDQUFDOTZCLENBQUMsRUFBRTtvQkFDekM7Z0JBQ0YsT0FBTztvQkFDTCxJQUFJLENBQUNBLENBQUMsQ0FBQ3l4QixTQUFTLENBQUMsSUFBSSxDQUFDcHhCLENBQUMsQ0FBQ0wsQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUNLLENBQUMsQ0FBQ0wsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQ0ssQ0FBQyxDQUFDTCxDQUFDLENBQUMsRUFBRTtnQkFDekQ7WUFDRjtZQUVBLElBQUksQ0FBQzhvQixPQUFPLEdBQUcsSUFBSSxDQUFDcFEsSUFBSSxDQUFDdEcsVUFBVSxDQUFDMFcsT0FBTztRQUM3QztRQUVBLFNBQVNvUztZQUNQLElBQUksQ0FBQ0Usc0JBQXNCLEdBQUc7WUFDOUIsSUFBSSxDQUFDRCxHQUFHLENBQUM5TixLQUFLO1lBRWQsSUFBSSxDQUFDLElBQUksQ0FBQzFtQixDQUFDLENBQUNvaUIsZUFBZSxDQUFDbHhCLE1BQU0sRUFBRTtnQkFDbEMsSUFBSSxDQUFDc2pDLEdBQUcsQ0FBQzFKLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQzlxQixDQUFDLENBQUMzRyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDMkcsQ0FBQyxDQUFDM0csQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMyRyxDQUFDLENBQUMzRyxDQUFDLENBQUMsRUFBRTtnQkFDMUQsSUFBSSxDQUFDbzdCLHNCQUFzQixHQUFHO1lBQ2hDLE9BQU87Z0JBQ0w7WUFDRjtZQUVBLElBQUksQ0FBQyxJQUFJLENBQUNyN0IsQ0FBQyxDQUFDZ3BCLGVBQWUsQ0FBQ2x4QixNQUFNLEVBQUU7Z0JBQ2xDLElBQUksQ0FBQ3NqQyxHQUFHLENBQUMvSixLQUFLLENBQUMsSUFBSSxDQUFDcnhCLENBQUMsQ0FBQ0MsQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUNELENBQUMsQ0FBQ0MsQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUNELENBQUMsQ0FBQ0MsQ0FBQyxDQUFDLEVBQUU7Z0JBQ3BELElBQUksQ0FBQ283QixzQkFBc0IsR0FBRztZQUNoQyxPQUFPO2dCQUNMO1lBQ0Y7WUFFQSxJQUFJLElBQUksQ0FBQ3gwQixFQUFFLEVBQUU7Z0JBQ1gsSUFBSSxDQUFDLElBQUksQ0FBQ0EsRUFBRSxDQUFDbWlCLGVBQWUsQ0FBQ2x4QixNQUFNLElBQUksQ0FBQyxJQUFJLENBQUNnUCxFQUFFLENBQUNraUIsZUFBZSxDQUFDbHhCLE1BQU0sRUFBRTtvQkFDdEUsSUFBSSxDQUFDc2pDLEdBQUcsQ0FBQ2hLLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQ3ZxQixFQUFFLENBQUM1RyxDQUFDLEVBQUUsSUFBSSxDQUFDNkcsRUFBRSxDQUFDN0csQ0FBQztvQkFDM0MsSUFBSSxDQUFDbzdCLHNCQUFzQixHQUFHO2dCQUNoQyxPQUFPO29CQUNMO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJLElBQUksQ0FBQ243QixDQUFDLEVBQUU7Z0JBQ1YsSUFBSSxDQUFDLElBQUksQ0FBQ0EsQ0FBQyxDQUFDOG9CLGVBQWUsQ0FBQ2x4QixNQUFNLEVBQUU7b0JBQ2xDLElBQUksQ0FBQ3NqQyxHQUFHLENBQUMxSyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUN4d0IsQ0FBQyxDQUFDRCxDQUFDO29CQUN6QixJQUFJLENBQUNvN0Isc0JBQXNCLEdBQUc7Z0JBQ2hDO1lBQ0YsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDVixFQUFFLENBQUMzUixlQUFlLENBQUNseEIsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDOGlDLEVBQUUsQ0FBQzVSLGVBQWUsQ0FBQ2x4QixNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMraUMsRUFBRSxDQUFDN1IsZUFBZSxDQUFDbHhCLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQzIyQixFQUFFLENBQUN6RixlQUFlLENBQUNseEIsTUFBTSxFQUFFO2dCQUNuSixJQUFJLENBQUNzakMsR0FBRyxDQUFDcEssT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDMkosRUFBRSxDQUFDMTZCLENBQUMsRUFBRTh3QixPQUFPLENBQUMsSUFBSSxDQUFDNkosRUFBRSxDQUFDMzZCLENBQUMsRUFBRTZ3QixPQUFPLENBQUMsSUFBSSxDQUFDK0osRUFBRSxDQUFDNTZCLENBQUMsRUFBRSt3QixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUN2QyxFQUFFLENBQUN4dUIsQ0FBQyxDQUFDLEVBQUUsRUFBRTh3QixPQUFPLENBQUMsSUFBSSxDQUFDdEMsRUFBRSxDQUFDeHVCLENBQUMsQ0FBQyxFQUFFLEVBQUU2d0IsT0FBTyxDQUFDLElBQUksQ0FBQ3JDLEVBQUUsQ0FBQ3h1QixDQUFDLENBQUMsRUFBRTtnQkFDcEksSUFBSSxDQUFDbzdCLHNCQUFzQixHQUFHO1lBQ2hDO1FBQ0Y7UUFFQSxTQUFTSTtRQUNQLHFDQUFxQztRQUN2QztRQUVBLFNBQVNsUyxtQkFBbUJoeEIsSUFBSTtZQUM5QixJQUFJLENBQUNtakMsbUJBQW1CLENBQUNuakM7WUFFekIsSUFBSSxDQUFDb2dCLElBQUksQ0FBQzRRLGtCQUFrQixDQUFDaHhCO1lBQzdCLElBQUksQ0FBQzJpQyxRQUFRLEdBQUc7UUFDbEI7UUFFQSxTQUFTUyxrQkFBa0JoakIsSUFBSSxFQUFFaFcsSUFBSSxFQUFFc1AsU0FBUztZQUM5QyxJQUFJLENBQUMwRyxJQUFJLEdBQUdBO1lBQ1osSUFBSSxDQUFDb1EsT0FBTyxHQUFHLENBQUM7WUFDaEIsSUFBSSxDQUFDbEYsUUFBUSxHQUFHO1lBQ2hCLElBQUksQ0FBQ2xoQixJQUFJLEdBQUdBO1lBQ1osSUFBSSxDQUFDMUMsQ0FBQyxHQUFHLElBQUlrd0IsVUFBVSxvREFBb0Q7WUFFM0UsSUFBSSxDQUFDaUwsR0FBRyxHQUFHLElBQUlqTDtZQUNmLElBQUksQ0FBQ2tMLHNCQUFzQixHQUFHO1lBQzlCLElBQUksQ0FBQzlRLDRCQUE0QixDQUFDdFksYUFBYTBHO1lBRS9DLElBQUloVyxLQUFLckMsQ0FBQyxJQUFJcUMsS0FBS3JDLENBQUMsQ0FBQ04sQ0FBQyxFQUFFO2dCQUN0QixJQUFJLENBQUM4NkIsRUFBRSxHQUFHL1EsZ0JBQWdCQyxPQUFPLENBQUNyUixNQUFNaFcsS0FBS3JDLENBQUMsQ0FBQ2tjLENBQUMsRUFBRSxHQUFHLEdBQUcsSUFBSTtnQkFDNUQsSUFBSSxDQUFDdWUsRUFBRSxHQUFHaFIsZ0JBQWdCQyxPQUFPLENBQUNyUixNQUFNaFcsS0FBS3JDLENBQUMsQ0FBQ3drQixDQUFDLEVBQUUsR0FBRyxHQUFHLElBQUk7Z0JBRTVELElBQUluaUIsS0FBS3JDLENBQUMsQ0FBQzhuQixDQUFDLEVBQUU7b0JBQ1osSUFBSSxDQUFDNFMsRUFBRSxHQUFHalIsZ0JBQWdCQyxPQUFPLENBQUNyUixNQUFNaFcsS0FBS3JDLENBQUMsQ0FBQzhuQixDQUFDLEVBQUUsR0FBRyxHQUFHLElBQUk7Z0JBQzlEO1lBQ0YsT0FBTztnQkFDTCxJQUFJLENBQUM5bkIsQ0FBQyxHQUFHeXBCLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUtyQyxDQUFDLElBQUk7b0JBQy9DeUQsR0FBRzt3QkFBQzt3QkFBRzt3QkFBRztxQkFBRTtnQkFDZCxHQUFHLEdBQUcsR0FBRyxJQUFJO1lBQ2Y7WUFFQSxJQUFJcEIsS0FBS2s0QixFQUFFLEVBQUU7Z0JBQ1gsSUFBSSxDQUFDQSxFQUFFLEdBQUc5USxnQkFBZ0JDLE9BQU8sQ0FBQ3JSLE1BQU1oVyxLQUFLazRCLEVBQUUsRUFBRSxHQUFHeDlCLFdBQVcsSUFBSTtnQkFDbkUsSUFBSSxDQUFDdTlCLEVBQUUsR0FBRzdRLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUtpNEIsRUFBRSxFQUFFLEdBQUd2OUIsV0FBVyxJQUFJO2dCQUNuRSxJQUFJLENBQUNzOUIsRUFBRSxHQUFHNVEsZ0JBQWdCQyxPQUFPLENBQUNyUixNQUFNaFcsS0FBS2c0QixFQUFFLEVBQUUsR0FBR3Q5QixXQUFXLElBQUk7Z0JBRW5FLElBQUlzRixLQUFLOHJCLEVBQUUsQ0FBQzFxQixDQUFDLENBQUMsRUFBRSxDQUFDNGdCLEVBQUUsRUFBRTtvQkFDbkIsSUFBSS9zQjtvQkFDSixJQUFJQyxNQUFNOEssS0FBSzhyQixFQUFFLENBQUMxcUIsQ0FBQyxDQUFDak0sTUFBTTtvQkFFMUIsSUFBS0YsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7d0JBQzNCK0ssS0FBSzhyQixFQUFFLENBQUMxcUIsQ0FBQyxDQUFDbk0sRUFBRSxDQUFDOHNCLEVBQUUsR0FBRzt3QkFDbEIvaEIsS0FBSzhyQixFQUFFLENBQUMxcUIsQ0FBQyxDQUFDbk0sRUFBRSxDQUFDK3NCLEVBQUUsR0FBRztvQkFDcEI7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDOEosRUFBRSxHQUFHMUUsZ0JBQWdCQyxPQUFPLENBQUNyUixNQUFNaFcsS0FBSzhyQixFQUFFLEVBQUUsR0FBR3B4QixXQUFXLElBQUksR0FBRywwREFBMEQ7Z0JBRWhJLElBQUksQ0FBQ294QixFQUFFLENBQUM5SSxFQUFFLEdBQUc7WUFDZixPQUFPO2dCQUNMLElBQUksQ0FBQ3psQixDQUFDLEdBQUc2cEIsZ0JBQWdCQyxPQUFPLENBQUNyUixNQUFNaFcsS0FBS3pDLENBQUMsSUFBSTtvQkFDL0M2RCxHQUFHO2dCQUNMLEdBQUcsR0FBRzFHLFdBQVcsSUFBSTtZQUN2QjtZQUVBLElBQUlzRixLQUFLa0UsRUFBRSxFQUFFO2dCQUNYLElBQUksQ0FBQ0EsRUFBRSxHQUFHa2pCLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUtrRSxFQUFFLEVBQUUsR0FBR3hKLFdBQVcsSUFBSTtnQkFDbkUsSUFBSSxDQUFDeUosRUFBRSxHQUFHaWpCLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUttRSxFQUFFLEVBQUUsR0FBR3pKLFdBQVcsSUFBSTtZQUNyRTtZQUVBLElBQUksQ0FBQ3VKLENBQUMsR0FBR21qQixnQkFBZ0JDLE9BQU8sQ0FBQ3JSLE1BQU1oVyxLQUFLaUUsQ0FBQyxJQUFJO2dCQUMvQzdDLEdBQUc7b0JBQUM7b0JBQUc7b0JBQUc7aUJBQUU7WUFDZCxHQUFHLEdBQUcsR0FBRyxJQUFJO1lBQ2IsSUFBSSxDQUFDL0QsQ0FBQyxHQUFHK3BCLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUszQyxDQUFDLElBQUk7Z0JBQy9DK0QsR0FBRztvQkFBQztvQkFBSztvQkFBSztpQkFBSTtZQUNwQixHQUFHLEdBQUcsTUFBTSxJQUFJLEdBQUcsNkpBQTZKO1lBRWhMLElBQUlwQixLQUFLOEMsQ0FBQyxFQUFFO2dCQUNWLElBQUksQ0FBQ0EsQ0FBQyxHQUFHc2tCLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUs4QyxDQUFDLEVBQUUsR0FBRyxNQUFNa1Q7WUFDMUQsT0FBTztnQkFDTCxJQUFJLENBQUNsVCxDQUFDLEdBQUc7b0JBQ1BvakIsTUFBTTtvQkFDTjVvQixHQUFHO2dCQUNMO1lBQ0Y7WUFFQSxJQUFJLENBQUNpN0IsUUFBUSxHQUFHO1lBRWhCLElBQUksQ0FBQyxJQUFJLENBQUM5USxpQkFBaUIsQ0FBQ3R5QixNQUFNLEVBQUU7Z0JBQ2xDLElBQUksQ0FBQzR4QixRQUFRLENBQUM7WUFDaEI7UUFDRjtRQUVBaVMsa0JBQWtCM2pDLFNBQVMsR0FBRztZQUM1QnlpQyxlQUFlQTtZQUNmL1EsVUFBVXdPO1lBQ1ZpRCxvQkFBb0JBO1lBQ3BCTSxZQUFZQTtRQUNkO1FBQ0Foa0MsZ0JBQWdCO1lBQUMweUI7U0FBeUIsRUFBRXdSO1FBQzVDQSxrQkFBa0IzakMsU0FBUyxDQUFDdXhCLGtCQUFrQixHQUFHQTtRQUNqRG9TLGtCQUFrQjNqQyxTQUFTLENBQUMwakMsbUJBQW1CLEdBQUd2Uix5QkFBeUJueUIsU0FBUyxDQUFDdXhCLGtCQUFrQjtRQUV2RyxTQUFTcVMscUJBQXFCampCLElBQUksRUFBRWhXLElBQUksRUFBRXNQLFNBQVM7WUFDakQsT0FBTyxJQUFJMHBCLGtCQUFrQmhqQixNQUFNaFcsTUFBTXNQO1FBQzNDO1FBRUEsT0FBTztZQUNMMnBCLHNCQUFzQkE7UUFDeEI7SUFDRjtJQUVBLFNBQVNDLG9CQUFvQjtJQUU3QnBrQyxnQkFBZ0I7UUFBQ3FnQztLQUFjLEVBQUUrRDtJQUVqQ0EsaUJBQWlCN2pDLFNBQVMsQ0FBQysvQixzQkFBc0IsR0FBRyxTQUFVcGYsSUFBSSxFQUFFaFcsSUFBSTtRQUN0RSxJQUFJLENBQUMrbUIsUUFBUSxHQUFHLElBQUksQ0FBQ3dPLFdBQVc7UUFDaEMsSUFBSSxDQUFDL3dCLENBQUMsR0FBRzRpQixnQkFBZ0JDLE9BQU8sQ0FBQ3JSLE1BQU1oVyxLQUFLd0UsQ0FBQyxFQUFFLEdBQUcsTUFBTSxJQUFJO1FBQzVELElBQUksQ0FBQzFCLENBQUMsR0FBR3NrQixnQkFBZ0JDLE9BQU8sQ0FBQ3JSLE1BQU1oVyxLQUFLOEMsQ0FBQyxFQUFFLEdBQUcsTUFBTSxJQUFJO1FBQzVELElBQUksQ0FBQ3EyQixFQUFFLEdBQUd2Qix5QkFBeUJxQixvQkFBb0IsQ0FBQ2pqQixNQUFNaFcsS0FBS201QixFQUFFLEVBQUUsSUFBSTtRQUMzRSxJQUFJLENBQUNDLEVBQUUsR0FBR2hTLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUttNUIsRUFBRSxDQUFDQyxFQUFFLEVBQUUsR0FBRyxNQUFNLElBQUk7UUFDakUsSUFBSSxDQUFDQyxFQUFFLEdBQUdqUyxnQkFBZ0JDLE9BQU8sQ0FBQ3JSLE1BQU1oVyxLQUFLbTVCLEVBQUUsQ0FBQ0UsRUFBRSxFQUFFLEdBQUcsTUFBTSxJQUFJO1FBQ2pFLElBQUksQ0FBQ3I1QixJQUFJLEdBQUdBO1FBRVosSUFBSSxDQUFDLElBQUksQ0FBQ3luQixpQkFBaUIsQ0FBQ3R5QixNQUFNLEVBQUU7WUFDbEMsSUFBSSxDQUFDNHhCLFFBQVEsQ0FBQztRQUNoQjtRQUVBLElBQUksQ0FBQ1csV0FBVyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUNELGlCQUFpQixDQUFDdHlCLE1BQU07UUFDbEQsSUFBSSxDQUFDbWtDLE9BQU8sR0FBRyxJQUFJOUw7UUFDbkIsSUFBSSxDQUFDK0wsT0FBTyxHQUFHLElBQUkvTDtRQUNuQixJQUFJLENBQUNnTSxPQUFPLEdBQUcsSUFBSWhNO1FBQ25CLElBQUksQ0FBQ2lNLE9BQU8sR0FBRyxJQUFJak07UUFDbkIsSUFBSSxDQUFDMEQsTUFBTSxHQUFHLElBQUkxRDtJQUNwQjtJQUVBMEwsaUJBQWlCN2pDLFNBQVMsQ0FBQ3FrQyxlQUFlLEdBQUcsU0FBVUosT0FBTyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRXRLLFNBQVMsRUFBRTdSLElBQUksRUFBRXNjLEdBQUc7UUFDcEcsSUFBSTlhLE1BQU04YSxNQUFNLENBQUMsSUFBSTtRQUNyQixJQUFJQyxTQUFTMUssVUFBVTd4QixDQUFDLENBQUNDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxJQUFJNHhCLFVBQVU3eEIsQ0FBQyxDQUFDQyxDQUFDLENBQUMsRUFBRSxJQUFLLEtBQUkrZixJQUFHO1FBQ2pFLElBQUl3YyxTQUFTM0ssVUFBVTd4QixDQUFDLENBQUNDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxJQUFJNHhCLFVBQVU3eEIsQ0FBQyxDQUFDQyxDQUFDLENBQUMsRUFBRSxJQUFLLEtBQUkrZixJQUFHO1FBQ2pFaWMsUUFBUXZLLFNBQVMsQ0FBQ0csVUFBVXZ4QixDQUFDLENBQUNMLENBQUMsQ0FBQyxFQUFFLEdBQUd1aEIsTUFBTXhCLE1BQU02UixVQUFVdnhCLENBQUMsQ0FBQ0wsQ0FBQyxDQUFDLEVBQUUsR0FBR3VoQixNQUFNeEIsTUFBTTZSLFVBQVV2eEIsQ0FBQyxDQUFDTCxDQUFDLENBQUMsRUFBRTtRQUNoR2k4QixRQUFReEssU0FBUyxDQUFDLENBQUNHLFVBQVVqckIsQ0FBQyxDQUFDM0csQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDNHhCLFVBQVVqckIsQ0FBQyxDQUFDM0csQ0FBQyxDQUFDLEVBQUUsRUFBRTR4QixVQUFVanJCLENBQUMsQ0FBQzNHLENBQUMsQ0FBQyxFQUFFO1FBQ3hFaThCLFFBQVF4TCxNQUFNLENBQUMsQ0FBQ21CLFVBQVUzeEIsQ0FBQyxDQUFDRCxDQUFDLEdBQUd1aEIsTUFBTXhCO1FBQ3RDa2MsUUFBUXhLLFNBQVMsQ0FBQ0csVUFBVWpyQixDQUFDLENBQUMzRyxDQUFDLENBQUMsRUFBRSxFQUFFNHhCLFVBQVVqckIsQ0FBQyxDQUFDM0csQ0FBQyxDQUFDLEVBQUUsRUFBRTR4QixVQUFVanJCLENBQUMsQ0FBQzNHLENBQUMsQ0FBQyxFQUFFO1FBQ3RFazhCLFFBQVF6SyxTQUFTLENBQUMsQ0FBQ0csVUFBVWpyQixDQUFDLENBQUMzRyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM0eEIsVUFBVWpyQixDQUFDLENBQUMzRyxDQUFDLENBQUMsRUFBRSxFQUFFNHhCLFVBQVVqckIsQ0FBQyxDQUFDM0csQ0FBQyxDQUFDLEVBQUU7UUFDeEVrOEIsUUFBUTlLLEtBQUssQ0FBQ2lMLE1BQU0sSUFBSUMsU0FBU0EsUUFBUUQsTUFBTSxJQUFJRSxTQUFTQTtRQUM1REwsUUFBUXpLLFNBQVMsQ0FBQ0csVUFBVWpyQixDQUFDLENBQUMzRyxDQUFDLENBQUMsRUFBRSxFQUFFNHhCLFVBQVVqckIsQ0FBQyxDQUFDM0csQ0FBQyxDQUFDLEVBQUUsRUFBRTR4QixVQUFVanJCLENBQUMsQ0FBQzNHLENBQUMsQ0FBQyxFQUFFO0lBQ3hFO0lBRUE0N0IsaUJBQWlCN2pDLFNBQVMsQ0FBQzZlLElBQUksR0FBRyxTQUFVOEIsSUFBSSxFQUFFaGUsR0FBRyxFQUFFbXdCLEdBQUcsRUFBRTJSLFNBQVM7UUFDbkUsSUFBSSxDQUFDOWpCLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNoZSxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDbXdCLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUMyUixTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDQyxPQUFPLEdBQUcsRUFBRTtRQUNqQixJQUFJLENBQUM3VCxPQUFPLEdBQUcsQ0FBQztRQUNoQixJQUFJLENBQUN3Qiw0QkFBNEIsQ0FBQzVSO1FBQ2xDLElBQUksQ0FBQ29mLHNCQUFzQixDQUFDcGYsTUFBTWhlLEdBQUcsQ0FBQ213QixJQUFJO1FBRTFDLE1BQU9BLE1BQU0sRUFBRztZQUNkQSxPQUFPLEdBQUcsZ0RBQWdEO1lBRTFELElBQUksQ0FBQzZSLFNBQVMsQ0FBQ0UsT0FBTyxDQUFDbGlDLEdBQUcsQ0FBQ213QixJQUFJO1FBQ2pDO1FBRUEsSUFBSSxJQUFJLENBQUNWLGlCQUFpQixDQUFDdHlCLE1BQU0sRUFBRTtZQUNqQyxJQUFJLENBQUNpTSxDQUFDLEdBQUc7UUFDWCxPQUFPO1lBQ0wsSUFBSSxDQUFDMmxCLFFBQVEsQ0FBQztRQUNoQjtJQUNGO0lBRUFtUyxpQkFBaUI3akMsU0FBUyxDQUFDOGtDLGFBQWEsR0FBRyxTQUFVQyxRQUFRO1FBQzNELElBQUlubEM7UUFDSixJQUFJQyxNQUFNa2xDLFNBQVNqbEMsTUFBTTtRQUV6QixJQUFLRixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQm1sQyxRQUFRLENBQUNubEMsRUFBRSxDQUFDb2xDLFVBQVUsR0FBRztZQUV6QixJQUFJRCxRQUFRLENBQUNubEMsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLE1BQU07Z0JBQzNCLElBQUksQ0FBQ3U0QixhQUFhLENBQUNDLFFBQVEsQ0FBQ25sQyxFQUFFLENBQUM0TixFQUFFO1lBQ25DO1FBQ0Y7SUFDRjtJQUVBcTJCLGlCQUFpQjdqQyxTQUFTLENBQUNpbEMsYUFBYSxHQUFHLFNBQVVGLFFBQVE7UUFDM0QsSUFBSUcsY0FBYzkzQixLQUFLQyxLQUFLLENBQUNELEtBQUtFLFNBQVMsQ0FBQ3kzQjtRQUM1QyxJQUFJLENBQUNELGFBQWEsQ0FBQ0k7UUFDbkIsT0FBT0E7SUFDVDtJQUVBckIsaUJBQWlCN2pDLFNBQVMsQ0FBQ21sQyxpQkFBaUIsR0FBRyxTQUFVSixRQUFRLEVBQUVLLFVBQVU7UUFDM0UsSUFBSXhsQztRQUNKLElBQUlDLE1BQU1rbEMsU0FBU2psQyxNQUFNO1FBRXpCLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCbWxDLFFBQVEsQ0FBQ25sQyxFQUFFLENBQUN5bEMsT0FBTyxHQUFHRDtZQUV0QixJQUFJTCxRQUFRLENBQUNubEMsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLE1BQU07Z0JBQzNCLElBQUksQ0FBQzQ0QixpQkFBaUIsQ0FBQ0osUUFBUSxDQUFDbmxDLEVBQUUsQ0FBQzROLEVBQUUsRUFBRTQzQjtZQUN6QztRQUNGO0lBQ0Y7SUFFQXZCLGlCQUFpQjdqQyxTQUFTLENBQUMrZ0MsYUFBYSxHQUFHLFNBQVU3UCxhQUFhO1FBQ2hFLElBQUlvVTtRQUNKLElBQUlDO1FBQ0osSUFBSTNsQztRQUNKLElBQUk0cEI7UUFDSixJQUFJZ2M7UUFDSixJQUFJQyxjQUFjO1FBRWxCLElBQUksSUFBSSxDQUFDNVUsSUFBSSxJQUFJSyxlQUFlO1lBQzlCLElBQUl3VSxTQUFTeGhDLEtBQUt5aEMsSUFBSSxDQUFDLElBQUksQ0FBQ3gyQixDQUFDLENBQUNsSCxDQUFDO1lBRS9CLElBQUksSUFBSSxDQUFDMjhCLE9BQU8sQ0FBQzlrQyxNQUFNLEdBQUc0bEMsUUFBUTtnQkFDaEMsTUFBTyxJQUFJLENBQUNkLE9BQU8sQ0FBQzlrQyxNQUFNLEdBQUc0bEMsT0FBUTtvQkFDbkMsSUFBSUUsUUFBUTt3QkFDVnA0QixJQUFJLElBQUksQ0FBQ3kzQixhQUFhLENBQUMsSUFBSSxDQUFDTixTQUFTO3dCQUNyQ3A0QixJQUFJO29CQUNOO29CQUNBcTVCLE1BQU1wNEIsRUFBRSxDQUFDck0sSUFBSSxDQUFDO3dCQUNaeU4sR0FBRzs0QkFDREEsR0FBRzs0QkFDSGkzQixJQUFJOzRCQUNKOTVCLEdBQUc7Z0NBQUM7Z0NBQUc7NkJBQUU7d0JBQ1g7d0JBQ0EwTCxJQUFJO3dCQUNKaEssR0FBRzs0QkFDRG1CLEdBQUc7NEJBQ0hpM0IsSUFBSTs0QkFDSjk1QixHQUFHO3dCQUNMO3dCQUNBekQsR0FBRzs0QkFDRHNHLEdBQUc7NEJBQ0hpM0IsSUFBSTs0QkFDSjk1QixHQUFHO2dDQUFDO2dDQUFHOzZCQUFFO3dCQUNYO3dCQUNBN0QsR0FBRzs0QkFDRDBHLEdBQUc7NEJBQ0hpM0IsSUFBSTs0QkFDSjk1QixHQUFHO2dDQUFDO29DQUNGL0QsR0FBRztvQ0FDSHVELEdBQUc7b0NBQ0gvQyxHQUFHO2dDQUNMO2dDQUFHO29DQUNEUixHQUFHO29DQUNIdUQsR0FBRztvQ0FDSC9DLEdBQUc7Z0NBQ0w7NkJBQUU7d0JBQ0o7d0JBQ0FSLEdBQUc7NEJBQ0Q0RyxHQUFHOzRCQUNIaTNCLElBQUk7NEJBQ0o5NUIsR0FBRztnQ0FBQztnQ0FBSzs2QkFBSTt3QkFDZjt3QkFDQStDLElBQUk7NEJBQ0ZGLEdBQUc7NEJBQ0hpM0IsSUFBSTs0QkFDSjk1QixHQUFHO3dCQUNMO3dCQUNBOEMsSUFBSTs0QkFDRkQsR0FBRzs0QkFDSGkzQixJQUFJOzRCQUNKOTVCLEdBQUc7d0JBQ0w7d0JBQ0FRLElBQUk7b0JBQ047b0JBQ0EsSUFBSSxDQUFDNUosR0FBRyxDQUFDcVQsTUFBTSxDQUFDLEdBQUcsR0FBRzR2QjtvQkFFdEIsSUFBSSxDQUFDaEIsT0FBTyxDQUFDNXVCLE1BQU0sQ0FBQyxHQUFHLEdBQUc0dkI7b0JBRTFCLElBQUksQ0FBQ2xCLGNBQWMsSUFBSTtnQkFDekI7Z0JBRUEsSUFBSSxDQUFDL2pCLElBQUksQ0FBQ21sQixZQUFZO2dCQUN0QkwsY0FBYztZQUNoQjtZQUVBRCxPQUFPO1lBQ1AsSUFBSUo7WUFFSixJQUFLeGxDLElBQUksR0FBR0EsS0FBSyxJQUFJLENBQUNnbEMsT0FBTyxDQUFDOWtDLE1BQU0sR0FBRyxHQUFHRixLQUFLLEVBQUc7Z0JBQ2hEd2xDLGFBQWFJLE9BQU9FO2dCQUNwQixJQUFJLENBQUNkLE9BQU8sQ0FBQ2hsQyxFQUFFLENBQUN5bEMsT0FBTyxHQUFHRDtnQkFDMUIsSUFBSSxDQUFDRCxpQkFBaUIsQ0FBQyxJQUFJLENBQUNQLE9BQU8sQ0FBQ2hsQyxFQUFFLENBQUM0TixFQUFFLEVBQUU0M0I7Z0JBRTNDLElBQUksQ0FBQ0EsWUFBWTtvQkFDZixJQUFJVyxRQUFRLElBQUksQ0FBQ3RCLFNBQVMsQ0FBQzdrQyxFQUFFLENBQUM0TixFQUFFO29CQUNoQyxJQUFJdzRCLGdCQUFnQkQsS0FBSyxDQUFDQSxNQUFNam1DLE1BQU0sR0FBRyxFQUFFO29CQUUzQyxJQUFJa21DLGNBQWNuTSxTQUFTLENBQUNwckIsRUFBRSxDQUFDeEcsQ0FBQyxLQUFLLEdBQUc7d0JBQ3RDKzlCLGNBQWNuTSxTQUFTLENBQUNwckIsRUFBRSxDQUFDb2lCLElBQUksR0FBRzt3QkFDbENtVixjQUFjbk0sU0FBUyxDQUFDcHJCLEVBQUUsQ0FBQ3hHLENBQUMsR0FBRztvQkFDakMsT0FBTzt3QkFDTCs5QixjQUFjbk0sU0FBUyxDQUFDcHJCLEVBQUUsQ0FBQ29pQixJQUFJLEdBQUc7b0JBQ3BDO2dCQUNGO2dCQUVBMlUsUUFBUTtZQUNWO1lBRUEsSUFBSSxDQUFDZCxjQUFjLEdBQUdnQixRQUFRLEtBQUs7WUFFbkMsSUFBSTc4QixTQUFTLElBQUksQ0FBQzRFLENBQUMsQ0FBQ3hGLENBQUM7WUFDckIsSUFBSWcrQixlQUFlcDlCLFNBQVM7WUFDNUIsSUFBSXE5QixjQUFjcjlCLFNBQVMsSUFBSTNFLEtBQUtLLEtBQUssQ0FBQ3NFLFVBQVUzRSxLQUFLeWhDLElBQUksQ0FBQzk4QjtZQUM5RCxJQUFJczlCLFNBQVMsSUFBSSxDQUFDbEMsT0FBTyxDQUFDeEwsS0FBSztZQUMvQixJQUFJMk4sU0FBUyxJQUFJLENBQUNsQyxPQUFPLENBQUN6TCxLQUFLO1lBQy9CLElBQUk0TixTQUFTLElBQUksQ0FBQ2xDLE9BQU8sQ0FBQzFMLEtBQUs7WUFDL0IsSUFBSSxDQUFDd0wsT0FBTyxDQUFDM08sS0FBSztZQUNsQixJQUFJLENBQUM0TyxPQUFPLENBQUM1TyxLQUFLO1lBQ2xCLElBQUksQ0FBQzZPLE9BQU8sQ0FBQzdPLEtBQUs7WUFDbEIsSUFBSSxDQUFDOE8sT0FBTyxDQUFDOU8sS0FBSztZQUNsQixJQUFJLENBQUN1RyxNQUFNLENBQUN2RyxLQUFLO1lBQ2pCLElBQUlnUixZQUFZO1lBRWhCLElBQUl6OUIsU0FBUyxHQUFHO2dCQUNkLE1BQU95OUIsWUFBWUosWUFBYTtvQkFDOUIsSUFBSSxDQUFDN0IsZUFBZSxDQUFDLElBQUksQ0FBQ0osT0FBTyxFQUFFLElBQUksQ0FBQ0MsT0FBTyxFQUFFLElBQUksQ0FBQ0MsT0FBTyxFQUFFLElBQUksQ0FBQ0wsRUFBRSxFQUFFLEdBQUc7b0JBQzNFd0MsYUFBYTtnQkFDZjtnQkFFQSxJQUFJTCxjQUFjO29CQUNoQixJQUFJLENBQUM1QixlQUFlLENBQUMsSUFBSSxDQUFDSixPQUFPLEVBQUUsSUFBSSxDQUFDQyxPQUFPLEVBQUUsSUFBSSxDQUFDQyxPQUFPLEVBQUUsSUFBSSxDQUFDTCxFQUFFLEVBQUVtQyxjQUFjO29CQUN0RkssYUFBYUw7Z0JBQ2Y7WUFDRixPQUFPLElBQUlwOUIsU0FBUyxHQUFHO2dCQUNyQixNQUFPeTlCLFlBQVlKLFlBQWE7b0JBQzlCLElBQUksQ0FBQzdCLGVBQWUsQ0FBQyxJQUFJLENBQUNKLE9BQU8sRUFBRSxJQUFJLENBQUNDLE9BQU8sRUFBRSxJQUFJLENBQUNDLE9BQU8sRUFBRSxJQUFJLENBQUNMLEVBQUUsRUFBRSxHQUFHO29CQUMzRXdDLGFBQWE7Z0JBQ2Y7Z0JBRUEsSUFBSUwsY0FBYztvQkFDaEIsSUFBSSxDQUFDNUIsZUFBZSxDQUFDLElBQUksQ0FBQ0osT0FBTyxFQUFFLElBQUksQ0FBQ0MsT0FBTyxFQUFFLElBQUksQ0FBQ0MsT0FBTyxFQUFFLElBQUksQ0FBQ0wsRUFBRSxFQUFFLENBQUNtQyxjQUFjO29CQUN2RkssYUFBYUw7Z0JBQ2Y7WUFDRjtZQUVBcm1DLElBQUksSUFBSSxDQUFDK0ssSUFBSSxDQUFDOHVCLENBQUMsS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDaUwsY0FBYyxHQUFHO1lBQ2xEbGIsTUFBTSxJQUFJLENBQUM3ZSxJQUFJLENBQUM4dUIsQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDO1lBQy9CK0wsT0FBTyxJQUFJLENBQUNkLGNBQWM7WUFDMUIsSUFBSTc0QjtZQUNKLElBQUlDO1lBRUosTUFBTzA1QixLQUFNO2dCQUNYRixRQUFRLElBQUksQ0FBQ2IsU0FBUyxDQUFDN2tDLEVBQUUsQ0FBQzROLEVBQUU7Z0JBQzVCKzNCLGlCQUFpQkQsS0FBSyxDQUFDQSxNQUFNeGxDLE1BQU0sR0FBRyxFQUFFLENBQUMrNUIsU0FBUyxDQUFDME0sTUFBTSxDQUFDdCtCLENBQUMsQ0FBQ3d3QixLQUFLO2dCQUNqRTNzQixPQUFPeTVCLGVBQWV6bEMsTUFBTTtnQkFDNUJ3bEMsS0FBSyxDQUFDQSxNQUFNeGxDLE1BQU0sR0FBRyxFQUFFLENBQUMrNUIsU0FBUyxDQUFDME0sTUFBTSxDQUFDMVYsSUFBSSxHQUFHO2dCQUNoRHlVLEtBQUssQ0FBQ0EsTUFBTXhsQyxNQUFNLEdBQUcsRUFBRSxDQUFDKzVCLFNBQVMsQ0FBQ3ByQixFQUFFLENBQUNvaUIsSUFBSSxHQUFHO2dCQUM1Q3lVLEtBQUssQ0FBQ0EsTUFBTXhsQyxNQUFNLEdBQUcsRUFBRSxDQUFDKzVCLFNBQVMsQ0FBQ3ByQixFQUFFLENBQUN4RyxDQUFDLEdBQUcsSUFBSSxDQUFDeThCLGNBQWMsS0FBSyxJQUFJLElBQUksQ0FBQ1gsRUFBRSxDQUFDOTdCLENBQUMsR0FBRyxJQUFJLENBQUM4N0IsRUFBRSxDQUFDOTdCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQys3QixFQUFFLENBQUMvN0IsQ0FBQyxHQUFHLElBQUksQ0FBQzg3QixFQUFFLENBQUM5N0IsQ0FBQyxJQUFLckksQ0FBQUEsSUFBSyxLQUFJLENBQUM4a0MsY0FBYyxHQUFHLEVBQUM7Z0JBRXBKLElBQUk0QixjQUFjLEdBQUc7b0JBQ25CLElBQUkxbUMsTUFBTSxLQUFLNHBCLFFBQVEsS0FBSzVwQixNQUFNLElBQUksQ0FBQzhrQyxjQUFjLEdBQUcsS0FBS2xiLFFBQVEsQ0FBQyxHQUFHO3dCQUN2RSxJQUFJLENBQUM2YSxlQUFlLENBQUMsSUFBSSxDQUFDSixPQUFPLEVBQUUsSUFBSSxDQUFDQyxPQUFPLEVBQUUsSUFBSSxDQUFDQyxPQUFPLEVBQUUsSUFBSSxDQUFDTCxFQUFFLEVBQUUsR0FBRztvQkFDN0U7b0JBRUEsSUFBSSxDQUFDakksTUFBTSxDQUFDaEMsU0FBUyxDQUFDdU0sTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEdBQUcsRUFBRUEsTUFBTSxDQUFDLEdBQUcsRUFBRUEsTUFBTSxDQUFDLEdBQUcsRUFBRUEsTUFBTSxDQUFDLEdBQUcsRUFBRUEsTUFBTSxDQUFDLEdBQUcsRUFBRUEsTUFBTSxDQUFDLEdBQUc7b0JBQzFNLElBQUksQ0FBQ3ZLLE1BQU0sQ0FBQ2hDLFNBQVMsQ0FBQ3dNLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxHQUFHLEVBQUVBLE1BQU0sQ0FBQyxHQUFHLEVBQUVBLE1BQU0sQ0FBQyxHQUFHLEVBQUVBLE1BQU0sQ0FBQyxHQUFHLEVBQUVBLE1BQU0sQ0FBQyxHQUFHLEVBQUVBLE1BQU0sQ0FBQyxHQUFHO29CQUMxTSxJQUFJLENBQUN4SyxNQUFNLENBQUNoQyxTQUFTLENBQUNzTSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsR0FBRyxFQUFFQSxNQUFNLENBQUMsR0FBRyxFQUFFQSxNQUFNLENBQUMsR0FBRyxFQUFFQSxNQUFNLENBQUMsR0FBRyxFQUFFQSxNQUFNLENBQUMsR0FBRyxFQUFFQSxNQUFNLENBQUMsR0FBRztvQkFFMU0sSUFBS3Q2QixJQUFJLEdBQUdBLElBQUlDLE1BQU1ELEtBQUssRUFBRzt3QkFDNUIwNUIsY0FBYyxDQUFDMTVCLEVBQUUsR0FBRyxJQUFJLENBQUNnd0IsTUFBTSxDQUFDcEQsS0FBSyxDQUFDNXNCLEVBQUU7b0JBQzFDO29CQUVBLElBQUksQ0FBQ2d3QixNQUFNLENBQUN2RyxLQUFLO2dCQUNuQixPQUFPO29CQUNMLElBQUksQ0FBQ3VHLE1BQU0sQ0FBQ3ZHLEtBQUs7b0JBRWpCLElBQUt6cEIsSUFBSSxHQUFHQSxJQUFJQyxNQUFNRCxLQUFLLEVBQUc7d0JBQzVCMDVCLGNBQWMsQ0FBQzE1QixFQUFFLEdBQUcsSUFBSSxDQUFDZ3dCLE1BQU0sQ0FBQ3BELEtBQUssQ0FBQzVzQixFQUFFO29CQUMxQztnQkFDRjtnQkFFQXk2QixhQUFhO2dCQUNiZCxRQUFRO2dCQUNSNWxDLEtBQUs0cEI7WUFDUDtRQUNGLE9BQU87WUFDTGdjLE9BQU8sSUFBSSxDQUFDZCxjQUFjO1lBQzFCOWtDLElBQUk7WUFDSjRwQixNQUFNO1lBRU4sTUFBT2djLEtBQU07Z0JBQ1hGLFFBQVEsSUFBSSxDQUFDYixTQUFTLENBQUM3a0MsRUFBRSxDQUFDNE4sRUFBRTtnQkFDNUIrM0IsaUJBQWlCRCxLQUFLLENBQUNBLE1BQU14bEMsTUFBTSxHQUFHLEVBQUUsQ0FBQys1QixTQUFTLENBQUMwTSxNQUFNLENBQUN0K0IsQ0FBQyxDQUFDd3dCLEtBQUs7Z0JBQ2pFNk0sS0FBSyxDQUFDQSxNQUFNeGxDLE1BQU0sR0FBRyxFQUFFLENBQUMrNUIsU0FBUyxDQUFDME0sTUFBTSxDQUFDMVYsSUFBSSxHQUFHO2dCQUNoRHlVLEtBQUssQ0FBQ0EsTUFBTXhsQyxNQUFNLEdBQUcsRUFBRSxDQUFDKzVCLFNBQVMsQ0FBQ3ByQixFQUFFLENBQUNvaUIsSUFBSSxHQUFHO2dCQUM1QzJVLFFBQVE7Z0JBQ1I1bEMsS0FBSzRwQjtZQUNQO1FBQ0Y7UUFFQSxPQUFPaWM7SUFDVDtJQUVBNUIsaUJBQWlCN2pDLFNBQVMsQ0FBQ2swQixRQUFRLEdBQUcsWUFBYTtJQUVuRCxTQUFTc1Msd0JBQXdCO0lBRWpDL21DLGdCQUFnQjtRQUFDcWdDO0tBQWMsRUFBRTBHO0lBRWpDQSxxQkFBcUJ4bUMsU0FBUyxDQUFDKy9CLHNCQUFzQixHQUFHLFNBQVVwZixJQUFJLEVBQUVoVyxJQUFJO1FBQzFFLElBQUksQ0FBQyttQixRQUFRLEdBQUcsSUFBSSxDQUFDd08sV0FBVztRQUNoQyxJQUFJLENBQUN1RyxFQUFFLEdBQUcxVSxnQkFBZ0JDLE9BQU8sQ0FBQ3JSLE1BQU1oVyxLQUFLekMsQ0FBQyxFQUFFLEdBQUcsTUFBTSxJQUFJO1FBQzdELElBQUksQ0FBQ21xQixXQUFXLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQ29VLEVBQUUsQ0FBQ3pWLGVBQWUsQ0FBQ2x4QixNQUFNO0lBQ3JEO0lBRUEwbUMscUJBQXFCeG1DLFNBQVMsQ0FBQ21pQyxXQUFXLEdBQUcsU0FBVXozQixJQUFJLEVBQUVoRixLQUFLO1FBQ2hFLElBQUk0OEIsYUFBYTFPLFVBQVU5TixVQUFVO1FBQ3JDd2MsV0FBV256QixDQUFDLEdBQUd6RSxLQUFLeUUsQ0FBQztRQUNyQixJQUFJdlA7UUFDSixJQUFJQyxNQUFNNkssS0FBS2liLE9BQU87UUFDdEIsSUFBSStnQjtRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJam5CLFFBQVE7UUFDWixJQUFJa1Q7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBRUosSUFBS3p6QixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQjhtQyxXQUFXaDhCLEtBQUt6QyxDQUFDLENBQUNySSxFQUFFO1lBQ3BCZ25DLFdBQVdsOEIsS0FBSytDLENBQUMsQ0FBQzdOLEVBQUU7WUFDcEIrbUMsV0FBV2o4QixLQUFLOUssQ0FBQyxDQUFDQSxFQUFFO1lBRXBCLElBQUk4bUMsUUFBUSxDQUFDLEVBQUUsS0FBS0UsUUFBUSxDQUFDLEVBQUUsSUFBSUYsUUFBUSxDQUFDLEVBQUUsS0FBS0UsUUFBUSxDQUFDLEVBQUUsSUFBSUYsUUFBUSxDQUFDLEVBQUUsS0FBS0MsUUFBUSxDQUFDLEVBQUUsSUFBSUQsUUFBUSxDQUFDLEVBQUUsS0FBS0MsUUFBUSxDQUFDLEVBQUUsRUFBRTtnQkFDNUgsSUFBSSxDQUFDL21DLE1BQU0sS0FBS0EsTUFBTUMsTUFBTSxNQUFNLENBQUM2SyxLQUFLeUUsQ0FBQyxFQUFFO29CQUN6Q216QixXQUFXdlAsV0FBVyxDQUFDMlQsUUFBUSxDQUFDLEVBQUUsRUFBRUEsUUFBUSxDQUFDLEVBQUUsRUFBRUUsUUFBUSxDQUFDLEVBQUUsRUFBRUEsUUFBUSxDQUFDLEVBQUUsRUFBRUQsUUFBUSxDQUFDLEVBQUUsRUFBRUEsUUFBUSxDQUFDLEVBQUUsRUFBRTdtQjtvQkFDckc7O2tEQUV3QyxHQUV4Q0EsU0FBUztnQkFDWCxPQUFPO29CQUNMLElBQUlsZ0IsTUFBTSxHQUFHO3dCQUNYaW5DLFVBQVVuOEIsS0FBS3pDLENBQUMsQ0FBQ3BJLE1BQU0sRUFBRTtvQkFDM0IsT0FBTzt3QkFDTGduQyxVQUFVbjhCLEtBQUt6QyxDQUFDLENBQUNySSxJQUFJLEVBQUU7b0JBQ3pCO29CQUVBa25DLFdBQVc1aUMsS0FBS0csSUFBSSxDQUFDSCxLQUFLQyxHQUFHLENBQUN1aUMsUUFBUSxDQUFDLEVBQUUsR0FBR0csT0FBTyxDQUFDLEVBQUUsRUFBRSxLQUFLM2lDLEtBQUtDLEdBQUcsQ0FBQ3VpQyxRQUFRLENBQUMsRUFBRSxHQUFHRyxPQUFPLENBQUMsRUFBRSxFQUFFO29CQUNoR0UsYUFBYUQsV0FBVzVpQyxLQUFLUyxHQUFHLENBQUNtaUMsV0FBVyxHQUFHcGhDLFNBQVNvaEMsV0FBVztvQkFDbkUxVCxLQUFLc1QsUUFBUSxDQUFDLEVBQUUsR0FBRyxDQUFDRyxPQUFPLENBQUMsRUFBRSxHQUFHSCxRQUFRLENBQUMsRUFBRSxJQUFJSztvQkFDaEQvVCxLQUFLSTtvQkFDTEMsS0FBS3FULFFBQVEsQ0FBQyxFQUFFLEdBQUcsQ0FBQ0EsUUFBUSxDQUFDLEVBQUUsR0FBR0csT0FBTyxDQUFDLEVBQUUsSUFBSUU7b0JBQ2hEOVQsS0FBS0k7b0JBQ0xILEtBQUtGLEtBQUssQ0FBQ0EsS0FBSzBULFFBQVEsQ0FBQyxFQUFFLElBQUluaEM7b0JBQy9CNHRCLEtBQUtGLEtBQUssQ0FBQ0EsS0FBS3lULFFBQVEsQ0FBQyxFQUFFLElBQUluaEM7b0JBQy9CKzhCLFdBQVd2UCxXQUFXLENBQUNDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUl2VDtvQkFDL0NBLFNBQVM7b0JBRVQsSUFBSWxnQixNQUFNQyxNQUFNLEdBQUc7d0JBQ2pCZ25DLFVBQVVuOEIsS0FBS3pDLENBQUMsQ0FBQyxFQUFFO29CQUNyQixPQUFPO3dCQUNMNCtCLFVBQVVuOEIsS0FBS3pDLENBQUMsQ0FBQ3JJLElBQUksRUFBRTtvQkFDekI7b0JBRUFrbkMsV0FBVzVpQyxLQUFLRyxJQUFJLENBQUNILEtBQUtDLEdBQUcsQ0FBQ3VpQyxRQUFRLENBQUMsRUFBRSxHQUFHRyxPQUFPLENBQUMsRUFBRSxFQUFFLEtBQUszaUMsS0FBS0MsR0FBRyxDQUFDdWlDLFFBQVEsQ0FBQyxFQUFFLEdBQUdHLE9BQU8sQ0FBQyxFQUFFLEVBQUU7b0JBQ2hHRSxhQUFhRCxXQUFXNWlDLEtBQUtTLEdBQUcsQ0FBQ21pQyxXQUFXLEdBQUdwaEMsU0FBU29oQyxXQUFXO29CQUNuRTVULEtBQUt3VCxRQUFRLENBQUMsRUFBRSxHQUFHLENBQUNHLE9BQU8sQ0FBQyxFQUFFLEdBQUdILFFBQVEsQ0FBQyxFQUFFLElBQUlLO29CQUNoRC9ULEtBQUtFO29CQUNMQyxLQUFLdVQsUUFBUSxDQUFDLEVBQUUsR0FBRyxDQUFDRyxPQUFPLENBQUMsRUFBRSxHQUFHSCxRQUFRLENBQUMsRUFBRSxJQUFJSztvQkFDaEQ5VCxLQUFLRTtvQkFDTEMsS0FBS0osS0FBSyxDQUFDQSxLQUFLMFQsUUFBUSxDQUFDLEVBQUUsSUFBSW5oQztvQkFDL0I4dEIsS0FBS0osS0FBSyxDQUFDQSxLQUFLeVQsUUFBUSxDQUFDLEVBQUUsSUFBSW5oQztvQkFDL0IrOEIsV0FBV3ZQLFdBQVcsQ0FBQ0MsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSXZUO29CQUMvQ0EsU0FBUztnQkFDWDtZQUNGLE9BQU87Z0JBQ0x3aUIsV0FBV3ZQLFdBQVcsQ0FBQ3JvQixLQUFLekMsQ0FBQyxDQUFDckksRUFBRSxDQUFDLEVBQUUsRUFBRThLLEtBQUt6QyxDQUFDLENBQUNySSxFQUFFLENBQUMsRUFBRSxFQUFFOEssS0FBSytDLENBQUMsQ0FBQzdOLEVBQUUsQ0FBQyxFQUFFLEVBQUU4SyxLQUFLK0MsQ0FBQyxDQUFDN04sRUFBRSxDQUFDLEVBQUUsRUFBRThLLEtBQUs5SyxDQUFDLENBQUNBLEVBQUUsQ0FBQyxFQUFFLEVBQUU4SyxLQUFLOUssQ0FBQyxDQUFDQSxFQUFFLENBQUMsRUFBRSxFQUFFa2dCO2dCQUMzR0EsU0FBUztZQUNYO1FBQ0Y7UUFFQSxPQUFPd2lCO0lBQ1Q7SUFFQWtFLHFCQUFxQnhtQyxTQUFTLENBQUMrZ0MsYUFBYSxHQUFHLFNBQVU3UCxhQUFhO1FBQ3BFLElBQUkrUDtRQUNKLElBQUlyaEM7UUFDSixJQUFJQyxNQUFNLElBQUksQ0FBQzhNLE1BQU0sQ0FBQzdNLE1BQU07UUFDNUIsSUFBSStMO1FBQ0osSUFBSUM7UUFDSixJQUFJMjZCLEtBQUssSUFBSSxDQUFDQSxFQUFFLENBQUN4K0IsQ0FBQztRQUVsQixJQUFJdytCLE9BQU8sR0FBRztZQUNaLElBQUluZTtZQUNKLElBQUkyTTtZQUVKLElBQUtyMUIsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7Z0JBQzNCMG9CLFlBQVksSUFBSSxDQUFDM2IsTUFBTSxDQUFDL00sRUFBRTtnQkFDMUJxMUIsdUJBQXVCM00sVUFBVTJNLG9CQUFvQjtnQkFFckQsSUFBSSxDQUFFLEVBQUMzTSxVQUFVeUwsS0FBSyxDQUFDbEQsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDQSxJQUFJLElBQUksQ0FBQ0ssYUFBWSxHQUFJO29CQUM1RCtELHFCQUFxQmQsYUFBYTtvQkFDbEM3TCxVQUFVeUwsS0FBSyxDQUFDbEQsSUFBSSxHQUFHO29CQUN2Qm9RLGFBQWEzWSxVQUFVeUwsS0FBSyxDQUFDaUIsS0FBSyxDQUFDcm9CLE1BQU07b0JBQ3pDYixPQUFPd2MsVUFBVXlMLEtBQUssQ0FBQ2lCLEtBQUssQ0FBQ3JQLE9BQU87b0JBRXBDLElBQUs5WixJQUFJLEdBQUdBLElBQUlDLE1BQU1ELEtBQUssRUFBRzt3QkFDNUJvcEIscUJBQXFCZixRQUFRLENBQUMsSUFBSSxDQUFDaU8sV0FBVyxDQUFDbEIsVUFBVSxDQUFDcDFCLEVBQUUsRUFBRTQ2QjtvQkFDaEU7Z0JBQ0Y7Z0JBRUFuZSxVQUFVeUwsS0FBSyxDQUFDaUIsS0FBSyxHQUFHMU0sVUFBVTJNLG9CQUFvQjtZQUN4RDtRQUNGO1FBRUEsSUFBSSxDQUFDLElBQUksQ0FBQzdDLGlCQUFpQixDQUFDdHlCLE1BQU0sRUFBRTtZQUNsQyxJQUFJLENBQUMrd0IsSUFBSSxHQUFHO1FBQ2Q7SUFDRjtJQUVBLFNBQVNtVyxXQUFXcDRCLENBQUMsRUFBRXhHLENBQUM7UUFDdEIsT0FBT2xFLEtBQUtjLEdBQUcsQ0FBQzRKLElBQUl4RyxLQUFLLFVBQVVsRSxLQUFLUyxHQUFHLENBQUNULEtBQUtjLEdBQUcsQ0FBQzRKLElBQUkxSyxLQUFLYyxHQUFHLENBQUNvRDtJQUNwRTtJQUVBLFNBQVM2K0IsVUFBVTUrQixDQUFDO1FBQ2xCLE9BQU9uRSxLQUFLYyxHQUFHLENBQUNxRCxNQUFNO0lBQ3hCO0lBRUEsU0FBUzYrQixLQUFLdFIsRUFBRSxFQUFFQyxFQUFFLEVBQUVxTSxNQUFNO1FBQzFCLE9BQU90TSxLQUFNLEtBQUlzTSxNQUFLLElBQUtyTSxLQUFLcU07SUFDbEM7SUFFQSxTQUFTaUYsVUFBVXZSLEVBQUUsRUFBRUMsRUFBRSxFQUFFcU0sTUFBTTtRQUMvQixPQUFPO1lBQUNnRixLQUFLdFIsRUFBRSxDQUFDLEVBQUUsRUFBRUMsRUFBRSxDQUFDLEVBQUUsRUFBRXFNO1lBQVNnRixLQUFLdFIsRUFBRSxDQUFDLEVBQUUsRUFBRUMsRUFBRSxDQUFDLEVBQUUsRUFBRXFNO1NBQVE7SUFDakU7SUFFQSxTQUFTa0YsVUFBVXg0QixDQUFDLEVBQUV4RyxDQUFDLEVBQUUrRyxDQUFDO1FBQ3hCLFVBQVU7UUFDVixJQUFJUCxNQUFNLEdBQUcsT0FBTyxFQUFFO1FBQ3RCLElBQUk1RyxJQUFJSSxJQUFJQSxJQUFJLElBQUl3RyxJQUFJTyxHQUFHLGdCQUFnQjtRQUUzQyxJQUFJbkgsSUFBSSxHQUFHLE9BQU8sRUFBRTtRQUNwQixJQUFJcS9CLGFBQWEsQ0FBQ2ovQixJQUFLLEtBQUl3RyxDQUFBQSxHQUFJLFNBQVM7UUFFeEMsSUFBSTVHLE1BQU0sR0FBRyxPQUFPO1lBQUNxL0I7U0FBVztRQUNoQyxJQUFJQyxRQUFRcGpDLEtBQUtHLElBQUksQ0FBQzJELEtBQU0sS0FBSTRHLENBQUFBLEdBQUksVUFBVTtRQUU5QyxPQUFPO1lBQUN5NEIsYUFBYUM7WUFBT0QsYUFBYUM7U0FBTTtJQUNqRDtJQUVBLFNBQVNDLHVCQUF1QjNSLEVBQUUsRUFBRUMsRUFBRSxFQUFFK0UsRUFBRSxFQUFFNE0sRUFBRTtRQUM1QyxPQUFPO1lBQUMsQ0FBQzVSLEtBQUssSUFBSUMsS0FBSyxJQUFJK0UsS0FBSzRNO1lBQUksSUFBSTVSLEtBQUssSUFBSUMsS0FBSyxJQUFJK0U7WUFBSSxDQUFDLElBQUloRixLQUFLLElBQUlDO1lBQUlEO1NBQUc7SUFDckY7SUFFQSxTQUFTNlIsWUFBWW4vQixDQUFDO1FBQ3BCLE9BQU8sSUFBSW8vQixpQkFBaUJwL0IsR0FBR0EsR0FBR0EsR0FBR0EsR0FBRztJQUMxQztJQUVBLFNBQVNvL0IsaUJBQWlCOVIsRUFBRSxFQUFFQyxFQUFFLEVBQUUrRSxFQUFFLEVBQUU0TSxFQUFFLEVBQUVHLFNBQVM7UUFDakQsSUFBSUEsYUFBYUMsV0FBV2hTLElBQUlDLEtBQUs7WUFDbkNBLEtBQUtzUixVQUFVdlIsSUFBSTRSLElBQUksSUFBSTtRQUM3QjtRQUVBLElBQUlHLGFBQWFDLFdBQVdoTixJQUFJNE0sS0FBSztZQUNuQzVNLEtBQUt1TSxVQUFVdlIsSUFBSTRSLElBQUksSUFBSTtRQUM3QjtRQUVBLElBQUlLLFNBQVNOLHVCQUF1QjNSLEVBQUUsQ0FBQyxFQUFFLEVBQUVDLEVBQUUsQ0FBQyxFQUFFLEVBQUUrRSxFQUFFLENBQUMsRUFBRSxFQUFFNE0sRUFBRSxDQUFDLEVBQUU7UUFDOUQsSUFBSU0sU0FBU1AsdUJBQXVCM1IsRUFBRSxDQUFDLEVBQUUsRUFBRUMsRUFBRSxDQUFDLEVBQUUsRUFBRStFLEVBQUUsQ0FBQyxFQUFFLEVBQUU0TSxFQUFFLENBQUMsRUFBRTtRQUM5RCxJQUFJLENBQUM1NEIsQ0FBQyxHQUFHO1lBQUNpNUIsTUFBTSxDQUFDLEVBQUU7WUFBRUMsTUFBTSxDQUFDLEVBQUU7U0FBQztRQUMvQixJQUFJLENBQUMxL0IsQ0FBQyxHQUFHO1lBQUN5L0IsTUFBTSxDQUFDLEVBQUU7WUFBRUMsTUFBTSxDQUFDLEVBQUU7U0FBQztRQUMvQixJQUFJLENBQUMzNEIsQ0FBQyxHQUFHO1lBQUMwNEIsTUFBTSxDQUFDLEVBQUU7WUFBRUMsTUFBTSxDQUFDLEVBQUU7U0FBQztRQUMvQixJQUFJLENBQUNwL0IsQ0FBQyxHQUFHO1lBQUNtL0IsTUFBTSxDQUFDLEVBQUU7WUFBRUMsTUFBTSxDQUFDLEVBQUU7U0FBQztRQUMvQixJQUFJLENBQUMzakIsTUFBTSxHQUFHO1lBQUN5UjtZQUFJQztZQUFJK0U7WUFBSTRNO1NBQUc7SUFDaEM7SUFFQUUsaUJBQWlCMW5DLFNBQVMsQ0FBQ2tvQixLQUFLLEdBQUcsU0FBVTFmLENBQUM7UUFDNUMsT0FBTztZQUFFLEVBQUMsSUFBSSxDQUFDb0csQ0FBQyxDQUFDLEVBQUUsR0FBR3BHLElBQUksSUFBSSxDQUFDSixDQUFDLENBQUMsRUFBRSxJQUFJSSxJQUFJLElBQUksQ0FBQzJHLENBQUMsQ0FBQyxFQUFFLElBQUkzRyxJQUFJLElBQUksQ0FBQ0UsQ0FBQyxDQUFDLEVBQUU7WUFBRyxFQUFDLElBQUksQ0FBQ2tHLENBQUMsQ0FBQyxFQUFFLEdBQUdwRyxJQUFJLElBQUksQ0FBQ0osQ0FBQyxDQUFDLEVBQUUsSUFBSUksSUFBSSxJQUFJLENBQUMyRyxDQUFDLENBQUMsRUFBRSxJQUFJM0csSUFBSSxJQUFJLENBQUNFLENBQUMsQ0FBQyxFQUFFO1NBQUM7SUFDdkk7SUFFQWcvQixpQkFBaUIxbkMsU0FBUyxDQUFDK25DLFVBQVUsR0FBRyxTQUFVdi9CLENBQUM7UUFDakQsT0FBTztZQUFFLEtBQUlBLElBQUksSUFBSSxDQUFDb0csQ0FBQyxDQUFDLEVBQUUsR0FBRyxJQUFJLElBQUksQ0FBQ3hHLENBQUMsQ0FBQyxFQUFFLElBQUlJLElBQUksSUFBSSxDQUFDMkcsQ0FBQyxDQUFDLEVBQUU7WUFBRyxLQUFJM0csSUFBSSxJQUFJLENBQUNvRyxDQUFDLENBQUMsRUFBRSxHQUFHLElBQUksSUFBSSxDQUFDeEcsQ0FBQyxDQUFDLEVBQUUsSUFBSUksSUFBSSxJQUFJLENBQUMyRyxDQUFDLENBQUMsRUFBRTtTQUFDO0lBQ25IO0lBRUF1NEIsaUJBQWlCMW5DLFNBQVMsQ0FBQ2dvQyxZQUFZLEdBQUcsU0FBVXgvQixDQUFDO1FBQ25ELElBQUlGLElBQUksSUFBSSxDQUFDeS9CLFVBQVUsQ0FBQ3YvQjtRQUN4QixPQUFPdEUsS0FBS3FyQixLQUFLLENBQUNqbkIsQ0FBQyxDQUFDLEVBQUUsRUFBRUEsQ0FBQyxDQUFDLEVBQUU7SUFDOUI7SUFFQW8vQixpQkFBaUIxbkMsU0FBUyxDQUFDaW9DLFdBQVcsR0FBRyxTQUFVei9CLENBQUM7UUFDbEQsSUFBSUYsSUFBSSxJQUFJLENBQUN5L0IsVUFBVSxDQUFDdi9CO1FBQ3hCLE9BQU90RSxLQUFLcXJCLEtBQUssQ0FBQ2puQixDQUFDLENBQUMsRUFBRSxFQUFFQSxDQUFDLENBQUMsRUFBRTtJQUM5QjtJQUVBby9CLGlCQUFpQjFuQyxTQUFTLENBQUNrb0MsZ0JBQWdCLEdBQUc7UUFDNUMsSUFBSUMsUUFBUSxJQUFJLENBQUN2NUIsQ0FBQyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUN4RyxDQUFDLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQ3dHLENBQUMsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDeEcsQ0FBQyxDQUFDLEVBQUU7UUFDekQsSUFBSTYrQixVQUFVa0IsUUFBUSxPQUFPLEVBQUU7UUFDL0IsSUFBSUMsUUFBUSxDQUFDLE1BQU8sS0FBSSxDQUFDeDVCLENBQUMsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDTyxDQUFDLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQ1AsQ0FBQyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUNPLENBQUMsQ0FBQyxFQUFFLElBQUlnNUI7UUFDckUsSUFBSUUsU0FBU0QsUUFBUUEsUUFBUSxJQUFJLElBQUssS0FBSSxDQUFDaGdDLENBQUMsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDK0csQ0FBQyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMvRyxDQUFDLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQytHLENBQUMsQ0FBQyxFQUFFLElBQUlnNUI7UUFDdkYsSUFBSUUsU0FBUyxHQUFHLE9BQU8sRUFBRTtRQUN6QixJQUFJQyxPQUFPcGtDLEtBQUtHLElBQUksQ0FBQ2drQztRQUVyQixJQUFJcEIsVUFBVXFCLE9BQU87WUFDbkIsSUFBSUEsT0FBTyxLQUFLQSxPQUFPLEdBQUcsT0FBTztnQkFBQ0Y7YUFBTTtZQUN4QyxPQUFPLEVBQUU7UUFDWDtRQUVBLE9BQU87WUFBQ0EsUUFBUUU7WUFBTUYsUUFBUUU7U0FBSyxDQUFDQyxNQUFNLENBQUMsU0FBVXJnQyxDQUFDO1lBQ3BELE9BQU9BLElBQUksS0FBS0EsSUFBSTtRQUN0QjtJQUNGO0lBRUF3L0IsaUJBQWlCMW5DLFNBQVMsQ0FBQzhOLEtBQUssR0FBRyxTQUFVdEYsQ0FBQztRQUM1QyxJQUFJQSxLQUFLLEdBQUcsT0FBTztZQUFDaS9CLFlBQVksSUFBSSxDQUFDdGpCLE1BQU0sQ0FBQyxFQUFFO1lBQUcsSUFBSTtTQUFDO1FBQ3RELElBQUkzYixLQUFLLEdBQUcsT0FBTztZQUFDLElBQUk7WUFBRWkvQixZQUFZLElBQUksQ0FBQ3RqQixNQUFNLENBQUMsSUFBSSxDQUFDQSxNQUFNLENBQUNya0IsTUFBTSxHQUFHLEVBQUU7U0FBRTtRQUMzRSxJQUFJMG9DLE1BQU1yQixVQUFVLElBQUksQ0FBQ2hqQixNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQ0EsTUFBTSxDQUFDLEVBQUUsRUFBRTNiO1FBQ3BELElBQUlpZ0MsTUFBTXRCLFVBQVUsSUFBSSxDQUFDaGpCLE1BQU0sQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDQSxNQUFNLENBQUMsRUFBRSxFQUFFM2I7UUFDcEQsSUFBSTIwQixNQUFNZ0ssVUFBVSxJQUFJLENBQUNoakIsTUFBTSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUNBLE1BQU0sQ0FBQyxFQUFFLEVBQUUzYjtRQUNwRCxJQUFJa2dDLE1BQU12QixVQUFVcUIsS0FBS0MsS0FBS2pnQztRQUM5QixJQUFJbWdDLE1BQU14QixVQUFVc0IsS0FBS3RMLEtBQUszMEI7UUFDOUIsSUFBSWcvQixLQUFLTCxVQUFVdUIsS0FBS0MsS0FBS25nQztRQUM3QixPQUFPO1lBQUMsSUFBSWsvQixpQkFBaUIsSUFBSSxDQUFDdmpCLE1BQU0sQ0FBQyxFQUFFLEVBQUVxa0IsS0FBS0UsS0FBS2xCLElBQUk7WUFBTyxJQUFJRSxpQkFBaUJGLElBQUltQixLQUFLeEwsS0FBSyxJQUFJLENBQUNoWixNQUFNLENBQUMsRUFBRSxFQUFFO1NBQU07SUFDN0g7SUFFQSxTQUFTeWtCLFFBQVF2ZCxHQUFHLEVBQUVuZSxJQUFJO1FBQ3hCLElBQUl2SSxNQUFNMG1CLElBQUlsSCxNQUFNLENBQUMsRUFBRSxDQUFDalgsS0FBSztRQUM3QixJQUFJekksTUFBTTRtQixJQUFJbEgsTUFBTSxDQUFDa0gsSUFBSWxILE1BQU0sQ0FBQ3JrQixNQUFNLEdBQUcsRUFBRSxDQUFDb04sS0FBSztRQUVqRCxJQUFJdkksTUFBTUYsS0FBSztZQUNiLElBQUk4RyxJQUFJOUc7WUFDUkEsTUFBTUU7WUFDTkEsTUFBTTRHO1FBQ1IsRUFBRSxtQ0FBbUM7UUFHckMsSUFBSWxELElBQUkrK0IsVUFBVSxJQUFJL2IsSUFBSXpjLENBQUMsQ0FBQzFCLEtBQUssRUFBRSxJQUFJbWUsSUFBSWpqQixDQUFDLENBQUM4RSxLQUFLLEVBQUVtZSxJQUFJbGMsQ0FBQyxDQUFDakMsS0FBSztRQUUvRCxJQUFLLElBQUl0TixJQUFJLEdBQUdBLElBQUl5SSxFQUFFdkksTUFBTSxFQUFFRixLQUFLLEVBQUc7WUFDcEMsSUFBSXlJLENBQUMsQ0FBQ3pJLEVBQUUsR0FBRyxLQUFLeUksQ0FBQyxDQUFDekksRUFBRSxHQUFHLEdBQUc7Z0JBQ3hCLElBQUlxRixNQUFNb21CLElBQUluRCxLQUFLLENBQUM3ZixDQUFDLENBQUN6SSxFQUFFLENBQUMsQ0FBQ3NOLEtBQUs7Z0JBQy9CLElBQUlqSSxNQUFNTixLQUFLQSxNQUFNTTtxQkFBUyxJQUFJQSxNQUFNUixLQUFLQSxNQUFNUTtZQUNyRDtRQUNGO1FBRUEsT0FBTztZQUNMTixLQUFLQTtZQUNMRixLQUFLQTtRQUNQO0lBQ0Y7SUFFQWlqQyxpQkFBaUIxbkMsU0FBUyxDQUFDNm9DLE1BQU0sR0FBRztRQUNsQyxPQUFPO1lBQ0xya0IsR0FBR29rQixRQUFRLElBQUksRUFBRTtZQUNqQjliLEdBQUc4YixRQUFRLElBQUksRUFBRTtRQUNuQjtJQUNGO0lBRUFsQixpQkFBaUIxbkMsU0FBUyxDQUFDOG9DLFdBQVcsR0FBRztRQUN2QyxJQUFJRCxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUN4QixPQUFPO1lBQ0w3aUMsTUFBTTZpQyxPQUFPcmtCLENBQUMsQ0FBQzdmLEdBQUc7WUFDbEJva0MsT0FBT0YsT0FBT3JrQixDQUFDLENBQUMvZixHQUFHO1lBQ25Cc0IsS0FBSzhpQyxPQUFPL2IsQ0FBQyxDQUFDbm9CLEdBQUc7WUFDakJxa0MsUUFBUUgsT0FBTy9iLENBQUMsQ0FBQ3JvQixHQUFHO1lBQ3BCMk4sT0FBT3kyQixPQUFPcmtCLENBQUMsQ0FBQy9mLEdBQUcsR0FBR29rQyxPQUFPcmtCLENBQUMsQ0FBQzdmLEdBQUc7WUFDbEMwTixRQUFRdzJCLE9BQU8vYixDQUFDLENBQUNyb0IsR0FBRyxHQUFHb2tDLE9BQU8vYixDQUFDLENBQUNub0IsR0FBRztZQUNuQ3NrQyxJQUFJLENBQUNKLE9BQU9ya0IsQ0FBQyxDQUFDL2YsR0FBRyxHQUFHb2tDLE9BQU9ya0IsQ0FBQyxDQUFDN2YsR0FBRyxJQUFJO1lBQ3BDdWtDLElBQUksQ0FBQ0wsT0FBTy9iLENBQUMsQ0FBQ3JvQixHQUFHLEdBQUdva0MsT0FBTy9iLENBQUMsQ0FBQ25vQixHQUFHLElBQUk7UUFDdEM7SUFDRjtJQUVBLFNBQVN3a0MsY0FBYzlkLEdBQUcsRUFBRTFCLEVBQUUsRUFBRXlmLEVBQUU7UUFDaEMsSUFBSXoxQixNQUFNMFgsSUFBSXlkLFdBQVc7UUFDekIsT0FBTztZQUNMRyxJQUFJdDFCLElBQUlzMUIsRUFBRTtZQUNWQyxJQUFJdjFCLElBQUl1MUIsRUFBRTtZQUNWOTJCLE9BQU91QixJQUFJdkIsS0FBSztZQUNoQkMsUUFBUXNCLElBQUl0QixNQUFNO1lBQ2xCZ1osS0FBS0E7WUFDTDdpQixHQUFHLENBQUNtaEIsS0FBS3lmLEVBQUMsSUFBSztZQUNmemYsSUFBSUE7WUFDSnlmLElBQUlBO1FBQ047SUFDRjtJQUVBLFNBQVNDLFVBQVUxK0IsSUFBSTtRQUNyQixJQUFJbUQsUUFBUW5ELEtBQUswZ0IsR0FBRyxDQUFDdmQsS0FBSyxDQUFDO1FBQzNCLE9BQU87WUFBQ3E3QixjQUFjcjdCLEtBQUssQ0FBQyxFQUFFLEVBQUVuRCxLQUFLZ2YsRUFBRSxFQUFFaGYsS0FBS25DLENBQUM7WUFBRzJnQyxjQUFjcjdCLEtBQUssQ0FBQyxFQUFFLEVBQUVuRCxLQUFLbkMsQ0FBQyxFQUFFbUMsS0FBS3krQixFQUFFO1NBQUU7SUFDN0Y7SUFFQSxTQUFTRSxhQUFhdk8sRUFBRSxFQUFFaEIsRUFBRTtRQUMxQixPQUFPNzFCLEtBQUtjLEdBQUcsQ0FBQysxQixHQUFHa08sRUFBRSxHQUFHbFAsR0FBR2tQLEVBQUUsSUFBSSxJQUFJbE8sR0FBRzNvQixLQUFLLEdBQUcybkIsR0FBRzNuQixLQUFLLElBQUlsTyxLQUFLYyxHQUFHLENBQUMrMUIsR0FBR21PLEVBQUUsR0FBR25QLEdBQUdtUCxFQUFFLElBQUksSUFBSW5PLEdBQUcxb0IsTUFBTSxHQUFHMG5CLEdBQUcxbkIsTUFBTTtJQUNqSDtJQUVBLFNBQVNrM0IsZUFBZXZPLEVBQUUsRUFBRWhCLEVBQUUsRUFBRXdQLEtBQUssRUFBRUMsU0FBUyxFQUFFQyxhQUFhLEVBQUVDLFlBQVk7UUFDM0UsSUFBSSxDQUFDTCxhQUFhdE8sSUFBSWhCLEtBQUs7UUFFM0IsSUFBSXdQLFNBQVNHLGdCQUFnQjNPLEdBQUc1b0IsS0FBSyxJQUFJcTNCLGFBQWF6TyxHQUFHM29CLE1BQU0sSUFBSW8zQixhQUFhelAsR0FBRzVuQixLQUFLLElBQUlxM0IsYUFBYXpQLEdBQUczbkIsTUFBTSxJQUFJbzNCLFdBQVc7WUFDL0hDLGNBQWN2b0MsSUFBSSxDQUFDO2dCQUFDNjVCLEdBQUd4eUIsQ0FBQztnQkFBRXd4QixHQUFHeHhCLENBQUM7YUFBQztZQUMvQjtRQUNGO1FBRUEsSUFBSW9oQyxNQUFNUCxVQUFVck87UUFDcEIsSUFBSTZPLE1BQU1SLFVBQVVyUDtRQUNwQnVQLGVBQWVLLEdBQUcsQ0FBQyxFQUFFLEVBQUVDLEdBQUcsQ0FBQyxFQUFFLEVBQUVMLFFBQVEsR0FBR0MsV0FBV0MsZUFBZUM7UUFDcEVKLGVBQWVLLEdBQUcsQ0FBQyxFQUFFLEVBQUVDLEdBQUcsQ0FBQyxFQUFFLEVBQUVMLFFBQVEsR0FBR0MsV0FBV0MsZUFBZUM7UUFDcEVKLGVBQWVLLEdBQUcsQ0FBQyxFQUFFLEVBQUVDLEdBQUcsQ0FBQyxFQUFFLEVBQUVMLFFBQVEsR0FBR0MsV0FBV0MsZUFBZUM7UUFDcEVKLGVBQWVLLEdBQUcsQ0FBQyxFQUFFLEVBQUVDLEdBQUcsQ0FBQyxFQUFFLEVBQUVMLFFBQVEsR0FBR0MsV0FBV0MsZUFBZUM7SUFDdEU7SUFFQWpDLGlCQUFpQjFuQyxTQUFTLENBQUMwcEMsYUFBYSxHQUFHLFNBQVVJLEtBQUssRUFBRUwsU0FBUyxFQUFFRSxZQUFZO1FBQ2pGLElBQUlGLGNBQWNqdkIsV0FBV2l2QixZQUFZO1FBQ3pDLElBQUlFLGlCQUFpQm52QixXQUFXbXZCLGVBQWU7UUFDL0MsSUFBSUQsZ0JBQWdCLEVBQUU7UUFDdEJILGVBQWVKLGNBQWMsSUFBSSxFQUFFLEdBQUcsSUFBSUEsY0FBY1csT0FBTyxHQUFHLElBQUksR0FBR0wsV0FBV0MsZUFBZUM7UUFDbkcsT0FBT0Q7SUFDVDtJQUVBaEMsaUJBQWlCNUYsWUFBWSxHQUFHLFNBQVVqTyxTQUFTLEVBQUUvVCxLQUFLO1FBQ3hELElBQUlpcUIsWUFBWSxDQUFDanFCLFFBQVEsS0FBSytULFVBQVUvekIsTUFBTTtRQUM5QyxPQUFPLElBQUk0bkMsaUJBQWlCN1QsVUFBVTVyQixDQUFDLENBQUM2WCxNQUFNLEVBQUUrVCxVQUFVcG1CLENBQUMsQ0FBQ3FTLE1BQU0sRUFBRStULFVBQVVqMEIsQ0FBQyxDQUFDbXFDLFVBQVUsRUFBRWxXLFVBQVU1ckIsQ0FBQyxDQUFDOGhDLFVBQVUsRUFBRTtJQUN0SDtJQUVBckMsaUJBQWlCc0Msb0JBQW9CLEdBQUcsU0FBVW5XLFNBQVMsRUFBRS9ULEtBQUs7UUFDaEUsSUFBSWlxQixZQUFZLENBQUNqcUIsUUFBUSxLQUFLK1QsVUFBVS96QixNQUFNO1FBQzlDLE9BQU8sSUFBSTRuQyxpQkFBaUI3VCxVQUFVNXJCLENBQUMsQ0FBQzhoQyxVQUFVLEVBQUVsVyxVQUFVajBCLENBQUMsQ0FBQ21xQyxVQUFVLEVBQUVsVyxVQUFVcG1CLENBQUMsQ0FBQ3FTLE1BQU0sRUFBRStULFVBQVU1ckIsQ0FBQyxDQUFDNlgsTUFBTSxFQUFFO0lBQ3RIO0lBRUEsU0FBU21xQixhQUFhcjdCLENBQUMsRUFBRXhHLENBQUM7UUFDeEIsT0FBTztZQUFDd0csQ0FBQyxDQUFDLEVBQUUsR0FBR3hHLENBQUMsQ0FBQyxFQUFFLEdBQUd3RyxDQUFDLENBQUMsRUFBRSxHQUFHeEcsQ0FBQyxDQUFDLEVBQUU7WUFBRXdHLENBQUMsQ0FBQyxFQUFFLEdBQUd4RyxDQUFDLENBQUMsRUFBRSxHQUFHd0csQ0FBQyxDQUFDLEVBQUUsR0FBR3hHLENBQUMsQ0FBQyxFQUFFO1lBQUV3RyxDQUFDLENBQUMsRUFBRSxHQUFHeEcsQ0FBQyxDQUFDLEVBQUUsR0FBR3dHLENBQUMsQ0FBQyxFQUFFLEdBQUd4RyxDQUFDLENBQUMsRUFBRTtTQUFDO0lBQzFGO0lBRUEsU0FBUzhoQyxpQkFBaUJDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLElBQUk7UUFDbEQsSUFBSXhTLEtBQUs7WUFBQ3FTLE1BQU0sQ0FBQyxFQUFFO1lBQUVBLE1BQU0sQ0FBQyxFQUFFO1lBQUU7U0FBRTtRQUNsQyxJQUFJNUcsS0FBSztZQUFDNkcsSUFBSSxDQUFDLEVBQUU7WUFBRUEsSUFBSSxDQUFDLEVBQUU7WUFBRTtTQUFFO1FBQzlCLElBQUlHLEtBQUs7WUFBQ0YsTUFBTSxDQUFDLEVBQUU7WUFBRUEsTUFBTSxDQUFDLEVBQUU7WUFBRTtTQUFFO1FBQ2xDLElBQUlHLEtBQUs7WUFBQ0YsSUFBSSxDQUFDLEVBQUU7WUFBRUEsSUFBSSxDQUFDLEVBQUU7WUFBRTtTQUFFO1FBQzlCLElBQUlwaUMsSUFBSStoQyxhQUFhQSxhQUFhblMsSUFBSXlMLEtBQUswRyxhQUFhTSxJQUFJQztRQUM1RCxJQUFJdkQsVUFBVS8rQixDQUFDLENBQUMsRUFBRSxHQUFHLE9BQU87UUFDNUIsT0FBTztZQUFDQSxDQUFDLENBQUMsRUFBRSxHQUFHQSxDQUFDLENBQUMsRUFBRTtZQUFFQSxDQUFDLENBQUMsRUFBRSxHQUFHQSxDQUFDLENBQUMsRUFBRTtTQUFDO0lBQ25DO0lBRUEsU0FBU3VpQyxZQUFZbmlDLENBQUMsRUFBRXN1QixLQUFLLEVBQUU5MkIsTUFBTTtRQUNuQyxPQUFPO1lBQUN3SSxDQUFDLENBQUMsRUFBRSxHQUFHcEUsS0FBSzJyQixHQUFHLENBQUMrRyxTQUFTOTJCO1lBQVF3SSxDQUFDLENBQUMsRUFBRSxHQUFHcEUsS0FBSzhxQixHQUFHLENBQUM0SCxTQUFTOTJCO1NBQU87SUFDM0U7SUFFQSxTQUFTNHFDLGNBQWM3VSxFQUFFLEVBQUUrRSxFQUFFO1FBQzNCLE9BQU8xMkIsS0FBS3ltQyxLQUFLLENBQUM5VSxFQUFFLENBQUMsRUFBRSxHQUFHK0UsRUFBRSxDQUFDLEVBQUUsRUFBRS9FLEVBQUUsQ0FBQyxFQUFFLEdBQUcrRSxFQUFFLENBQUMsRUFBRTtJQUNoRDtJQUVBLFNBQVNnTixXQUFXL1IsRUFBRSxFQUFFK0UsRUFBRTtRQUN4QixPQUFPb00sV0FBV25SLEVBQUUsQ0FBQyxFQUFFLEVBQUUrRSxFQUFFLENBQUMsRUFBRSxLQUFLb00sV0FBV25SLEVBQUUsQ0FBQyxFQUFFLEVBQUUrRSxFQUFFLENBQUMsRUFBRTtJQUM1RDtJQUVBLFNBQVNnUSxrQkFBa0I7SUFFM0JuckMsZ0JBQWdCO1FBQUNxZ0M7S0FBYyxFQUFFOEs7SUFFakNBLGVBQWU1cUMsU0FBUyxDQUFDKy9CLHNCQUFzQixHQUFHLFNBQVVwZixJQUFJLEVBQUVoVyxJQUFJO1FBQ3BFLElBQUksQ0FBQyttQixRQUFRLEdBQUcsSUFBSSxDQUFDd08sV0FBVztRQUNoQyxJQUFJLENBQUMySyxTQUFTLEdBQUc5WSxnQkFBZ0JDLE9BQU8sQ0FBQ3JSLE1BQU1oVyxLQUFLM0MsQ0FBQyxFQUFFLEdBQUcsTUFBTSxJQUFJO1FBQ3BFLElBQUksQ0FBQzhpQyxTQUFTLEdBQUcvWSxnQkFBZ0JDLE9BQU8sQ0FBQ3JSLE1BQU1oVyxLQUFLekMsQ0FBQyxFQUFFLEdBQUcsTUFBTSxJQUFJO1FBQ3BFLElBQUksQ0FBQzZpQyxVQUFVLEdBQUdoWixnQkFBZ0JDLE9BQU8sQ0FBQ3JSLE1BQU1oVyxLQUFLMEIsRUFBRSxFQUFFLEdBQUcsTUFBTSxJQUFJO1FBQ3RFLElBQUksQ0FBQ2dtQixXQUFXLEdBQUcsSUFBSSxDQUFDd1ksU0FBUyxDQUFDN1osZUFBZSxDQUFDbHhCLE1BQU0sS0FBSyxLQUFLLElBQUksQ0FBQ2dyQyxTQUFTLENBQUM5WixlQUFlLENBQUNseEIsTUFBTSxLQUFLLEtBQUssSUFBSSxDQUFDaXJDLFVBQVUsQ0FBQy9aLGVBQWUsQ0FBQ2x4QixNQUFNLEtBQUs7SUFDOUo7SUFFQSxTQUFTa3JDLFNBQVNDLFlBQVksRUFBRS9pQixLQUFLLEVBQUUwTyxLQUFLLEVBQUUvdkIsU0FBUyxFQUFFZ2tDLFNBQVMsRUFBRUssWUFBWSxFQUFFQyxXQUFXO1FBQzNGLElBQUlDLE9BQU94VSxRQUFRMXlCLEtBQUtvQixFQUFFLEdBQUc7UUFDN0IsSUFBSStsQyxPQUFPelUsUUFBUTF5QixLQUFLb0IsRUFBRSxHQUFHO1FBQzdCLElBQUl3OUIsS0FBSzVhLEtBQUssQ0FBQyxFQUFFLEdBQUdoa0IsS0FBSzJyQixHQUFHLENBQUMrRyxTQUFTL3ZCLFlBQVlna0M7UUFDbEQsSUFBSTlILEtBQUs3YSxLQUFLLENBQUMsRUFBRSxHQUFHaGtCLEtBQUs4cUIsR0FBRyxDQUFDNEgsU0FBUy92QixZQUFZZ2tDO1FBQ2xESSxhQUFhbFksV0FBVyxDQUFDK1AsSUFBSUMsSUFBSUQsS0FBSzUrQixLQUFLMnJCLEdBQUcsQ0FBQ3ViLFFBQVFGLGNBQWNuSSxLQUFLNytCLEtBQUs4cUIsR0FBRyxDQUFDb2MsUUFBUUYsY0FBY3BJLEtBQUs1K0IsS0FBSzJyQixHQUFHLENBQUN3YixRQUFRRixhQUFhcEksS0FBSzcrQixLQUFLOHFCLEdBQUcsQ0FBQ3FjLFFBQVFGLGFBQWFGLGFBQWFuckMsTUFBTTtJQUNwTTtJQUVBLFNBQVN3ckMsdUJBQXVCNWpCLEdBQUcsRUFBRUMsR0FBRztRQUN0QyxJQUFJNGpCLFNBQVM7WUFBQzVqQixHQUFHLENBQUMsRUFBRSxHQUFHRCxHQUFHLENBQUMsRUFBRTtZQUFFQyxHQUFHLENBQUMsRUFBRSxHQUFHRCxHQUFHLENBQUMsRUFBRTtTQUFDO1FBQy9DLElBQUk4akIsTUFBTSxDQUFDdG5DLEtBQUtvQixFQUFFLEdBQUc7UUFDckIsSUFBSW1tQyxnQkFBZ0I7WUFBQ3ZuQyxLQUFLMnJCLEdBQUcsQ0FBQzJiLE9BQU9ELE1BQU0sQ0FBQyxFQUFFLEdBQUdybkMsS0FBSzhxQixHQUFHLENBQUN3YyxPQUFPRCxNQUFNLENBQUMsRUFBRTtZQUFFcm5DLEtBQUs4cUIsR0FBRyxDQUFDd2MsT0FBT0QsTUFBTSxDQUFDLEVBQUUsR0FBR3JuQyxLQUFLMnJCLEdBQUcsQ0FBQzJiLE9BQU9ELE1BQU0sQ0FBQyxFQUFFO1NBQUM7UUFDbEksT0FBT0U7SUFDVDtJQUVBLFNBQVNDLG1CQUFtQmhoQyxJQUFJLEVBQUVpaEMsR0FBRztRQUNuQyxJQUFJQyxZQUFZRCxRQUFRLElBQUlqaEMsS0FBSzVLLE1BQU0sS0FBSyxJQUFJNnJDLE1BQU07UUFDdEQsSUFBSTVCLFlBQVksQ0FBQzRCLE1BQU0sS0FBS2poQyxLQUFLNUssTUFBTTtRQUN2QyxJQUFJK3JDLFlBQVluaEMsS0FBS3pDLENBQUMsQ0FBQzJqQyxVQUFVO1FBQ2pDLElBQUlFLFlBQVlwaEMsS0FBS3pDLENBQUMsQ0FBQzhoQyxVQUFVO1FBQ2pDLElBQUlnQyxVQUFVVCx1QkFBdUJPLFdBQVdDO1FBQ2hELE9BQU81bkMsS0FBS3FyQixLQUFLLENBQUMsR0FBRyxLQUFLcnJCLEtBQUtxckIsS0FBSyxDQUFDd2MsT0FBTyxDQUFDLEVBQUUsRUFBRUEsT0FBTyxDQUFDLEVBQUU7SUFDN0Q7SUFFQSxTQUFTQyxhQUFhZixZQUFZLEVBQUV2Z0MsSUFBSSxFQUFFaWhDLEdBQUcsRUFBRWQsU0FBUyxFQUFFQyxTQUFTLEVBQUVtQixTQUFTLEVBQUVwbEMsU0FBUztRQUN2RixJQUFJK3ZCLFFBQVE4VSxtQkFBbUJoaEMsTUFBTWloQztRQUNyQyxJQUFJempCLFFBQVF4ZCxLQUFLekMsQ0FBQyxDQUFDMGpDLE1BQU1qaEMsS0FBS2liLE9BQU8sQ0FBQztRQUN0QyxJQUFJa21CLFlBQVluaEMsS0FBS3pDLENBQUMsQ0FBQzBqQyxRQUFRLElBQUlqaEMsS0FBS2liLE9BQU8sR0FBRyxJQUFJZ21CLE1BQU0sRUFBRTtRQUM5RCxJQUFJRyxZQUFZcGhDLEtBQUt6QyxDQUFDLENBQUMsQ0FBQzBqQyxNQUFNLEtBQUtqaEMsS0FBS2liLE9BQU8sQ0FBQztRQUNoRCxJQUFJdW1CLFdBQVdELGNBQWMsSUFBSS9uQyxLQUFLRyxJQUFJLENBQUNILEtBQUtDLEdBQUcsQ0FBQytqQixLQUFLLENBQUMsRUFBRSxHQUFHMmpCLFNBQVMsQ0FBQyxFQUFFLEVBQUUsS0FBSzNuQyxLQUFLQyxHQUFHLENBQUMrakIsS0FBSyxDQUFDLEVBQUUsR0FBRzJqQixTQUFTLENBQUMsRUFBRSxFQUFFLE1BQU07UUFDMUgsSUFBSU0sV0FBV0YsY0FBYyxJQUFJL25DLEtBQUtHLElBQUksQ0FBQ0gsS0FBS0MsR0FBRyxDQUFDK2pCLEtBQUssQ0FBQyxFQUFFLEdBQUc0akIsU0FBUyxDQUFDLEVBQUUsRUFBRSxLQUFLNW5DLEtBQUtDLEdBQUcsQ0FBQytqQixLQUFLLENBQUMsRUFBRSxHQUFHNGpCLFNBQVMsQ0FBQyxFQUFFLEVBQUUsTUFBTTtRQUMxSGQsU0FBU0MsY0FBY3ZnQyxLQUFLekMsQ0FBQyxDQUFDMGpDLE1BQU1qaEMsS0FBS2liLE9BQU8sQ0FBQyxFQUFFaVIsT0FBTy92QixXQUFXZ2tDLFdBQVdzQixXQUFZLEVBQUNyQixZQUFZLEtBQUssSUFBSW9CLFdBQVksRUFBQ3BCLFlBQVksS0FBSyxJQUFJbUI7SUFDdEo7SUFFQSxTQUFTRyxjQUFjbkIsWUFBWSxFQUFFbnZCLE9BQU8sRUFBRSt1QixTQUFTLEVBQUVDLFNBQVMsRUFBRW1CLFNBQVMsRUFBRXBsQyxTQUFTO1FBQ3RGLElBQUssSUFBSWpILElBQUksR0FBR0EsSUFBSWtyQyxXQUFXbHJDLEtBQUssRUFBRztZQUNyQyxJQUFJNEksSUFBSSxDQUFDNUksSUFBSSxLQUFNa3JDLENBQUFBLFlBQVk7WUFDL0IsSUFBSTVsQixPQUFPK21CLGNBQWMsSUFBSS9uQyxLQUFLRyxJQUFJLENBQUNILEtBQUtDLEdBQUcsQ0FBQzJYLFFBQVFxSSxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR3JJLFFBQVFxSSxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxLQUFLamdCLEtBQUtDLEdBQUcsQ0FBQzJYLFFBQVFxSSxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR3JJLFFBQVFxSSxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxNQUFNO1lBQzlKLElBQUl5UyxRQUFROWEsUUFBUW1zQixXQUFXLENBQUN6L0I7WUFDaEMsSUFBSTBmLFFBQVFwTSxRQUFRb00sS0FBSyxDQUFDMWY7WUFDMUJ3aUMsU0FBU0MsY0FBYy9pQixPQUFPME8sT0FBTy92QixXQUFXZ2tDLFdBQVczbEIsT0FBUSxFQUFDNGxCLFlBQVksS0FBSyxJQUFJNWxCLE9BQVEsRUFBQzRsQixZQUFZLEtBQUssSUFBSW1CO1lBQ3ZIcGxDLFlBQVksQ0FBQ0E7UUFDZjtRQUVBLE9BQU9BO0lBQ1Q7SUFFQStqQyxlQUFlNXFDLFNBQVMsQ0FBQ21pQyxXQUFXLEdBQUcsU0FBVXozQixJQUFJLEVBQUVtZ0MsU0FBUyxFQUFFQyxTQUFTLEVBQUVtQixTQUFTO1FBQ3BGLElBQUlJLFFBQVEzaEMsS0FBS2liLE9BQU87UUFDeEIsSUFBSTJjLGFBQWExTyxVQUFVOU4sVUFBVTtRQUNyQ3djLFdBQVduekIsQ0FBQyxHQUFHekUsS0FBS3lFLENBQUM7UUFFckIsSUFBSSxDQUFDekUsS0FBS3lFLENBQUMsRUFBRTtZQUNYazlCLFNBQVM7UUFDWDtRQUVBLElBQUlBLFVBQVUsR0FBRyxPQUFPL0o7UUFDeEIsSUFBSXo3QixZQUFZLENBQUM7UUFDakIsSUFBSWlWLFVBQVU0ckIsaUJBQWlCNUYsWUFBWSxDQUFDcDNCLE1BQU07UUFDbERzaEMsYUFBYTFKLFlBQVk1M0IsTUFBTSxHQUFHbWdDLFdBQVdDLFdBQVdtQixXQUFXcGxDO1FBRW5FLElBQUssSUFBSWpILElBQUksR0FBR0EsSUFBSXlzQyxPQUFPenNDLEtBQUssRUFBRztZQUNqQ2lILFlBQVl1bEMsY0FBYzlKLFlBQVl4bUIsU0FBUyt1QixXQUFXQyxXQUFXbUIsV0FBVyxDQUFDcGxDO1lBRWpGLElBQUlqSCxNQUFNeXNDLFFBQVEsS0FBSyxDQUFDM2hDLEtBQUt5RSxDQUFDLEVBQUU7Z0JBQzlCMk0sVUFBVTtZQUNaLE9BQU87Z0JBQ0xBLFVBQVU0ckIsaUJBQWlCNUYsWUFBWSxDQUFDcDNCLE1BQU0sQ0FBQzlLLElBQUksS0FBS3lzQztZQUMxRDtZQUVBTCxhQUFhMUosWUFBWTUzQixNQUFNOUssSUFBSSxHQUFHaXJDLFdBQVdDLFdBQVdtQixXQUFXcGxDO1FBQ3pFO1FBRUEsT0FBT3k3QjtJQUNUO0lBRUFzSSxlQUFlNXFDLFNBQVMsQ0FBQytnQyxhQUFhLEdBQUcsU0FBVTdQLGFBQWE7UUFDOUQsSUFBSStQO1FBQ0osSUFBSXJoQztRQUNKLElBQUlDLE1BQU0sSUFBSSxDQUFDOE0sTUFBTSxDQUFDN00sTUFBTTtRQUM1QixJQUFJK0w7UUFDSixJQUFJQztRQUNKLElBQUkrK0IsWUFBWSxJQUFJLENBQUNBLFNBQVMsQ0FBQzVpQyxDQUFDO1FBQ2hDLElBQUk2aUMsWUFBWTVtQyxLQUFLTyxHQUFHLENBQUMsR0FBR1AsS0FBS3dCLEtBQUssQ0FBQyxJQUFJLENBQUNvbEMsU0FBUyxDQUFDN2lDLENBQUM7UUFDdkQsSUFBSWdrQyxZQUFZLElBQUksQ0FBQ2xCLFVBQVUsQ0FBQzlpQyxDQUFDO1FBRWpDLElBQUk0aUMsY0FBYyxHQUFHO1lBQ25CLElBQUl2aUI7WUFDSixJQUFJMk07WUFFSixJQUFLcjFCLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO2dCQUMzQjBvQixZQUFZLElBQUksQ0FBQzNiLE1BQU0sQ0FBQy9NLEVBQUU7Z0JBQzFCcTFCLHVCQUF1QjNNLFVBQVUyTSxvQkFBb0I7Z0JBRXJELElBQUksQ0FBRSxFQUFDM00sVUFBVXlMLEtBQUssQ0FBQ2xELElBQUksSUFBSSxDQUFDLElBQUksQ0FBQ0EsSUFBSSxJQUFJLENBQUNLLGFBQVksR0FBSTtvQkFDNUQrRCxxQkFBcUJkLGFBQWE7b0JBQ2xDN0wsVUFBVXlMLEtBQUssQ0FBQ2xELElBQUksR0FBRztvQkFDdkJvUSxhQUFhM1ksVUFBVXlMLEtBQUssQ0FBQ2lCLEtBQUssQ0FBQ3JvQixNQUFNO29CQUN6Q2IsT0FBT3djLFVBQVV5TCxLQUFLLENBQUNpQixLQUFLLENBQUNyUCxPQUFPO29CQUVwQyxJQUFLOVosSUFBSSxHQUFHQSxJQUFJQyxNQUFNRCxLQUFLLEVBQUc7d0JBQzVCb3BCLHFCQUFxQmYsUUFBUSxDQUFDLElBQUksQ0FBQ2lPLFdBQVcsQ0FBQ2xCLFVBQVUsQ0FBQ3AxQixFQUFFLEVBQUVnL0IsV0FBV0MsV0FBV21CO29CQUN0RjtnQkFDRjtnQkFFQTNqQixVQUFVeUwsS0FBSyxDQUFDaUIsS0FBSyxHQUFHMU0sVUFBVTJNLG9CQUFvQjtZQUN4RDtRQUNGO1FBRUEsSUFBSSxDQUFDLElBQUksQ0FBQzdDLGlCQUFpQixDQUFDdHlCLE1BQU0sRUFBRTtZQUNsQyxJQUFJLENBQUMrd0IsSUFBSSxHQUFHO1FBQ2Q7SUFDRjtJQUVBLFNBQVN5YixhQUFhelcsRUFBRSxFQUFFK0UsRUFBRSxFQUFFc0gsTUFBTTtRQUNsQyxJQUFJdEwsUUFBUTF5QixLQUFLcXJCLEtBQUssQ0FBQ3FMLEVBQUUsQ0FBQyxFQUFFLEdBQUcvRSxFQUFFLENBQUMsRUFBRSxFQUFFK0UsRUFBRSxDQUFDLEVBQUUsR0FBRy9FLEVBQUUsQ0FBQyxFQUFFO1FBQ25ELE9BQU87WUFBQzRVLFlBQVk1VSxJQUFJZSxPQUFPc0w7WUFBU3VJLFlBQVk3UCxJQUFJaEUsT0FBT3NMO1NBQVE7SUFDekU7SUFFQSxTQUFTcUssY0FBY3p3QixPQUFPLEVBQUVvbUIsTUFBTTtRQUNwQyxJQUFJdE07UUFDSixJQUFJNFc7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJbkY7UUFDSixJQUFJajhCO1FBQ0pBLElBQUkrZ0MsYUFBYXh3QixRQUFRcUksTUFBTSxDQUFDLEVBQUUsRUFBRXJJLFFBQVFxSSxNQUFNLENBQUMsRUFBRSxFQUFFK2Q7UUFDdkR0TSxLQUFLcnFCLENBQUMsQ0FBQyxFQUFFO1FBQ1RpaEMsTUFBTWpoQyxDQUFDLENBQUMsRUFBRTtRQUNWQSxJQUFJK2dDLGFBQWF4d0IsUUFBUXFJLE1BQU0sQ0FBQyxFQUFFLEVBQUVySSxRQUFRcUksTUFBTSxDQUFDLEVBQUUsRUFBRStkO1FBQ3ZEdUssTUFBTWxoQyxDQUFDLENBQUMsRUFBRTtRQUNWbWhDLE1BQU1uaEMsQ0FBQyxDQUFDLEVBQUU7UUFDVkEsSUFBSStnQyxhQUFheHdCLFFBQVFxSSxNQUFNLENBQUMsRUFBRSxFQUFFckksUUFBUXFJLE1BQU0sQ0FBQyxFQUFFLEVBQUUrZDtRQUN2RHlLLE1BQU1waEMsQ0FBQyxDQUFDLEVBQUU7UUFDVmk4QixLQUFLajhCLENBQUMsQ0FBQyxFQUFFO1FBQ1QsSUFBSXNxQixLQUFLcVUsaUJBQWlCdFUsSUFBSTRXLEtBQUtDLEtBQUtDO1FBQ3hDLElBQUk3VyxPQUFPLE1BQU1BLEtBQUsyVztRQUN0QixJQUFJNVIsS0FBS3NQLGlCQUFpQnlDLEtBQUtuRixJQUFJaUYsS0FBS0M7UUFDeEMsSUFBSTlSLE9BQU8sTUFBTUEsS0FBSytSO1FBQ3RCLE9BQU8sSUFBSWpGLGlCQUFpQjlSLElBQUlDLElBQUkrRSxJQUFJNE07SUFDMUM7SUFFQSxTQUFTb0YsVUFBVTNCLFlBQVksRUFBRTRCLElBQUksRUFBRUMsSUFBSSxFQUFFQyxRQUFRLEVBQUVDLFVBQVU7UUFDL0QsSUFBSXBYLEtBQUtpWCxLQUFLMW9CLE1BQU0sQ0FBQyxFQUFFO1FBQ3ZCLElBQUkwUixLQUFLaVgsS0FBSzNvQixNQUFNLENBQUMsRUFBRSxFQUFFLFFBQVE7UUFFakMsSUFBSTRvQixhQUFhLEdBQUcsT0FBT25YLElBQUkscUNBQXFDO1FBRXBFLElBQUlnUyxXQUFXaFMsSUFBSUMsS0FBSyxPQUFPRCxJQUFJLFFBQVE7UUFFM0MsSUFBSW1YLGFBQWEsR0FBRztZQUNsQixJQUFJRSxXQUFXLENBQUNKLEtBQUs3RSxZQUFZLENBQUM7WUFDbEMsSUFBSWtGLFVBQVUsQ0FBQ0osS0FBSzlFLFlBQVksQ0FBQyxLQUFLOWpDLEtBQUtvQixFQUFFO1lBQzdDLElBQUk2bkMsU0FBU2pELGlCQUFpQnRVLElBQUk2VSxZQUFZN1UsSUFBSXFYLFdBQVcvb0MsS0FBS29CLEVBQUUsR0FBRyxHQUFHLE1BQU11d0IsSUFBSTRVLFlBQVk1VSxJQUFJb1gsV0FBVy9vQyxLQUFLb0IsRUFBRSxHQUFHLEdBQUc7WUFDNUgsSUFBSThuQyxTQUFTRCxTQUFTekMsY0FBY3lDLFFBQVF2WCxNQUFNOFUsY0FBYzlVLElBQUlDLE1BQU07WUFDMUUsSUFBSTBDLE1BQU1rUyxZQUFZN1UsSUFBSXFYLFVBQVUsSUFBSUcsU0FBUzduQztZQUNqRDBsQyxhQUFhcFksT0FBTyxDQUFDMEYsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUUsRUFBRSxLQUFLMFMsYUFBYW5yQyxNQUFNLEtBQUs7WUFDbEV5NEIsTUFBTWtTLFlBQVk1VSxJQUFJcVgsU0FBUyxJQUFJRSxTQUFTN25DO1lBQzVDMGxDLGFBQWFsWSxXQUFXLENBQUM4QyxFQUFFLENBQUMsRUFBRSxFQUFFQSxFQUFFLENBQUMsRUFBRSxFQUFFQSxFQUFFLENBQUMsRUFBRSxFQUFFQSxFQUFFLENBQUMsRUFBRSxFQUFFMEMsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUUsRUFBRTBTLGFBQWFuckMsTUFBTTtZQUN4RixPQUFPKzFCO1FBQ1QsRUFBRSxRQUFRO1FBR1YsSUFBSTFMLEtBQUt5ZCxXQUFXaFMsSUFBSWlYLEtBQUsxb0IsTUFBTSxDQUFDLEVBQUUsSUFBSTBvQixLQUFLMW9CLE1BQU0sQ0FBQyxFQUFFLEdBQUcwb0IsS0FBSzFvQixNQUFNLENBQUMsRUFBRTtRQUN6RSxJQUFJd0YsS0FBS2llLFdBQVcvUixJQUFJaVgsS0FBSzNvQixNQUFNLENBQUMsRUFBRSxJQUFJMm9CLEtBQUszb0IsTUFBTSxDQUFDLEVBQUUsR0FBRzJvQixLQUFLM29CLE1BQU0sQ0FBQyxFQUFFO1FBQ3pFLElBQUlrcEIsZUFBZW5ELGlCQUFpQi9mLElBQUl5TCxJQUFJQyxJQUFJbE07UUFFaEQsSUFBSTBqQixnQkFBZ0IzQyxjQUFjMkMsY0FBY3pYLE1BQU1vWCxZQUFZO1lBQ2hFL0IsYUFBYWxZLFdBQVcsQ0FBQ3NhLFlBQVksQ0FBQyxFQUFFLEVBQUVBLFlBQVksQ0FBQyxFQUFFLEVBQUVBLFlBQVksQ0FBQyxFQUFFLEVBQUVBLFlBQVksQ0FBQyxFQUFFLEVBQUVBLFlBQVksQ0FBQyxFQUFFLEVBQUVBLFlBQVksQ0FBQyxFQUFFLEVBQUVwQyxhQUFhbnJDLE1BQU07WUFDbEosT0FBT3V0QztRQUNUO1FBRUEsT0FBT3pYO0lBQ1Q7SUFFQSxTQUFTMFgsZ0JBQWdCMStCLENBQUMsRUFBRXhHLENBQUM7UUFDM0IsSUFBSW1sQyxZQUFZMytCLEVBQUU4NkIsYUFBYSxDQUFDdGhDO1FBQ2hDLElBQUltbEMsVUFBVXp0QyxNQUFNLElBQUlrbkMsV0FBV3VHLFNBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLElBQUlBLFVBQVV4eEIsS0FBSztRQUN2RSxJQUFJd3hCLFVBQVV6dEMsTUFBTSxFQUFFLE9BQU95dEMsU0FBUyxDQUFDLEVBQUU7UUFDekMsT0FBTztJQUNUO0lBRUEsU0FBU0MseUJBQXlCNStCLENBQUMsRUFBRXhHLENBQUM7UUFDcEMsSUFBSXFsQyxPQUFPNytCLEVBQUU2UyxLQUFLO1FBQ2xCLElBQUlpc0IsT0FBT3RsQyxFQUFFcVosS0FBSztRQUNsQixJQUFJOHJCLFlBQVlELGdCQUFnQjErQixDQUFDLENBQUNBLEVBQUU5TyxNQUFNLEdBQUcsRUFBRSxFQUFFc0ksQ0FBQyxDQUFDLEVBQUU7UUFFckQsSUFBSW1sQyxXQUFXO1lBQ2JFLElBQUksQ0FBQzcrQixFQUFFOU8sTUFBTSxHQUFHLEVBQUUsR0FBRzhPLENBQUMsQ0FBQ0EsRUFBRTlPLE1BQU0sR0FBRyxFQUFFLENBQUNnTyxLQUFLLENBQUN5L0IsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUU7WUFDM0RHLElBQUksQ0FBQyxFQUFFLEdBQUd0bEMsQ0FBQyxDQUFDLEVBQUUsQ0FBQzBGLEtBQUssQ0FBQ3kvQixTQUFTLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRTtRQUN2QztRQUVBLElBQUkzK0IsRUFBRTlPLE1BQU0sR0FBRyxLQUFLc0ksRUFBRXRJLE1BQU0sR0FBRyxHQUFHO1lBQ2hDeXRDLFlBQVlELGdCQUFnQjErQixDQUFDLENBQUMsRUFBRSxFQUFFeEcsQ0FBQyxDQUFDQSxFQUFFdEksTUFBTSxHQUFHLEVBQUU7WUFFakQsSUFBSXl0QyxXQUFXO2dCQUNiLE9BQU87b0JBQUM7d0JBQUMzK0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQ2QsS0FBSyxDQUFDeS9CLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFO3FCQUFDO29CQUFFO3dCQUFDbmxDLENBQUMsQ0FBQ0EsRUFBRXRJLE1BQU0sR0FBRyxFQUFFLENBQUNnTyxLQUFLLENBQUN5L0IsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUU7cUJBQUM7aUJBQUM7WUFDbEY7UUFDRjtRQUVBLE9BQU87WUFBQ0U7WUFBTUM7U0FBSztJQUNyQjtJQUVBLFNBQVNDLG1CQUFtQnYwQixRQUFRO1FBQ2xDLElBQUk3TjtRQUVKLElBQUssSUFBSTNMLElBQUksR0FBR0EsSUFBSXdaLFNBQVN0WixNQUFNLEVBQUVGLEtBQUssRUFBRztZQUMzQzJMLElBQUlpaUMseUJBQXlCcDBCLFFBQVEsQ0FBQ3haLElBQUksRUFBRSxFQUFFd1osUUFBUSxDQUFDeFosRUFBRTtZQUN6RHdaLFFBQVEsQ0FBQ3haLElBQUksRUFBRSxHQUFHMkwsQ0FBQyxDQUFDLEVBQUU7WUFDdEI2TixRQUFRLENBQUN4WixFQUFFLEdBQUcyTCxDQUFDLENBQUMsRUFBRTtRQUNwQjtRQUVBLElBQUk2TixTQUFTdFosTUFBTSxHQUFHLEdBQUc7WUFDdkJ5TCxJQUFJaWlDLHlCQUF5QnAwQixRQUFRLENBQUNBLFNBQVN0WixNQUFNLEdBQUcsRUFBRSxFQUFFc1osUUFBUSxDQUFDLEVBQUU7WUFDdkVBLFFBQVEsQ0FBQ0EsU0FBU3RaLE1BQU0sR0FBRyxFQUFFLEdBQUd5TCxDQUFDLENBQUMsRUFBRTtZQUNwQzZOLFFBQVEsQ0FBQyxFQUFFLEdBQUc3TixDQUFDLENBQUMsRUFBRTtRQUNwQjtRQUVBLE9BQU82TjtJQUNUO0lBRUEsU0FBU3cwQixtQkFBbUI5eEIsT0FBTyxFQUFFb21CLE1BQU07UUFDekM7Ozs7O0lBS0EsR0FDQSxJQUFJMkwsT0FBTy94QixRQUFRb3NCLGdCQUFnQjtRQUNuQyxJQUFJbGlDO1FBQ0osSUFBSStpQztRQUNKLElBQUlqN0I7UUFDSixJQUFJZ2dDO1FBRUosSUFBSUQsS0FBSy90QyxNQUFNLEtBQUssR0FBRztZQUNyQixPQUFPO2dCQUFDeXNDLGNBQWN6d0IsU0FBU29tQjthQUFRO1FBQ3pDO1FBRUEsSUFBSTJMLEtBQUsvdEMsTUFBTSxLQUFLLEtBQUtrbkMsV0FBVzZHLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSTtZQUMvQy8vQixRQUFRZ08sUUFBUWhPLEtBQUssQ0FBQysvQixJQUFJLENBQUMsRUFBRTtZQUM3QjduQyxPQUFPOEgsS0FBSyxDQUFDLEVBQUU7WUFDZmk3QixRQUFRajdCLEtBQUssQ0FBQyxFQUFFO1lBQ2hCLE9BQU87Z0JBQUN5K0IsY0FBY3ZtQyxNQUFNazhCO2dCQUFTcUssY0FBY3hELE9BQU83RzthQUFRO1FBQ3BFO1FBRUFwMEIsUUFBUWdPLFFBQVFoTyxLQUFLLENBQUMrL0IsSUFBSSxDQUFDLEVBQUU7UUFDN0I3bkMsT0FBTzhILEtBQUssQ0FBQyxFQUFFO1FBQ2YsSUFBSXRGLElBQUksQ0FBQ3FsQyxJQUFJLENBQUMsRUFBRSxHQUFHQSxJQUFJLENBQUMsRUFBRSxJQUFLLEtBQUlBLElBQUksQ0FBQyxFQUFFO1FBQzFDLy9CLFFBQVFBLEtBQUssQ0FBQyxFQUFFLENBQUNBLEtBQUssQ0FBQ3RGO1FBQ3ZCc2xDLE1BQU1oZ0MsS0FBSyxDQUFDLEVBQUU7UUFDZGk3QixRQUFRajdCLEtBQUssQ0FBQyxFQUFFO1FBQ2hCLE9BQU87WUFBQ3krQixjQUFjdm1DLE1BQU1rOEI7WUFBU3FLLGNBQWN1QixLQUFLNUw7WUFBU3FLLGNBQWN4RCxPQUFPN0c7U0FBUTtJQUNoRztJQUVBLFNBQVM2TCxzQkFBc0I7SUFFL0J0dUMsZ0JBQWdCO1FBQUNxZ0M7S0FBYyxFQUFFaU87SUFFakNBLG1CQUFtQi90QyxTQUFTLENBQUMrL0Isc0JBQXNCLEdBQUcsU0FBVXBmLElBQUksRUFBRWhXLElBQUk7UUFDeEUsSUFBSSxDQUFDK21CLFFBQVEsR0FBRyxJQUFJLENBQUN3TyxXQUFXO1FBQ2hDLElBQUksQ0FBQ2dDLE1BQU0sR0FBR25RLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUtpRSxDQUFDLEVBQUUsR0FBRyxNQUFNLElBQUk7UUFDakUsSUFBSSxDQUFDbytCLFVBQVUsR0FBR2piLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUtxakMsRUFBRSxFQUFFLEdBQUcsTUFBTSxJQUFJO1FBQ3RFLElBQUksQ0FBQ2pCLFFBQVEsR0FBR3BpQyxLQUFLc2pDLEVBQUU7UUFDdkIsSUFBSSxDQUFDNWIsV0FBVyxHQUFHLElBQUksQ0FBQzZQLE1BQU0sQ0FBQ2xSLGVBQWUsQ0FBQ2x4QixNQUFNLEtBQUs7SUFDNUQ7SUFFQWl1QyxtQkFBbUIvdEMsU0FBUyxDQUFDbWlDLFdBQVcsR0FBRyxTQUFVK0wsV0FBVyxFQUFFaE0sTUFBTSxFQUFFNkssUUFBUSxFQUFFQyxVQUFVO1FBQzVGLElBQUkvQixlQUFlclgsVUFBVTlOLFVBQVU7UUFDdkNtbEIsYUFBYTk3QixDQUFDLEdBQUcrK0IsWUFBWS8rQixDQUFDO1FBQzlCLElBQUlrOUIsUUFBUTZCLFlBQVlwdUMsTUFBTTtRQUU5QixJQUFJLENBQUNvdUMsWUFBWS8rQixDQUFDLEVBQUU7WUFDbEJrOUIsU0FBUztRQUNYO1FBRUEsSUFBSXpzQztRQUNKLElBQUlpTTtRQUNKLElBQUlpUTtRQUNKLElBQUlxeUIsZ0JBQWdCLEVBQUU7UUFFdEIsSUFBS3Z1QyxJQUFJLEdBQUdBLElBQUl5c0MsT0FBT3pzQyxLQUFLLEVBQUc7WUFDN0JrYyxVQUFVNHJCLGlCQUFpQjVGLFlBQVksQ0FBQ29NLGFBQWF0dUM7WUFDckR1dUMsY0FBY2h0QyxJQUFJLENBQUN5c0MsbUJBQW1COXhCLFNBQVNvbUI7UUFDakQ7UUFFQSxJQUFJLENBQUNnTSxZQUFZLytCLENBQUMsRUFBRTtZQUNsQixJQUFLdlAsSUFBSXlzQyxRQUFRLEdBQUd6c0MsS0FBSyxHQUFHQSxLQUFLLEVBQUc7Z0JBQ2xDa2MsVUFBVTRyQixpQkFBaUJzQyxvQkFBb0IsQ0FBQ2tFLGFBQWF0dUM7Z0JBQzdEdXVDLGNBQWNodEMsSUFBSSxDQUFDeXNDLG1CQUFtQjl4QixTQUFTb21CO1lBQ2pEO1FBQ0Y7UUFFQWlNLGdCQUFnQlIsbUJBQW1CUSxnQkFBZ0IsMERBQTBEO1FBRTdHLElBQUlobUIsWUFBWTtRQUNoQixJQUFJaW1CLFVBQVU7UUFFZCxJQUFLeHVDLElBQUksR0FBR0EsSUFBSXV1QyxjQUFjcnVDLE1BQU0sRUFBRUYsS0FBSyxFQUFHO1lBQzVDLElBQUl5dUMsZUFBZUYsYUFBYSxDQUFDdnVDLEVBQUU7WUFDbkMsSUFBSXd1QyxTQUFTam1CLFlBQVl5a0IsVUFBVTNCLGNBQWNtRCxTQUFTQyxZQUFZLENBQUMsRUFBRSxFQUFFdEIsVUFBVUM7WUFDckZvQixVQUFVQyxZQUFZLENBQUNBLGFBQWF2dUMsTUFBTSxHQUFHLEVBQUU7WUFFL0MsSUFBSytMLElBQUksR0FBR0EsSUFBSXdpQyxhQUFhdnVDLE1BQU0sRUFBRStMLEtBQUssRUFBRztnQkFDM0NpUSxVQUFVdXlCLFlBQVksQ0FBQ3hpQyxFQUFFO2dCQUV6QixJQUFJc2MsYUFBYXlmLFdBQVc5ckIsUUFBUXFJLE1BQU0sQ0FBQyxFQUFFLEVBQUVnRSxZQUFZO29CQUN6RDhpQixhQUFhcFksT0FBTyxDQUFDL1csUUFBUXFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFckksUUFBUXFJLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEtBQUs4bUIsYUFBYW5yQyxNQUFNLEtBQUs7Z0JBQ2hHLE9BQU87b0JBQ0xtckMsYUFBYWxZLFdBQVcsQ0FBQ2pYLFFBQVFxSSxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRXJJLFFBQVFxSSxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRXJJLFFBQVFxSSxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRXJJLFFBQVFxSSxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRXJJLFFBQVFxSSxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRXJJLFFBQVFxSSxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRThtQixhQUFhbnJDLE1BQU07Z0JBQ2xMO2dCQUVBbXJDLGFBQWFsWSxXQUFXLENBQUNqWCxRQUFRcUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUVySSxRQUFRcUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUVySSxRQUFRcUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUVySSxRQUFRcUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUVySSxRQUFRcUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUVySSxRQUFRcUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU4bUIsYUFBYW5yQyxNQUFNO2dCQUNoTHFvQixZQUFZck0sUUFBUXFJLE1BQU0sQ0FBQyxFQUFFO1lBQy9CO1FBQ0Y7UUFFQSxJQUFJZ3FCLGNBQWNydUMsTUFBTSxFQUFFOHNDLFVBQVUzQixjQUFjbUQsU0FBU0QsYUFBYSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUVwQixVQUFVQztRQUMxRixPQUFPL0I7SUFDVDtJQUVBOEMsbUJBQW1CL3RDLFNBQVMsQ0FBQytnQyxhQUFhLEdBQUcsU0FBVTdQLGFBQWE7UUFDbEUsSUFBSStQO1FBQ0osSUFBSXJoQztRQUNKLElBQUlDLE1BQU0sSUFBSSxDQUFDOE0sTUFBTSxDQUFDN00sTUFBTTtRQUM1QixJQUFJK0w7UUFDSixJQUFJQztRQUNKLElBQUlvMkIsU0FBUyxJQUFJLENBQUNBLE1BQU0sQ0FBQ2o2QixDQUFDO1FBQzFCLElBQUkra0MsYUFBYSxJQUFJLENBQUNBLFVBQVUsQ0FBQy9rQyxDQUFDO1FBQ2xDLElBQUk4a0MsV0FBVyxJQUFJLENBQUNBLFFBQVE7UUFFNUIsSUFBSTdLLFdBQVcsR0FBRztZQUNoQixJQUFJNVo7WUFDSixJQUFJMk07WUFFSixJQUFLcjFCLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO2dCQUMzQjBvQixZQUFZLElBQUksQ0FBQzNiLE1BQU0sQ0FBQy9NLEVBQUU7Z0JBQzFCcTFCLHVCQUF1QjNNLFVBQVUyTSxvQkFBb0I7Z0JBRXJELElBQUksQ0FBRSxFQUFDM00sVUFBVXlMLEtBQUssQ0FBQ2xELElBQUksSUFBSSxDQUFDLElBQUksQ0FBQ0EsSUFBSSxJQUFJLENBQUNLLGFBQVksR0FBSTtvQkFDNUQrRCxxQkFBcUJkLGFBQWE7b0JBQ2xDN0wsVUFBVXlMLEtBQUssQ0FBQ2xELElBQUksR0FBRztvQkFDdkJvUSxhQUFhM1ksVUFBVXlMLEtBQUssQ0FBQ2lCLEtBQUssQ0FBQ3JvQixNQUFNO29CQUN6Q2IsT0FBT3djLFVBQVV5TCxLQUFLLENBQUNpQixLQUFLLENBQUNyUCxPQUFPO29CQUVwQyxJQUFLOVosSUFBSSxHQUFHQSxJQUFJQyxNQUFNRCxLQUFLLEVBQUc7d0JBQzVCb3BCLHFCQUFxQmYsUUFBUSxDQUFDLElBQUksQ0FBQ2lPLFdBQVcsQ0FBQ2xCLFVBQVUsQ0FBQ3AxQixFQUFFLEVBQUVxMkIsUUFBUTZLLFVBQVVDO29CQUNsRjtnQkFDRjtnQkFFQTFrQixVQUFVeUwsS0FBSyxDQUFDaUIsS0FBSyxHQUFHMU0sVUFBVTJNLG9CQUFvQjtZQUN4RDtRQUNGO1FBRUEsSUFBSSxDQUFDLElBQUksQ0FBQzdDLGlCQUFpQixDQUFDdHlCLE1BQU0sRUFBRTtZQUNsQyxJQUFJLENBQUMrd0IsSUFBSSxHQUFHO1FBQ2Q7SUFDRjtJQUVBLFNBQVN5ZCxrQkFBa0JDLFFBQVE7UUFDakMsSUFBSUMsU0FBU0QsU0FBU0UsTUFBTSxHQUFHRixTQUFTRSxNQUFNLENBQUMzZ0MsS0FBSyxDQUFDLE9BQU8sRUFBRTtRQUM5RCxJQUFJNGdDLFVBQVU7UUFDZCxJQUFJRCxTQUFTO1FBQ2IsSUFBSTV1QyxNQUFNMnVDLE9BQU8xdUMsTUFBTTtRQUN2QixJQUFJNnVDO1FBRUosSUFBSyxJQUFJL3VDLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQy9CK3VDLFlBQVlILE1BQU0sQ0FBQzV1QyxFQUFFLENBQUNndkMsV0FBVztZQUVqQyxPQUFRRDtnQkFDTixLQUFLO29CQUNIRixTQUFTO29CQUNUO2dCQUVGLEtBQUs7b0JBQ0hDLFVBQVU7b0JBQ1Y7Z0JBRUYsS0FBSztvQkFDSEEsVUFBVTtvQkFDVjtnQkFFRixLQUFLO29CQUNIQSxVQUFVO29CQUNWO2dCQUVGLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSEEsVUFBVTtvQkFDVjtnQkFFRixLQUFLO2dCQUNMLEtBQUs7b0JBQ0hBLFVBQVU7b0JBQ1Y7Z0JBRUY7b0JBQ0U7WUFDSjtRQUNGO1FBRUEsT0FBTztZQUNMN29DLE9BQU80b0M7WUFDUEksUUFBUU4sU0FBU0csT0FBTyxJQUFJQTtRQUM5QjtJQUNGO0lBRUEsSUFBSUksY0FBYztRQUNoQixJQUFJQyxpQkFBaUI7UUFDckIsSUFBSUMsWUFBWTtZQUNkN2UsR0FBRztZQUNIOGUsTUFBTTtZQUNOdGlDLFFBQVEsRUFBRTtZQUNWaEMsTUFBTTtnQkFDSmdDLFFBQVEsRUFBRTtZQUNaO1FBQ0Y7UUFDQSxJQUFJdWlDLHFCQUFxQixFQUFFLEVBQUUsbUJBQW1CO1FBRWhEQSxxQkFBcUJBLG1CQUFtQjF0QixNQUFNLENBQUM7WUFBQztZQUFNO1lBQU07WUFBTTtZQUFNO1lBQU07WUFBTTtZQUFNO1lBQU07WUFBTTtZQUFNO1lBQU07WUFBTTtZQUFNO1lBQU07WUFBTTtZQUFNO1lBQU07WUFBTTtZQUFNO1lBQU07WUFBTTtZQUFNO1lBQU07WUFBTTtZQUFNO1lBQU07WUFBTTtZQUFNO1lBQU07WUFBTTtZQUFNO1lBQU07U0FBSztRQUNyUCxJQUFJMnRCLHdCQUF3QjtRQUM1QixJQUFJQyx3QkFBd0I7UUFDNUIsSUFBSUMsbUJBQW1CO1FBQ3ZCLElBQUlDLG1CQUFtQjtRQUN2QixJQUFJQyxtQ0FBbUM7UUFDdkMsSUFBSUMsK0JBQStCO1FBQ25DLElBQUlDLGtDQUFrQztRQUN0QyxJQUFJQyxrQ0FBa0M7UUFDdEMsSUFBSUMscUJBQXFCO1lBQUM7WUFBWTtZQUFZO1lBQVk7WUFBWTtTQUFXO1FBRXJGLFNBQVNDLGdCQUFnQkMsSUFBSTtZQUMzQixJQUFJQyxjQUFjRCxLQUFLL2hDLEtBQUssQ0FBQztZQUM3QixJQUFJbE87WUFDSixJQUFJQyxNQUFNaXdDLFlBQVlod0MsTUFBTTtZQUM1QixJQUFJaXdDLGtCQUFrQixFQUFFO1lBRXhCLElBQUtud0MsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7Z0JBQzNCLElBQUlrd0MsV0FBVyxDQUFDbHdDLEVBQUUsS0FBSyxnQkFBZ0Jrd0MsV0FBVyxDQUFDbHdDLEVBQUUsS0FBSyxhQUFhO29CQUNyRW13QyxnQkFBZ0I1dUMsSUFBSSxDQUFDMnVDLFdBQVcsQ0FBQ2x3QyxFQUFFO2dCQUNyQztZQUNGO1lBRUEsT0FBT213QyxnQkFBZ0JqL0IsSUFBSSxDQUFDO1FBQzlCO1FBRUEsU0FBU2svQixVQUFVSCxJQUFJLEVBQUVJLE1BQU07WUFDN0IsSUFBSUMsYUFBYTd3QyxVQUFVLFNBQVMsdUNBQXVDO1lBRTNFNndDLFdBQVd2dUIsWUFBWSxDQUFDLGVBQWU7WUFDdkN1dUIsV0FBV3JxQyxLQUFLLENBQUNzcUMsVUFBVSxHQUFHRjtZQUM5QixJQUFJRyxPQUFPL3dDLFVBQVUsU0FBUywyREFBMkQ7WUFFekYrd0MsS0FBS3R1QixTQUFTLEdBQUcsa0JBQWtCLHlEQUF5RDtZQUU1Rm91QixXQUFXcnFDLEtBQUssQ0FBQ0MsUUFBUSxHQUFHO1lBQzVCb3FDLFdBQVdycUMsS0FBSyxDQUFDRyxJQUFJLEdBQUc7WUFDeEJrcUMsV0FBV3JxQyxLQUFLLENBQUNFLEdBQUcsR0FBRyxZQUFZLG9EQUFvRDtZQUV2Rm1xQyxXQUFXcnFDLEtBQUssQ0FBQ3dxQyxRQUFRLEdBQUcsU0FBUyw0QkFBNEI7WUFFakVILFdBQVdycUMsS0FBSyxDQUFDeXFDLFdBQVcsR0FBRztZQUMvQkosV0FBV3JxQyxLQUFLLENBQUMwcUMsU0FBUyxHQUFHO1lBQzdCTCxXQUFXcnFDLEtBQUssQ0FBQzJxQyxVQUFVLEdBQUc7WUFDOUJOLFdBQVdycUMsS0FBSyxDQUFDNHFDLGFBQWEsR0FBRztZQUNqQ1AsV0FBVzU3QixXQUFXLENBQUM4N0I7WUFDdkI3d0MsU0FBU3FpQixJQUFJLENBQUN0TixXQUFXLENBQUM0N0IsYUFBYSwwQ0FBMEM7WUFFakYsSUFBSTk5QixRQUFRZytCLEtBQUtNLFdBQVc7WUFDNUJOLEtBQUt2cUMsS0FBSyxDQUFDc3FDLFVBQVUsR0FBR1AsZ0JBQWdCQyxRQUFRLE9BQU9JO1lBQ3ZELE9BQU87Z0JBQ0xHLE1BQU1BO2dCQUNOamdCLEdBQUcvZDtnQkFDSHUrQixRQUFRVDtZQUNWO1FBQ0Y7UUFFQSxTQUFTVTtZQUNQLElBQUloeEM7WUFDSixJQUFJQyxNQUFNLElBQUksQ0FBQzJiLEtBQUssQ0FBQzFiLE1BQU07WUFDM0IsSUFBSXN3QztZQUNKLElBQUlqZ0I7WUFDSixJQUFJMGdCLGNBQWNoeEM7WUFFbEIsSUFBS0QsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7Z0JBQzNCLElBQUksSUFBSSxDQUFDNGIsS0FBSyxDQUFDNWIsRUFBRSxDQUFDa3hDLE1BQU0sRUFBRTtvQkFDeEJELGVBQWU7Z0JBQ2pCLE9BQU8sSUFBSSxJQUFJLENBQUNyMUIsS0FBSyxDQUFDNWIsRUFBRSxDQUFDbXhDLE9BQU8sS0FBSyxPQUFPLElBQUksQ0FBQ3YxQixLQUFLLENBQUM1YixFQUFFLENBQUNnUyxNQUFNLEtBQUssR0FBRztvQkFDdEUsSUFBSSxDQUFDNEosS0FBSyxDQUFDNWIsRUFBRSxDQUFDa3hDLE1BQU0sR0FBRztnQkFDekIsT0FBTztvQkFDTFYsT0FBTyxJQUFJLENBQUM1MEIsS0FBSyxDQUFDNWIsRUFBRSxDQUFDb3hDLFFBQVEsQ0FBQ1osSUFBSTtvQkFDbENqZ0IsSUFBSSxJQUFJLENBQUMzVSxLQUFLLENBQUM1YixFQUFFLENBQUNveEMsUUFBUSxDQUFDN2dCLENBQUM7b0JBRTVCLElBQUlpZ0IsS0FBS00sV0FBVyxLQUFLdmdCLEdBQUc7d0JBQzFCMGdCLGVBQWU7d0JBQ2YsSUFBSSxDQUFDcjFCLEtBQUssQ0FBQzViLEVBQUUsQ0FBQ2t4QyxNQUFNLEdBQUc7b0JBQ3pCLE9BQU87d0JBQ0xWLE9BQU8sSUFBSSxDQUFDNTBCLEtBQUssQ0FBQzViLEVBQUUsQ0FBQ3F4QyxRQUFRLENBQUNiLElBQUk7d0JBQ2xDamdCLElBQUksSUFBSSxDQUFDM1UsS0FBSyxDQUFDNWIsRUFBRSxDQUFDcXhDLFFBQVEsQ0FBQzlnQixDQUFDO3dCQUU1QixJQUFJaWdCLEtBQUtNLFdBQVcsS0FBS3ZnQixHQUFHOzRCQUMxQjBnQixlQUFlOzRCQUNmLElBQUksQ0FBQ3IxQixLQUFLLENBQUM1YixFQUFFLENBQUNreEMsTUFBTSxHQUFHO3dCQUN6QjtvQkFDRjtvQkFFQSxJQUFJLElBQUksQ0FBQ3QxQixLQUFLLENBQUM1YixFQUFFLENBQUNreEMsTUFBTSxFQUFFO3dCQUN4QixJQUFJLENBQUN0MUIsS0FBSyxDQUFDNWIsRUFBRSxDQUFDcXhDLFFBQVEsQ0FBQ04sTUFBTSxDQUFDVCxVQUFVLENBQUNnQixXQUFXLENBQUMsSUFBSSxDQUFDMTFCLEtBQUssQ0FBQzViLEVBQUUsQ0FBQ3F4QyxRQUFRLENBQUNOLE1BQU07d0JBQ2xGLElBQUksQ0FBQ24xQixLQUFLLENBQUM1YixFQUFFLENBQUNveEMsUUFBUSxDQUFDTCxNQUFNLENBQUNULFVBQVUsQ0FBQ2dCLFdBQVcsQ0FBQyxJQUFJLENBQUMxMUIsS0FBSyxDQUFDNWIsRUFBRSxDQUFDb3hDLFFBQVEsQ0FBQ0wsTUFBTTtvQkFDcEY7Z0JBQ0Y7WUFDRjtZQUVBLElBQUlFLGdCQUFnQixLQUFLTSxLQUFLQyxHQUFHLEtBQUssSUFBSSxDQUFDbHhCLFFBQVEsR0FBRzZ1QixnQkFBZ0I7Z0JBQ3BFcHlCLFdBQVcsSUFBSSxDQUFDMDBCLHNCQUFzQixFQUFFO1lBQzFDLE9BQU87Z0JBQ0wxMEIsV0FBVyxJQUFJLENBQUMyMEIsaUJBQWlCLEVBQUU7WUFDckM7UUFDRjtRQUVBLFNBQVNDLGFBQWFoRCxRQUFRLEVBQUVpRCxHQUFHO1lBQ2pDLElBQUlDLFNBQVNseUMsU0FBU3FpQixJQUFJLElBQUk0dkIsTUFBTSxRQUFRO1lBQzVDLElBQUlFO1lBQ0osSUFBSUMsWUFBWXJELGtCQUFrQkM7WUFFbEMsSUFBSWtELFdBQVcsT0FBTztnQkFDcEIsSUFBSUcsVUFBVTduQyxTQUFTO2dCQUN2QjZuQyxRQUFRL3JDLEtBQUssQ0FBQ3dxQyxRQUFRLEdBQUcsU0FBUywrQ0FBK0M7Z0JBRWpGdUIsUUFBUWp3QixZQUFZLENBQUMsZUFBZTRzQixTQUFTc0QsT0FBTztnQkFDcERELFFBQVFqd0IsWUFBWSxDQUFDLGNBQWNnd0IsVUFBVTlyQyxLQUFLO2dCQUNsRCtyQyxRQUFRandCLFlBQVksQ0FBQyxlQUFlZ3dCLFVBQVU5QyxNQUFNO2dCQUNwRCtDLFFBQVFFLFdBQVcsR0FBRztnQkFFdEIsSUFBSXZELFNBQVN3RCxNQUFNLEVBQUU7b0JBQ25CSCxRQUFRL3JDLEtBQUssQ0FBQ3NxQyxVQUFVLEdBQUc7b0JBQzNCeUIsUUFBUWp3QixZQUFZLENBQUMsU0FBUzRzQixTQUFTd0QsTUFBTTtnQkFDL0MsT0FBTztvQkFDTEgsUUFBUS9yQyxLQUFLLENBQUNzcUMsVUFBVSxHQUFHNUIsU0FBU3NELE9BQU87Z0JBQzdDO2dCQUVBTCxJQUFJbDlCLFdBQVcsQ0FBQ3M5QjtnQkFDaEJGLFNBQVNFO1lBQ1gsT0FBTztnQkFDTCxJQUFJSSxnQkFBZ0IsSUFBSUMsZ0JBQWdCLEtBQUssS0FBSzEvQixVQUFVLENBQUM7Z0JBQzdEeS9CLGNBQWNuQyxJQUFJLEdBQUc4QixVQUFVOXJDLEtBQUssR0FBRyxNQUFNOHJDLFVBQVU5QyxNQUFNLEdBQUcsWUFBWU4sU0FBU3NELE9BQU87Z0JBQzVGSCxTQUFTTTtZQUNYO1lBRUEsU0FBU0UsUUFBUUMsSUFBSTtnQkFDbkIsSUFBSVYsV0FBVyxPQUFPO29CQUNwQkMsT0FBT0ksV0FBVyxHQUFHSztvQkFDckIsT0FBT1QsT0FBT1UscUJBQXFCO2dCQUNyQztnQkFFQSxPQUFPVixPQUFPVyxXQUFXLENBQUNGLE1BQU0vL0IsS0FBSztZQUN2QztZQUVBLE9BQU87Z0JBQ0xpZ0MsYUFBYUg7WUFDZjtRQUNGO1FBRUEsU0FBU3YyQixTQUFTNHlCLFFBQVEsRUFBRWowQixJQUFJO1lBQzlCLElBQUksQ0FBQ2kwQixVQUFVO2dCQUNiLElBQUksQ0FBQ2wyQixRQUFRLEdBQUc7Z0JBQ2hCO1lBQ0Y7WUFFQSxJQUFJLElBQUksQ0FBQ3ZMLEtBQUssRUFBRTtnQkFDZCxJQUFJLENBQUN1TCxRQUFRLEdBQUc7Z0JBQ2hCLElBQUksQ0FBQ21ELEtBQUssR0FBRyt5QixTQUFTK0QsSUFBSTtnQkFDMUI7WUFDRjtZQUVBLElBQUksQ0FBQy95QyxTQUFTcWlCLElBQUksRUFBRTtnQkFDbEIsSUFBSSxDQUFDdkosUUFBUSxHQUFHO2dCQUNoQmsyQixTQUFTK0QsSUFBSSxDQUFDQyxPQUFPLENBQUMsU0FBVTVuQyxJQUFJO29CQUNsQ0EsS0FBSyttQyxNQUFNLEdBQUdILGFBQWE1bUM7b0JBQzNCQSxLQUFLNm5DLEtBQUssR0FBRyxDQUFDO2dCQUNoQjtnQkFDQSxJQUFJLENBQUNoM0IsS0FBSyxHQUFHK3lCLFNBQVMrRCxJQUFJO2dCQUMxQjtZQUNGO1lBRUEsSUFBSUcsVUFBVWxFLFNBQVMrRCxJQUFJO1lBQzNCLElBQUkxeUM7WUFDSixJQUFJQyxNQUFNNHlDLFFBQVEzeUMsTUFBTTtZQUN4QixJQUFJNHlDLGdCQUFnQjd5QztZQUVwQixJQUFLRCxJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztnQkFDM0IsSUFBSSt5QyxpQkFBaUI7Z0JBQ3JCLElBQUlDO2dCQUNKLElBQUkvbUM7Z0JBQ0o0bUMsT0FBTyxDQUFDN3lDLEVBQUUsQ0FBQ2t4QyxNQUFNLEdBQUc7Z0JBQ3BCMkIsT0FBTyxDQUFDN3lDLEVBQUUsQ0FBQ294QyxRQUFRLEdBQUdoQixVQUFVeUMsT0FBTyxDQUFDN3lDLEVBQUUsQ0FBQ2l5QyxPQUFPLEVBQUU7Z0JBQ3BEWSxPQUFPLENBQUM3eUMsRUFBRSxDQUFDcXhDLFFBQVEsR0FBR2pCLFVBQVV5QyxPQUFPLENBQUM3eUMsRUFBRSxDQUFDaXlDLE9BQU8sRUFBRTtnQkFFcEQsSUFBSSxDQUFDWSxPQUFPLENBQUM3eUMsRUFBRSxDQUFDaXpDLEtBQUssRUFBRTtvQkFDckJKLE9BQU8sQ0FBQzd5QyxFQUFFLENBQUNreEMsTUFBTSxHQUFHO29CQUNwQjRCLGlCQUFpQjtnQkFDbkIsT0FBTyxJQUFJRCxPQUFPLENBQUM3eUMsRUFBRSxDQUFDbXhDLE9BQU8sS0FBSyxPQUFPMEIsT0FBTyxDQUFDN3lDLEVBQUUsQ0FBQ2dTLE1BQU0sS0FBSyxHQUFHO29CQUNoRWdoQyxpQkFBaUJyekMsU0FBU3V6QyxnQkFBZ0IsQ0FBQyxvQ0FBb0NMLE9BQU8sQ0FBQzd5QyxFQUFFLENBQUNpeUMsT0FBTyxHQUFHLHVDQUF1Q1ksT0FBTyxDQUFDN3lDLEVBQUUsQ0FBQ2l5QyxPQUFPLEdBQUc7b0JBRWhLLElBQUllLGVBQWU5eUMsTUFBTSxHQUFHLEdBQUc7d0JBQzdCNnlDLGlCQUFpQjtvQkFDbkI7b0JBRUEsSUFBSUEsZ0JBQWdCO3dCQUNsQixJQUFJM3FDLElBQUkzSSxVQUFVO3dCQUNsQjJJLEVBQUUyWixZQUFZLENBQUMsYUFBYTh3QixPQUFPLENBQUM3eUMsRUFBRSxDQUFDbXhDLE9BQU87d0JBQzlDL29DLEVBQUUyWixZQUFZLENBQUMsWUFBWTh3QixPQUFPLENBQUM3eUMsRUFBRSxDQUFDZ1MsTUFBTTt3QkFDNUM1SixFQUFFMlosWUFBWSxDQUFDLFlBQVk4d0IsT0FBTyxDQUFDN3lDLEVBQUUsQ0FBQ2l5QyxPQUFPO3dCQUM3QzdwQyxFQUFFMUksSUFBSSxHQUFHO3dCQUNUMEksRUFBRThaLFNBQVMsR0FBRyw4QkFBOEIyd0IsT0FBTyxDQUFDN3lDLEVBQUUsQ0FBQ2l5QyxPQUFPLEdBQUcscUNBQXFDWSxPQUFPLENBQUM3eUMsRUFBRSxDQUFDaXpDLEtBQUssR0FBRzt3QkFDekh2NEIsS0FBS2hHLFdBQVcsQ0FBQ3RNO29CQUNuQjtnQkFDRixPQUFPLElBQUl5cUMsT0FBTyxDQUFDN3lDLEVBQUUsQ0FBQ214QyxPQUFPLEtBQUssT0FBTzBCLE9BQU8sQ0FBQzd5QyxFQUFFLENBQUNnUyxNQUFNLEtBQUssR0FBRztvQkFDaEVnaEMsaUJBQWlCcnpDLFNBQVN1ekMsZ0JBQWdCLENBQUM7b0JBRTNDLElBQUtqbkMsSUFBSSxHQUFHQSxJQUFJK21DLGVBQWU5eUMsTUFBTSxFQUFFK0wsS0FBSyxFQUFHO3dCQUM3QyxJQUFJK21DLGNBQWMsQ0FBQy9tQyxFQUFFLENBQUNxeUIsSUFBSSxDQUFDanVCLE9BQU8sQ0FBQ3dpQyxPQUFPLENBQUM3eUMsRUFBRSxDQUFDaXpDLEtBQUssTUFBTSxDQUFDLEdBQUc7NEJBQzNELHlCQUF5Qjs0QkFDekJGLGlCQUFpQjt3QkFDbkI7b0JBQ0Y7b0JBRUEsSUFBSUEsZ0JBQWdCO3dCQUNsQixJQUFJblosSUFBSW42QixVQUFVO3dCQUNsQm02QixFQUFFN1gsWUFBWSxDQUFDLGFBQWE4d0IsT0FBTyxDQUFDN3lDLEVBQUUsQ0FBQ214QyxPQUFPO3dCQUM5Q3ZYLEVBQUU3WCxZQUFZLENBQUMsWUFBWTh3QixPQUFPLENBQUM3eUMsRUFBRSxDQUFDZ1MsTUFBTTt3QkFDNUM0bkIsRUFBRWw2QixJQUFJLEdBQUc7d0JBQ1RrNkIsRUFBRXVaLEdBQUcsR0FBRzt3QkFDUnZaLEVBQUUwRSxJQUFJLEdBQUd1VSxPQUFPLENBQUM3eUMsRUFBRSxDQUFDaXpDLEtBQUs7d0JBQ3pCdHpDLFNBQVNxaUIsSUFBSSxDQUFDdE4sV0FBVyxDQUFDa2xCO29CQUM1QjtnQkFDRixPQUFPLElBQUlpWixPQUFPLENBQUM3eUMsRUFBRSxDQUFDbXhDLE9BQU8sS0FBSyxPQUFPMEIsT0FBTyxDQUFDN3lDLEVBQUUsQ0FBQ2dTLE1BQU0sS0FBSyxHQUFHO29CQUNoRWdoQyxpQkFBaUJyekMsU0FBU3V6QyxnQkFBZ0IsQ0FBQztvQkFFM0MsSUFBS2puQyxJQUFJLEdBQUdBLElBQUkrbUMsZUFBZTl5QyxNQUFNLEVBQUUrTCxLQUFLLEVBQUc7d0JBQzdDLElBQUk0bUMsT0FBTyxDQUFDN3lDLEVBQUUsQ0FBQ2l6QyxLQUFLLEtBQUtELGNBQWMsQ0FBQy9tQyxFQUFFLENBQUNqSyxHQUFHLEVBQUU7NEJBQzlDLHlCQUF5Qjs0QkFDekIrd0MsaUJBQWlCO3dCQUNuQjtvQkFDRjtvQkFFQSxJQUFJQSxnQkFBZ0I7d0JBQ2xCLElBQUlLLEtBQUszekMsVUFBVTt3QkFDbkIyekMsR0FBR3J4QixZQUFZLENBQUMsYUFBYTh3QixPQUFPLENBQUM3eUMsRUFBRSxDQUFDbXhDLE9BQU87d0JBQy9DaUMsR0FBR3J4QixZQUFZLENBQUMsWUFBWTh3QixPQUFPLENBQUM3eUMsRUFBRSxDQUFDZ1MsTUFBTTt3QkFDN0NvaEMsR0FBR3J4QixZQUFZLENBQUMsT0FBTzt3QkFDdkJxeEIsR0FBR3J4QixZQUFZLENBQUMsUUFBUTh3QixPQUFPLENBQUM3eUMsRUFBRSxDQUFDaXpDLEtBQUs7d0JBQ3hDdjRCLEtBQUtoRyxXQUFXLENBQUMwK0I7b0JBQ25CO2dCQUNGO2dCQUVBUCxPQUFPLENBQUM3eUMsRUFBRSxDQUFDOHhDLE1BQU0sR0FBR0gsYUFBYWtCLE9BQU8sQ0FBQzd5QyxFQUFFLEVBQUUwYTtnQkFDN0NtNEIsT0FBTyxDQUFDN3lDLEVBQUUsQ0FBQzR5QyxLQUFLLEdBQUcsQ0FBQztnQkFDcEIsSUFBSSxDQUFDaDNCLEtBQUssQ0FBQ3JhLElBQUksQ0FBQ3N4QyxPQUFPLENBQUM3eUMsRUFBRTtZQUM1QjtZQUVBLElBQUk4eUMsa0JBQWtCLEdBQUc7Z0JBQ3ZCLElBQUksQ0FBQ3I2QixRQUFRLEdBQUc7WUFDbEIsT0FBTztnQkFDTCxtR0FBbUc7Z0JBQ25HLHNDQUFzQztnQkFDdENzRSxXQUFXLElBQUksQ0FBQ2kwQixnQkFBZ0IsQ0FBQzc4QixJQUFJLENBQUMsSUFBSSxHQUFHO1lBQy9DO1FBQ0Y7UUFFQSxTQUFTMkgsU0FBUzVPLEtBQUs7WUFDckIsSUFBSSxDQUFDQSxPQUFPO2dCQUNWO1lBQ0Y7WUFFQSxJQUFJLENBQUMsSUFBSSxDQUFDQSxLQUFLLEVBQUU7Z0JBQ2YsSUFBSSxDQUFDQSxLQUFLLEdBQUcsRUFBRTtZQUNqQjtZQUVBLElBQUlsTjtZQUNKLElBQUlDLE1BQU1pTixNQUFNaE4sTUFBTTtZQUN0QixJQUFJK0w7WUFDSixJQUFJQyxPQUFPLElBQUksQ0FBQ2dCLEtBQUssQ0FBQ2hOLE1BQU07WUFDNUIsSUFBSW16QztZQUVKLElBQUtyekMsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7Z0JBQzNCaU0sSUFBSTtnQkFDSm9uQyxRQUFRO2dCQUVSLE1BQU9wbkMsSUFBSUMsS0FBTTtvQkFDZixJQUFJLElBQUksQ0FBQ2dCLEtBQUssQ0FBQ2pCLEVBQUUsQ0FBQ2hHLEtBQUssS0FBS2lILEtBQUssQ0FBQ2xOLEVBQUUsQ0FBQ2lHLEtBQUssSUFBSSxJQUFJLENBQUNpSCxLQUFLLENBQUNqQixFQUFFLENBQUNnbUMsT0FBTyxLQUFLL2tDLEtBQUssQ0FBQ2xOLEVBQUUsQ0FBQ2l5QyxPQUFPLElBQUksSUFBSSxDQUFDL2tDLEtBQUssQ0FBQ2pCLEVBQUUsQ0FBQ3FuQyxFQUFFLEtBQUtwbUMsS0FBSyxDQUFDbE4sRUFBRSxDQUFDc3pDLEVBQUUsRUFBRTt3QkFDNUhELFFBQVE7b0JBQ1Y7b0JBRUFwbkMsS0FBSztnQkFDUDtnQkFFQSxJQUFJLENBQUNvbkMsT0FBTztvQkFDVixJQUFJLENBQUNubUMsS0FBSyxDQUFDM0wsSUFBSSxDQUFDMkwsS0FBSyxDQUFDbE4sRUFBRTtvQkFDeEJrTSxRQUFRO2dCQUNWO1lBQ0Y7UUFDRjtRQUVBLFNBQVNxbkMsWUFBWUMsS0FBSyxFQUFFdnRDLEtBQUssRUFBRWdxQyxJQUFJO1lBQ3JDLElBQUlqd0MsSUFBSTtZQUNSLElBQUlDLE1BQU0sSUFBSSxDQUFDaU4sS0FBSyxDQUFDaE4sTUFBTTtZQUUzQixNQUFPRixJQUFJQyxJQUFLO2dCQUNkLElBQUksSUFBSSxDQUFDaU4sS0FBSyxDQUFDbE4sRUFBRSxDQUFDc3pDLEVBQUUsS0FBS0UsU0FBUyxJQUFJLENBQUN0bUMsS0FBSyxDQUFDbE4sRUFBRSxDQUFDaUcsS0FBSyxLQUFLQSxTQUFTLElBQUksQ0FBQ2lILEtBQUssQ0FBQ2xOLEVBQUUsQ0FBQ2l5QyxPQUFPLEtBQUtoQyxNQUFNO29CQUNqRyxPQUFPLElBQUksQ0FBQy9pQyxLQUFLLENBQUNsTixFQUFFO2dCQUN0QjtnQkFFQUEsS0FBSztZQUNQO1lBRUEsSUFBSSxDQUFDLE9BQU93ekMsVUFBVSxZQUFZQSxNQUFNQyxVQUFVLENBQUMsT0FBTyxNQUFNLENBQUNELEtBQUksS0FBTUUsV0FBV0EsUUFBUUMsSUFBSSxDQUFDLGlDQUFpQztnQkFDakksQ0FBQyxJQUFJLENBQUNDLE9BQU8sRUFBRTtnQkFDaEIsSUFBSSxDQUFDQSxPQUFPLEdBQUc7Z0JBQ2ZGLFFBQVFDLElBQUksQ0FBQyxxREFBcURILE9BQU92dEMsT0FBT2dxQyxPQUFPLGlDQUFpQztZQUMxSDtZQUVBLE9BQU9iO1FBQ1Q7UUFFQSxTQUFTcUQsWUFBWW9CLE1BQU0sRUFBRUMsUUFBUSxFQUFFekUsSUFBSTtZQUN6QyxJQUFJVixXQUFXLElBQUksQ0FBQ29GLGFBQWEsQ0FBQ0QsV0FBVywrQ0FBK0M7WUFDNUYsMENBQTBDO1lBRTFDLElBQUk1ekIsUUFBUTJ6QjtZQUVaLElBQUksQ0FBQ2xGLFNBQVNpRSxLQUFLLENBQUMxeUIsTUFBTSxFQUFFO2dCQUMxQixJQUFJOHhCLFVBQVVyRCxTQUFTbUQsTUFBTTtnQkFFN0IsSUFBSStCLFdBQVcsS0FBSztvQkFDbEIsSUFBSUcsYUFBYWhDLFFBQVFTLFdBQVcsQ0FBQyxNQUFNb0IsU0FBUztvQkFDcEQsSUFBSUksYUFBYWpDLFFBQVFTLFdBQVcsQ0FBQztvQkFDckM5RCxTQUFTaUUsS0FBSyxDQUFDMXlCLE1BQU0sR0FBRyxDQUFDOHpCLGFBQWFDLFVBQVMsSUFBSztnQkFDdEQsT0FBTztvQkFDTHRGLFNBQVNpRSxLQUFLLENBQUMxeUIsTUFBTSxHQUFHOHhCLFFBQVFTLFdBQVcsQ0FBQ29CLFVBQVU7Z0JBQ3hEO1lBQ0Y7WUFFQSxPQUFPbEYsU0FBU2lFLEtBQUssQ0FBQzF5QixNQUFNLEdBQUdtdkI7UUFDakM7UUFFQSxTQUFTMEUsY0FBY3Y4QixJQUFJO1lBQ3pCLElBQUl4WCxJQUFJO1lBQ1IsSUFBSUMsTUFBTSxJQUFJLENBQUMyYixLQUFLLENBQUMxYixNQUFNO1lBRTNCLE1BQU9GLElBQUlDLElBQUs7Z0JBQ2QsSUFBSSxJQUFJLENBQUMyYixLQUFLLENBQUM1YixFQUFFLENBQUNrMEMsS0FBSyxLQUFLMThCLE1BQU07b0JBQ2hDLE9BQU8sSUFBSSxDQUFDb0UsS0FBSyxDQUFDNWIsRUFBRTtnQkFDdEI7Z0JBRUFBLEtBQUs7WUFDUDtZQUVBLE9BQU8sSUFBSSxDQUFDNGIsS0FBSyxDQUFDLEVBQUU7UUFDdEI7UUFFQSxTQUFTdTRCLGFBQWFDLE1BQU07WUFDMUIsSUFBSUMsWUFBWTtZQUNoQixJQUFJN3lCLFFBQVE0eUIsT0FBT1gsVUFBVSxDQUFDO1lBRTlCLElBQUlqeUIsU0FBUyxVQUFVQSxTQUFTLFFBQVE7Z0JBQ3RDLElBQUk4eUIsU0FBU0YsT0FBT1gsVUFBVSxDQUFDO2dCQUUvQixJQUFJYSxVQUFVLFVBQVVBLFVBQVUsUUFBUTtvQkFDeENELFlBQVksQ0FBQzd5QixRQUFRLE1BQUssSUFBSyxRQUFROHlCLFNBQVMsU0FBUztnQkFDM0Q7WUFDRjtZQUVBLE9BQU9EO1FBQ1QsRUFBRSxzQkFBc0I7UUFHeEIsU0FBU0UsV0FBV0MsYUFBYSxFQUFFQyxjQUFjO1lBQy9DLElBQUlDLE1BQU1GLGNBQWNockMsUUFBUSxDQUFDLE1BQU1pckMsZUFBZWpyQyxRQUFRLENBQUM7WUFDL0QsT0FBT3VtQyxtQkFBbUIxL0IsT0FBTyxDQUFDcWtDLFNBQVMsQ0FBQztRQUM5QztRQUVBLFNBQVNDLGtCQUFrQkMsUUFBUTtZQUNqQyxPQUFPQSxhQUFhaEY7UUFDdEIsRUFBRSx1RUFBdUU7UUFDekUseUVBQXlFO1FBQ3pFLGdFQUFnRTtRQUdoRSxTQUFTaUYsb0JBQW9CRCxRQUFRO1lBQ25DLE9BQU9BLGFBQWFqRjtRQUN0QixFQUFFLG9FQUFvRTtRQUN0RSxxRUFBcUU7UUFDckUsNEVBQTRFO1FBRzVFLFNBQVNtRixlQUFlVixNQUFNO1lBQzVCLElBQUlDLFlBQVlGLGFBQWFDO1lBRTdCLElBQUlDLGFBQWF4RSxtQ0FBbUN3RSxhQUFhdkUsaUNBQWlDO2dCQUNoRyxPQUFPO1lBQ1Q7WUFFQSxPQUFPO1FBQ1QsRUFBRSx1REFBdUQ7UUFDekQsNERBQTREO1FBRzVELFNBQVNpRixZQUFZWCxNQUFNO1lBQ3pCLE9BQU9VLGVBQWVWLE9BQU9sNUIsTUFBTSxDQUFDLEdBQUcsT0FBTzQ1QixlQUFlVixPQUFPbDVCLE1BQU0sQ0FBQyxHQUFHO1FBQ2hGO1FBRUEsU0FBUzg1QixvQkFBb0JDLE1BQU07WUFDakMsT0FBTzNGLG1CQUFtQmovQixPQUFPLENBQUM0a0MsWUFBWSxDQUFDO1FBQ2pELEVBQUUsb0RBQW9EO1FBQ3RELHNDQUFzQztRQUN0Qyx1Q0FBdUM7UUFHdkMsU0FBU0MsZUFBZTNDLElBQUksRUFBRXJ5QixLQUFLO1lBQ2pDLElBQUltMEIsWUFBWUYsYUFBYTVCLEtBQUtyM0IsTUFBTSxDQUFDZ0YsT0FBTztZQUVoRCxJQUFJbTBCLGNBQWM5RSx1QkFBdUI7Z0JBQ3ZDLE9BQU87WUFDVDtZQUVBLElBQUk5QyxRQUFRO1lBQ1p2c0IsU0FBUztZQUVULE1BQU91c0IsUUFBUSxFQUFHO2dCQUNoQjRILFlBQVlGLGFBQWE1QixLQUFLcjNCLE1BQU0sQ0FBQ2dGLE9BQU87Z0JBRTVDLElBQUltMEIsWUFBWTVFLG9CQUFvQjRFLFlBQVkzRSxrQkFBa0I7b0JBQ2hFLE9BQU87Z0JBQ1Q7Z0JBRUFqRCxTQUFTO2dCQUNUdnNCLFNBQVM7WUFDWDtZQUVBLE9BQU9pMEIsYUFBYTVCLEtBQUtyM0IsTUFBTSxDQUFDZ0YsT0FBTyxRQUFRc3ZCO1FBQ2pEO1FBRUEsU0FBUzJGO1lBQ1AsSUFBSSxDQUFDMThCLFFBQVEsR0FBRztRQUNsQjtRQUVBLElBQUkyOEIsT0FBTyxTQUFTQTtZQUNsQixJQUFJLENBQUN4NUIsS0FBSyxHQUFHLEVBQUU7WUFDZixJQUFJLENBQUMxTyxLQUFLLEdBQUc7WUFDYixJQUFJLENBQUNtb0MsYUFBYSxHQUFHO1lBQ3JCLElBQUksQ0FBQzU4QixRQUFRLEdBQUc7WUFDaEIsSUFBSSxDQUFDbTdCLE9BQU8sR0FBRztZQUNmLElBQUksQ0FBQ3R6QixRQUFRLEdBQUdpeEIsS0FBS0MsR0FBRztZQUN4QixJQUFJLENBQUNFLGlCQUFpQixHQUFHLElBQUksQ0FBQ3lELFdBQVcsQ0FBQ2hoQyxJQUFJLENBQUMsSUFBSTtZQUNuRCxJQUFJLENBQUNzOUIsc0JBQXNCLEdBQUcsSUFBSSxDQUFDVCxnQkFBZ0IsQ0FBQzc4QixJQUFJLENBQUMsSUFBSTtRQUMvRDtRQUVBaWhDLEtBQUtiLFVBQVUsR0FBR0E7UUFDbEJhLEtBQUtULGlCQUFpQixHQUFHQTtRQUN6QlMsS0FBS0wsV0FBVyxHQUFHQTtRQUNuQkssS0FBS04sY0FBYyxHQUFHQTtRQUN0Qk0sS0FBS0osbUJBQW1CLEdBQUdBO1FBQzNCSSxLQUFLRixjQUFjLEdBQUdBO1FBQ3RCRSxLQUFLUCxtQkFBbUIsR0FBR0E7UUFDM0JPLEtBQUs3RixxQkFBcUIsR0FBR0E7UUFDN0IsSUFBSStGLGdCQUFnQjtZQUNsQng1QixVQUFVQTtZQUNWQyxVQUFVQTtZQUNWdzNCLGFBQWFBO1lBQ2JRLGVBQWVBO1lBQ2Z0QixhQUFhQTtZQUNiekIsa0JBQWtCQTtZQUNsQm1FLGFBQWFBO1FBQ2Y7UUFDQUMsS0FBS2gxQyxTQUFTLEdBQUdrMUM7UUFDakIsT0FBT0Y7SUFDVDtJQUVBLFNBQVNHLFlBQVk5bUMsYUFBYTtRQUNoQyxJQUFJLENBQUNBLGFBQWEsR0FBR0E7SUFDdkI7SUFFQThtQyxZQUFZbjFDLFNBQVMsQ0FBQ2d5QixPQUFPLEdBQUcsU0FBVXJuQixJQUFJO1FBQzVDLElBQUksSUFBSSxDQUFDMEQsYUFBYSxDQUFDK21DLEtBQUssSUFBSSxJQUFJLENBQUMvbUMsYUFBYSxDQUFDK21DLEtBQUssQ0FBQ3pxQyxLQUFLc25CLEdBQUcsQ0FBQyxFQUFFO1lBQ2xFLE9BQU8veEIsT0FBT20xQyxNQUFNLENBQUMxcUMsTUFBTSxJQUFJLENBQUMwRCxhQUFhLENBQUMrbUMsS0FBSyxDQUFDenFDLEtBQUtzbkIsR0FBRyxDQUFDLENBQUMzcEIsQ0FBQztRQUNqRTtRQUVBLE9BQU9xQztJQUNUO0lBRUEsU0FBUzJxQyxZQUFZam5DLGFBQWE7UUFDaEMsT0FBTyxJQUFJOG1DLFlBQVk5bUM7SUFDekI7SUFFQSxTQUFTa25DLHFCQUFxQjtJQUU5QkEsa0JBQWtCdjFDLFNBQVMsR0FBRztRQUM1QncxQyxnQkFBZ0IsU0FBU0E7WUFDdkIsb0ZBQW9GO1lBQ3BGLElBQUksQ0FBQ0MsU0FBUyxHQUFHLE9BQU8sd0JBQXdCO1lBRWhELElBQUksQ0FBQ0MsTUFBTSxHQUFHLE9BQU8scURBQXFEO1lBRTFFLElBQUksQ0FBQ0MsYUFBYSxHQUFHLE9BQU8sOEJBQThCO1lBRTFELElBQUksQ0FBQ0Msb0JBQW9CLEdBQUcsRUFBRTtRQUNoQztRQUNBQyx3QkFBd0IsU0FBU0EsdUJBQXVCQyxTQUFTO1lBQy9ELElBQUksSUFBSSxDQUFDRixvQkFBb0IsQ0FBQzNsQyxPQUFPLENBQUM2bEMsZUFBZSxDQUFDLEdBQUc7Z0JBQ3ZELElBQUksQ0FBQ0Ysb0JBQW9CLENBQUN6MEMsSUFBSSxDQUFDMjBDO1lBQ2pDO1FBQ0Y7UUFDQUMsMkJBQTJCLFNBQVNBLDBCQUEwQkQsU0FBUztZQUNyRSxJQUFJLElBQUksQ0FBQ0Ysb0JBQW9CLENBQUMzbEMsT0FBTyxDQUFDNmxDLGVBQWUsQ0FBQyxHQUFHO2dCQUN2RCxJQUFJLENBQUNGLG9CQUFvQixDQUFDNS9CLE1BQU0sQ0FBQyxJQUFJLENBQUM0L0Isb0JBQW9CLENBQUMzbEMsT0FBTyxDQUFDNmxDLFlBQVk7WUFDakY7UUFDRjtRQUNBRSx3QkFBd0IsU0FBU0EsdUJBQXVCQyxHQUFHO1lBQ3pELElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNEO1FBQ3hCO1FBQ0FFLG1CQUFtQixTQUFTQTtZQUMxQixJQUFJLElBQUksQ0FBQ0MsY0FBYyxDQUFDQyxLQUFLLENBQUM1b0MsQ0FBQyxDQUFDeEYsQ0FBQyxJQUFJLEdBQUc7Z0JBQ3RDLElBQUksQ0FBQyxJQUFJLENBQUMwdEMsYUFBYSxJQUFJLElBQUksQ0FBQ3Q3QixVQUFVLENBQUNpOEIsWUFBWSxDQUFDQyxpQkFBaUIsRUFBRTtvQkFDekUsSUFBSSxDQUFDWixhQUFhLEdBQUc7b0JBQ3JCLElBQUksQ0FBQ2oyQixJQUFJO2dCQUNYO1lBQ0YsT0FBTyxJQUFJLElBQUksQ0FBQ2kyQixhQUFhLEVBQUU7Z0JBQzdCLElBQUksQ0FBQ0EsYUFBYSxHQUFHO2dCQUNyQixJQUFJLENBQUNoMkIsSUFBSTtZQUNYO1FBQ0Y7UUFFQTs7Ozs7OztPQU9HLEdBQ0h1MkIsa0JBQWtCLFNBQVNBLGlCQUFpQkQsR0FBRztZQUM3QyxJQUFJLElBQUksQ0FBQ3RyQyxJQUFJLENBQUM2RCxFQUFFLEdBQUcsSUFBSSxDQUFDN0QsSUFBSSxDQUFDK0QsRUFBRSxJQUFJdW5DLE9BQU8sSUFBSSxDQUFDdHJDLElBQUksQ0FBQzhELEVBQUUsR0FBRyxJQUFJLENBQUM5RCxJQUFJLENBQUMrRCxFQUFFLEdBQUd1bkMsS0FBSztnQkFDM0UsSUFBSSxJQUFJLENBQUNSLFNBQVMsS0FBSyxNQUFNO29CQUMzQixJQUFJLENBQUNwN0IsVUFBVSxDQUFDd1csSUFBSSxHQUFHO29CQUN2QixJQUFJLENBQUNBLElBQUksR0FBRztvQkFDWixJQUFJLENBQUM0a0IsU0FBUyxHQUFHO29CQUNqQixJQUFJLENBQUM5MUIsSUFBSTtnQkFDWDtZQUNGLE9BQU8sSUFBSSxJQUFJLENBQUM4MUIsU0FBUyxLQUFLLE9BQU87Z0JBQ25DLElBQUksQ0FBQ3A3QixVQUFVLENBQUN3VyxJQUFJLEdBQUc7Z0JBQ3ZCLElBQUksQ0FBQzRrQixTQUFTLEdBQUc7Z0JBQ2pCLElBQUksQ0FBQy8xQixJQUFJO1lBQ1g7UUFDRjtRQUNBODJCLGtCQUFrQixTQUFTQTtZQUN6QixJQUFJNTJDO1lBQ0osSUFBSUMsTUFBTSxJQUFJLENBQUMrMUMsb0JBQW9CLENBQUM5MUMsTUFBTTtZQUUxQyxJQUFLRixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztnQkFDM0IsSUFBSSxDQUFDZzJDLG9CQUFvQixDQUFDaDJDLEVBQUUsQ0FBQ3dkLFdBQVcsQ0FBQyxJQUFJLENBQUM4VCxhQUFhO1lBQzdEO1FBQ0E7eUVBQ21FLEdBRXJFO1FBQ0F1bEIsa0JBQWtCLFNBQVNBO1lBQ3pCLE9BQU87Z0JBQ0wxd0MsS0FBSztnQkFDTEMsTUFBTTtnQkFDTm9NLE9BQU87Z0JBQ1BDLFFBQVE7WUFDVjtRQUNGO1FBQ0Fxa0MsY0FBYyxTQUFTQTtZQUNyQixJQUFJLElBQUksQ0FBQy9yQyxJQUFJLENBQUM0QixFQUFFLEtBQUssR0FBRztnQkFDdEIsT0FBTztvQkFDTDRqQixHQUFHLElBQUksQ0FBQ3hsQixJQUFJLENBQUNnc0MsUUFBUSxDQUFDdmtDLEtBQUs7b0JBQzNCckssR0FBRyxJQUFJLENBQUM0QyxJQUFJLENBQUNnc0MsUUFBUSxDQUFDdGtDLE1BQU07Z0JBQzlCO1lBQ0Y7WUFFQSxPQUFPO2dCQUNMOGQsR0FBRyxJQUFJLENBQUN4bEIsSUFBSSxDQUFDeUgsS0FBSztnQkFDbEJySyxHQUFHLElBQUksQ0FBQzRDLElBQUksQ0FBQzBILE1BQU07WUFDckI7UUFDRjtJQUNGO0lBRUEsSUFBSXVrQyxlQUFlO1FBQ2pCLElBQUlDLGlCQUFpQjtZQUNuQixHQUFHO1lBQ0gsR0FBRztZQUNILEdBQUc7WUFDSCxHQUFHO1lBQ0gsR0FBRztZQUNILEdBQUc7WUFDSCxHQUFHO1lBQ0gsR0FBRztZQUNILEdBQUc7WUFDSCxHQUFHO1lBQ0gsSUFBSTtZQUNKLElBQUk7WUFDSixJQUFJO1lBQ0osSUFBSTtZQUNKLElBQUk7WUFDSixJQUFJO1FBQ047UUFDQSxPQUFPLFNBQVVDLElBQUk7WUFDbkIsT0FBT0QsY0FBYyxDQUFDQyxLQUFLLElBQUk7UUFDakM7SUFDRjtJQUVBLFNBQVNDLGFBQWFwc0MsSUFBSSxFQUFFZ1csSUFBSSxFQUFFMUcsU0FBUztRQUN6QyxJQUFJLENBQUMzUixDQUFDLEdBQUd5cEIsZ0JBQWdCQyxPQUFPLENBQUNyUixNQUFNaFcsS0FBSzFDLENBQUMsRUFBRSxHQUFHLEdBQUdnUztJQUN2RDtJQUVBLFNBQVMrOEIsWUFBWXJzQyxJQUFJLEVBQUVnVyxJQUFJLEVBQUUxRyxTQUFTO1FBQ3hDLElBQUksQ0FBQzNSLENBQUMsR0FBR3lwQixnQkFBZ0JDLE9BQU8sQ0FBQ3JSLE1BQU1oVyxLQUFLMUMsQ0FBQyxFQUFFLEdBQUcsR0FBR2dTO0lBQ3ZEO0lBRUEsU0FBU2c5QixZQUFZdHNDLElBQUksRUFBRWdXLElBQUksRUFBRTFHLFNBQVM7UUFDeEMsSUFBSSxDQUFDM1IsQ0FBQyxHQUFHeXBCLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUsxQyxDQUFDLEVBQUUsR0FBRyxHQUFHZ1M7SUFDdkQ7SUFFQSxTQUFTaTlCLFlBQVl2c0MsSUFBSSxFQUFFZ1csSUFBSSxFQUFFMUcsU0FBUztRQUN4QyxJQUFJLENBQUMzUixDQUFDLEdBQUd5cEIsZ0JBQWdCQyxPQUFPLENBQUNyUixNQUFNaFcsS0FBSzFDLENBQUMsRUFBRSxHQUFHLEdBQUdnUztJQUN2RDtJQUVBLFNBQVNrOUIsaUJBQWlCeHNDLElBQUksRUFBRWdXLElBQUksRUFBRTFHLFNBQVM7UUFDN0MsSUFBSSxDQUFDM1IsQ0FBQyxHQUFHeXBCLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUsxQyxDQUFDLEVBQUUsR0FBRyxHQUFHZ1M7SUFDdkQ7SUFFQSxTQUFTbTlCLGdCQUFnQnpzQyxJQUFJLEVBQUVnVyxJQUFJLEVBQUUxRyxTQUFTO1FBQzVDLElBQUksQ0FBQzNSLENBQUMsR0FBR3lwQixnQkFBZ0JDLE9BQU8sQ0FBQ3JSLE1BQU1oVyxLQUFLMUMsQ0FBQyxFQUFFLEdBQUcsR0FBR2dTO0lBQ3ZEO0lBRUEsU0FBU285QixlQUFlMXNDLElBQUksRUFBRWdXLElBQUksRUFBRTFHLFNBQVM7UUFDM0MsSUFBSSxDQUFDM1IsQ0FBQyxHQUFHeXBCLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUsxQyxDQUFDLEVBQUUsR0FBRyxHQUFHZ1M7SUFDdkQ7SUFFQSxTQUFTcTlCO1FBQ1AsSUFBSSxDQUFDaHZDLENBQUMsR0FBRyxDQUFDO0lBQ1o7SUFFQSxTQUFTaXZDLGVBQWU1c0MsSUFBSSxFQUFFL0UsT0FBTztRQUNuQyxJQUFJNHhDLFVBQVU3c0MsS0FBSzhzQyxFQUFFLElBQUksRUFBRTtRQUMzQixJQUFJLENBQUNDLGNBQWMsR0FBRyxFQUFFO1FBQ3hCLElBQUk5M0M7UUFDSixJQUFJQyxNQUFNMjNDLFFBQVExM0MsTUFBTTtRQUN4QixJQUFJNjNDO1FBRUosSUFBSy8zQyxJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQiszQyxhQUFhLElBQUlDLFlBQVlKLE9BQU8sQ0FBQzUzQyxFQUFFLEVBQUVnRztZQUN6QyxJQUFJLENBQUM4eEMsY0FBYyxDQUFDdjJDLElBQUksQ0FBQ3cyQztRQUMzQjtJQUNGO0lBRUEsU0FBU0MsWUFBWWp0QyxJQUFJLEVBQUUvRSxPQUFPO1FBQ2hDLElBQUksQ0FBQ2laLElBQUksQ0FBQ2xVLE1BQU0vRTtJQUNsQjtJQUVBbkcsZ0JBQWdCO1FBQUMweUI7S0FBeUIsRUFBRXlsQjtJQUM1Q0EsWUFBWTUzQyxTQUFTLENBQUMweEIsUUFBUSxHQUFHa21CLFlBQVk1M0MsU0FBUyxDQUFDc3lCLHdCQUF3QjtJQUUvRXNsQixZQUFZNTNDLFNBQVMsQ0FBQzZlLElBQUksR0FBRyxTQUFVbFUsSUFBSSxFQUFFL0UsT0FBTztRQUNsRCxJQUFJLENBQUMrRSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDK3NDLGNBQWMsR0FBRyxFQUFFO1FBQ3hCLElBQUksQ0FBQ25sQiw0QkFBNEIsQ0FBQzNzQjtRQUNsQyxJQUFJaEc7UUFDSixJQUFJQyxNQUFNLElBQUksQ0FBQzhLLElBQUksQ0FBQzhzQyxFQUFFLENBQUMzM0MsTUFBTTtRQUM3QixJQUFJKzNDO1FBQ0osSUFBSUwsVUFBVSxJQUFJLENBQUM3c0MsSUFBSSxDQUFDOHNDLEVBQUU7UUFFMUIsSUFBSzczQyxJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQmk0QyxNQUFNO1lBRU4sT0FBUUwsT0FBTyxDQUFDNTNDLEVBQUUsQ0FBQzJNLEVBQUU7Z0JBQ25CLEtBQUs7b0JBQ0hzckMsTUFBTSxJQUFJZCxhQUFhUyxPQUFPLENBQUM1M0MsRUFBRSxFQUFFZ0csU0FBUyxJQUFJO29CQUNoRDtnQkFFRixLQUFLO29CQUNIaXlDLE1BQU0sSUFBSWIsWUFBWVEsT0FBTyxDQUFDNTNDLEVBQUUsRUFBRWdHLFNBQVMsSUFBSTtvQkFDL0M7Z0JBRUYsS0FBSztvQkFDSGl5QyxNQUFNLElBQUlaLFlBQVlPLE9BQU8sQ0FBQzUzQyxFQUFFLEVBQUVnRyxTQUFTLElBQUk7b0JBQy9DO2dCQUVGLEtBQUs7b0JBQ0hpeUMsTUFBTSxJQUFJWCxZQUFZTSxPQUFPLENBQUM1M0MsRUFBRSxFQUFFZ0csU0FBUyxJQUFJO29CQUMvQztnQkFFRixLQUFLO2dCQUNMLEtBQUs7b0JBQ0hpeUMsTUFBTSxJQUFJUixlQUFlRyxPQUFPLENBQUM1M0MsRUFBRSxFQUFFZ0csU0FBUyxJQUFJO29CQUNsRDtnQkFFRixLQUFLO29CQUNIaXlDLE1BQU0sSUFBSVYsaUJBQWlCSyxPQUFPLENBQUM1M0MsRUFBRSxFQUFFZ0csU0FBUyxJQUFJO29CQUNwRDtnQkFFRixLQUFLO29CQUNIaXlDLE1BQU0sSUFBSVQsZ0JBQWdCSSxPQUFPLENBQUM1M0MsRUFBRSxFQUFFZ0csU0FBUyxJQUFJO29CQUNuRDtnQkFFRixLQUFLO29CQUNIaXlDLE1BQU0sSUFBSU4sZUFBZUMsT0FBTyxDQUFDNTNDLEVBQUUsRUFBRWdHLFNBQVMsSUFBSTtvQkFDbEQ7Z0JBQ0YsVUFBVTtnQkFFVjtvQkFDRWl5QyxNQUFNLElBQUlQLGNBQWNFLE9BQU8sQ0FBQzUzQyxFQUFFLEVBQUVnRyxTQUFTLElBQUk7b0JBQ2pEO1lBQ0o7WUFFQSxJQUFJaXlDLEtBQUs7Z0JBQ1AsSUFBSSxDQUFDSCxjQUFjLENBQUN2MkMsSUFBSSxDQUFDMDJDO1lBQzNCO1FBQ0Y7SUFDRjtJQUVBLFNBQVNDLGVBQWU7SUFFeEJBLFlBQVk5M0MsU0FBUyxHQUFHO1FBQ3RCKzNDLFlBQVksU0FBU0E7WUFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQ3B0QyxJQUFJLENBQUN1QixPQUFPLEVBQUU7Z0JBQ3RCLE9BQU87WUFDVDtZQUVBLElBQUl0TSxJQUFJO1lBQ1IsSUFBSUMsTUFBTSxJQUFJLENBQUM4SyxJQUFJLENBQUN5QixlQUFlLENBQUN0TSxNQUFNO1lBRTFDLE1BQU9GLElBQUlDLElBQUs7Z0JBQ2QsSUFBSSxJQUFJLENBQUM4SyxJQUFJLENBQUN5QixlQUFlLENBQUN4TSxFQUFFLENBQUNrM0MsSUFBSSxLQUFLLE9BQU8sSUFBSSxDQUFDbnNDLElBQUksQ0FBQ3lCLGVBQWUsQ0FBQ3hNLEVBQUUsQ0FBQzJQLEVBQUUsS0FBSyxPQUFPO29CQUMxRixPQUFPO2dCQUNUO2dCQUVBM1AsS0FBSztZQUNQO1lBRUEsT0FBTztRQUNUO1FBQ0FnYyxpQkFBaUIsU0FBU0E7WUFDeEIsSUFBSWpZLHdCQUF3QitGO1lBRTVCLElBQUksQ0FBQy9GLHVCQUF1QjtnQkFDMUI7WUFDRjtZQUVBLElBQUlxMEMsMkJBQTJCcjBDLHNCQUFzQjtZQUNyRCxJQUFJczBDLDZCQUE2QnQwQyxzQkFBc0I7WUFDdkQsSUFBSXUwQywyQkFBMkJ2MEMsc0JBQXNCO1lBQ3JELElBQUl3MEMsMEJBQTBCeDBDLHNCQUFzQjtZQUNwRCxJQUFJeTBDLDBCQUEwQnowQyxzQkFBc0I7WUFDcEQsSUFBSSxDQUFDMDBDLGNBQWMsR0FBR0wseUJBQXlCLElBQUk7WUFFbkQsSUFBSSxJQUFJLENBQUNydEMsSUFBSSxDQUFDdUIsT0FBTyxJQUFJLElBQUksQ0FBQ29zQyxXQUFXLEVBQUU7Z0JBQ3pDLElBQUksQ0FBQ0QsY0FBYyxDQUFDRSxxQkFBcUIsQ0FBQyxJQUFJLENBQUNELFdBQVc7WUFDNUQ7WUFFQSxJQUFJRSxtQkFBbUJQLDJCQUEyQlEsc0JBQXNCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQ0osY0FBYztZQUNsRyxJQUFJLENBQUNBLGNBQWMsQ0FBQ0ssd0JBQXdCLENBQUNGO1lBRTdDLElBQUksSUFBSSxDQUFDN3RDLElBQUksQ0FBQzRCLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQzVCLElBQUksQ0FBQ2dOLEVBQUUsRUFBRTtnQkFDdEMsSUFBSSxDQUFDRSxhQUFhLEdBQUd1Z0Msd0JBQXdCLElBQUk7WUFDbkQsT0FBTyxJQUFJLElBQUksQ0FBQ3p0QyxJQUFJLENBQUM0QixFQUFFLEtBQUssR0FBRztnQkFDN0IsSUFBSSxDQUFDOHJDLGNBQWMsQ0FBQ00sY0FBYyxHQUFHVCx5QkFBeUIsSUFBSSxDQUFDVSxVQUFVLEVBQUUsSUFBSSxDQUFDQyxTQUFTLEVBQUUsSUFBSSxDQUFDUixjQUFjO2dCQUNsSCxJQUFJLENBQUNBLGNBQWMsQ0FBQ1MsT0FBTyxHQUFHLElBQUksQ0FBQ1QsY0FBYyxDQUFDTSxjQUFjO1lBQ2xFLE9BQU8sSUFBSSxJQUFJLENBQUNodUMsSUFBSSxDQUFDNEIsRUFBRSxLQUFLLEdBQUc7Z0JBQzdCLElBQUksQ0FBQzhyQyxjQUFjLENBQUNVLGFBQWEsR0FBR1osd0JBQXdCLElBQUk7Z0JBQ2hFLElBQUksQ0FBQ0UsY0FBYyxDQUFDbEcsSUFBSSxHQUFHLElBQUksQ0FBQ2tHLGNBQWMsQ0FBQ1UsYUFBYTtZQUM5RDtRQUNGO1FBQ0FDLGNBQWMsU0FBU0E7WUFDckIsSUFBSUMsaUJBQWlCckMsYUFBYSxJQUFJLENBQUNqc0MsSUFBSSxDQUFDdXVDLEVBQUU7WUFDOUMsSUFBSXY0QixPQUFPLElBQUksQ0FBQ3c0QixXQUFXLElBQUksSUFBSSxDQUFDQyxZQUFZO1lBQ2hEejRCLEtBQUs5YSxLQUFLLENBQUMsaUJBQWlCLEdBQUdvekM7UUFDakM7UUFDQUksY0FBYyxTQUFTQSxhQUFhMXVDLElBQUksRUFBRTBQLFVBQVUsRUFBRW5OLElBQUk7WUFDeEQsSUFBSSxDQUFDbU4sVUFBVSxHQUFHQTtZQUNsQixJQUFJLENBQUNuTixJQUFJLEdBQUdBO1lBQ1osSUFBSSxDQUFDdkMsSUFBSSxHQUFHQTtZQUNaLElBQUksQ0FBQzJ1QyxPQUFPLEdBQUczeEMsbUJBQW1CLDJEQUEyRDtZQUU3RixJQUFJLENBQUMsSUFBSSxDQUFDZ0QsSUFBSSxDQUFDZ0UsRUFBRSxFQUFFO2dCQUNqQixJQUFJLENBQUNoRSxJQUFJLENBQUNnRSxFQUFFLEdBQUc7WUFDakIsRUFBRSxrQkFBa0I7WUFHcEIsSUFBSSxDQUFDNHFDLGNBQWMsR0FBRyxJQUFJaEMsZUFBZSxJQUFJLENBQUM1c0MsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUN5bkIsaUJBQWlCO1FBQ2xGO1FBQ0FvbkIsU0FBUyxTQUFTQTtZQUNoQixPQUFPLElBQUksQ0FBQ2w2QyxJQUFJO1FBQ2xCO1FBQ0FtM0Msa0JBQWtCLFNBQVNBLG9CQUFvQjtJQUNqRDtJQUVBOzs7OztHQUtDLEdBQ0QsU0FBU2dELGdCQUFnQjtJQUV6QkEsYUFBYXo1QyxTQUFTLEdBQUc7UUFDdkI7Ozs7T0FJRyxHQUNIc3JCLFdBQVcsU0FBU0E7WUFDbEIsdUNBQXVDO1lBQ3ZDLElBQUksQ0FBQzRGLGFBQWEsR0FBRyxPQUFPLDhCQUE4QjtZQUUxRCxJQUFJLENBQUNrQixpQkFBaUIsR0FBRyxFQUFFLEVBQUUsK0RBQStEO1lBRTVGLElBQUksQ0FBQ3ZCLElBQUksR0FBRztRQUNkO1FBRUE7Ozs7Ozs7OztPQVNHLEdBQ0g2b0IsbUJBQW1CLFNBQVNBLGtCQUFrQnpELEdBQUcsRUFBRTBELFNBQVM7WUFDMUQsSUFBSS81QztZQUNKLElBQUlDLE1BQU0sSUFBSSxDQUFDdXlCLGlCQUFpQixDQUFDdHlCLE1BQU07WUFFdkMsSUFBS0YsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7Z0JBQzNCLElBQUkrNUMsYUFBYSxJQUFJLENBQUNDLFNBQVMsSUFBSSxJQUFJLENBQUN4bkIsaUJBQWlCLENBQUN4eUIsRUFBRSxDQUFDaXNCLFFBQVEsS0FBSyxhQUFhO29CQUNyRixJQUFJLENBQUN1RyxpQkFBaUIsQ0FBQ3h5QixFQUFFLENBQUM4eEIsUUFBUTtvQkFFbEMsSUFBSSxJQUFJLENBQUNVLGlCQUFpQixDQUFDeHlCLEVBQUUsQ0FBQ2l4QixJQUFJLEVBQUU7d0JBQ2xDLElBQUksQ0FBQ3hXLFVBQVUsQ0FBQ3dXLElBQUksR0FBRzt3QkFDdkIsSUFBSSxDQUFDQSxJQUFJLEdBQUc7b0JBQ2Q7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0FVLG9CQUFvQixTQUFTQSxtQkFBbUJoeEIsSUFBSTtZQUNsRCxJQUFJLElBQUksQ0FBQzZ4QixpQkFBaUIsQ0FBQ25pQixPQUFPLENBQUMxUCxVQUFVLENBQUMsR0FBRztnQkFDL0MsSUFBSSxDQUFDNnhCLGlCQUFpQixDQUFDanhCLElBQUksQ0FBQ1o7WUFDOUI7UUFDRjtJQUNGO0lBRUEsU0FBU3M1QyxlQUFlbHZDLElBQUksRUFBRTBQLFVBQVUsRUFBRW5OLElBQUk7UUFDNUMsSUFBSSxDQUFDb2UsU0FBUztRQUNkLElBQUksQ0FBQ2txQixjQUFjO1FBQ25CLElBQUksQ0FBQ3RpQyxTQUFTLEdBQUdtSCxXQUFXb0YsWUFBWSxDQUFDOVUsS0FBSzhCLEtBQUs7UUFDbkQsSUFBSSxDQUFDaUksV0FBVyxHQUFHMkYsV0FBV3kvQixXQUFXLENBQUM1a0MsUUFBUSxDQUFDLElBQUksQ0FBQ2hDLFNBQVM7UUFDakUsSUFBSSxDQUFDbW1DLFlBQVksQ0FBQzF1QyxNQUFNMFAsWUFBWW5OO0lBQ3RDO0lBRUEyc0MsZUFBZTc1QyxTQUFTLENBQUMwWCxZQUFZLEdBQUcsWUFBYTtJQUVyRGpZLGdCQUFnQjtRQUFDODFDO1FBQW1CdUM7UUFBYTJCO0tBQWEsRUFBRUk7SUFFaEVBLGVBQWU3NUMsU0FBUyxDQUFDKzVDLGNBQWMsR0FBRztRQUN4QyxPQUFPO0lBQ1Q7SUFFQUYsZUFBZTc1QyxTQUFTLENBQUNvZCxXQUFXLEdBQUcsWUFBYTtJQUVwRHk4QixlQUFlNzVDLFNBQVMsQ0FBQ21WLE9BQU8sR0FBRyxZQUFhO0lBRWhEMGtDLGVBQWU3NUMsU0FBUyxDQUFDNGIsZUFBZSxHQUFHO1FBQ3pDLElBQUlqWSx3QkFBd0IrRjtRQUU1QixJQUFJLENBQUMvRix1QkFBdUI7WUFDMUI7UUFDRjtRQUVBLElBQUlxMkMsbUJBQW1CcjJDLHNCQUFzQjtRQUM3QyxJQUFJLENBQUMwMEMsY0FBYyxHQUFHMkIsaUJBQWlCLElBQUk7SUFDN0M7SUFFQUgsZUFBZTc1QyxTQUFTLENBQUNpNkMsY0FBYyxHQUFHO1FBQ3hDLE9BQU8sSUFBSSxDQUFDdmxDLFdBQVc7SUFDekI7SUFFQSxTQUFTd2xDLGFBQWF2dkMsSUFBSSxFQUFFMFAsVUFBVSxFQUFFbk4sSUFBSTtRQUMxQyxJQUFJLENBQUNvZSxTQUFTO1FBQ2QsSUFBSSxDQUFDa3FCLGNBQWM7UUFDbkIsSUFBSSxDQUFDdGlDLFNBQVMsR0FBR21ILFdBQVdvRixZQUFZLENBQUM5VSxLQUFLOEIsS0FBSztRQUNuRCxJQUFJLENBQUM0c0MsWUFBWSxDQUFDMXVDLE1BQU0wUCxZQUFZbk47UUFDcEMsSUFBSSxDQUFDaXRDLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJMzRDLFlBQVksSUFBSSxDQUFDNFksVUFBVSxDQUFDcEgsYUFBYSxDQUFDLElBQUksQ0FBQ0MsU0FBUztRQUM1RCxJQUFJLENBQUNoUyxLQUFLLEdBQUcsSUFBSSxDQUFDbVosVUFBVSxDQUFDWixlQUFlLENBQUNqWSxXQUFXLENBQUNDO1FBQ3pELElBQUksQ0FBQzQ0QyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDaGdDLFVBQVUsQ0FBQ1osZUFBZSxDQUFDeFksUUFBUSxDQUFDLElBQUk7UUFDN0MsSUFBSSxDQUFDcTVDLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ3Y1QyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUN3NUMsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ3pqQyxFQUFFLEdBQUduTSxLQUFLbU0sRUFBRSxHQUFHaWIsZ0JBQWdCQyxPQUFPLENBQUMsSUFBSSxFQUFFcm5CLEtBQUttTSxFQUFFLEVBQUUsR0FBR3VELFdBQVc5QixTQUFTLEVBQUUsSUFBSSxJQUFJO1lBQzFGaWlDLGNBQWM7UUFDaEI7UUFDQSxJQUFJLENBQUNDLEVBQUUsR0FBRzFvQixnQkFBZ0JDLE9BQU8sQ0FBQyxJQUFJLEVBQUVybkIsS0FBSyt2QyxFQUFFLElBQUkvdkMsS0FBSyt2QyxFQUFFLENBQUNELEVBQUUsR0FBRzl2QyxLQUFLK3ZDLEVBQUUsQ0FBQ0QsRUFBRSxHQUFHO1lBQzNFMXVDLEdBQUc7Z0JBQUM7YUFBSTtRQUNWLEdBQUcsR0FBRyxNQUFNLElBQUk7SUFDbEI7SUFFQW11QyxhQUFhbDZDLFNBQVMsQ0FBQzBYLFlBQVksR0FBRyxTQUFVdStCLEdBQUc7UUFDakQsSUFBSSxDQUFDRCxzQkFBc0IsQ0FBQ0MsS0FBSztRQUNqQyxJQUFJLENBQUN5RCxpQkFBaUIsQ0FBQ3pELEtBQUs7UUFFNUIsSUFBSSxDQUFDLElBQUksQ0FBQ24vQixFQUFFLENBQUMwakMsWUFBWSxFQUFFO1lBQ3pCLElBQUlHLGVBQWUsSUFBSSxDQUFDN2pDLEVBQUUsQ0FBQzdPLENBQUM7WUFDNUIsSUFBSSxDQUFDb3lDLFlBQVksR0FBR007UUFDdEIsT0FBTztZQUNMLElBQUksQ0FBQ04sWUFBWSxHQUFHcEUsTUFBTSxJQUFJLENBQUN0ckMsSUFBSSxDQUFDZ0UsRUFBRTtRQUN4QztRQUVBLElBQUksQ0FBQzVOLE9BQU8sR0FBRyxJQUFJLENBQUMwNUMsRUFBRSxDQUFDeHlDLENBQUMsQ0FBQyxFQUFFO1FBQzNCLElBQUkyeUMsY0FBYyxJQUFJLENBQUM3NUMsT0FBTyxHQUFHLElBQUksQ0FBQ3U1QyxpQkFBaUI7UUFFdkQsSUFBSSxJQUFJLENBQUNDLGVBQWUsS0FBS0ssYUFBYTtZQUN4QyxJQUFJLENBQUNMLGVBQWUsR0FBR0s7WUFDdkIsSUFBSSxDQUFDMTVDLEtBQUssQ0FBQ3NCLE1BQU0sQ0FBQ280QztRQUNwQjtJQUNGO0lBRUFuN0MsZ0JBQWdCO1FBQUM4MUM7UUFBbUJ1QztRQUFhMkI7S0FBYSxFQUFFUztJQUVoRUEsYUFBYWw2QyxTQUFTLENBQUNvZCxXQUFXLEdBQUc7UUFDbkMsSUFBSSxJQUFJLENBQUNxNEIsU0FBUyxJQUFJLElBQUksQ0FBQzJFLFFBQVEsRUFBRTtZQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDRCxVQUFVLEVBQUU7Z0JBQ3BCLElBQUksQ0FBQ2o1QyxLQUFLLENBQUNZLElBQUk7Z0JBQ2YsSUFBSSxDQUFDWixLQUFLLENBQUNhLElBQUksQ0FBQyxJQUFJLENBQUNzNEMsWUFBWSxHQUFHLElBQUksQ0FBQ2hnQyxVQUFVLENBQUM5QixTQUFTO2dCQUM3RCxJQUFJLENBQUM0aEMsVUFBVSxHQUFHO1lBQ3BCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQ2o1QyxLQUFLLENBQUNjLE9BQU8sTUFBTWtDLEtBQUtjLEdBQUcsQ0FBQyxJQUFJLENBQUNxMUMsWUFBWSxHQUFHLElBQUksQ0FBQ2hnQyxVQUFVLENBQUM5QixTQUFTLEdBQUcsSUFBSSxDQUFDclgsS0FBSyxDQUFDYSxJQUFJLE1BQU0sS0FBSztnQkFDckgsSUFBSSxDQUFDYixLQUFLLENBQUNhLElBQUksQ0FBQyxJQUFJLENBQUNzNEMsWUFBWSxHQUFHLElBQUksQ0FBQ2hnQyxVQUFVLENBQUM5QixTQUFTO1lBQy9EO1FBQ0Y7SUFDRjtJQUVBMmhDLGFBQWFsNkMsU0FBUyxDQUFDMmYsSUFBSSxHQUFHLFlBQzlCO0lBRUF1NkIsYUFBYWw2QyxTQUFTLENBQUMwZixJQUFJLEdBQUc7UUFDNUIsSUFBSSxDQUFDeGUsS0FBSyxDQUFDRSxLQUFLO1FBQ2hCLElBQUksQ0FBQys0QyxVQUFVLEdBQUc7SUFDcEI7SUFFQUQsYUFBYWw2QyxTQUFTLENBQUNvQixLQUFLLEdBQUc7UUFDN0IsSUFBSSxDQUFDRixLQUFLLENBQUNFLEtBQUs7UUFDaEIsSUFBSSxDQUFDKzRDLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLFFBQVEsR0FBRztJQUNsQjtJQUVBRixhQUFhbDZDLFNBQVMsQ0FBQ3FCLE1BQU0sR0FBRztRQUM5QixJQUFJLENBQUMrNEMsUUFBUSxHQUFHO0lBQ2xCO0lBRUFGLGFBQWFsNkMsU0FBUyxDQUFDc0IsT0FBTyxHQUFHLFNBQVVDLFNBQVM7UUFDbEQsSUFBSSxDQUFDTCxLQUFLLENBQUNlLElBQUksQ0FBQ1Y7SUFDbEI7SUFFQTI0QyxhQUFhbDZDLFNBQVMsQ0FBQ3dDLE1BQU0sR0FBRyxTQUFVcTRDLFdBQVc7UUFDbkQsSUFBSSxDQUFDUCxpQkFBaUIsR0FBR087UUFDekIsSUFBSSxDQUFDTixlQUFlLEdBQUdNLGNBQWMsSUFBSSxDQUFDOTVDLE9BQU87UUFDakQsSUFBSSxDQUFDRyxLQUFLLENBQUNzQixNQUFNLENBQUMsSUFBSSxDQUFDKzNDLGVBQWU7SUFDeEM7SUFFQUwsYUFBYWw2QyxTQUFTLENBQUMrNUMsY0FBYyxHQUFHO1FBQ3RDLE9BQU87SUFDVDtJQUVBRyxhQUFhbDZDLFNBQVMsQ0FBQ21WLE9BQU8sR0FBRyxZQUFhO0lBRTlDK2tDLGFBQWFsNkMsU0FBUyxDQUFDeTJDLGdCQUFnQixHQUFHLFlBQWE7SUFFdkR5RCxhQUFhbDZDLFNBQVMsQ0FBQzRiLGVBQWUsR0FBRyxZQUFhO0lBRXRELFNBQVNrL0IsZ0JBQWdCO0lBRXpCQSxhQUFhOTZDLFNBQVMsQ0FBQys2QyxXQUFXLEdBQUcsU0FBVTlFLEdBQUc7UUFDaEQsSUFBSXIyQztRQUNKLElBQUlDLE1BQU0sSUFBSSxDQUFDNkwsTUFBTSxDQUFDNUwsTUFBTTtRQUM1QixJQUFJNks7UUFDSixJQUFJLENBQUNjLGNBQWMsR0FBRztRQUV0QixJQUFLN0wsSUFBSUMsTUFBTSxHQUFHRCxLQUFLLEdBQUdBLEtBQUssRUFBRztZQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDbWxDLFFBQVEsQ0FBQ25sQyxFQUFFLEVBQUU7Z0JBQ3JCK0ssT0FBTyxJQUFJLENBQUNlLE1BQU0sQ0FBQzlMLEVBQUU7Z0JBRXJCLElBQUkrSyxLQUFLNkQsRUFBRSxHQUFHN0QsS0FBSytELEVBQUUsSUFBSXVuQyxNQUFNLElBQUksQ0FBQ3ZxQyxNQUFNLENBQUM5TCxFQUFFLENBQUM4TyxFQUFFLElBQUkvRCxLQUFLOEQsRUFBRSxHQUFHOUQsS0FBSytELEVBQUUsR0FBR3VuQyxNQUFNLElBQUksQ0FBQ3ZxQyxNQUFNLENBQUM5TCxFQUFFLENBQUM4TyxFQUFFLEVBQUU7b0JBQy9GLElBQUksQ0FBQ3NzQyxTQUFTLENBQUNwN0M7Z0JBQ2pCO1lBQ0Y7WUFFQSxJQUFJLENBQUM2TCxjQUFjLEdBQUcsSUFBSSxDQUFDczVCLFFBQVEsQ0FBQ25sQyxFQUFFLEdBQUcsSUFBSSxDQUFDNkwsY0FBYyxHQUFHO1FBQ2pFO1FBRUEsSUFBSSxDQUFDd3ZDLG9CQUFvQjtJQUMzQjtJQUVBSCxhQUFhOTZDLFNBQVMsQ0FBQ2s3QyxVQUFVLEdBQUcsU0FBVUMsS0FBSztRQUNqRCxPQUFRQSxNQUFNNXVDLEVBQUU7WUFDZCxLQUFLO2dCQUNILE9BQU8sSUFBSSxDQUFDNnVDLFdBQVcsQ0FBQ0Q7WUFFMUIsS0FBSztnQkFDSCxPQUFPLElBQUksQ0FBQ0UsVUFBVSxDQUFDRjtZQUV6QixLQUFLO2dCQUNILE9BQU8sSUFBSSxDQUFDRyxXQUFXLENBQUNIO1lBRTFCLEtBQUs7Z0JBQ0gsT0FBTyxJQUFJLENBQUNJLFVBQVUsQ0FBQ0o7WUFFekIsS0FBSztnQkFDSCxPQUFPLElBQUksQ0FBQ0ssV0FBVyxDQUFDTDtZQUUxQixLQUFLO2dCQUNILE9BQU8sSUFBSSxDQUFDTSxVQUFVLENBQUNOO1lBRXpCLEtBQUs7Z0JBQ0gsT0FBTyxJQUFJLENBQUMzNUMsV0FBVyxDQUFDMjVDO1lBRTFCLEtBQUs7Z0JBQ0gsT0FBTyxJQUFJLENBQUNPLFlBQVksQ0FBQ1A7WUFFM0IsS0FBSztnQkFDSCxPQUFPLElBQUksQ0FBQ1EsYUFBYSxDQUFDUjtZQUU1QjtnQkFDRSxPQUFPLElBQUksQ0FBQ0ksVUFBVSxDQUFDSjtRQUMzQjtJQUNGO0lBRUFMLGFBQWE5NkMsU0FBUyxDQUFDMDdDLFlBQVksR0FBRztRQUNwQyxNQUFNLElBQUlsbEMsTUFBTTtJQUNsQjtJQUVBc2tDLGFBQWE5NkMsU0FBUyxDQUFDd0IsV0FBVyxHQUFHLFNBQVVtSixJQUFJO1FBQ2pELE9BQU8sSUFBSXV2QyxhQUFhdnZDLE1BQU0sSUFBSSxDQUFDMFAsVUFBVSxFQUFFLElBQUk7SUFDckQ7SUFFQXlnQyxhQUFhOTZDLFNBQVMsQ0FBQzI3QyxhQUFhLEdBQUcsU0FBVWh4QyxJQUFJO1FBQ25ELE9BQU8sSUFBSWt2QyxlQUFlbHZDLE1BQU0sSUFBSSxDQUFDMFAsVUFBVSxFQUFFLElBQUk7SUFDdkQ7SUFFQXlnQyxhQUFhOTZDLFNBQVMsQ0FBQzQ3QyxhQUFhLEdBQUc7UUFDckMsSUFBSWg4QztRQUNKLElBQUlDLE1BQU0sSUFBSSxDQUFDNkwsTUFBTSxDQUFDNUwsTUFBTTtRQUU1QixJQUFLRixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQixJQUFJLENBQUNvN0MsU0FBUyxDQUFDcDdDO1FBQ2pCO1FBRUEsSUFBSSxDQUFDcTdDLG9CQUFvQjtJQUMzQjtJQUVBSCxhQUFhOTZDLFNBQVMsQ0FBQ3NiLGFBQWEsR0FBRyxTQUFVQyxTQUFTO1FBQ3hELElBQUksQ0FBQzlQLGNBQWMsR0FBRztRQUN0QixJQUFJN0w7UUFDSixJQUFJQyxNQUFNMGIsVUFBVXpiLE1BQU07UUFDMUIsSUFBSStMO1FBQ0osSUFBSUMsT0FBTyxJQUFJLENBQUNKLE1BQU0sQ0FBQzVMLE1BQU07UUFFN0IsSUFBS0YsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDM0JpTSxJQUFJO1lBRUosTUFBT0EsSUFBSUMsS0FBTTtnQkFDZixJQUFJLElBQUksQ0FBQ0osTUFBTSxDQUFDRyxFQUFFLENBQUNvQixFQUFFLEtBQUtzTyxTQUFTLENBQUMzYixFQUFFLENBQUNxTixFQUFFLEVBQUU7b0JBQ3pDLElBQUksQ0FBQ3ZCLE1BQU0sQ0FBQ0csRUFBRSxHQUFHMFAsU0FBUyxDQUFDM2IsRUFBRTtvQkFDN0I7Z0JBQ0Y7Z0JBRUFpTSxLQUFLO1lBQ1A7UUFDRjtJQUNGO0lBRUFpdkMsYUFBYTk2QyxTQUFTLENBQUN1YSxtQkFBbUIsR0FBRyxTQUFVc2hDLFVBQVU7UUFDL0QsSUFBSSxDQUFDeGhDLFVBQVUsQ0FBQ2QsZ0JBQWdCLEdBQUdzaUM7SUFDckM7SUFFQWYsYUFBYTk2QyxTQUFTLENBQUM2YyxTQUFTLEdBQUc7UUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQ3hDLFVBQVUsQ0FBQ3loQyxlQUFlLEVBQUU7WUFDcEMsSUFBSSxDQUFDRixhQUFhO1FBQ3BCO0lBQ0Y7SUFFQWQsYUFBYTk2QyxTQUFTLENBQUMrN0MscUJBQXFCLEdBQUcsU0FBVW4yQyxPQUFPLEVBQUVvMkMsVUFBVSxFQUFFQyxTQUFTO1FBQ3JGLElBQUlsWCxXQUFXLElBQUksQ0FBQ0EsUUFBUTtRQUM1QixJQUFJcjVCLFNBQVMsSUFBSSxDQUFDQSxNQUFNO1FBQ3hCLElBQUk5TCxJQUFJO1FBQ1IsSUFBSUMsTUFBTTZMLE9BQU81TCxNQUFNO1FBRXZCLE1BQU9GLElBQUlDLElBQUs7WUFDZCxJQUFJNkwsTUFBTSxDQUFDOUwsRUFBRSxDQUFDZ3RCLEdBQUcsSUFBSW92QixZQUFZO2dCQUMvQiw2QkFBNkI7Z0JBQzdCLElBQUksQ0FBQ2pYLFFBQVEsQ0FBQ25sQyxFQUFFLElBQUltbEMsUUFBUSxDQUFDbmxDLEVBQUUsS0FBSyxNQUFNO29CQUN4QyxJQUFJLENBQUNvN0MsU0FBUyxDQUFDcDdDO29CQUNmLElBQUksQ0FBQ3M4QyxpQkFBaUIsQ0FBQ3QyQztnQkFDekIsT0FBTztvQkFDTHEyQyxVQUFVOTZDLElBQUksQ0FBQzRqQyxRQUFRLENBQUNubEMsRUFBRTtvQkFDMUJtbEMsUUFBUSxDQUFDbmxDLEVBQUUsQ0FBQ3U4QyxXQUFXO29CQUV2QixJQUFJendDLE1BQU0sQ0FBQzlMLEVBQUUsQ0FBQyt3QyxNQUFNLEtBQUtuMkIsV0FBVzt3QkFDbEMsSUFBSSxDQUFDdWhDLHFCQUFxQixDQUFDbjJDLFNBQVM4RixNQUFNLENBQUM5TCxFQUFFLENBQUMrd0MsTUFBTSxFQUFFc0w7b0JBQ3hELE9BQU87d0JBQ0xyMkMsUUFBUXcyQyxZQUFZLENBQUNIO29CQUN2QjtnQkFDRjtZQUNGO1lBRUFyOEMsS0FBSztRQUNQO0lBQ0Y7SUFFQWs3QyxhQUFhOTZDLFNBQVMsQ0FBQ2s4QyxpQkFBaUIsR0FBRyxTQUFVdDJDLE9BQU87UUFDMUQsSUFBSSxDQUFDeTJDLGVBQWUsQ0FBQ2w3QyxJQUFJLENBQUN5RTtJQUM1QjtJQUVBazFDLGFBQWE5NkMsU0FBUyxDQUFDdWMsdUJBQXVCLEdBQUcsU0FBVXhQLE1BQU07UUFDL0QsSUFBSW5OO1FBQ0osSUFBSUMsTUFBTWtOLE9BQU9qTixNQUFNO1FBRXZCLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCLElBQUltTixNQUFNLENBQUNuTixFQUFFLENBQUMrWCxFQUFFLEVBQUU7Z0JBQ2hCLElBQUl6SyxPQUFPLElBQUksQ0FBQ211QyxVQUFVLENBQUN0dUMsTUFBTSxDQUFDbk4sRUFBRTtnQkFDcENzTixLQUFLME8sZUFBZTtnQkFDcEIsSUFBSSxDQUFDdkIsVUFBVSxDQUFDZCxnQkFBZ0IsQ0FBQ2pDLG1CQUFtQixDQUFDcEs7WUFDdkQ7UUFDRjtJQUNGO0lBRUE0dEMsYUFBYTk2QyxTQUFTLENBQUNzOEMsY0FBYyxHQUFHLFNBQVUxdkIsR0FBRztRQUNuRCxJQUFJaHRCO1FBQ0osSUFBSUMsTUFBTSxJQUFJLENBQUNrbEMsUUFBUSxDQUFDamxDLE1BQU07UUFFOUIsSUFBS0YsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDM0IsSUFBSSxJQUFJLENBQUNtbEMsUUFBUSxDQUFDbmxDLEVBQUUsQ0FBQytLLElBQUksQ0FBQ2lpQixHQUFHLEtBQUtBLEtBQUs7Z0JBQ3JDLE9BQU8sSUFBSSxDQUFDbVksUUFBUSxDQUFDbmxDLEVBQUU7WUFDekI7UUFDRjtRQUVBLE9BQU87SUFDVDtJQUVBazdDLGFBQWE5NkMsU0FBUyxDQUFDK2YsZ0JBQWdCLEdBQUcsU0FBVXJWLElBQUk7UUFDdEQsSUFBSTZ4QyxZQUFZN3hDLEtBQUtxUixLQUFLO1FBQzFCLElBQUluVztRQUVKLElBQUksT0FBTzIyQyxjQUFjLFVBQVU7WUFDakMzMkMsVUFBVSxJQUFJLENBQUNtL0IsUUFBUSxDQUFDd1gsVUFBVTtRQUNwQyxPQUFPO1lBQ0wsSUFBSTM4QztZQUNKLElBQUlDLE1BQU0sSUFBSSxDQUFDa2xDLFFBQVEsQ0FBQ2psQyxNQUFNO1lBRTlCLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO2dCQUMzQixJQUFJLElBQUksQ0FBQ21sQyxRQUFRLENBQUNubEMsRUFBRSxDQUFDK0ssSUFBSSxDQUFDOE0sRUFBRSxLQUFLOGtDLFdBQVc7b0JBQzFDMzJDLFVBQVUsSUFBSSxDQUFDbS9CLFFBQVEsQ0FBQ25sQyxFQUFFO29CQUMxQjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxJQUFJOEssS0FBSzVLLE1BQU0sS0FBSyxHQUFHO1lBQ3JCLE9BQU84RjtRQUNUO1FBRUEsT0FBT0EsUUFBUW1hLGdCQUFnQixDQUFDclY7SUFDbEM7SUFFQW93QyxhQUFhOTZDLFNBQVMsQ0FBQ3c4QyxlQUFlLEdBQUcsU0FBVW5nQyxRQUFRLEVBQUVvZ0MsY0FBYztRQUN6RSxJQUFJLENBQUNwaUMsVUFBVSxDQUFDb0IsV0FBVyxHQUFHLElBQUlxekI7UUFDbEMsSUFBSSxDQUFDejBCLFVBQVUsQ0FBQzZYLFdBQVcsR0FBR29qQixZQUFZajVCO1FBQzFDLElBQUksQ0FBQ2hDLFVBQVUsQ0FBQ29CLFdBQVcsQ0FBQ0MsUUFBUSxDQUFDVyxTQUFTdlAsS0FBSztRQUNuRCxJQUFJLENBQUN1TixVQUFVLENBQUNvQixXQUFXLENBQUNFLFFBQVEsQ0FBQ1UsU0FBU2IsS0FBSyxFQUFFaWhDO1FBQ3JELElBQUksQ0FBQ3BpQyxVQUFVLENBQUNvRixZQUFZLEdBQUcsSUFBSSxDQUFDaTlCLGFBQWEsQ0FBQ2o5QixZQUFZLENBQUMxTCxJQUFJLENBQUMsSUFBSSxDQUFDMm9DLGFBQWE7UUFDdEYsSUFBSSxDQUFDcmlDLFVBQVUsQ0FBQ3BILGFBQWEsR0FBRyxJQUFJLENBQUN5cEMsYUFBYSxDQUFDenBDLGFBQWEsQ0FBQ2MsSUFBSSxDQUFDLElBQUksQ0FBQzJvQyxhQUFhO1FBQ3hGLElBQUksQ0FBQ3JpQyxVQUFVLENBQUN5L0IsV0FBVyxHQUFHLElBQUksQ0FBQzRDLGFBQWEsQ0FBQ2xqQyxjQUFjO1FBQy9ELElBQUksQ0FBQ2EsVUFBVSxDQUFDWixlQUFlLEdBQUcsSUFBSSxDQUFDaWpDLGFBQWEsQ0FBQ2pqQyxlQUFlO1FBQ3BFLElBQUksQ0FBQ1ksVUFBVSxDQUFDMFcsT0FBTyxHQUFHO1FBQzFCLElBQUksQ0FBQzFXLFVBQVUsQ0FBQzlCLFNBQVMsR0FBRzhELFNBQVNDLEVBQUU7UUFDdkMsSUFBSSxDQUFDakMsVUFBVSxDQUFDNUMsRUFBRSxHQUFHNEUsU0FBUzVFLEVBQUU7UUFDaEMsSUFBSSxDQUFDNEMsVUFBVSxDQUFDc2lDLFFBQVEsR0FBRztZQUN6QnhzQixHQUFHOVQsU0FBUzhULENBQUM7WUFDYnBvQixHQUFHc1UsU0FBU3RVLENBQUM7UUFDZjtJQUNGO0lBRUEsSUFBSTYwQyxjQUFjO1FBQ2hCQyxrQkFBa0I7SUFDcEI7SUFFQSxTQUFTQyxvQkFBb0I7SUFFN0JBLGlCQUFpQjk4QyxTQUFTLEdBQUc7UUFDM0IrOEMsZUFBZSxTQUFTQTtZQUN0QixJQUFJcmEsTUFBTSxJQUFJdks7WUFDZCxJQUFJLENBQUNpZSxjQUFjLEdBQUc7Z0JBQ3BCQyxPQUFPLElBQUksQ0FBQzFyQyxJQUFJLENBQUM0QyxFQUFFLEdBQUdnMUIseUJBQXlCcUIsb0JBQW9CLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQ2o1QixJQUFJLENBQUM0QyxFQUFFLEVBQUUsSUFBSSxJQUFJO29CQUM5RkUsR0FBRztnQkFDTDtnQkFDQXV2QyxTQUFTO2dCQUNUQyxjQUFjO2dCQUNkQyxRQUFRO2dCQUNSeGEsS0FBS0E7Z0JBQ0x5YSxVQUFVemE7Z0JBQ1YwYSxjQUFjO1lBQ2hCO1lBRUEsSUFBSSxJQUFJLENBQUN6eUMsSUFBSSxDQUFDMHlDLEVBQUUsRUFBRTtnQkFDaEIsSUFBSSxDQUFDakgsY0FBYyxDQUFDQyxLQUFLLENBQUMvUyxZQUFZLEdBQUc7WUFDM0MsRUFBRSx1Q0FBdUM7WUFHekMsSUFBSSxJQUFJLENBQUMzNEIsSUFBSSxDQUFDNEIsRUFBRSxLQUFLLElBQUksQ0FDekI7UUFDRjtRQUNBK3dDLGlCQUFpQixTQUFTQTtZQUN4QixJQUFJLENBQUNsSCxjQUFjLENBQUM4RyxNQUFNLEdBQUcsSUFBSSxDQUFDOUcsY0FBYyxDQUFDQyxLQUFLLENBQUM1b0MsQ0FBQyxDQUFDb2pCLElBQUksSUFBSSxJQUFJLENBQUNLLGFBQWE7WUFDbkYsSUFBSSxDQUFDa2xCLGNBQWMsQ0FBQzRHLE9BQU8sR0FBRyxJQUFJLENBQUM1RyxjQUFjLENBQUNDLEtBQUssQ0FBQ3hsQixJQUFJLElBQUksSUFBSSxDQUFDSyxhQUFhO1lBRWxGLElBQUksSUFBSSxDQUFDK3FCLFNBQVMsRUFBRTtnQkFDbEIsSUFBSXZaO2dCQUNKLElBQUk2YSxXQUFXLElBQUksQ0FBQ25ILGNBQWMsQ0FBQzFULEdBQUc7Z0JBQ3RDLElBQUk5aUMsSUFBSTtnQkFDUixJQUFJQyxNQUFNLElBQUksQ0FBQ284QyxTQUFTLENBQUNuOEMsTUFBTSxFQUFFLHFGQUFxRjtnQkFFdEgsSUFBSSxDQUFDLElBQUksQ0FBQ3MyQyxjQUFjLENBQUM0RyxPQUFPLEVBQUU7b0JBQ2hDLE1BQU9wOUMsSUFBSUMsSUFBSzt3QkFDZCxJQUFJLElBQUksQ0FBQ284QyxTQUFTLENBQUNyOEMsRUFBRSxDQUFDdzJDLGNBQWMsQ0FBQ0MsS0FBSyxDQUFDeGxCLElBQUksRUFBRTs0QkFDL0MsSUFBSSxDQUFDdWxCLGNBQWMsQ0FBQzRHLE9BQU8sR0FBRzs0QkFDOUI7d0JBQ0Y7d0JBRUFwOUMsS0FBSztvQkFDUDtnQkFDRjtnQkFFQSxJQUFJLElBQUksQ0FBQ3cyQyxjQUFjLENBQUM0RyxPQUFPLEVBQUU7b0JBQy9CdGEsTUFBTSxJQUFJLENBQUMwVCxjQUFjLENBQUNDLEtBQUssQ0FBQ3B1QyxDQUFDLENBQUN3d0IsS0FBSztvQkFDdkM4a0IsU0FBU3BoQixjQUFjLENBQUN1RztvQkFFeEIsSUFBSzlpQyxJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRzt3QkFDM0IyOUMsU0FBUzNoQixRQUFRLENBQUMsSUFBSSxDQUFDcWdCLFNBQVMsQ0FBQ3I4QyxFQUFFLENBQUN3MkMsY0FBYyxDQUFDQyxLQUFLLENBQUNwdUMsQ0FBQztvQkFDNUQ7Z0JBQ0Y7WUFDRjtZQUVBLElBQUksSUFBSSxDQUFDbXVDLGNBQWMsQ0FBQzRHLE9BQU8sRUFBRTtnQkFDL0IsSUFBSSxDQUFDNUcsY0FBYyxDQUFDNkcsWUFBWSxHQUFHLElBQUksQ0FBQzdHLGNBQWMsQ0FBQzRHLE9BQU87WUFDaEU7WUFFQSxJQUFJLElBQUksQ0FBQzVHLGNBQWMsQ0FBQzhHLE1BQU0sRUFBRTtnQkFDOUIsSUFBSSxDQUFDOUcsY0FBYyxDQUFDZ0gsWUFBWSxHQUFHLElBQUksQ0FBQ2hILGNBQWMsQ0FBQ0MsS0FBSyxDQUFDNW9DLENBQUMsQ0FBQ3hGLENBQUM7WUFDbEU7UUFDRjtRQUNBdTFDLHNCQUFzQixTQUFTQTtZQUM3QixJQUFJLElBQUksQ0FBQ0MsZUFBZSxFQUFFO2dCQUN4QixJQUFJNzlDLElBQUk7Z0JBQ1IsSUFBSUMsTUFBTSxJQUFJLENBQUM0OUMsZUFBZSxDQUFDMzlDLE1BQU07Z0JBQ3JDLElBQUksQ0FBQ3MyQyxjQUFjLENBQUM2RyxZQUFZLEdBQUcsSUFBSSxDQUFDN0csY0FBYyxDQUFDNEcsT0FBTztnQkFFOUQsSUFBSSxDQUFDLElBQUksQ0FBQzVHLGNBQWMsQ0FBQzZHLFlBQVksSUFBSSxDQUFDLElBQUksQ0FBQzdHLGNBQWMsQ0FBQzhHLE1BQU0sRUFBRTtvQkFDcEUsTUFBT3Q5QyxJQUFJQyxJQUFLO3dCQUNkLElBQUksSUFBSSxDQUFDNDlDLGVBQWUsQ0FBQzc5QyxFQUFFLENBQUNpeEIsSUFBSSxFQUFFOzRCQUNoQyxJQUFJLENBQUN1bEIsY0FBYyxDQUFDNkcsWUFBWSxHQUFHO3dCQUNyQzt3QkFFQSxJQUFJLElBQUksQ0FBQ1EsZUFBZSxDQUFDNzlDLEVBQUUsQ0FBQ3M5QyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUM5RyxjQUFjLENBQUM4RyxNQUFNLEVBQUU7NEJBQ2pFLElBQUksQ0FBQzlHLGNBQWMsQ0FBQ2dILFlBQVksR0FBRyxJQUFJLENBQUNoSCxjQUFjLENBQUNDLEtBQUssQ0FBQzVvQyxDQUFDLENBQUN4RixDQUFDOzRCQUNoRSxJQUFJLENBQUNtdUMsY0FBYyxDQUFDOEcsTUFBTSxHQUFHO3dCQUMvQjt3QkFFQXQ5QyxLQUFLO29CQUNQO2dCQUNGO2dCQUVBLElBQUksSUFBSSxDQUFDdzJDLGNBQWMsQ0FBQzZHLFlBQVksRUFBRTtvQkFDcEMsSUFBSUUsV0FBVyxJQUFJLENBQUMvRyxjQUFjLENBQUMrRyxRQUFRO29CQUMzQyxJQUFJLENBQUNNLGVBQWUsQ0FBQyxFQUFFLENBQUM1aEIsTUFBTSxDQUFDL0gsS0FBSyxDQUFDcXBCO29CQUVyQyxJQUFLdjlDLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO3dCQUMzQixJQUFJODlDLE9BQU8sSUFBSSxDQUFDRCxlQUFlLENBQUM3OUMsRUFBRSxDQUFDaThCLE1BQU07d0JBQ3pDc2hCLFNBQVN2aEIsUUFBUSxDQUFDOGhCO29CQUNwQjtvQkFFQVAsU0FBU3ZoQixRQUFRLENBQUMsSUFBSSxDQUFDd2EsY0FBYyxDQUFDMVQsR0FBRztnQkFDM0M7Z0JBRUEsSUFBSSxJQUFJLENBQUMwVCxjQUFjLENBQUM4RyxNQUFNLEVBQUU7b0JBQzlCLElBQUlTLFVBQVUsSUFBSSxDQUFDdkgsY0FBYyxDQUFDZ0gsWUFBWTtvQkFFOUMsSUFBS3g5QyxJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRzt3QkFDM0IrOUMsV0FBVyxJQUFJLENBQUNGLGVBQWUsQ0FBQzc5QyxFQUFFLENBQUNnK0MsT0FBTyxHQUFHO29CQUMvQztvQkFFQSxJQUFJLENBQUN4SCxjQUFjLENBQUNnSCxZQUFZLEdBQUdPO2dCQUNyQztZQUNGO1FBQ0Y7UUFDQUUsd0JBQXdCLFNBQVNBO1lBQy9CLElBQUksSUFBSSxDQUFDQyx3QkFBd0IsRUFBRTtnQkFDakMsSUFBSUMsbUJBQW1CLElBQUksQ0FBQ0Qsd0JBQXdCLENBQUNFLFVBQVUsQ0FBQ3BCLFlBQVlDLGdCQUFnQjtnQkFFNUYsSUFBSWtCLGlCQUFpQmorQyxNQUFNLEVBQUU7b0JBQzNCLElBQUksQ0FBQzI5QyxlQUFlLEdBQUcsRUFBRTtvQkFDekIsSUFBSSxDQUFDckgsY0FBYyxDQUFDK0csUUFBUSxHQUFHLElBQUlobEI7b0JBQ25DLElBQUl2NEIsSUFBSTtvQkFDUixJQUFJQyxNQUFNaytDLGlCQUFpQmorQyxNQUFNO29CQUVqQyxJQUFLRixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRzt3QkFDM0IsSUFBSSxDQUFDNjlDLGVBQWUsQ0FBQ3Q4QyxJQUFJLENBQUM0OEMsZ0JBQWdCLENBQUNuK0MsRUFBRTtvQkFDL0M7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0FxK0MsZUFBZSxTQUFTQSxjQUFjNXhDLEVBQUU7WUFDdEMsSUFBSTZ4QyxhQUFhLEVBQUU7WUFDbkJBLFdBQVcvOEMsSUFBSSxDQUFDLElBQUksQ0FBQ2kxQyxjQUFjO1lBQ25DLElBQUlwM0MsT0FBTztZQUNYLElBQUlrTyxPQUFPLElBQUksQ0FBQ0EsSUFBSTtZQUVwQixNQUFPbE8sS0FBTTtnQkFDWCxJQUFJa08sS0FBS2twQyxjQUFjLEVBQUU7b0JBQ3ZCLElBQUlscEMsS0FBS3ZDLElBQUksQ0FBQ3VCLE9BQU8sRUFBRTt3QkFDckJneUMsV0FBV2xvQyxNQUFNLENBQUMsR0FBRyxHQUFHOUksS0FBS2twQyxjQUFjO29CQUM3QztvQkFFQWxwQyxPQUFPQSxLQUFLQSxJQUFJO2dCQUNsQixPQUFPO29CQUNMbE8sT0FBTztnQkFDVDtZQUNGO1lBRUEsSUFBSVk7WUFDSixJQUFJQyxNQUFNcStDLFdBQVdwK0MsTUFBTTtZQUMzQixJQUFJcStDO1lBRUosSUFBS3YrQyxJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztnQkFDM0J1K0MsUUFBUUQsVUFBVSxDQUFDdCtDLEVBQUUsQ0FBQzhpQyxHQUFHLENBQUM5RixpQkFBaUIsQ0FBQyxHQUFHLEdBQUcsSUFBSSxrRUFBa0U7Z0JBRXhIdndCLEtBQUs7b0JBQUNBLEVBQUUsQ0FBQyxFQUFFLEdBQUc4eEMsS0FBSyxDQUFDLEVBQUU7b0JBQUU5eEMsRUFBRSxDQUFDLEVBQUUsR0FBRzh4QyxLQUFLLENBQUMsRUFBRTtvQkFBRTtpQkFBRTtZQUM5QztZQUVBLE9BQU85eEM7UUFDVDtRQUNBK3hDLFNBQVMsSUFBSWptQjtJQUNmO0lBRUEsU0FBU2ttQixZQUFZMXpDLElBQUksRUFBRS9FLE9BQU8sRUFBRXlVLFVBQVU7UUFDNUMsSUFBSSxDQUFDMVAsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQy9FLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUN5VSxVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQzRPLFVBQVUsR0FBRyxFQUFFO1FBQ3BCLElBQUksQ0FBQzdjLGVBQWUsR0FBRyxJQUFJLENBQUN6QixJQUFJLENBQUN5QixlQUFlLElBQUksRUFBRTtRQUN0RCxJQUFJLENBQUNreUMsV0FBVyxHQUFHO1FBQ25CLElBQUloa0MsT0FBTyxJQUFJLENBQUNELFVBQVUsQ0FBQ0MsSUFBSTtRQUMvQixJQUFJMWE7UUFDSixJQUFJQyxNQUFNLElBQUksQ0FBQ3VNLGVBQWUsR0FBRyxJQUFJLENBQUNBLGVBQWUsQ0FBQ3RNLE1BQU0sR0FBRztRQUMvRCxJQUFJLENBQUN5K0MsUUFBUSxHQUFHdjdDLGlCQUFpQm5EO1FBQ2pDLElBQUksQ0FBQzIrQyxTQUFTLEdBQUc7UUFDakIsSUFBSTl6QztRQUNKLElBQUkrekMsYUFBYSxJQUFJLENBQUNyeUMsZUFBZTtRQUNyQyxJQUFJaWdDLFFBQVE7UUFDWixJQUFJcVMsZUFBZSxFQUFFO1FBQ3JCLElBQUk3eUM7UUFDSixJQUFJQztRQUNKLElBQUl3dEMsVUFBVTN4QztRQUNkLElBQUlnM0M7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSXI2QjtRQUNKLElBQUlzNkIsV0FBVztRQUNmLElBQUlDLFVBQVU7UUFFZCxJQUFLbi9DLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCLElBQUk2K0MsVUFBVSxDQUFDNytDLEVBQUUsQ0FBQ2szQyxJQUFJLEtBQUssT0FBTzJILFVBQVUsQ0FBQzcrQyxFQUFFLENBQUNrM0MsSUFBSSxLQUFLLE9BQU8ySCxVQUFVLENBQUM3K0MsRUFBRSxDQUFDMGtDLEdBQUcsSUFBSW1hLFVBQVUsQ0FBQzcrQyxFQUFFLENBQUM2TixDQUFDLENBQUMxQixDQUFDLEtBQUssT0FBTzB5QyxVQUFVLENBQUM3K0MsRUFBRSxDQUFDNk4sQ0FBQyxDQUFDK1csQ0FBQyxFQUFFO2dCQUNuSXM2QixXQUFXO2dCQUNYQyxVQUFVO1lBQ1o7WUFFQSxJQUFJLENBQUNOLFVBQVUsQ0FBQzcrQyxFQUFFLENBQUNrM0MsSUFBSSxLQUFLLE9BQU8ySCxVQUFVLENBQUM3K0MsRUFBRSxDQUFDazNDLElBQUksS0FBSyxHQUFFLEtBQU16SyxVQUFVLEdBQUc7Z0JBQzdFc1MsT0FBTzUwQyxTQUFTO2dCQUNoQjQwQyxLQUFLaDlCLFlBQVksQ0FBQyxRQUFRO2dCQUMxQmc5QixLQUFLaDlCLFlBQVksQ0FBQyxTQUFTLElBQUksQ0FBQy9iLE9BQU8sQ0FBQ3NILElBQUksQ0FBQ3ZDLElBQUksQ0FBQ3dsQixDQUFDLElBQUk7Z0JBQ3ZEd3VCLEtBQUtoOUIsWUFBWSxDQUFDLFVBQVUsSUFBSSxDQUFDL2IsT0FBTyxDQUFDc0gsSUFBSSxDQUFDdkMsSUFBSSxDQUFDNUMsQ0FBQyxJQUFJO2dCQUN4RDIyQyxhQUFhdjlDLElBQUksQ0FBQ3c5QztZQUNwQixPQUFPO2dCQUNMQSxPQUFPO1lBQ1Q7WUFFQWowQyxPQUFPWCxTQUFTO1lBRWhCLElBQUkwMEMsVUFBVSxDQUFDNytDLEVBQUUsQ0FBQ2szQyxJQUFJLEtBQUssS0FBSztnQkFDOUIsa0RBQWtEO2dCQUNsRCxJQUFJLENBQUN5SCxRQUFRLENBQUMzK0MsRUFBRSxHQUFHO29CQUNqQjZPLElBQUlzakIsZ0JBQWdCQyxPQUFPLENBQUMsSUFBSSxDQUFDcHNCLE9BQU8sRUFBRTY0QyxVQUFVLENBQUM3K0MsRUFBRSxDQUFDNk4sQ0FBQyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUM3SCxPQUFPO29CQUNoRnJGLE1BQU1nMEIscUJBQXFCd0QsWUFBWSxDQUFDLElBQUksQ0FBQ255QixPQUFPLEVBQUU2NEMsVUFBVSxDQUFDNytDLEVBQUUsRUFBRTtvQkFDckUrZ0IsTUFBTWpXO29CQUNOczBDLFVBQVU7Z0JBQ1o7Z0JBQ0Exa0MsS0FBS2hHLFdBQVcsQ0FBQzVKO1lBQ25CLE9BQU87Z0JBQ0wyaEMsU0FBUztnQkFDVDNoQyxLQUFLaVgsWUFBWSxDQUFDLFFBQVE4OEIsVUFBVSxDQUFDNytDLEVBQUUsQ0FBQ2szQyxJQUFJLEtBQUssTUFBTSxZQUFZO2dCQUNuRXBzQyxLQUFLaVgsWUFBWSxDQUFDLGFBQWE7Z0JBQy9CLElBQUlzOUI7Z0JBRUosSUFBSVIsVUFBVSxDQUFDNytDLEVBQUUsQ0FBQzRrQixDQUFDLENBQUN6WSxDQUFDLEtBQUssR0FBRztvQkFDM0IreUMsV0FBVztvQkFDWEMsVUFBVTtvQkFDVnY2QixJQUFJdU4sZ0JBQWdCQyxPQUFPLENBQUMsSUFBSSxDQUFDcHNCLE9BQU8sRUFBRTY0QyxVQUFVLENBQUM3K0MsRUFBRSxDQUFDNGtCLENBQUMsRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDNWUsT0FBTztvQkFDaEZxNUMsV0FBV3QzQztvQkFDWGkzQyxXQUFXNzBDLFNBQVM7b0JBQ3BCNjBDLFNBQVNqOUIsWUFBWSxDQUFDLE1BQU1zOUI7b0JBQzVCSixVQUFVOTBDLFNBQVM7b0JBQ25CODBDLFFBQVFsOUIsWUFBWSxDQUFDLFlBQVk7b0JBQ2pDazlCLFFBQVFsOUIsWUFBWSxDQUFDLE1BQU07b0JBQzNCazlCLFFBQVFsOUIsWUFBWSxDQUFDLFVBQVU7b0JBQy9CaTlCLFNBQVN0cUMsV0FBVyxDQUFDdXFDO29CQUNyQnZrQyxLQUFLaEcsV0FBVyxDQUFDc3FDO29CQUNqQmwwQyxLQUFLaVgsWUFBWSxDQUFDLFVBQVU4OEIsVUFBVSxDQUFDNytDLEVBQUUsQ0FBQ2szQyxJQUFJLEtBQUssTUFBTSxZQUFZO2dCQUN2RSxPQUFPO29CQUNMK0gsVUFBVTtvQkFDVnI2QixJQUFJO2dCQUNOLEVBQUUsa0RBQWtEO2dCQUdwRCxJQUFJLENBQUN5RSxVQUFVLENBQUNycEIsRUFBRSxHQUFHO29CQUNuQitnQixNQUFNalc7b0JBQ044WixHQUFHQTtvQkFDSDA2QixPQUFPTDtvQkFDUEcsVUFBVTtvQkFDVkcsY0FBYztvQkFDZEMsVUFBVUg7b0JBQ1ZJLFlBQVk7Z0JBQ2Q7Z0JBRUEsSUFBSVosVUFBVSxDQUFDNytDLEVBQUUsQ0FBQ2szQyxJQUFJLEtBQUssS0FBSztvQkFDOUJockMsT0FBTzR5QyxhQUFhNStDLE1BQU07b0JBQzFCLElBQUlxSSxJQUFJNEIsU0FBUztvQkFFakIsSUFBSzhCLElBQUksR0FBR0EsSUFBSUMsTUFBTUQsS0FBSyxFQUFHO3dCQUM1QjFELEVBQUVtTSxXQUFXLENBQUNvcUMsWUFBWSxDQUFDN3lDLEVBQUU7b0JBQy9CO29CQUVBLElBQUl5ekMsT0FBT3YxQyxTQUFTO29CQUNwQnUxQyxLQUFLMzlCLFlBQVksQ0FBQyxhQUFhO29CQUMvQjI5QixLQUFLMzlCLFlBQVksQ0FBQyxNQUFNMjNCLFVBQVUsTUFBTWpOO29CQUN4Q2lULEtBQUtockMsV0FBVyxDQUFDNUo7b0JBQ2pCNFAsS0FBS2hHLFdBQVcsQ0FBQ2dyQztvQkFDakJuM0MsRUFBRXdaLFlBQVksQ0FBQyxRQUFRLFNBQVN2aUIsb0JBQW9CLE1BQU1rNkMsVUFBVSxNQUFNak4sUUFBUTtvQkFDbEZxUyxhQUFhNStDLE1BQU0sR0FBRztvQkFDdEI0K0MsYUFBYXY5QyxJQUFJLENBQUNnSDtnQkFDcEIsT0FBTztvQkFDTHUyQyxhQUFhdjlDLElBQUksQ0FBQ3VKO2dCQUNwQjtnQkFFQSxJQUFJK3pDLFVBQVUsQ0FBQzcrQyxFQUFFLENBQUMwa0MsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDa2EsU0FBUyxFQUFFO29CQUN4QyxJQUFJLENBQUNBLFNBQVMsR0FBRyxJQUFJLENBQUNlLG9CQUFvQjtnQkFDNUMsRUFBRSxrREFBa0Q7Z0JBR3BELElBQUksQ0FBQ2hCLFFBQVEsQ0FBQzMrQyxFQUFFLEdBQUc7b0JBQ2pCK2dCLE1BQU1qVztvQkFDTnMwQyxVQUFVO29CQUNWdndDLElBQUlzakIsZ0JBQWdCQyxPQUFPLENBQUMsSUFBSSxDQUFDcHNCLE9BQU8sRUFBRTY0QyxVQUFVLENBQUM3K0MsRUFBRSxDQUFDNk4sQ0FBQyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUM3SCxPQUFPO29CQUNoRnJGLE1BQU1nMEIscUJBQXFCd0QsWUFBWSxDQUFDLElBQUksQ0FBQ255QixPQUFPLEVBQUU2NEMsVUFBVSxDQUFDNytDLEVBQUUsRUFBRTtvQkFDckU0L0MsU0FBU2I7Z0JBQ1g7Z0JBRUEsSUFBSSxDQUFDLElBQUksQ0FBQ0osUUFBUSxDQUFDMytDLEVBQUUsQ0FBQ1csSUFBSSxDQUFDd0wsQ0FBQyxFQUFFO29CQUM1QixJQUFJLENBQUMwekMsUUFBUSxDQUFDaEIsVUFBVSxDQUFDNytDLEVBQUUsRUFBRSxJQUFJLENBQUMyK0MsUUFBUSxDQUFDMytDLEVBQUUsQ0FBQ1csSUFBSSxDQUFDMEgsQ0FBQyxFQUFFLElBQUksQ0FBQ3MyQyxRQUFRLENBQUMzK0MsRUFBRTtnQkFDeEU7WUFDRjtRQUNGO1FBRUEsSUFBSSxDQUFDMCtDLFdBQVcsR0FBR3YwQyxTQUFTKzBDO1FBQzVCai9DLE1BQU02K0MsYUFBYTUrQyxNQUFNO1FBRXpCLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCLElBQUksQ0FBQzArQyxXQUFXLENBQUNocUMsV0FBVyxDQUFDb3FDLFlBQVksQ0FBQzkrQyxFQUFFO1FBQzlDO1FBRUEsSUFBSXlzQyxRQUFRLEdBQUc7WUFDYixJQUFJLENBQUNpUyxXQUFXLENBQUMzOEIsWUFBWSxDQUFDLE1BQU0yM0I7WUFDcEMsSUFBSSxDQUFDMXpDLE9BQU8sQ0FBQzg1QyxhQUFhLENBQUMvOUIsWUFBWSxDQUFDbzlCLFNBQVMsU0FBUzMvQyxvQkFBb0IsTUFBTWs2QyxVQUFVO1lBQzlGaC9CLEtBQUtoRyxXQUFXLENBQUMsSUFBSSxDQUFDZ3FDLFdBQVc7UUFDbkM7UUFFQSxJQUFJLElBQUksQ0FBQ0MsUUFBUSxDQUFDeitDLE1BQU0sRUFBRTtZQUN4QixJQUFJLENBQUM4RixPQUFPLENBQUNpd0Msc0JBQXNCLENBQUMsSUFBSTtRQUMxQztJQUNGO0lBRUF3SSxZQUFZcitDLFNBQVMsQ0FBQzIvQyxlQUFlLEdBQUcsU0FBVTdzQixHQUFHO1FBQ25ELE9BQU8sSUFBSSxDQUFDeXJCLFFBQVEsQ0FBQ3pyQixJQUFJLENBQUN2eUIsSUFBSTtJQUNoQztJQUVBODlDLFlBQVlyK0MsU0FBUyxDQUFDb2QsV0FBVyxHQUFHLFNBQVV3aUMsWUFBWTtRQUN4RCxJQUFJckMsV0FBVyxJQUFJLENBQUMzM0MsT0FBTyxDQUFDd3dDLGNBQWMsQ0FBQzFULEdBQUc7UUFDOUMsSUFBSTlpQztRQUNKLElBQUlDLE1BQU0sSUFBSSxDQUFDdU0sZUFBZSxDQUFDdE0sTUFBTTtRQUVyQyxJQUFLRixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQixJQUFJLElBQUksQ0FBQzIrQyxRQUFRLENBQUMzK0MsRUFBRSxDQUFDVyxJQUFJLENBQUNzd0IsSUFBSSxJQUFJK3VCLGNBQWM7Z0JBQzlDLElBQUksQ0FBQ0gsUUFBUSxDQUFDLElBQUksQ0FBQ3J6QyxlQUFlLENBQUN4TSxFQUFFLEVBQUUsSUFBSSxDQUFDMitDLFFBQVEsQ0FBQzMrQyxFQUFFLENBQUNXLElBQUksQ0FBQzBILENBQUMsRUFBRSxJQUFJLENBQUNzMkMsUUFBUSxDQUFDMytDLEVBQUU7WUFDbEY7WUFFQSxJQUFJLElBQUksQ0FBQzIrQyxRQUFRLENBQUMzK0MsRUFBRSxDQUFDNk8sRUFBRSxDQUFDb2lCLElBQUksSUFBSSt1QixjQUFjO2dCQUM1QyxJQUFJLENBQUNyQixRQUFRLENBQUMzK0MsRUFBRSxDQUFDK2dCLElBQUksQ0FBQ2dCLFlBQVksQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDNDhCLFFBQVEsQ0FBQzMrQyxFQUFFLENBQUM2TyxFQUFFLENBQUN4RyxDQUFDO1lBQzFFO1lBRUEsSUFBSSxJQUFJLENBQUNtRSxlQUFlLENBQUN4TSxFQUFFLENBQUNrM0MsSUFBSSxLQUFLLEtBQUs7Z0JBQ3hDLElBQUksSUFBSSxDQUFDeUgsUUFBUSxDQUFDMytDLEVBQUUsQ0FBQzQvQyxPQUFPLElBQUssS0FBSSxDQUFDNTVDLE9BQU8sQ0FBQ3d3QyxjQUFjLENBQUNDLEtBQUssQ0FBQ3hsQixJQUFJLElBQUkrdUIsWUFBVyxHQUFJO29CQUN4RixJQUFJLENBQUNyQixRQUFRLENBQUMzK0MsRUFBRSxDQUFDNC9DLE9BQU8sQ0FBQzc5QixZQUFZLENBQUMsYUFBYTQ3QixTQUFTL2dCLGdCQUFnQixHQUFHaUIsT0FBTztnQkFDeEY7Z0JBRUEsSUFBSSxJQUFJLENBQUN4VSxVQUFVLENBQUNycEIsRUFBRSxDQUFDNGtCLENBQUMsSUFBSyxLQUFJLENBQUN5RSxVQUFVLENBQUNycEIsRUFBRSxDQUFDNGtCLENBQUMsQ0FBQ3FNLElBQUksSUFBSSt1QixZQUFXLEdBQUk7b0JBQ3ZFLElBQUlmLFVBQVUsSUFBSSxDQUFDNTFCLFVBQVUsQ0FBQ3JwQixFQUFFLENBQUNzL0MsS0FBSztvQkFFdEMsSUFBSSxJQUFJLENBQUNqMkIsVUFBVSxDQUFDcnBCLEVBQUUsQ0FBQzRrQixDQUFDLENBQUN2YyxDQUFDLEdBQUcsR0FBRzt3QkFDOUIsSUFBSSxJQUFJLENBQUNnaEIsVUFBVSxDQUFDcnBCLEVBQUUsQ0FBQ3UvQyxZQUFZLEtBQUssU0FBUzs0QkFDL0MsSUFBSSxDQUFDbDJCLFVBQVUsQ0FBQ3JwQixFQUFFLENBQUN1L0MsWUFBWSxHQUFHOzRCQUNsQyxJQUFJLENBQUNsMkIsVUFBVSxDQUFDcnBCLEVBQUUsQ0FBQytnQixJQUFJLENBQUNnQixZQUFZLENBQUMsVUFBVSxTQUFTdmlCLG9CQUFvQixNQUFNLElBQUksQ0FBQzZwQixVQUFVLENBQUNycEIsRUFBRSxDQUFDdy9DLFFBQVEsR0FBRzt3QkFDbEg7d0JBRUFQLFFBQVFsOUIsWUFBWSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUNzSCxVQUFVLENBQUNycEIsRUFBRSxDQUFDNGtCLENBQUMsQ0FBQ3ZjLENBQUM7b0JBQ3hELE9BQU87d0JBQ0wsSUFBSSxJQUFJLENBQUNnaEIsVUFBVSxDQUFDcnBCLEVBQUUsQ0FBQ3UvQyxZQUFZLEtBQUssVUFBVTs0QkFDaEQsSUFBSSxDQUFDbDJCLFVBQVUsQ0FBQ3JwQixFQUFFLENBQUN1L0MsWUFBWSxHQUFHOzRCQUNsQyxJQUFJLENBQUNsMkIsVUFBVSxDQUFDcnBCLEVBQUUsQ0FBQytnQixJQUFJLENBQUNnQixZQUFZLENBQUMsVUFBVTt3QkFDakQ7d0JBRUEsSUFBSSxDQUFDc0gsVUFBVSxDQUFDcnBCLEVBQUUsQ0FBQytnQixJQUFJLENBQUNnQixZQUFZLENBQUMsZ0JBQWdCLElBQUksQ0FBQ3NILFVBQVUsQ0FBQ3JwQixFQUFFLENBQUM0a0IsQ0FBQyxDQUFDdmMsQ0FBQyxHQUFHO29CQUNoRjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUVBbzJDLFlBQVlyK0MsU0FBUyxDQUFDNi9DLGNBQWMsR0FBRztRQUNyQyxPQUFPLElBQUksQ0FBQ3ZCLFdBQVc7SUFDekI7SUFFQUQsWUFBWXIrQyxTQUFTLENBQUN1L0Msb0JBQW9CLEdBQUc7UUFDM0MsSUFBSTcwQyxPQUFPO1FBQ1hBLFFBQVEsT0FBTyxJQUFJLENBQUMyUCxVQUFVLENBQUNzaUMsUUFBUSxDQUFDeHNCLENBQUM7UUFDekN6bEIsUUFBUSxPQUFPLElBQUksQ0FBQzJQLFVBQVUsQ0FBQ3NpQyxRQUFRLENBQUM1MEMsQ0FBQztRQUN6QzJDLFFBQVEsUUFBUSxJQUFJLENBQUMyUCxVQUFVLENBQUNzaUMsUUFBUSxDQUFDeHNCLENBQUM7UUFDMUN6bEIsUUFBUSxRQUFRLElBQUksQ0FBQzJQLFVBQVUsQ0FBQ3NpQyxRQUFRLENBQUM1MEMsQ0FBQyxHQUFHO1FBQzdDLE9BQU8yQztJQUNUO0lBRUEyekMsWUFBWXIrQyxTQUFTLENBQUN5L0MsUUFBUSxHQUFHLFNBQVV6d0MsUUFBUSxFQUFFOHdDLFNBQVMsRUFBRXZCLFFBQVE7UUFDdEUsSUFBSXdCLGFBQWEsT0FBT0QsVUFBVTczQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxNQUFNNjNDLFVBQVU3M0MsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ25FLElBQUlySTtRQUNKLElBQUlDO1FBQ0pBLE1BQU1pZ0QsVUFBVW42QixPQUFPO1FBRXZCLElBQUsvbEIsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDM0IsOEpBQThKO1lBQzlKbWdELGNBQWMsT0FBT0QsVUFBVXJ5QyxDQUFDLENBQUM3TixJQUFJLEVBQUUsQ0FBQyxFQUFFLEdBQUcsTUFBTWtnRCxVQUFVcnlDLENBQUMsQ0FBQzdOLElBQUksRUFBRSxDQUFDLEVBQUUsR0FBRyxNQUFNa2dELFVBQVVsZ0QsQ0FBQyxDQUFDQSxFQUFFLENBQUMsRUFBRSxHQUFHLE1BQU1rZ0QsVUFBVWxnRCxDQUFDLENBQUNBLEVBQUUsQ0FBQyxFQUFFLEdBQUcsTUFBTWtnRCxVQUFVNzNDLENBQUMsQ0FBQ3JJLEVBQUUsQ0FBQyxFQUFFLEdBQUcsTUFBTWtnRCxVQUFVNzNDLENBQUMsQ0FBQ3JJLEVBQUUsQ0FBQyxFQUFFO1FBQ2xMLEVBQUUsOEpBQThKO1FBR2hLLElBQUlrZ0QsVUFBVTN3QyxDQUFDLElBQUl0UCxNQUFNLEdBQUc7WUFDMUJrZ0QsY0FBYyxPQUFPRCxVQUFVcnlDLENBQUMsQ0FBQzdOLElBQUksRUFBRSxDQUFDLEVBQUUsR0FBRyxNQUFNa2dELFVBQVVyeUMsQ0FBQyxDQUFDN04sSUFBSSxFQUFFLENBQUMsRUFBRSxHQUFHLE1BQU1rZ0QsVUFBVWxnRCxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxNQUFNa2dELFVBQVVsZ0QsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsTUFBTWtnRCxVQUFVNzNDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLE1BQU02M0MsVUFBVTczQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7UUFDbEwsRUFBRSwyQ0FBMkM7UUFHN0MsSUFBSXMyQyxTQUFTUyxRQUFRLEtBQUtlLFlBQVk7WUFDcEMsSUFBSUMsaUJBQWlCO1lBRXJCLElBQUl6QixTQUFTNTlCLElBQUksRUFBRTtnQkFDakIsSUFBSW0vQixVQUFVM3dDLENBQUMsRUFBRTtvQkFDZjZ3QyxpQkFBaUJoeEMsU0FBU3MxQixHQUFHLEdBQUcsSUFBSSxDQUFDa2EsU0FBUyxHQUFHdUIsYUFBYUE7Z0JBQ2hFO2dCQUVBeEIsU0FBUzU5QixJQUFJLENBQUNnQixZQUFZLENBQUMsS0FBS3ErQjtZQUNsQztZQUVBekIsU0FBU1MsUUFBUSxHQUFHZTtRQUN0QjtJQUNGO0lBRUExQixZQUFZcitDLFNBQVMsQ0FBQ21WLE9BQU8sR0FBRztRQUM5QixJQUFJLENBQUN2UCxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUN5VSxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDaWtDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUMzekMsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDeUIsZUFBZSxHQUFHO0lBQ3pCO0lBRUEsSUFBSTZ6QyxpQkFBaUI7UUFDbkIsSUFBSS9yQyxLQUFLLENBQUM7UUFDVkEsR0FBR2dzQyxZQUFZLEdBQUdBO1FBQ2xCaHNDLEdBQUdpc0MsNEJBQTRCLEdBQUdBO1FBRWxDLFNBQVNELGFBQWFFLEtBQUssRUFBRUMsZUFBZTtZQUMxQyxJQUFJQyxNQUFNdjJDLFNBQVM7WUFDbkJ1MkMsSUFBSTMrQixZQUFZLENBQUMsTUFBTXkrQjtZQUV2QixJQUFJQyxvQkFBb0IsTUFBTTtnQkFDNUJDLElBQUkzK0IsWUFBWSxDQUFDLGVBQWU7Z0JBQ2hDMitCLElBQUkzK0IsWUFBWSxDQUFDLEtBQUs7Z0JBQ3RCMitCLElBQUkzK0IsWUFBWSxDQUFDLEtBQUs7Z0JBQ3RCMitCLElBQUkzK0IsWUFBWSxDQUFDLFNBQVM7Z0JBQzFCMitCLElBQUkzK0IsWUFBWSxDQUFDLFVBQVU7WUFDN0I7WUFFQSxPQUFPMitCO1FBQ1Q7UUFFQSxTQUFTSDtZQUNQLElBQUlJLGdCQUFnQngyQyxTQUFTO1lBQzdCdzJDLGNBQWM1K0IsWUFBWSxDQUFDLFFBQVE7WUFDbkM0K0IsY0FBYzUrQixZQUFZLENBQUMsK0JBQStCO1lBQzFENCtCLGNBQWM1K0IsWUFBWSxDQUFDLFVBQVU7WUFDckMsT0FBTzQrQjtRQUNUO1FBRUEsT0FBT3JzQztJQUNUO0lBRUEsSUFBSXNzQyxpQkFBaUI7UUFDbkIsSUFBSXRzQyxLQUFLO1lBQ1A0cUMsVUFBVTtZQUNWMkIsZUFBZTtZQUNmQyxpQkFBaUIsT0FBT3pPLG9CQUFvQjtRQUM5QztRQUVBLElBQUksV0FBV251QyxJQUFJLENBQUM3RixVQUFVOEYsU0FBUyxLQUFLLFVBQVVELElBQUksQ0FBQzdGLFVBQVU4RixTQUFTLEtBQUssV0FBV0QsSUFBSSxDQUFDN0YsVUFBVThGLFNBQVMsS0FBSyxhQUFhRCxJQUFJLENBQUM3RixVQUFVOEYsU0FBUyxHQUFHO1lBQ2pLbVEsR0FBRzRxQyxRQUFRLEdBQUc7UUFDaEI7UUFFQSxJQUFJLFdBQVdoN0MsSUFBSSxDQUFDN0YsVUFBVThGLFNBQVMsR0FBRztZQUN4Q21RLEdBQUd1c0MsYUFBYSxHQUFHO1FBQ3JCO1FBRUEsT0FBT3ZzQztJQUNUO0lBRUEsSUFBSXlzQyxzQkFBc0IsQ0FBQztJQUMzQixJQUFJQyxXQUFXO0lBRWYsU0FBU0MsV0FBV2xnQyxJQUFJO1FBQ3RCLElBQUkvZ0I7UUFDSixJQUFJa2hELFNBQVM7UUFDYixJQUFJamhELE1BQU04Z0IsS0FBS2hXLElBQUksQ0FBQzhzQyxFQUFFLEdBQUc5MkIsS0FBS2hXLElBQUksQ0FBQzhzQyxFQUFFLENBQUMzM0MsTUFBTSxHQUFHO1FBQy9DLElBQUlzZ0QsUUFBUXo0QztRQUNaLElBQUkyNEMsTUFBTUwsZUFBZUMsWUFBWSxDQUFDRSxPQUFPO1FBQzdDLElBQUkvVCxRQUFRO1FBQ1osSUFBSSxDQUFDMFUsT0FBTyxHQUFHLEVBQUU7UUFDakIsSUFBSUM7UUFFSixJQUFLcGhELElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCb2hELGdCQUFnQjtZQUNoQixJQUFJMWhELE9BQU9xaEIsS0FBS2hXLElBQUksQ0FBQzhzQyxFQUFFLENBQUM3M0MsRUFBRSxDQUFDMk0sRUFBRTtZQUU3QixJQUFJbzBDLG1CQUFtQixDQUFDcmhELEtBQUssRUFBRTtnQkFDN0IsSUFBSTJoRCxTQUFTTixtQkFBbUIsQ0FBQ3JoRCxLQUFLLENBQUM0aEQsTUFBTTtnQkFDN0NGLGdCQUFnQixJQUFJQyxPQUFPWCxLQUFLMy9CLEtBQUs0NEIsY0FBYyxDQUFDN0IsY0FBYyxDQUFDOTNDLEVBQUUsRUFBRStnQixNQUFNaWdDLFdBQVd2VSxPQUFPeVU7Z0JBQy9GQSxTQUFTRixXQUFXdlU7Z0JBRXBCLElBQUlzVSxtQkFBbUIsQ0FBQ3JoRCxLQUFLLENBQUM2aEQsY0FBYyxFQUFFO29CQUM1QzlVLFNBQVM7Z0JBQ1g7WUFDRjtZQUVBLElBQUkyVSxlQUFlO2dCQUNqQixJQUFJLENBQUNELE9BQU8sQ0FBQzUvQyxJQUFJLENBQUM2L0M7WUFDcEI7UUFDRjtRQUVBLElBQUkzVSxPQUFPO1lBQ1QxckIsS0FBS3RHLFVBQVUsQ0FBQ0MsSUFBSSxDQUFDaEcsV0FBVyxDQUFDZ3NDO1lBQ2pDMy9CLEtBQUt5NEIsWUFBWSxDQUFDejNCLFlBQVksQ0FBQyxVQUFVLFNBQVN2aUIsb0JBQW9CLE1BQU1naEQsUUFBUTtRQUN0RjtRQUVBLElBQUksSUFBSSxDQUFDVyxPQUFPLENBQUNqaEQsTUFBTSxFQUFFO1lBQ3ZCNmdCLEtBQUtrMUIsc0JBQXNCLENBQUMsSUFBSTtRQUNsQztJQUNGO0lBRUFnTCxXQUFXN2dELFNBQVMsQ0FBQ29kLFdBQVcsR0FBRyxTQUFVOFQsYUFBYTtRQUN4RCxJQUFJdHhCO1FBQ0osSUFBSUMsTUFBTSxJQUFJLENBQUNraEQsT0FBTyxDQUFDamhELE1BQU07UUFFN0IsSUFBS0YsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDM0IsSUFBSSxDQUFDbWhELE9BQU8sQ0FBQ25oRCxFQUFFLENBQUN3ZCxXQUFXLENBQUM4VDtRQUM5QjtJQUNGO0lBRUEydkIsV0FBVzdnRCxTQUFTLENBQUNnK0MsVUFBVSxHQUFHLFNBQVUxK0MsSUFBSTtRQUM5QyxJQUFJTTtRQUNKLElBQUlDLE1BQU0sSUFBSSxDQUFDa2hELE9BQU8sQ0FBQ2poRCxNQUFNO1FBQzdCLElBQUkwM0MsVUFBVSxFQUFFO1FBRWhCLElBQUs1M0MsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDM0IsSUFBSSxJQUFJLENBQUNtaEQsT0FBTyxDQUFDbmhELEVBQUUsQ0FBQ04sSUFBSSxLQUFLQSxNQUFNO2dCQUNqQ2s0QyxRQUFRcjJDLElBQUksQ0FBQyxJQUFJLENBQUM0L0MsT0FBTyxDQUFDbmhELEVBQUU7WUFDOUI7UUFDRjtRQUVBLE9BQU80M0M7SUFDVDtJQUVBLFNBQVM0SixpQkFBaUJuMEMsRUFBRSxFQUFFaTBDLE1BQU0sRUFBRUMsY0FBYztRQUNsRFIsbUJBQW1CLENBQUMxekMsR0FBRyxHQUFHO1lBQ3hCaTBDLFFBQVFBO1lBQ1JDLGdCQUFnQkE7UUFDbEI7SUFDRjtJQUVBLFNBQVNFLGtCQUFrQjtJQUUzQkEsZUFBZXJoRCxTQUFTLEdBQUc7UUFDekJzaEQscUJBQXFCLFNBQVNBO1lBQzVCLElBQUksQ0FBQ2xJLFlBQVksR0FBR3J2QyxTQUFTO1FBQy9CO1FBQ0F3M0MseUJBQXlCLFNBQVNBO1lBQ2hDLElBQUksQ0FBQ0MsWUFBWSxHQUFHejNDLFNBQVM7WUFDN0IsSUFBSSxDQUFDMDNDLGtCQUFrQixHQUFHLElBQUksQ0FBQ3JJLFlBQVk7WUFDM0MsSUFBSSxDQUFDc0csYUFBYSxHQUFHLElBQUksQ0FBQ3RHLFlBQVk7WUFDdEMsSUFBSSxDQUFDc0ksWUFBWSxHQUFHO1lBQ3BCLElBQUlDLHFCQUFxQixNQUFNLHVEQUF1RDtZQUV0RixJQUFJLElBQUksQ0FBQ2gzQyxJQUFJLENBQUNpM0MsRUFBRSxFQUFFO2dCQUNoQixJQUFJLENBQUNDLFVBQVUsR0FBRyxDQUFDO2dCQUNuQixJQUFJQyxLQUFLLzNDLFNBQVM7Z0JBQ2xCKzNDLEdBQUduZ0MsWUFBWSxDQUFDLE1BQU0sSUFBSSxDQUFDMjNCLE9BQU87Z0JBQ2xDd0ksR0FBR3h0QyxXQUFXLENBQUMsSUFBSSxDQUFDOGtDLFlBQVk7Z0JBQ2hDdUkscUJBQXFCRztnQkFDckIsSUFBSSxDQUFDem5DLFVBQVUsQ0FBQ0MsSUFBSSxDQUFDaEcsV0FBVyxDQUFDd3RDO1lBQ25DLE9BQU8sSUFBSSxJQUFJLENBQUNuM0MsSUFBSSxDQUFDbzNDLEVBQUUsRUFBRTtnQkFDdkIsSUFBSSxDQUFDUCxZQUFZLENBQUNsdEMsV0FBVyxDQUFDLElBQUksQ0FBQzhrQyxZQUFZO2dCQUMvQ3VJLHFCQUFxQixJQUFJLENBQUNILFlBQVk7Z0JBQ3RDLElBQUksQ0FBQ3JJLFdBQVcsR0FBRyxJQUFJLENBQUNxSSxZQUFZO1lBQ3RDLE9BQU87Z0JBQ0wsSUFBSSxDQUFDckksV0FBVyxHQUFHLElBQUksQ0FBQ0MsWUFBWTtZQUN0QztZQUVBLElBQUksSUFBSSxDQUFDenVDLElBQUksQ0FBQ3EzQyxFQUFFLEVBQUU7Z0JBQ2hCLElBQUksQ0FBQzVJLFlBQVksQ0FBQ3ozQixZQUFZLENBQUMsTUFBTSxJQUFJLENBQUNoWCxJQUFJLENBQUNxM0MsRUFBRTtZQUNuRDtZQUVBLElBQUksSUFBSSxDQUFDcjNDLElBQUksQ0FBQzRFLEVBQUUsRUFBRTtnQkFDaEIsSUFBSSxDQUFDNnBDLFlBQVksQ0FBQ3ozQixZQUFZLENBQUMsU0FBUyxJQUFJLENBQUNoWCxJQUFJLENBQUM0RSxFQUFFO1lBQ3RELEVBQUUscUlBQXFJO1lBR3ZJLElBQUksSUFBSSxDQUFDNUUsSUFBSSxDQUFDNEIsRUFBRSxLQUFLLEtBQUssQ0FBQyxJQUFJLENBQUM1QixJQUFJLENBQUNzM0MsRUFBRSxFQUFFO2dCQUN2QyxJQUFJQyxLQUFLbjRDLFNBQVM7Z0JBQ2xCLElBQUlzQyxLQUFLdEMsU0FBUztnQkFDbEJzQyxHQUFHc1YsWUFBWSxDQUFDLEtBQUssV0FBVyxJQUFJLENBQUNoWCxJQUFJLENBQUN3bEIsQ0FBQyxHQUFHLFNBQVMsSUFBSSxDQUFDeGxCLElBQUksQ0FBQ3dsQixDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUN4bEIsSUFBSSxDQUFDNUMsQ0FBQyxHQUFHLFNBQVMsSUFBSSxDQUFDNEMsSUFBSSxDQUFDNUMsQ0FBQyxHQUFHO2dCQUNoSCxJQUFJbzZDLFNBQVN4NkM7Z0JBQ2J1NkMsR0FBR3ZnQyxZQUFZLENBQUMsTUFBTXdnQztnQkFDdEJELEdBQUc1dEMsV0FBVyxDQUFDakk7Z0JBQ2YsSUFBSSxDQUFDZ08sVUFBVSxDQUFDQyxJQUFJLENBQUNoRyxXQUFXLENBQUM0dEM7Z0JBRWpDLElBQUksSUFBSSxDQUFDbkssVUFBVSxJQUFJO29CQUNyQixJQUFJcUssVUFBVXI0QyxTQUFTO29CQUN2QnE0QyxRQUFRemdDLFlBQVksQ0FBQyxhQUFhLFNBQVN2aUIsb0JBQW9CLE1BQU0raUQsU0FBUztvQkFDOUVDLFFBQVE5dEMsV0FBVyxDQUFDLElBQUksQ0FBQzhrQyxZQUFZO29CQUNyQyxJQUFJLENBQUNxSSxrQkFBa0IsR0FBR1c7b0JBRTFCLElBQUlULG9CQUFvQjt3QkFDdEJBLG1CQUFtQnJ0QyxXQUFXLENBQUMsSUFBSSxDQUFDbXRDLGtCQUFrQjtvQkFDeEQsT0FBTzt3QkFDTCxJQUFJLENBQUN0SSxXQUFXLEdBQUcsSUFBSSxDQUFDc0ksa0JBQWtCO29CQUM1QztnQkFDRixPQUFPO29CQUNMLElBQUksQ0FBQ3JJLFlBQVksQ0FBQ3ozQixZQUFZLENBQUMsYUFBYSxTQUFTdmlCLG9CQUFvQixNQUFNK2lELFNBQVM7Z0JBQzFGO1lBQ0Y7WUFFQSxJQUFJLElBQUksQ0FBQ3gzQyxJQUFJLENBQUN1dUMsRUFBRSxLQUFLLEdBQUc7Z0JBQ3RCLElBQUksQ0FBQ0YsWUFBWTtZQUNuQjtRQUNGO1FBQ0FxSixlQUFlLFNBQVNBO1lBQ3RCLElBQUksSUFBSSxDQUFDak0sY0FBYyxDQUFDNkcsWUFBWSxFQUFFO2dCQUNwQyxJQUFJLENBQUN3RSxrQkFBa0IsQ0FBQzkvQixZQUFZLENBQUMsYUFBYSxJQUFJLENBQUN5MEIsY0FBYyxDQUFDK0csUUFBUSxDQUFDMWYsT0FBTztZQUN4RjtZQUVBLElBQUksSUFBSSxDQUFDMlksY0FBYyxDQUFDOEcsTUFBTSxFQUFFO2dCQUM5QixJQUFJLENBQUN1RSxrQkFBa0IsQ0FBQzkvQixZQUFZLENBQUMsV0FBVyxJQUFJLENBQUN5MEIsY0FBYyxDQUFDZ0gsWUFBWTtZQUNsRjtRQUNGO1FBQ0FrRixvQkFBb0IsU0FBU0E7WUFDM0IsSUFBSSxDQUFDbEosWUFBWSxHQUFHO1lBQ3BCLElBQUksQ0FBQ29JLFlBQVksR0FBRztZQUNwQixJQUFJLENBQUNsSixXQUFXLENBQUNuakMsT0FBTztRQUMxQjtRQUNBNGtDLGdCQUFnQixTQUFTQTtZQUN2QixJQUFJLElBQUksQ0FBQ3B2QyxJQUFJLENBQUNzM0MsRUFBRSxFQUFFO2dCQUNoQixPQUFPO1lBQ1Q7WUFFQSxPQUFPLElBQUksQ0FBQzlJLFdBQVc7UUFDekI7UUFDQW9KLDRCQUE0QixTQUFTQTtZQUNuQyxJQUFJLENBQUNqSyxXQUFXLEdBQUcsSUFBSStGLFlBQVksSUFBSSxDQUFDMXpDLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDMFAsVUFBVTtZQUNuRSxJQUFJLENBQUN5akMsd0JBQXdCLEdBQUcsSUFBSStDLFdBQVcsSUFBSTtZQUNuRCxJQUFJLENBQUNoRCxzQkFBc0I7UUFDN0I7UUFDQTJFLFVBQVUsU0FBU0EsU0FBU0MsU0FBUztZQUNuQyxtR0FBbUc7WUFDbkcsK0VBQStFO1lBQy9FLHdDQUF3QztZQUN4QyxJQUFJLENBQUMsSUFBSSxDQUFDWixVQUFVLEVBQUU7Z0JBQ3BCLElBQUksQ0FBQ0EsVUFBVSxHQUFHLENBQUM7WUFDckI7WUFFQSxJQUFJLENBQUMsSUFBSSxDQUFDQSxVQUFVLENBQUNZLFVBQVUsRUFBRTtnQkFDL0IsSUFBSXgxQyxLQUFLLElBQUksQ0FBQ3FzQyxPQUFPLEdBQUcsTUFBTW1KO2dCQUM5QixJQUFJckM7Z0JBQ0osSUFBSUU7Z0JBQ0osSUFBSW9DO2dCQUNKLElBQUlaO2dCQUVKLElBQUlXLGNBQWMsS0FBS0EsY0FBYyxHQUFHO29CQUN0QyxJQUFJRSxTQUFTNTRDLFNBQVM7b0JBQ3RCNDRDLE9BQU9oaEMsWUFBWSxDQUFDLE1BQU0xVTtvQkFDMUIwMUMsT0FBT2hoQyxZQUFZLENBQUMsYUFBYThnQyxjQUFjLElBQUksY0FBYztvQkFDakVDLGFBQWEzNEMsU0FBUztvQkFDdEIyNEMsV0FBV3Z1QyxjQUFjLENBQUMsZ0NBQWdDLFFBQVEsTUFBTSxJQUFJLENBQUNtbEMsT0FBTztvQkFDcEZxSixPQUFPcnVDLFdBQVcsQ0FBQ291QztvQkFDbkIsSUFBSSxDQUFDcm9DLFVBQVUsQ0FBQ0MsSUFBSSxDQUFDaEcsV0FBVyxDQUFDcXVDO29CQUVqQyxJQUFJLENBQUNuQyxlQUFlMUIsUUFBUSxJQUFJMkQsY0FBYyxHQUFHO3dCQUMvQ0UsT0FBT2hoQyxZQUFZLENBQUMsYUFBYTt3QkFDakN5K0IsUUFBUXo0Qzt3QkFDUjI0QyxNQUFNTCxlQUFlQyxZQUFZLENBQUNFO3dCQUNsQyxJQUFJLENBQUMvbEMsVUFBVSxDQUFDQyxJQUFJLENBQUNoRyxXQUFXLENBQUNnc0M7d0JBQ2pDQSxJQUFJaHNDLFdBQVcsQ0FBQzJyQyxlQUFlRSw0QkFBNEI7d0JBQzNEMkIsS0FBSy8zQyxTQUFTO3dCQUNkKzNDLEdBQUd4dEMsV0FBVyxDQUFDb3VDO3dCQUNmQyxPQUFPcnVDLFdBQVcsQ0FBQ3d0Qzt3QkFDbkJBLEdBQUduZ0MsWUFBWSxDQUFDLFVBQVUsU0FBU3ZpQixvQkFBb0IsTUFBTWdoRCxRQUFRO29CQUN2RTtnQkFDRixPQUFPLElBQUlxQyxjQUFjLEdBQUc7b0JBQzFCLElBQUlHLFlBQVk3NEMsU0FBUztvQkFDekI2NEMsVUFBVWpoQyxZQUFZLENBQUMsTUFBTTFVO29CQUM3QjIxQyxVQUFVamhDLFlBQVksQ0FBQyxhQUFhO29CQUNwQyxJQUFJa2hDLGNBQWM5NEMsU0FBUztvQkFDM0I2NEMsVUFBVXR1QyxXQUFXLENBQUN1dUM7b0JBQ3RCekMsUUFBUXo0QztvQkFDUjI0QyxNQUFNTCxlQUFlQyxZQUFZLENBQUNFLFFBQVEsS0FBSztvQkFFL0MsSUFBSTBDLFFBQVEvNEMsU0FBUztvQkFDckIrNEMsTUFBTW5oQyxZQUFZLENBQUMsTUFBTTtvQkFDekIyK0IsSUFBSWhzQyxXQUFXLENBQUN3dUM7b0JBQ2hCLElBQUlDLFNBQVNoNUMsU0FBUztvQkFDdEJnNUMsT0FBT3BoQyxZQUFZLENBQUMsUUFBUTtvQkFDNUJvaEMsT0FBT3BoQyxZQUFZLENBQUMsZUFBZTtvQkFDbkNtaEMsTUFBTXh1QyxXQUFXLENBQUN5dUMsU0FBUyxLQUFLO29CQUVoQyxJQUFJLENBQUMxb0MsVUFBVSxDQUFDQyxJQUFJLENBQUNoRyxXQUFXLENBQUNnc0M7b0JBQ2pDLElBQUkwQyxZQUFZajVDLFNBQVM7b0JBQ3pCaTVDLFVBQVVyaEMsWUFBWSxDQUFDLFNBQVMsSUFBSSxDQUFDelUsSUFBSSxDQUFDdkMsSUFBSSxDQUFDd2xCLENBQUM7b0JBQ2hENnlCLFVBQVVyaEMsWUFBWSxDQUFDLFVBQVUsSUFBSSxDQUFDelUsSUFBSSxDQUFDdkMsSUFBSSxDQUFDNUMsQ0FBQztvQkFDakRpN0MsVUFBVXJoQyxZQUFZLENBQUMsS0FBSztvQkFDNUJxaEMsVUFBVXJoQyxZQUFZLENBQUMsS0FBSztvQkFDNUJxaEMsVUFBVXJoQyxZQUFZLENBQUMsUUFBUTtvQkFDL0JxaEMsVUFBVXJoQyxZQUFZLENBQUMsV0FBVztvQkFDbENraEMsWUFBWWxoQyxZQUFZLENBQUMsVUFBVSxTQUFTdmlCLG9CQUFvQixNQUFNZ2hELFFBQVE7b0JBQzlFeUMsWUFBWXZ1QyxXQUFXLENBQUMwdUM7b0JBQ3hCTixhQUFhMzRDLFNBQVM7b0JBQ3RCMjRDLFdBQVd2dUMsY0FBYyxDQUFDLGdDQUFnQyxRQUFRLE1BQU0sSUFBSSxDQUFDbWxDLE9BQU87b0JBQ3BGdUosWUFBWXZ1QyxXQUFXLENBQUNvdUM7b0JBRXhCLElBQUksQ0FBQ2xDLGVBQWUxQixRQUFRLEVBQUU7d0JBQzVCOEQsVUFBVWpoQyxZQUFZLENBQUMsYUFBYTt3QkFDcEMyK0IsSUFBSWhzQyxXQUFXLENBQUMyckMsZUFBZUUsNEJBQTRCO3dCQUMzRDJCLEtBQUsvM0MsU0FBUzt3QkFDZDg0QyxZQUFZdnVDLFdBQVcsQ0FBQzB1Qzt3QkFDeEJsQixHQUFHeHRDLFdBQVcsQ0FBQyxJQUFJLENBQUM4a0MsWUFBWTt3QkFDaEN5SixZQUFZdnVDLFdBQVcsQ0FBQ3d0QztvQkFDMUI7b0JBRUEsSUFBSSxDQUFDem5DLFVBQVUsQ0FBQ0MsSUFBSSxDQUFDaEcsV0FBVyxDQUFDc3VDO2dCQUNuQztnQkFFQSxJQUFJLENBQUNmLFVBQVUsQ0FBQ1ksVUFBVSxHQUFHeDFDO1lBQy9CO1lBRUEsT0FBTyxJQUFJLENBQUM0MEMsVUFBVSxDQUFDWSxVQUFVO1FBQ25DO1FBQ0FRLFVBQVUsU0FBU0EsU0FBU2gyQyxFQUFFO1lBQzVCLElBQUksQ0FBQyxJQUFJLENBQUN1MEMsWUFBWSxFQUFFO2dCQUN0QjtZQUNGO1lBRUEsSUFBSSxDQUFDQSxZQUFZLENBQUM3L0IsWUFBWSxDQUFDLFFBQVEsU0FBU3ZpQixvQkFBb0IsTUFBTTZOLEtBQUs7UUFDakY7SUFDRjtJQUVBOzs7O0dBSUMsR0FDRCxTQUFTaTJDLG9CQUFvQjtJQUU3QkEsaUJBQWlCbGpELFNBQVMsR0FBRztRQUMzQjs7OztPQUlHLEdBQ0htakQsZUFBZSxTQUFTQTtZQUN0Qix3QkFBd0I7WUFDeEIsSUFBSSxDQUFDbEgsU0FBUyxHQUFHLEVBQUUsRUFBRSwrREFBK0Q7WUFFcEYsSUFBSSxDQUFDckMsU0FBUyxHQUFHO1lBQ2pCLElBQUksQ0FBQ3dKLGNBQWM7UUFDckI7UUFFQTs7Ozs7O09BTUcsR0FDSGhILGNBQWMsU0FBU0EsYUFBYUgsU0FBUztZQUMzQyxJQUFJLENBQUNBLFNBQVMsR0FBR0E7UUFDbkI7UUFFQTs7OztPQUlHLEdBQ0hFLGFBQWEsU0FBU0E7WUFDcEIsSUFBSSxDQUFDdkMsU0FBUyxHQUFHO1FBQ25CO1FBRUE7Ozs7T0FJRyxHQUNId0osZ0JBQWdCLFNBQVNBO1lBQ3ZCLElBQUksSUFBSSxDQUFDejRDLElBQUksQ0FBQ2dtQyxNQUFNLEtBQUtuMkIsV0FBVztnQkFDbEMsSUFBSSxDQUFDdE4sSUFBSSxDQUFDNnVDLHFCQUFxQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUNweEMsSUFBSSxDQUFDZ21DLE1BQU0sRUFBRSxFQUFFO1lBQzVEO1FBQ0Y7SUFDRjtJQUVBLFNBQVMwUyx3QkFBd0I7SUFFaEM7UUFDQyxJQUFJQyxhQUFhO1lBQ2ZDLGFBQWEsU0FBU0EsWUFBWTU0QyxJQUFJLEVBQUUwUCxVQUFVLEVBQUVuTixJQUFJO2dCQUN0RCxJQUFJLENBQUNvZSxTQUFTO2dCQUNkLElBQUksQ0FBQyt0QixZQUFZLENBQUMxdUMsTUFBTTBQLFlBQVluTjtnQkFDcEMsSUFBSSxDQUFDNnZDLGFBQWEsQ0FBQ3B5QyxNQUFNMFAsWUFBWW5OO2dCQUNyQyxJQUFJLENBQUNpMkMsYUFBYTtnQkFDbEIsSUFBSSxDQUFDM04sY0FBYztnQkFDbkIsSUFBSSxDQUFDOEwsbUJBQW1CO2dCQUN4QixJQUFJLENBQUNDLHVCQUF1QjtnQkFDNUIsSUFBSSxDQUFDZ0IsMEJBQTBCO2dCQUMvQixJQUFJLENBQUNpQixhQUFhO2dCQUNsQixJQUFJLENBQUM5akMsSUFBSTtZQUNYO1lBQ0FBLE1BQU0sU0FBU0E7Z0JBQ2IsNkJBQTZCO2dCQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDZzJCLE1BQU0sSUFBSyxFQUFDLElBQUksQ0FBQ0QsU0FBUyxJQUFJLElBQUksQ0FBQ0UsYUFBYSxHQUFHO29CQUMzRCxJQUFJaDFCLE9BQU8sSUFBSSxDQUFDdzRCLFdBQVcsSUFBSSxJQUFJLENBQUNDLFlBQVk7b0JBQ2hEejRCLEtBQUs5YSxLQUFLLENBQUNJLE9BQU8sR0FBRztvQkFDckIsSUFBSSxDQUFDeXZDLE1BQU0sR0FBRztnQkFDaEI7WUFDRjtZQUNBLzFCLE1BQU0sU0FBU0E7Z0JBQ2IsNkJBQTZCO2dCQUM3QixJQUFJLElBQUksQ0FBQzgxQixTQUFTLElBQUksQ0FBQyxJQUFJLENBQUNFLGFBQWEsRUFBRTtvQkFDekMsSUFBSSxDQUFDLElBQUksQ0FBQ2hyQyxJQUFJLENBQUNzM0MsRUFBRSxFQUFFO3dCQUNqQixJQUFJdGhDLE9BQU8sSUFBSSxDQUFDdzRCLFdBQVcsSUFBSSxJQUFJLENBQUNDLFlBQVk7d0JBQ2hEejRCLEtBQUs5YSxLQUFLLENBQUNJLE9BQU8sR0FBRztvQkFDdkI7b0JBRUEsSUFBSSxDQUFDeXZDLE1BQU0sR0FBRztvQkFDZCxJQUFJLENBQUN4a0IsYUFBYSxHQUFHO2dCQUN2QjtZQUNGO1lBQ0E5VCxhQUFhLFNBQVNBO2dCQUNwQixtRUFBbUU7Z0JBQ25FLHlDQUF5QztnQkFDekMsSUFBSSxJQUFJLENBQUN6UyxJQUFJLENBQUNzM0MsRUFBRSxJQUFJLElBQUksQ0FBQ3ZNLE1BQU0sRUFBRTtvQkFDL0I7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDNEgsZUFBZTtnQkFDcEIsSUFBSSxDQUFDOUcsZ0JBQWdCO2dCQUNyQixJQUFJLENBQUNnSCxvQkFBb0I7Z0JBQ3pCLElBQUksQ0FBQzZFLGFBQWE7Z0JBQ2xCLElBQUksQ0FBQ29CLGtCQUFrQjtnQkFFdkIsSUFBSSxJQUFJLENBQUN2eUIsYUFBYSxFQUFFO29CQUN0QixJQUFJLENBQUNBLGFBQWEsR0FBRztnQkFDdkI7WUFDRjtZQUNBdXlCLG9CQUFvQixTQUFTQSxzQkFBc0I7WUFDbkQvckMsY0FBYyxTQUFTQSxhQUFhdStCLEdBQUc7Z0JBQ3JDLElBQUksQ0FBQ3BsQixJQUFJLEdBQUc7Z0JBQ1osSUFBSSxDQUFDbWxCLHNCQUFzQixDQUFDQztnQkFDNUIsSUFBSSxDQUFDeUQsaUJBQWlCLENBQUN6RCxLQUFLLElBQUksQ0FBQ1IsU0FBUztnQkFDMUMsSUFBSSxDQUFDVSxpQkFBaUI7WUFDeEI7WUFDQWhoQyxTQUFTLFNBQVNBO2dCQUNoQixJQUFJLENBQUN1dUMsU0FBUyxHQUFHO2dCQUNqQixJQUFJLENBQUNwQixrQkFBa0I7WUFDekI7UUFDRjtRQUNBN2lELGdCQUFnQjtZQUFDODFDO1lBQW1COTBDLG9CQUFvQjZpRDtTQUFZLEVBQUVEO0lBQ3hFO0lBRUEsU0FBU00sY0FBY2g1QyxJQUFJLEVBQUUwUCxVQUFVLEVBQUVuTixJQUFJO1FBQzNDLElBQUksQ0FBQ2dHLFNBQVMsR0FBR21ILFdBQVdvRixZQUFZLENBQUM5VSxLQUFLOEIsS0FBSztRQUVuRCxJQUFJLElBQUksQ0FBQ3lHLFNBQVMsSUFBSSxJQUFJLENBQUNBLFNBQVMsQ0FBQytlLEdBQUcsRUFBRTtZQUN4QyxJQUFJLENBQUMvZSxTQUFTLEdBQUdtSCxXQUFXNlgsV0FBVyxDQUFDRixPQUFPLENBQUMsSUFBSSxDQUFDOWUsU0FBUztRQUNoRTtRQUVBLElBQUksQ0FBQ3F3QyxXQUFXLENBQUM1NEMsTUFBTTBQLFlBQVluTjtRQUNuQyxJQUFJLENBQUMwMkMsVUFBVSxHQUFHO1lBQ2hCNzlDLEtBQUs7WUFDTEMsTUFBTTtZQUNOb00sT0FBTyxJQUFJLENBQUNjLFNBQVMsQ0FBQ2lkLENBQUM7WUFDdkI5ZCxRQUFRLElBQUksQ0FBQ2EsU0FBUyxDQUFDbkwsQ0FBQztRQUMxQjtJQUNGO0lBRUF0SSxnQkFBZ0I7UUFBQ3E0QztRQUFhZ0Y7UUFBa0J1RTtRQUFnQjZCO1FBQWtCeko7UUFBYzRKO0tBQXFCLEVBQUVNO0lBRXZIQSxjQUFjM2pELFNBQVMsQ0FBQ3dqRCxhQUFhLEdBQUc7UUFDdEMsSUFBSS9oRCxZQUFZLElBQUksQ0FBQzRZLFVBQVUsQ0FBQ3BILGFBQWEsQ0FBQyxJQUFJLENBQUNDLFNBQVM7UUFDNUQsSUFBSSxDQUFDd3dDLFNBQVMsR0FBRzM1QyxTQUFTO1FBQzFCLElBQUksQ0FBQzI1QyxTQUFTLENBQUMvaEMsWUFBWSxDQUFDLFNBQVMsSUFBSSxDQUFDek8sU0FBUyxDQUFDaWQsQ0FBQyxHQUFHO1FBQ3hELElBQUksQ0FBQ3V6QixTQUFTLENBQUMvaEMsWUFBWSxDQUFDLFVBQVUsSUFBSSxDQUFDek8sU0FBUyxDQUFDbkwsQ0FBQyxHQUFHO1FBQ3pELElBQUksQ0FBQzI3QyxTQUFTLENBQUMvaEMsWUFBWSxDQUFDLHVCQUF1QixJQUFJLENBQUN6TyxTQUFTLENBQUMyd0MsRUFBRSxJQUFJLElBQUksQ0FBQ3hwQyxVQUFVLENBQUNpOEIsWUFBWSxDQUFDd04sd0JBQXdCO1FBQzdILElBQUksQ0FBQ0osU0FBUyxDQUFDdnZDLGNBQWMsQ0FBQyxnQ0FBZ0MsUUFBUTFTO1FBQ3RFLElBQUksQ0FBQzIzQyxZQUFZLENBQUM5a0MsV0FBVyxDQUFDLElBQUksQ0FBQ292QyxTQUFTO0lBQzlDO0lBRUFDLGNBQWMzakQsU0FBUyxDQUFDeTJDLGdCQUFnQixHQUFHO1FBQ3pDLE9BQU8sSUFBSSxDQUFDbU4sVUFBVTtJQUN4QjtJQUVBLFNBQVNHLGlCQUFpQm4rQyxPQUFPLEVBQUVFLFFBQVE7UUFDekMsSUFBSSxDQUFDNmEsSUFBSSxHQUFHL2E7UUFDWixJQUFJLENBQUNrdEIsR0FBRyxHQUFHaHRCO0lBQ2I7SUFFQSxTQUFTaytDLGlCQUFpQjtJQUUxQkEsY0FBY2hrRCxTQUFTLEdBQUc7UUFDeEJpa0QscUJBQXFCLFNBQVNBLG9CQUFvQnQ1QyxJQUFJO1lBQ3BELElBQUkvSztZQUNKLElBQUlDLE1BQU0sSUFBSSxDQUFDcWtELGNBQWMsQ0FBQ3BrRCxNQUFNO1lBRXBDLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO2dCQUMzQixJQUFJLENBQUNza0QsY0FBYyxDQUFDdGtELEVBQUUsQ0FBQ3MwQixRQUFRLENBQUN2cEI7WUFDbEM7UUFDRjtRQUNBdzVDLDRCQUE0QixTQUFTQSwyQkFBMkJ4NUMsSUFBSTtZQUNsRSxJQUFJL0ssSUFBSTtZQUNSLElBQUlDLE1BQU0sSUFBSSxDQUFDcWtELGNBQWMsQ0FBQ3BrRCxNQUFNO1lBRXBDLE1BQU9GLElBQUlDLElBQUs7Z0JBQ2QsSUFBSSxJQUFJLENBQUNxa0QsY0FBYyxDQUFDdGtELEVBQUUsQ0FBQ3drRCxtQkFBbUIsQ0FBQ3o1QyxPQUFPO29CQUNwRCxPQUFPO2dCQUNUO1lBQ0Y7WUFFQSxPQUFPO1FBQ1Q7UUFDQTA1QyxpQkFBaUIsU0FBU0E7WUFDeEIsSUFBSSxDQUFDLElBQUksQ0FBQ0gsY0FBYyxDQUFDcGtELE1BQU0sRUFBRTtnQkFDL0I7WUFDRjtZQUVBLElBQUlGO1lBQ0osSUFBSUMsTUFBTSxJQUFJLENBQUM4TSxNQUFNLENBQUM3TSxNQUFNO1lBRTVCLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO2dCQUMzQixJQUFJLENBQUMrTSxNQUFNLENBQUMvTSxFQUFFLENBQUMrdEIsRUFBRSxDQUFDMkgsS0FBSztZQUN6QjtZQUVBejFCLE1BQU0sSUFBSSxDQUFDcWtELGNBQWMsQ0FBQ3BrRCxNQUFNO1lBQ2hDLElBQUl3a0Q7WUFFSixJQUFLMWtELElBQUlDLE1BQU0sR0FBR0QsS0FBSyxHQUFHQSxLQUFLLEVBQUc7Z0JBQ2hDMGtELHFCQUFxQixJQUFJLENBQUNKLGNBQWMsQ0FBQ3RrRCxFQUFFLENBQUNtaEMsYUFBYSxDQUFDLElBQUksQ0FBQzdQLGFBQWEsR0FBRyx3R0FBd0c7Z0JBQ3ZMLHdDQUF3QztnQkFFeEMsSUFBSW96QixvQkFBb0I7b0JBQ3RCO2dCQUNGO1lBQ0Y7UUFDRjtRQUNBQyx3QkFBd0IsU0FBU0EsdUJBQXVCNWpDLElBQUk7WUFDMUQsSUFBSW9rQixXQUFXLElBQUksQ0FBQ3lmLGlCQUFpQjtZQUNyQyxJQUFJNWtELElBQUk7WUFDUixJQUFJQyxNQUFNa2xDLFNBQVNqbEMsTUFBTTtZQUV6QixNQUFPRixJQUFJQyxJQUFLO2dCQUNkLElBQUlrbEMsUUFBUSxDQUFDbmxDLEVBQUUsQ0FBQytnQixJQUFJLEtBQUtBLE1BQU07b0JBQzdCLE9BQU9va0IsUUFBUSxDQUFDbmxDLEVBQUUsQ0FBQ2t6QixHQUFHO2dCQUN4QjtnQkFFQWx6QixLQUFLO1lBQ1A7WUFFQSxPQUFPO1FBQ1Q7UUFDQTZrRCxxQkFBcUIsU0FBU0Esb0JBQW9COWpDLElBQUksRUFBRW1TLEdBQUc7WUFDekQsSUFBSWlTLFdBQVcsSUFBSSxDQUFDeWYsaUJBQWlCO1lBQ3JDLElBQUk1a0QsSUFBSW1sQyxTQUFTamxDLE1BQU07WUFFdkIsTUFBT0YsRUFBRztnQkFDUkEsS0FBSztnQkFFTCxJQUFJbWxDLFFBQVEsQ0FBQ25sQyxFQUFFLENBQUMrZ0IsSUFBSSxLQUFLQSxNQUFNO29CQUM3Qm9rQixRQUFRLENBQUNubEMsRUFBRSxDQUFDa3pCLEdBQUcsR0FBR0E7b0JBQ2xCO2dCQUNGO1lBQ0Y7WUFFQWlTLFNBQVM1akMsSUFBSSxDQUFDLElBQUk0aUQsaUJBQWlCcGpDLE1BQU1tUztRQUMzQztRQUNBcGIsY0FBYyxTQUFTQSxhQUFhdStCLEdBQUc7WUFDckMsSUFBSSxDQUFDRCxzQkFBc0IsQ0FBQ0M7WUFDNUIsSUFBSSxDQUFDeUQsaUJBQWlCLENBQUN6RCxLQUFLLElBQUksQ0FBQ1IsU0FBUztRQUM1QztJQUNGO0lBRUEsSUFBSWlQLGNBQWM7UUFDaEIsR0FBRztRQUNILEdBQUc7UUFDSCxHQUFHO0lBQ0w7SUFDQSxJQUFJQyxlQUFlO1FBQ2pCLEdBQUc7UUFDSCxHQUFHO1FBQ0gsR0FBRztJQUNMO0lBRUEsU0FBU0MsYUFBYUMsWUFBWSxFQUFFQyxLQUFLLEVBQUUvd0IsS0FBSztRQUM5QyxJQUFJLENBQUNneEIsTUFBTSxHQUFHLEVBQUU7UUFDaEIsSUFBSSxDQUFDdlcsTUFBTSxHQUFHLEVBQUU7UUFDaEIsSUFBSSxDQUFDcVcsWUFBWSxHQUFHQTtRQUNwQixJQUFJLENBQUNHLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ3IzQixFQUFFLEdBQUdvRztRQUNWLElBQUksQ0FBQ2t4QixHQUFHLEdBQUdILE9BQU8sb0VBQW9FO1FBQ3RGLHlGQUF5RjtRQUN6RixzR0FBc0c7UUFFdEcsSUFBSSxDQUFDenlCLFdBQVcsR0FBRyxDQUFDLENBQUMwQixNQUFNaG9CLENBQUMsRUFBRSw4REFBOEQ7UUFFNUYsSUFBSW5NLElBQUk7UUFDUixJQUFJQyxNQUFNZ2xELGFBQWEva0QsTUFBTTtRQUU3QixNQUFPRixJQUFJQyxJQUFLO1lBQ2QsSUFBSWdsRCxZQUFZLENBQUNqbEQsRUFBRSxDQUFDMm1DLE1BQU0sQ0FBQ25VLGlCQUFpQixDQUFDdHlCLE1BQU0sRUFBRTtnQkFDbkQsSUFBSSxDQUFDdXlCLFdBQVcsR0FBRztnQkFDbkI7WUFDRjtZQUVBenlCLEtBQUs7UUFDUDtJQUNGO0lBRUFnbEQsYUFBYTVrRCxTQUFTLENBQUNpZ0MsYUFBYSxHQUFHO1FBQ3JDLElBQUksQ0FBQzVOLFdBQVcsR0FBRztJQUNyQjtJQUVBLFNBQVM2eUIsYUFBYXY2QyxJQUFJLEVBQUVtNkMsS0FBSztRQUMvQixJQUFJLENBQUNuNkMsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ3JMLElBQUksR0FBR3FMLEtBQUs0QixFQUFFO1FBQ25CLElBQUksQ0FBQzdELENBQUMsR0FBRztRQUNULElBQUksQ0FBQ3U4QyxHQUFHLEdBQUdIO1FBQ1gsSUFBSSxDQUFDajBCLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ3ZoQixNQUFNLEdBQUczRSxLQUFLczNDLEVBQUUsS0FBSztRQUMxQixJQUFJLENBQUNrRCxLQUFLLEdBQUdwN0MsU0FBUztRQUN0QixJQUFJLENBQUNxN0MsTUFBTSxHQUFHO0lBQ2hCO0lBRUFGLGFBQWFsbEQsU0FBUyxDQUFDczFCLEtBQUssR0FBRztRQUM3QixJQUFJLENBQUM1c0IsQ0FBQyxHQUFHO1FBQ1QsSUFBSSxDQUFDbW9CLElBQUksR0FBRztJQUNkO0lBRUEsU0FBU3cwQixhQUFhMWtDLElBQUksRUFBRWhXLElBQUksRUFBRW9PLFFBQVEsRUFBRWtCLFNBQVM7UUFDbkQsSUFBSSxDQUFDMEcsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ29RLE9BQU8sR0FBRyxDQUFDO1FBQ2hCLElBQUksQ0FBQ3UwQixTQUFTLEdBQUd0aUQsaUJBQWlCMkgsS0FBSzdLLE1BQU07UUFDN0MsSUFBSSxDQUFDaVosUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNoTixDQUFDLEdBQUc7UUFDVCxJQUFJLENBQUN3NUMsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxTQUFTLEdBQUcvaUQsaUJBQWlCLFdBQVdrSSxLQUFLN0ssTUFBTSxHQUFHNkssS0FBSzdLLE1BQU0sR0FBRyxJQUFJO1FBQzdFLElBQUksQ0FBQzJsRCxVQUFVLEdBQUdoakQsaUJBQWlCLFdBQVc7UUFDOUMsSUFBSSxDQUFDOHZCLDRCQUE0QixDQUFDdFk7UUFDbEMsSUFBSXJhO1FBQ0osSUFBSUMsTUFBTThLLEtBQUs3SyxNQUFNLElBQUk7UUFDekIsSUFBSVM7UUFFSixJQUFLWCxJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQlcsT0FBT3d4QixnQkFBZ0JDLE9BQU8sQ0FBQ3JSLE1BQU1oVyxJQUFJLENBQUMvSyxFQUFFLENBQUNxSSxDQUFDLEVBQUUsR0FBRyxHQUFHLElBQUk7WUFDMUQsSUFBSSxDQUFDOEQsQ0FBQyxHQUFHeEwsS0FBS3dMLENBQUMsSUFBSSxJQUFJLENBQUNBLENBQUM7WUFDekIsSUFBSSxDQUFDdTVDLFNBQVMsQ0FBQzFsRCxFQUFFLEdBQUc7Z0JBQ2xCbXRCLEdBQUdwaUIsSUFBSSxDQUFDL0ssRUFBRSxDQUFDbXRCLENBQUM7Z0JBQ1p6a0IsR0FBRy9IO1lBQ0w7UUFDRjtRQUVBLElBQUksQ0FBQyxJQUFJLENBQUN3TCxDQUFDLEVBQUU7WUFDWCxJQUFJLENBQUMybEIsUUFBUSxDQUFDO1FBQ2hCO1FBRUEsSUFBSSxDQUFDVyxXQUFXLEdBQUcsSUFBSSxDQUFDdG1CLENBQUM7SUFDM0I7SUFFQXM1QyxhQUFhcmxELFNBQVMsQ0FBQzB4QixRQUFRLEdBQUcsU0FBVXVSLFdBQVc7UUFDckQsSUFBSSxJQUFJLENBQUN0aUIsSUFBSSxDQUFDdEcsVUFBVSxDQUFDMFcsT0FBTyxLQUFLLElBQUksQ0FBQ0EsT0FBTyxJQUFJLENBQUNrUyxhQUFhO1lBQ2pFO1FBQ0Y7UUFFQSxJQUFJLENBQUNsUyxPQUFPLEdBQUcsSUFBSSxDQUFDcFEsSUFBSSxDQUFDdEcsVUFBVSxDQUFDMFcsT0FBTztRQUMzQyxJQUFJLENBQUN1Qix3QkFBd0I7UUFDN0IsSUFBSSxDQUFDekIsSUFBSSxHQUFHLElBQUksQ0FBQ0EsSUFBSSxJQUFJb1M7UUFFekIsSUFBSSxJQUFJLENBQUNwUyxJQUFJLEVBQUU7WUFDYixJQUFJanhCLElBQUk7WUFDUixJQUFJQyxNQUFNLElBQUksQ0FBQ3lsRCxTQUFTLENBQUN4bEQsTUFBTTtZQUUvQixJQUFJLElBQUksQ0FBQ2laLFFBQVEsS0FBSyxPQUFPO2dCQUMzQixJQUFJLENBQUN3c0MsT0FBTyxHQUFHO1lBQ2pCO1lBRUEsSUFBSzNsRCxJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztnQkFDM0IsSUFBSSxJQUFJLENBQUMwbEQsU0FBUyxDQUFDMWxELEVBQUUsQ0FBQ210QixDQUFDLEtBQUssS0FBSztvQkFDL0IsSUFBSSxJQUFJLENBQUNoVSxRQUFRLEtBQUssT0FBTzt3QkFDM0IsSUFBSSxDQUFDd3NDLE9BQU8sSUFBSSxNQUFNLElBQUksQ0FBQ0QsU0FBUyxDQUFDMWxELEVBQUUsQ0FBQzBJLENBQUMsQ0FBQ0wsQ0FBQztvQkFDN0MsT0FBTzt3QkFDTCxJQUFJLENBQUN1OUMsU0FBUyxDQUFDNWxELEVBQUUsR0FBRyxJQUFJLENBQUMwbEQsU0FBUyxDQUFDMWxELEVBQUUsQ0FBQzBJLENBQUMsQ0FBQ0wsQ0FBQztvQkFDM0M7Z0JBQ0YsT0FBTztvQkFDTCxJQUFJLENBQUN3OUMsVUFBVSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUNILFNBQVMsQ0FBQzFsRCxFQUFFLENBQUMwSSxDQUFDLENBQUNMLENBQUM7Z0JBQzVDO1lBQ0Y7UUFDRjtJQUNGO0lBRUF4SSxnQkFBZ0I7UUFBQzB5QjtLQUF5QixFQUFFa3pCO0lBRTVDLFNBQVNLLG1CQUFtQi9rQyxJQUFJLEVBQUVoVyxJQUFJLEVBQUVnN0MsT0FBTztRQUM3QyxJQUFJLENBQUNwekIsNEJBQTRCLENBQUM1UjtRQUNsQyxJQUFJLENBQUMrUSxRQUFRLEdBQUcsSUFBSSxDQUFDWSx3QkFBd0I7UUFDN0MsSUFBSSxDQUFDN2tCLENBQUMsR0FBR3NrQixnQkFBZ0JDLE9BQU8sQ0FBQ3JSLE1BQU1oVyxLQUFLOEMsQ0FBQyxFQUFFLEdBQUcsTUFBTSxJQUFJO1FBQzVELElBQUksQ0FBQzBpQixDQUFDLEdBQUc0QixnQkFBZ0JDLE9BQU8sQ0FBQ3JSLE1BQU1oVyxLQUFLd2xCLENBQUMsRUFBRSxHQUFHLE1BQU0sSUFBSTtRQUM1RCxJQUFJLENBQUN6bkIsQ0FBQyxHQUFHLElBQUkyOEMsYUFBYTFrQyxNQUFNaFcsS0FBS2pDLENBQUMsSUFBSSxDQUFDLEdBQUcsT0FBTyxJQUFJO1FBQ3pELElBQUksQ0FBQ3lHLENBQUMsR0FBRzRpQixnQkFBZ0JDLE9BQU8sQ0FBQ3JSLE1BQU1oVyxLQUFLd0UsQ0FBQyxFQUFFLEdBQUcsS0FBSyxJQUFJO1FBQzNELElBQUksQ0FBQ3RKLEtBQUssR0FBRzgvQztRQUNiLElBQUksQ0FBQ3R6QixXQUFXLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQ0EsV0FBVztJQUN2QztJQUVBNXlCLGdCQUFnQjtRQUFDMHlCO0tBQXlCLEVBQUV1ekI7SUFFNUMsU0FBU0UsaUJBQWlCamxDLElBQUksRUFBRWhXLElBQUksRUFBRWc3QyxPQUFPO1FBQzNDLElBQUksQ0FBQ3B6Qiw0QkFBNEIsQ0FBQzVSO1FBQ2xDLElBQUksQ0FBQytRLFFBQVEsR0FBRyxJQUFJLENBQUNZLHdCQUF3QjtRQUM3QyxJQUFJLENBQUM3a0IsQ0FBQyxHQUFHc2tCLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUs4QyxDQUFDLEVBQUUsR0FBRyxNQUFNLElBQUk7UUFDNUQsSUFBSSxDQUFDMEIsQ0FBQyxHQUFHNGlCLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUt3RSxDQUFDLEVBQUUsR0FBRyxLQUFLLElBQUk7UUFDM0QsSUFBSSxDQUFDdEosS0FBSyxHQUFHOC9DO0lBQ2Y7SUFFQWxtRCxnQkFBZ0I7UUFBQzB5QjtLQUF5QixFQUFFeXpCO0lBRTVDLFNBQVNDLGVBQWVsbEMsSUFBSSxFQUFFaFcsSUFBSSxFQUFFZzdDLE9BQU87UUFDekMsSUFBSSxDQUFDcHpCLDRCQUE0QixDQUFDNVI7UUFDbEMsSUFBSSxDQUFDK1EsUUFBUSxHQUFHLElBQUksQ0FBQ1ksd0JBQXdCO1FBQzdDLElBQUksQ0FBQ3pzQixLQUFLLEdBQUc4L0M7SUFDZjtJQUVBbG1ELGdCQUFnQjtRQUFDMHlCO0tBQXlCLEVBQUUwekI7SUFFNUMsU0FBU0MsaUJBQWlCbmxDLElBQUksRUFBRWhXLElBQUksRUFBRXNQLFNBQVM7UUFDN0MsSUFBSSxDQUFDdFAsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ3dFLENBQUMsR0FBRzFNLGlCQUFpQixVQUFVa0ksS0FBS3JDLENBQUMsR0FBRztRQUM3QyxJQUFJeTlDLFVBQVVwN0MsS0FBS29CLENBQUMsQ0FBQ0EsQ0FBQyxDQUFDLEVBQUUsQ0FBQy9ELENBQUMsR0FBRzJDLEtBQUtvQixDQUFDLENBQUNBLENBQUMsQ0FBQyxFQUFFLENBQUMvRCxDQUFDLENBQUNsSSxNQUFNLEdBQUc2SyxLQUFLckMsQ0FBQyxHQUFHLElBQUlxQyxLQUFLb0IsQ0FBQyxDQUFDQSxDQUFDLENBQUNqTSxNQUFNLEdBQUc2SyxLQUFLckMsQ0FBQyxHQUFHO1FBQzdGLElBQUksQ0FBQ21GLENBQUMsR0FBR2hMLGlCQUFpQixXQUFXc2pEO1FBQ3JDLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNDLFlBQVksR0FBRyxJQUFJLENBQUNDLGdCQUFnQjtRQUN6QyxJQUFJLENBQUNDLFdBQVcsR0FBR0w7UUFDbkIsSUFBSSxDQUFDeHpCLDRCQUE0QixDQUFDdFk7UUFDbEMsSUFBSSxDQUFDMVosSUFBSSxHQUFHd3hCLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUtvQixDQUFDLEVBQUUsR0FBRyxNQUFNLElBQUk7UUFDL0QsSUFBSSxDQUFDQSxDQUFDLEdBQUcsSUFBSSxDQUFDeEwsSUFBSSxDQUFDd0wsQ0FBQztRQUNwQixJQUFJLENBQUMybEIsUUFBUSxDQUFDO0lBQ2hCO0lBRUFvMEIsaUJBQWlCOWxELFNBQVMsQ0FBQ3FtRCxhQUFhLEdBQUcsU0FBVTEyQixNQUFNLEVBQUV4TCxNQUFNO1FBQ2pFLElBQUl2a0IsSUFBSTtRQUNSLElBQUlDLE1BQU0sSUFBSSxDQUFDNE4sQ0FBQyxDQUFDM04sTUFBTSxHQUFHO1FBQzFCLElBQUl3bUQ7UUFFSixNQUFPMW1ELElBQUlDLElBQUs7WUFDZHltRCxPQUFPcGlELEtBQUtjLEdBQUcsQ0FBQzJxQixNQUFNLENBQUMvdkIsSUFBSSxFQUFFLEdBQUcrdkIsTUFBTSxDQUFDeEwsU0FBUyxJQUFJdmtCLElBQUksRUFBRTtZQUUxRCxJQUFJMG1ELE9BQU8sTUFBTTtnQkFDZixPQUFPO1lBQ1Q7WUFFQTFtRCxLQUFLO1FBQ1A7UUFFQSxPQUFPO0lBQ1Q7SUFFQWttRCxpQkFBaUI5bEQsU0FBUyxDQUFDbW1ELGdCQUFnQixHQUFHO1FBQzVDLElBQUksSUFBSSxDQUFDMTRDLENBQUMsQ0FBQzNOLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQ3FQLENBQUMsQ0FBQ3JQLE1BQU0sR0FBRyxHQUFHO1lBQzNDLE9BQU87UUFDVDtRQUVBLElBQUksSUFBSSxDQUFDNkssSUFBSSxDQUFDb0IsQ0FBQyxDQUFDQSxDQUFDLENBQUMsRUFBRSxDQUFDL0QsQ0FBQyxFQUFFO1lBQ3RCLElBQUlwSSxJQUFJO1lBQ1IsSUFBSUMsTUFBTSxJQUFJLENBQUM4SyxJQUFJLENBQUNvQixDQUFDLENBQUNBLENBQUMsQ0FBQ2pNLE1BQU07WUFFOUIsTUFBT0YsSUFBSUMsSUFBSztnQkFDZCxJQUFJLENBQUMsSUFBSSxDQUFDd21ELGFBQWEsQ0FBQyxJQUFJLENBQUMxN0MsSUFBSSxDQUFDb0IsQ0FBQyxDQUFDQSxDQUFDLENBQUNuTSxFQUFFLENBQUNvSSxDQUFDLEVBQUUsSUFBSSxDQUFDMkMsSUFBSSxDQUFDckMsQ0FBQyxHQUFHO29CQUN4RCxPQUFPO2dCQUNUO2dCQUVBMUksS0FBSztZQUNQO1FBQ0YsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDeW1ELGFBQWEsQ0FBQyxJQUFJLENBQUMxN0MsSUFBSSxDQUFDb0IsQ0FBQyxDQUFDQSxDQUFDLEVBQUUsSUFBSSxDQUFDcEIsSUFBSSxDQUFDckMsQ0FBQyxHQUFHO1lBQzFELE9BQU87UUFDVDtRQUVBLE9BQU87SUFDVDtJQUVBdzlDLGlCQUFpQjlsRCxTQUFTLENBQUMweEIsUUFBUSxHQUFHLFNBQVV1UixXQUFXO1FBQ3pELElBQUksQ0FBQzFpQyxJQUFJLENBQUNteEIsUUFBUTtRQUNsQixJQUFJLENBQUNiLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ20xQixLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNDLEtBQUssR0FBRztRQUViLElBQUksSUFBSSxDQUFDMWxELElBQUksQ0FBQ3N3QixJQUFJLElBQUlvUyxhQUFhO1lBQ2pDLElBQUlyakM7WUFDSixJQUFJQyxNQUFNLElBQUksQ0FBQzhLLElBQUksQ0FBQ3JDLENBQUMsR0FBRztZQUN4QixJQUFJc29CO1lBQ0osSUFBSTNyQjtZQUVKLElBQUtyRixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztnQkFDM0JneEIsT0FBT2h4QixJQUFJLE1BQU0sSUFBSSxNQUFNO2dCQUMzQnFGLE1BQU1mLEtBQUt3QixLQUFLLENBQUMsSUFBSSxDQUFDbkYsSUFBSSxDQUFDMEgsQ0FBQyxDQUFDckksRUFBRSxHQUFHZ3hCO2dCQUVsQyxJQUFJLElBQUksQ0FBQ3poQixDQUFDLENBQUN2UCxFQUFFLEtBQUtxRixLQUFLO29CQUNyQixJQUFJLENBQUNrSyxDQUFDLENBQUN2UCxFQUFFLEdBQUdxRjtvQkFDWixJQUFJLENBQUMrZ0QsS0FBSyxHQUFHLENBQUMvaUI7Z0JBQ2hCO1lBQ0Y7WUFFQSxJQUFJLElBQUksQ0FBQ3gxQixDQUFDLENBQUMzTixNQUFNLEVBQUU7Z0JBQ2pCRCxNQUFNLElBQUksQ0FBQ1UsSUFBSSxDQUFDMEgsQ0FBQyxDQUFDbkksTUFBTTtnQkFFeEIsSUFBS0YsSUFBSSxJQUFJLENBQUMrSyxJQUFJLENBQUNyQyxDQUFDLEdBQUcsR0FBRzFJLElBQUlDLEtBQUtELEtBQUssRUFBRztvQkFDekNneEIsT0FBT2h4QixJQUFJLE1BQU0sSUFBSSxNQUFNO29CQUMzQnFGLE1BQU1yRixJQUFJLE1BQU0sSUFBSXNFLEtBQUt3QixLQUFLLENBQUMsSUFBSSxDQUFDbkYsSUFBSSxDQUFDMEgsQ0FBQyxDQUFDckksRUFBRSxHQUFHLE9BQU8sSUFBSSxDQUFDVyxJQUFJLENBQUMwSCxDQUFDLENBQUNySSxFQUFFO29CQUVyRSxJQUFJLElBQUksQ0FBQzZOLENBQUMsQ0FBQzdOLElBQUksSUFBSSxDQUFDK0ssSUFBSSxDQUFDckMsQ0FBQyxHQUFHLEVBQUUsS0FBS3JELEtBQUs7d0JBQ3ZDLElBQUksQ0FBQ3dJLENBQUMsQ0FBQzdOLElBQUksSUFBSSxDQUFDK0ssSUFBSSxDQUFDckMsQ0FBQyxHQUFHLEVBQUUsR0FBR3JEO3dCQUM5QixJQUFJLENBQUNnaEQsS0FBSyxHQUFHLENBQUNoakI7b0JBQ2hCO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJLENBQUNwUyxJQUFJLEdBQUcsQ0FBQ29TO1FBQ2Y7SUFDRjtJQUVBeGpDLGdCQUFnQjtRQUFDMHlCO0tBQXlCLEVBQUUyekI7SUFFNUMsU0FBU1MseUJBQXlCNWxDLElBQUksRUFBRWhXLElBQUksRUFBRWc3QyxPQUFPO1FBQ25ELElBQUksQ0FBQ3B6Qiw0QkFBNEIsQ0FBQzVSO1FBQ2xDLElBQUksQ0FBQytRLFFBQVEsR0FBRyxJQUFJLENBQUNZLHdCQUF3QjtRQUM3QyxJQUFJLENBQUNrMEIsZ0JBQWdCLENBQUM3bEMsTUFBTWhXLE1BQU1nN0M7SUFDcEM7SUFFQVkseUJBQXlCdm1ELFNBQVMsQ0FBQ3dtRCxnQkFBZ0IsR0FBRyxTQUFVN2xDLElBQUksRUFBRWhXLElBQUksRUFBRWc3QyxPQUFPO1FBQ2pGLElBQUksQ0FBQ2w0QyxDQUFDLEdBQUdza0IsZ0JBQWdCQyxPQUFPLENBQUNyUixNQUFNaFcsS0FBSzhDLENBQUMsRUFBRSxHQUFHLE1BQU0sSUFBSTtRQUM1RCxJQUFJLENBQUN6RixDQUFDLEdBQUcrcEIsZ0JBQWdCQyxPQUFPLENBQUNyUixNQUFNaFcsS0FBSzNDLENBQUMsRUFBRSxHQUFHLE1BQU0sSUFBSTtRQUM1RCxJQUFJLENBQUN1RCxDQUFDLEdBQUd3bUIsZ0JBQWdCQyxPQUFPLENBQUNyUixNQUFNaFcsS0FBS1ksQ0FBQyxFQUFFLEdBQUcsTUFBTSxJQUFJO1FBQzVELElBQUksQ0FBQ3hELENBQUMsR0FBR2dxQixnQkFBZ0JDLE9BQU8sQ0FBQ3JSLE1BQU1oVyxLQUFLNUMsQ0FBQyxJQUFJO1lBQy9DZ0UsR0FBRztRQUNMLEdBQUcsR0FBRyxNQUFNLElBQUk7UUFDaEIsSUFBSSxDQUFDNkMsQ0FBQyxHQUFHbWpCLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUtpRSxDQUFDLElBQUk7WUFDL0M3QyxHQUFHO1FBQ0wsR0FBRyxHQUFHMUcsV0FBVyxJQUFJO1FBQ3JCLElBQUksQ0FBQzhDLENBQUMsR0FBRyxJQUFJMjlDLGlCQUFpQm5sQyxNQUFNaFcsS0FBS3hDLENBQUMsRUFBRSxJQUFJO1FBQ2hELElBQUksQ0FBQ3RDLEtBQUssR0FBRzgvQztRQUNiLElBQUksQ0FBQ2MsS0FBSyxHQUFHLEVBQUU7UUFDZixJQUFJLENBQUNDLGVBQWUsQ0FBQ2YsUUFBUVIsS0FBSyxFQUFFeDZDO1FBQ3BDLElBQUksQ0FBQ2c4QyxrQkFBa0IsQ0FBQ2g4QyxNQUFNZzdDO1FBQzlCLElBQUksQ0FBQ3R6QixXQUFXLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQ0EsV0FBVztJQUN2QztJQUVBazBCLHlCQUF5QnZtRCxTQUFTLENBQUMwbUQsZUFBZSxHQUFHLFNBQVVFLFdBQVcsRUFBRWo4QyxJQUFJO1FBQzlFLElBQUlrOEMsYUFBYWwvQztRQUNqQixJQUFJbS9DLFFBQVEvOEMsU0FBU1ksS0FBS25DLENBQUMsS0FBSyxJQUFJLG1CQUFtQjtRQUN2RHMrQyxNQUFNbmxDLFlBQVksQ0FBQyxNQUFNa2xDO1FBQ3pCQyxNQUFNbmxDLFlBQVksQ0FBQyxnQkFBZ0I7UUFDbkNtbEMsTUFBTW5sQyxZQUFZLENBQUMsaUJBQWlCO1FBQ3BDLElBQUk4a0MsUUFBUSxFQUFFO1FBQ2QsSUFBSWpwQztRQUNKLElBQUkzUjtRQUNKLElBQUlDO1FBQ0pBLE9BQU9uQixLQUFLeEMsQ0FBQyxDQUFDRyxDQUFDLEdBQUc7UUFFbEIsSUFBS3VELElBQUksR0FBR0EsSUFBSUMsTUFBTUQsS0FBSyxFQUFHO1lBQzVCMlIsT0FBT3pULFNBQVM7WUFDaEIrOEMsTUFBTXh5QyxXQUFXLENBQUNrSjtZQUNsQmlwQyxNQUFNdGxELElBQUksQ0FBQ3FjO1FBQ2I7UUFFQW9wQyxZQUFZamxDLFlBQVksQ0FBQ2hYLEtBQUs0QixFQUFFLEtBQUssT0FBTyxTQUFTLFVBQVUsU0FBU25OLG9CQUFvQixNQUFNeW5ELGFBQWE7UUFDL0csSUFBSSxDQUFDRSxFQUFFLEdBQUdEO1FBQ1YsSUFBSSxDQUFDRSxHQUFHLEdBQUdQO0lBQ2I7SUFFQUYseUJBQXlCdm1ELFNBQVMsQ0FBQzJtRCxrQkFBa0IsR0FBRyxTQUFVaDhDLElBQUksRUFBRWc3QyxPQUFPO1FBQzdFLElBQUksSUFBSSxDQUFDeDlDLENBQUMsQ0FBQ2krQyxXQUFXLElBQUksQ0FBQyxJQUFJLENBQUNqK0MsQ0FBQyxDQUFDKzlDLFlBQVksRUFBRTtZQUM5QyxJQUFJMW9DO1lBQ0osSUFBSTNSO1lBQ0osSUFBSUM7WUFDSixJQUFJd3pDLE9BQU92MUMsU0FBUztZQUNwQixJQUFJdTBDLGNBQWN2MEMsU0FBUztZQUMzQnUxQyxLQUFLaHJDLFdBQVcsQ0FBQ2dxQztZQUNqQixJQUFJMkksWUFBWXQvQztZQUNoQixJQUFJdS9DLFNBQVN2L0M7WUFDYjIzQyxLQUFLMzlCLFlBQVksQ0FBQyxNQUFNdWxDO1lBQ3hCLElBQUlDLFNBQVNwOUMsU0FBU1ksS0FBS25DLENBQUMsS0FBSyxJQUFJLG1CQUFtQjtZQUN4RDIrQyxPQUFPeGxDLFlBQVksQ0FBQyxNQUFNc2xDO1lBQzFCRSxPQUFPeGxDLFlBQVksQ0FBQyxnQkFBZ0I7WUFDcEN3bEMsT0FBT3hsQyxZQUFZLENBQUMsaUJBQWlCO1lBQ3JDN1YsT0FBT25CLEtBQUt4QyxDQUFDLENBQUM0RCxDQUFDLENBQUNBLENBQUMsQ0FBQyxFQUFFLENBQUMvRCxDQUFDLEdBQUcyQyxLQUFLeEMsQ0FBQyxDQUFDNEQsQ0FBQyxDQUFDQSxDQUFDLENBQUMsRUFBRSxDQUFDL0QsQ0FBQyxDQUFDbEksTUFBTSxHQUFHNkssS0FBS3hDLENBQUMsQ0FBQzRELENBQUMsQ0FBQ0EsQ0FBQyxDQUFDak0sTUFBTTtZQUNuRSxJQUFJMm1ELFFBQVEsSUFBSSxDQUFDQSxLQUFLO1lBRXRCLElBQUs1NkMsSUFBSWxCLEtBQUt4QyxDQUFDLENBQUNHLENBQUMsR0FBRyxHQUFHdUQsSUFBSUMsTUFBTUQsS0FBSyxFQUFHO2dCQUN2QzJSLE9BQU96VCxTQUFTO2dCQUNoQnlULEtBQUttRSxZQUFZLENBQUMsY0FBYztnQkFDaEN3bEMsT0FBTzd5QyxXQUFXLENBQUNrSjtnQkFDbkJpcEMsTUFBTXRsRCxJQUFJLENBQUNxYztZQUNiO1lBRUE4Z0MsWUFBWTM4QixZQUFZLENBQUNoWCxLQUFLNEIsRUFBRSxLQUFLLE9BQU8sU0FBUyxVQUFVLFNBQVNuTixvQkFBb0IsTUFBTTZuRCxZQUFZO1lBRTlHLElBQUl0OEMsS0FBSzRCLEVBQUUsS0FBSyxNQUFNO2dCQUNwQit4QyxZQUFZMzhCLFlBQVksQ0FBQyxrQkFBa0IraUMsV0FBVyxDQUFDLzVDLEtBQUt5OEMsRUFBRSxJQUFJLEVBQUU7Z0JBQ3BFOUksWUFBWTM4QixZQUFZLENBQUMsbUJBQW1CZ2pDLFlBQVksQ0FBQ2g2QyxLQUFLc2pDLEVBQUUsSUFBSSxFQUFFO2dCQUV0RSxJQUFJdGpDLEtBQUtzakMsRUFBRSxLQUFLLEdBQUc7b0JBQ2pCcVEsWUFBWTM4QixZQUFZLENBQUMscUJBQXFCaFgsS0FBS3FqQyxFQUFFO2dCQUN2RDtZQUNGO1lBRUEsSUFBSSxDQUFDcVosRUFBRSxHQUFHRjtZQUNWLElBQUksQ0FBQ0csRUFBRSxHQUFHaEk7WUFDVixJQUFJLENBQUNpSSxHQUFHLEdBQUdkO1lBQ1gsSUFBSSxDQUFDUyxNQUFNLEdBQUdBO1lBQ2R2QixRQUFRUCxNQUFNLEdBQUc5RztRQUNuQjtJQUNGO0lBRUE3K0MsZ0JBQWdCO1FBQUMweUI7S0FBeUIsRUFBRW8wQjtJQUU1QyxTQUFTaUIsMkJBQTJCN21DLElBQUksRUFBRWhXLElBQUksRUFBRWc3QyxPQUFPO1FBQ3JELElBQUksQ0FBQ3B6Qiw0QkFBNEIsQ0FBQzVSO1FBQ2xDLElBQUksQ0FBQytRLFFBQVEsR0FBRyxJQUFJLENBQUNZLHdCQUF3QjtRQUM3QyxJQUFJLENBQUNuQyxDQUFDLEdBQUc0QixnQkFBZ0JDLE9BQU8sQ0FBQ3JSLE1BQU1oVyxLQUFLd2xCLENBQUMsRUFBRSxHQUFHLE1BQU0sSUFBSTtRQUM1RCxJQUFJLENBQUN6bkIsQ0FBQyxHQUFHLElBQUkyOEMsYUFBYTFrQyxNQUFNaFcsS0FBS2pDLENBQUMsSUFBSSxDQUFDLEdBQUcsT0FBTyxJQUFJO1FBQ3pELElBQUksQ0FBQzg5QyxnQkFBZ0IsQ0FBQzdsQyxNQUFNaFcsTUFBTWc3QztRQUNsQyxJQUFJLENBQUN0ekIsV0FBVyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUNBLFdBQVc7SUFDdkM7SUFFQTV5QixnQkFBZ0I7UUFBQzhtRDtRQUEwQnAwQjtLQUF5QixFQUFFcTFCO0lBRXRFLFNBQVNDO1FBQ1AsSUFBSSxDQUFDajZDLEVBQUUsR0FBRyxFQUFFO1FBQ1osSUFBSSxDQUFDazZDLFlBQVksR0FBRyxFQUFFO1FBQ3RCLElBQUksQ0FBQ0MsRUFBRSxHQUFHNTlDLFNBQVM7SUFDckI7SUFFQSxTQUFTNjlDLGlCQUFpQnJoQixNQUFNLEVBQUU5M0IsRUFBRSxFQUFFd0wsU0FBUztRQUM3QyxJQUFJLENBQUM0ZixTQUFTLEdBQUc7WUFDZjBNLFFBQVFBO1lBQ1I5M0IsSUFBSUE7WUFDSndMLFdBQVdBO1FBQ2I7UUFDQSxJQUFJLENBQUM4cUIsUUFBUSxHQUFHLEVBQUU7UUFDbEIsSUFBSSxDQUFDMVMsV0FBVyxHQUFHLElBQUksQ0FBQ3dILFNBQVMsQ0FBQzBNLE1BQU0sQ0FBQ25VLGlCQUFpQixDQUFDdHlCLE1BQU0sSUFBSSxJQUFJLENBQUMrNUIsU0FBUyxDQUFDcHJCLEVBQUUsQ0FBQ3VpQixlQUFlLENBQUNseEIsTUFBTTtJQUMvRztJQUVBLElBQUkrbkQsbUJBQW1CLFNBQVNBLGlCQUFpQi9ILFNBQVMsRUFBRWhnRCxNQUFNLEVBQUV3UCxNQUFNLEVBQUVvekIsR0FBRztRQUM3RSxJQUFJNWlDLFdBQVcsR0FBRztZQUNoQixPQUFPO1FBQ1Q7UUFFQSxJQUFJZ29ELEtBQUtoSSxVQUFVcnlDLENBQUM7UUFDcEIsSUFBSXM2QyxLQUFLakksVUFBVWxnRCxDQUFDO1FBQ3BCLElBQUlvMkIsS0FBSzhwQixVQUFVNzNDLENBQUM7UUFDcEIsSUFBSXJJO1FBQ0osSUFBSW9vRCxjQUFjLE9BQU90bEIsSUFBSXJGLHVCQUF1QixDQUFDckgsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUVBLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTtRQUV2RSxJQUFLcDJCLElBQUksR0FBR0EsSUFBSUUsUUFBUUYsS0FBSyxFQUFHO1lBQzlCb29ELGVBQWUsT0FBT3RsQixJQUFJckYsdUJBQXVCLENBQUN5cUIsRUFBRSxDQUFDbG9ELElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRWtvRCxFQUFFLENBQUNsb0QsSUFBSSxFQUFFLENBQUMsRUFBRSxJQUFJLE1BQU04aUMsSUFBSXJGLHVCQUF1QixDQUFDMHFCLEVBQUUsQ0FBQ25vRCxFQUFFLENBQUMsRUFBRSxFQUFFbW9ELEVBQUUsQ0FBQ25vRCxFQUFFLENBQUMsRUFBRSxJQUFJLE1BQU04aUMsSUFBSXJGLHVCQUF1QixDQUFDckgsRUFBRSxDQUFDcDJCLEVBQUUsQ0FBQyxFQUFFLEVBQUVvMkIsRUFBRSxDQUFDcDJCLEVBQUUsQ0FBQyxFQUFFO1FBQzlMO1FBRUEsSUFBSTBQLFVBQVV4UCxRQUFRO1lBQ3BCa29ELGVBQWUsT0FBT3RsQixJQUFJckYsdUJBQXVCLENBQUN5cUIsRUFBRSxDQUFDbG9ELElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRWtvRCxFQUFFLENBQUNsb0QsSUFBSSxFQUFFLENBQUMsRUFBRSxJQUFJLE1BQU04aUMsSUFBSXJGLHVCQUF1QixDQUFDMHFCLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFQSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxNQUFNcmxCLElBQUlyRix1QkFBdUIsQ0FBQ3JILEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFQSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDNUxneUIsZUFBZTtRQUNqQjtRQUVBLE9BQU9BO0lBQ1Q7SUFFQSxJQUFJQyxzQkFBc0I7UUFDeEIsSUFBSUMsa0JBQWtCLElBQUkvdkI7UUFFMUIsSUFBSWd3QixnQkFBZ0IsSUFBSWh3QjtRQUV4QixJQUFJamtCLEtBQUs7WUFDUGswQyxzQkFBc0JBO1FBQ3hCO1FBRUEsU0FBU0EscUJBQXFCejlDLElBQUk7WUFDaEMsT0FBUUEsS0FBSzRCLEVBQUU7Z0JBQ2IsS0FBSztvQkFDSCxPQUFPODdDO2dCQUVULEtBQUs7b0JBQ0gsT0FBT0M7Z0JBRVQsS0FBSztvQkFDSCxPQUFPQztnQkFFVCxLQUFLO29CQUNILE9BQU9DO2dCQUVULEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7b0JBQ0gsT0FBT0M7Z0JBRVQsS0FBSztvQkFDSCxPQUFPQztnQkFFVCxLQUFLO29CQUNILE9BQU9DO2dCQUVUO29CQUNFLE9BQU87WUFDWDtRQUNGO1FBRUEsU0FBU0QsdUJBQXVCRSxTQUFTLEVBQUVDLFFBQVEsRUFBRWpKLFlBQVk7WUFDL0QsSUFBSUEsZ0JBQWdCaUosU0FBU2h2QixTQUFTLENBQUNwckIsRUFBRSxDQUFDb2lCLElBQUksRUFBRTtnQkFDOUNnNEIsU0FBU2h2QixTQUFTLENBQUM1ZixTQUFTLENBQUMwSCxZQUFZLENBQUMsV0FBV2tuQyxTQUFTaHZCLFNBQVMsQ0FBQ3ByQixFQUFFLENBQUN4RyxDQUFDO1lBQzlFO1lBRUEsSUFBSTIzQyxnQkFBZ0JpSixTQUFTaHZCLFNBQVMsQ0FBQzBNLE1BQU0sQ0FBQzFWLElBQUksRUFBRTtnQkFDbERnNEIsU0FBU2h2QixTQUFTLENBQUM1ZixTQUFTLENBQUMwSCxZQUFZLENBQUMsYUFBYWtuQyxTQUFTaHZCLFNBQVMsQ0FBQzBNLE1BQU0sQ0FBQ3QrQixDQUFDLENBQUN3MUIsT0FBTztZQUM1RjtRQUNGO1FBRUEsU0FBU2tyQixjQUFjO1FBRXZCLFNBQVNGLFdBQVdHLFNBQVMsRUFBRUMsUUFBUSxFQUFFakosWUFBWTtZQUNuRCxJQUFJL3pDO1lBQ0osSUFBSUM7WUFDSixJQUFJZzlDO1lBQ0osSUFBSUM7WUFDSixJQUFJako7WUFDSixJQUFJdG1CO1lBQ0osSUFBSXd2QixPQUFPSCxTQUFTcmEsTUFBTSxDQUFDMXVDLE1BQU07WUFDakMsSUFBSW1sRCxNQUFNNEQsU0FBUzVELEdBQUc7WUFDdEIsSUFBSWp3QjtZQUNKLElBQUkwTjtZQUNKLElBQUl1bUI7WUFDSixJQUFJbDlDO1lBRUosSUFBS3l0QixJQUFJLEdBQUdBLElBQUl3dkIsTUFBTXh2QixLQUFLLEVBQUc7Z0JBQzVCdXZCLFNBQVNGLFNBQVNsN0IsRUFBRSxDQUFDa0QsSUFBSSxJQUFJK3VCO2dCQUU3QixJQUFJaUosU0FBU3JhLE1BQU0sQ0FBQ2hWLEVBQUUsQ0FBQ3lyQixHQUFHLEdBQUdBLEtBQUs7b0JBQ2hDdmlCLE1BQU15bEIsY0FBYzd5QixLQUFLO29CQUN6QjJ6QixhQUFhaEUsTUFBTTRELFNBQVNyYSxNQUFNLENBQUNoVixFQUFFLENBQUN5ckIsR0FBRztvQkFDekNsNUMsSUFBSTg4QyxTQUFTaEUsWUFBWSxDQUFDL2tELE1BQU0sR0FBRztvQkFFbkMsTUFBTyxDQUFDaXBELFVBQVVFLGFBQWEsRUFBRzt3QkFDaENGLFNBQVNGLFNBQVNoRSxZQUFZLENBQUM5NEMsRUFBRSxDQUFDdzZCLE1BQU0sQ0FBQzFWLElBQUksSUFBSWs0Qjt3QkFDakRFLGNBQWM7d0JBQ2RsOUMsS0FBSztvQkFDUDtvQkFFQSxJQUFJZzlDLFFBQVE7d0JBQ1ZFLGFBQWFoRSxNQUFNNEQsU0FBU3JhLE1BQU0sQ0FBQ2hWLEVBQUUsQ0FBQ3lyQixHQUFHO3dCQUN6Q2w1QyxJQUFJODhDLFNBQVNoRSxZQUFZLENBQUMva0QsTUFBTSxHQUFHO3dCQUVuQyxNQUFPbXBELGFBQWEsRUFBRzs0QkFDckJ2bUIsSUFBSTlHLFFBQVEsQ0FBQ2l0QixTQUFTaEUsWUFBWSxDQUFDOTRDLEVBQUUsQ0FBQ3c2QixNQUFNLENBQUN0K0IsQ0FBQzs0QkFDOUNnaEQsY0FBYzs0QkFDZGw5QyxLQUFLO3dCQUNQO29CQUNGO2dCQUNGLE9BQU87b0JBQ0wyMkIsTUFBTXdsQjtnQkFDUjtnQkFFQWx6QixRQUFRNnpCLFNBQVNsN0IsRUFBRSxDQUFDcUgsS0FBSztnQkFDekJscEIsT0FBT2twQixNQUFNclAsT0FBTztnQkFFcEIsSUFBSW9qQyxRQUFRO29CQUNWRCx3QkFBd0I7b0JBRXhCLElBQUtqOUMsSUFBSSxHQUFHQSxJQUFJQyxNQUFNRCxLQUFLLEVBQUc7d0JBQzVCaTBDLFlBQVk5cUIsTUFBTXJvQixNQUFNLENBQUNkLEVBQUU7d0JBRTNCLElBQUlpMEMsYUFBYUEsVUFBVW42QixPQUFPLEVBQUU7NEJBQ2xDbWpDLHlCQUF5QmpCLGlCQUFpQi9ILFdBQVdBLFVBQVVuNkIsT0FBTyxFQUFFbTZCLFVBQVUzd0MsQ0FBQyxFQUFFdXpCO3dCQUN2RjtvQkFDRjtvQkFFQW1tQixTQUFTOUQsTUFBTSxDQUFDdnJCLEVBQUUsR0FBR3N2QjtnQkFDdkIsT0FBTztvQkFDTEEsd0JBQXdCRCxTQUFTOUQsTUFBTSxDQUFDdnJCLEVBQUU7Z0JBQzVDO2dCQUVBcXZCLFNBQVNyYSxNQUFNLENBQUNoVixFQUFFLENBQUM5d0IsQ0FBQyxJQUFJa2dELFVBQVUzRyxFQUFFLEtBQUssT0FBTyxLQUFLNkc7Z0JBQ3JERCxTQUFTcmEsTUFBTSxDQUFDaFYsRUFBRSxDQUFDM0ksSUFBSSxHQUFHazRCLFVBQVVGLFNBQVNyYSxNQUFNLENBQUNoVixFQUFFLENBQUMzSSxJQUFJO1lBQzdEO1FBQ0Y7UUFFQSxTQUFTdzNCLFdBQVdPLFNBQVMsRUFBRUMsUUFBUSxFQUFFakosWUFBWTtZQUNuRCxJQUFJc0osWUFBWUwsU0FBU2hqRCxLQUFLO1lBRTlCLElBQUlnakQsU0FBUzE1QyxDQUFDLENBQUMwaEIsSUFBSSxJQUFJK3VCLGNBQWM7Z0JBQ25Dc0osVUFBVS9ELEtBQUssQ0FBQ3hqQyxZQUFZLENBQUMsUUFBUSxTQUFTcmQsUUFBUXVrRCxTQUFTMTVDLENBQUMsQ0FBQ2xILENBQUMsQ0FBQyxFQUFFLElBQUksTUFBTTNELFFBQVF1a0QsU0FBUzE1QyxDQUFDLENBQUNsSCxDQUFDLENBQUMsRUFBRSxJQUFJLE1BQU0zRCxRQUFRdWtELFNBQVMxNUMsQ0FBQyxDQUFDbEgsQ0FBQyxDQUFDLEVBQUUsSUFBSTtZQUM3STtZQUVBLElBQUk0Z0QsU0FBU3A3QyxDQUFDLENBQUNvakIsSUFBSSxJQUFJK3VCLGNBQWM7Z0JBQ25Dc0osVUFBVS9ELEtBQUssQ0FBQ3hqQyxZQUFZLENBQUMsZ0JBQWdCa25DLFNBQVNwN0MsQ0FBQyxDQUFDeEYsQ0FBQztZQUMzRDtRQUNGO1FBRUEsU0FBU3NnRCxxQkFBcUJLLFNBQVMsRUFBRUMsUUFBUSxFQUFFakosWUFBWTtZQUM3RDBJLGVBQWVNLFdBQVdDLFVBQVVqSjtZQUNwQzRJLGFBQWFJLFdBQVdDLFVBQVVqSjtRQUNwQztRQUVBLFNBQVMwSSxlQUFlTSxTQUFTLEVBQUVDLFFBQVEsRUFBRWpKLFlBQVk7WUFDdkQsSUFBSWtILFFBQVErQixTQUFTOUIsRUFBRTtZQUN2QixJQUFJb0MsYUFBYU4sU0FBUzFnRCxDQUFDLENBQUNpK0MsV0FBVztZQUN2QyxJQUFJMStCLE1BQU1taEMsU0FBUzdnRCxDQUFDLENBQUNDLENBQUM7WUFDdEIsSUFBSTBmLE1BQU1raEMsU0FBU3Q5QyxDQUFDLENBQUN0RCxDQUFDO1lBRXRCLElBQUk0Z0QsU0FBU3A3QyxDQUFDLENBQUNvakIsSUFBSSxJQUFJK3VCLGNBQWM7Z0JBQ25DLElBQUkzL0MsT0FBTzJvRCxVQUFVcjhDLEVBQUUsS0FBSyxPQUFPLGlCQUFpQjtnQkFDcERzOEMsU0FBU2hqRCxLQUFLLENBQUNzL0MsS0FBSyxDQUFDeGpDLFlBQVksQ0FBQzFoQixNQUFNNG9ELFNBQVNwN0MsQ0FBQyxDQUFDeEYsQ0FBQztZQUN0RDtZQUVBLElBQUk0Z0QsU0FBUzdnRCxDQUFDLENBQUM2b0IsSUFBSSxJQUFJK3VCLGNBQWM7Z0JBQ25DLElBQUl3SixRQUFRUixVQUFVcGdELENBQUMsS0FBSyxJQUFJLE9BQU87Z0JBQ3ZDLElBQUk2Z0QsUUFBUUQsVUFBVSxPQUFPLE9BQU87Z0JBQ3BDdEMsTUFBTW5sQyxZQUFZLENBQUN5bkMsT0FBTzFoQyxHQUFHLENBQUMsRUFBRTtnQkFDaENvL0IsTUFBTW5sQyxZQUFZLENBQUMwbkMsT0FBTzNoQyxHQUFHLENBQUMsRUFBRTtnQkFFaEMsSUFBSXloQyxjQUFjLENBQUNOLFNBQVMxZ0QsQ0FBQyxDQUFDKzlDLFlBQVksRUFBRTtvQkFDMUMyQyxTQUFTeEIsRUFBRSxDQUFDMWxDLFlBQVksQ0FBQ3luQyxPQUFPMWhDLEdBQUcsQ0FBQyxFQUFFO29CQUN0Q21oQyxTQUFTeEIsRUFBRSxDQUFDMWxDLFlBQVksQ0FBQzBuQyxPQUFPM2hDLEdBQUcsQ0FBQyxFQUFFO2dCQUN4QztZQUNGO1lBRUEsSUFBSSsrQjtZQUNKLElBQUk3bUQ7WUFDSixJQUFJQztZQUNKLElBQUkyZDtZQUVKLElBQUlxckMsU0FBUzFnRCxDQUFDLENBQUM2OUMsS0FBSyxJQUFJcEcsY0FBYztnQkFDcEM2RyxRQUFRb0MsU0FBUzdCLEdBQUc7Z0JBQ3BCLElBQUlzQyxVQUFVVCxTQUFTMWdELENBQUMsQ0FBQ2dILENBQUM7Z0JBQzFCdFAsTUFBTTRtRCxNQUFNM21ELE1BQU07Z0JBRWxCLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO29CQUMzQjRkLE9BQU9pcEMsS0FBSyxDQUFDN21ELEVBQUU7b0JBQ2Y0ZCxLQUFLbUUsWUFBWSxDQUFDLFVBQVUybkMsT0FBTyxDQUFDMXBELElBQUksRUFBRSxHQUFHO29CQUM3QzRkLEtBQUttRSxZQUFZLENBQUMsY0FBYyxTQUFTMm5DLE9BQU8sQ0FBQzFwRCxJQUFJLElBQUksRUFBRSxHQUFHLE1BQU0wcEQsT0FBTyxDQUFDMXBELElBQUksSUFBSSxFQUFFLEdBQUcsTUFBTTBwRCxPQUFPLENBQUMxcEQsSUFBSSxJQUFJLEVBQUUsR0FBRztnQkFDdEg7WUFDRjtZQUVBLElBQUl1cEQsY0FBZU4sQ0FBQUEsU0FBUzFnRCxDQUFDLENBQUM4OUMsS0FBSyxJQUFJckcsWUFBVyxHQUFJO2dCQUNwRCxJQUFJMkosVUFBVVYsU0FBUzFnRCxDQUFDLENBQUNzRixDQUFDO2dCQUUxQixJQUFJbzdDLFNBQVMxZ0QsQ0FBQyxDQUFDKzlDLFlBQVksRUFBRTtvQkFDM0JPLFFBQVFvQyxTQUFTN0IsR0FBRztnQkFDdEIsT0FBTztvQkFDTFAsUUFBUW9DLFNBQVN0QixHQUFHO2dCQUN0QjtnQkFFQTFuRCxNQUFNNG1ELE1BQU0zbUQsTUFBTTtnQkFFbEIsSUFBS0YsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7b0JBQzNCNGQsT0FBT2lwQyxLQUFLLENBQUM3bUQsRUFBRTtvQkFFZixJQUFJLENBQUNpcEQsU0FBUzFnRCxDQUFDLENBQUMrOUMsWUFBWSxFQUFFO3dCQUM1QjFvQyxLQUFLbUUsWUFBWSxDQUFDLFVBQVU0bkMsT0FBTyxDQUFDM3BELElBQUksRUFBRSxHQUFHO29CQUMvQztvQkFFQTRkLEtBQUttRSxZQUFZLENBQUMsZ0JBQWdCNG5DLE9BQU8sQ0FBQzNwRCxJQUFJLElBQUksRUFBRTtnQkFDdEQ7WUFDRjtZQUVBLElBQUlncEQsVUFBVXBnRCxDQUFDLEtBQUssR0FBRztnQkFDckIsSUFBSXFnRCxTQUFTdDlDLENBQUMsQ0FBQ3NsQixJQUFJLElBQUkrdUIsY0FBYztvQkFDbkNrSCxNQUFNbmxDLFlBQVksQ0FBQyxNQUFNZ0csR0FBRyxDQUFDLEVBQUU7b0JBQy9CbS9CLE1BQU1ubEMsWUFBWSxDQUFDLE1BQU1nRyxHQUFHLENBQUMsRUFBRTtvQkFFL0IsSUFBSXdoQyxjQUFjLENBQUNOLFNBQVMxZ0QsQ0FBQyxDQUFDKzlDLFlBQVksRUFBRTt3QkFDMUMyQyxTQUFTeEIsRUFBRSxDQUFDMWxDLFlBQVksQ0FBQyxNQUFNZ0csR0FBRyxDQUFDLEVBQUU7d0JBQ3JDa2hDLFNBQVN4QixFQUFFLENBQUMxbEMsWUFBWSxDQUFDLE1BQU1nRyxHQUFHLENBQUMsRUFBRTtvQkFDdkM7Z0JBQ0Y7WUFDRixPQUFPO2dCQUNMLElBQUl5UDtnQkFFSixJQUFJeXhCLFNBQVM3Z0QsQ0FBQyxDQUFDNm9CLElBQUksSUFBSWc0QixTQUFTdDlDLENBQUMsQ0FBQ3NsQixJQUFJLElBQUkrdUIsY0FBYztvQkFDdER4b0IsTUFBTWx6QixLQUFLRyxJQUFJLENBQUNILEtBQUtDLEdBQUcsQ0FBQ3VqQixHQUFHLENBQUMsRUFBRSxHQUFHQyxHQUFHLENBQUMsRUFBRSxFQUFFLEtBQUt6akIsS0FBS0MsR0FBRyxDQUFDdWpCLEdBQUcsQ0FBQyxFQUFFLEdBQUdDLEdBQUcsQ0FBQyxFQUFFLEVBQUU7b0JBQ3pFbS9CLE1BQU1ubEMsWUFBWSxDQUFDLEtBQUt5VjtvQkFFeEIsSUFBSSt4QixjQUFjLENBQUNOLFNBQVMxZ0QsQ0FBQyxDQUFDKzlDLFlBQVksRUFBRTt3QkFDMUMyQyxTQUFTeEIsRUFBRSxDQUFDMWxDLFlBQVksQ0FBQyxLQUFLeVY7b0JBQ2hDO2dCQUNGO2dCQUVBLElBQUl5eEIsU0FBU3Q5QyxDQUFDLENBQUNzbEIsSUFBSSxJQUFJZzRCLFNBQVM5Z0QsQ0FBQyxDQUFDOG9CLElBQUksSUFBSWc0QixTQUFTajZDLENBQUMsQ0FBQ2lpQixJQUFJLElBQUkrdUIsY0FBYztvQkFDekUsSUFBSSxDQUFDeG9CLEtBQUs7d0JBQ1JBLE1BQU1sekIsS0FBS0csSUFBSSxDQUFDSCxLQUFLQyxHQUFHLENBQUN1akIsR0FBRyxDQUFDLEVBQUUsR0FBR0MsR0FBRyxDQUFDLEVBQUUsRUFBRSxLQUFLempCLEtBQUtDLEdBQUcsQ0FBQ3VqQixHQUFHLENBQUMsRUFBRSxHQUFHQyxHQUFHLENBQUMsRUFBRSxFQUFFO29CQUMzRTtvQkFFQSxJQUFJNmhDLE1BQU10bEQsS0FBS3FyQixLQUFLLENBQUM1SCxHQUFHLENBQUMsRUFBRSxHQUFHRCxHQUFHLENBQUMsRUFBRSxFQUFFQyxHQUFHLENBQUMsRUFBRSxHQUFHRCxHQUFHLENBQUMsRUFBRTtvQkFDckQsSUFBSWdDLFVBQVVtL0IsU0FBUzlnRCxDQUFDLENBQUNFLENBQUM7b0JBRTFCLElBQUl5aEIsV0FBVyxHQUFHO3dCQUNoQkEsVUFBVTtvQkFDWixPQUFPLElBQUlBLFdBQVcsQ0FBQyxHQUFHO3dCQUN4QkEsVUFBVSxDQUFDO29CQUNiO29CQUVBLElBQUl4RSxPQUFPa1MsTUFBTTFOO29CQUNqQixJQUFJbEYsSUFBSXRnQixLQUFLMnJCLEdBQUcsQ0FBQzI1QixNQUFNWCxTQUFTajZDLENBQUMsQ0FBQzNHLENBQUMsSUFBSWlkLE9BQU93QyxHQUFHLENBQUMsRUFBRTtvQkFDcEQsSUFBSW9GLElBQUk1b0IsS0FBSzhxQixHQUFHLENBQUN3NkIsTUFBTVgsU0FBU2o2QyxDQUFDLENBQUMzRyxDQUFDLElBQUlpZCxPQUFPd0MsR0FBRyxDQUFDLEVBQUU7b0JBQ3BEby9CLE1BQU1ubEMsWUFBWSxDQUFDLE1BQU02QztvQkFDekJzaUMsTUFBTW5sQyxZQUFZLENBQUMsTUFBTW1MO29CQUV6QixJQUFJcThCLGNBQWMsQ0FBQ04sU0FBUzFnRCxDQUFDLENBQUMrOUMsWUFBWSxFQUFFO3dCQUMxQzJDLFNBQVN4QixFQUFFLENBQUMxbEMsWUFBWSxDQUFDLE1BQU02Qzt3QkFDL0Jxa0MsU0FBU3hCLEVBQUUsQ0FBQzFsQyxZQUFZLENBQUMsTUFBTW1MO29CQUNqQztnQkFDRixFQUFFLGtDQUFrQztZQUV0QztRQUNGO1FBRUEsU0FBUzA3QixhQUFhSSxTQUFTLEVBQUVDLFFBQVEsRUFBRWpKLFlBQVk7WUFDckQsSUFBSXNKLFlBQVlMLFNBQVNoakQsS0FBSztZQUM5QixJQUFJNkMsSUFBSW1nRCxTQUFTbmdELENBQUM7WUFFbEIsSUFBSUEsS0FBTUEsQ0FBQUEsRUFBRW1vQixJQUFJLElBQUkrdUIsWUFBVyxLQUFNbDNDLEVBQUU2OEMsT0FBTyxFQUFFO2dCQUM5QzJELFVBQVUvRCxLQUFLLENBQUN4akMsWUFBWSxDQUFDLG9CQUFvQmpaLEVBQUU2OEMsT0FBTztnQkFDMUQyRCxVQUFVL0QsS0FBSyxDQUFDeGpDLFlBQVksQ0FBQyxxQkFBcUJqWixFQUFFKzhDLFVBQVUsQ0FBQyxFQUFFO1lBQ25FO1lBRUEsSUFBSW9ELFNBQVMxNUMsQ0FBQyxJQUFLMDVDLENBQUFBLFNBQVMxNUMsQ0FBQyxDQUFDMGhCLElBQUksSUFBSSt1QixZQUFXLEdBQUk7Z0JBQ25Ec0osVUFBVS9ELEtBQUssQ0FBQ3hqQyxZQUFZLENBQUMsVUFBVSxTQUFTcmQsUUFBUXVrRCxTQUFTMTVDLENBQUMsQ0FBQ2xILENBQUMsQ0FBQyxFQUFFLElBQUksTUFBTTNELFFBQVF1a0QsU0FBUzE1QyxDQUFDLENBQUNsSCxDQUFDLENBQUMsRUFBRSxJQUFJLE1BQU0zRCxRQUFRdWtELFNBQVMxNUMsQ0FBQyxDQUFDbEgsQ0FBQyxDQUFDLEVBQUUsSUFBSTtZQUMvSTtZQUVBLElBQUk0Z0QsU0FBU3A3QyxDQUFDLENBQUNvakIsSUFBSSxJQUFJK3VCLGNBQWM7Z0JBQ25Dc0osVUFBVS9ELEtBQUssQ0FBQ3hqQyxZQUFZLENBQUMsa0JBQWtCa25DLFNBQVNwN0MsQ0FBQyxDQUFDeEYsQ0FBQztZQUM3RDtZQUVBLElBQUk0Z0QsU0FBUzE0QixDQUFDLENBQUNVLElBQUksSUFBSSt1QixjQUFjO2dCQUNuQ3NKLFVBQVUvRCxLQUFLLENBQUN4akMsWUFBWSxDQUFDLGdCQUFnQmtuQyxTQUFTMTRCLENBQUMsQ0FBQ2xvQixDQUFDO2dCQUV6RCxJQUFJaWhELFVBQVU5RCxNQUFNLEVBQUU7b0JBQ3BCOEQsVUFBVTlELE1BQU0sQ0FBQ3pqQyxZQUFZLENBQUMsZ0JBQWdCa25DLFNBQVMxNEIsQ0FBQyxDQUFDbG9CLENBQUM7Z0JBQzVEO1lBQ0Y7UUFDRjtRQUVBLE9BQU9pTTtJQUNUO0lBRUEsU0FBU3UxQyxnQkFBZ0I5K0MsSUFBSSxFQUFFMFAsVUFBVSxFQUFFbk4sSUFBSTtRQUM3Qyw0QkFBNEI7UUFDNUIsSUFBSSxDQUFDUCxNQUFNLEdBQUcsRUFBRSxFQUFFLGtCQUFrQjtRQUVwQyxJQUFJLENBQUNpc0MsVUFBVSxHQUFHanVDLEtBQUtnQyxNQUFNLEVBQUUsZ0RBQWdEO1FBRS9FLElBQUksQ0FBQys4QyxVQUFVLEdBQUcsRUFBRSxFQUFFLG1EQUFtRDtRQUV6RSxJQUFJLENBQUN4RixjQUFjLEdBQUcsRUFBRSxFQUFFLDhCQUE4QjtRQUV4RCxJQUFJLENBQUNyTCxTQUFTLEdBQUcsRUFBRSxFQUFFLHVDQUF1QztRQUU1RCxJQUFJLENBQUMyTCxpQkFBaUIsR0FBRyxFQUFFLEVBQUUsOEJBQThCO1FBRTNELElBQUksQ0FBQ21GLGdCQUFnQixHQUFHLEVBQUU7UUFDMUIsSUFBSSxDQUFDcEcsV0FBVyxDQUFDNTRDLE1BQU0wUCxZQUFZbk4sT0FBTyxtSUFBbUk7UUFDN0ssMENBQTBDO1FBRTFDLElBQUksQ0FBQ3c2QyxZQUFZLEdBQUcsRUFBRSxFQUFFLG1JQUFtSTtJQUM3SjtJQUVBam9ELGdCQUFnQjtRQUFDcTRDO1FBQWFnRjtRQUFrQnVFO1FBQWdCMkM7UUFBZWQ7UUFBa0J6SjtRQUFjNEo7S0FBcUIsRUFBRW9HO0lBRXRJQSxnQkFBZ0J6cEQsU0FBUyxDQUFDNHBELG9CQUFvQixHQUFHLFlBQWE7SUFFOURILGdCQUFnQnpwRCxTQUFTLENBQUM2cEQsY0FBYyxHQUFHLElBQUkxeEI7SUFFL0NzeEIsZ0JBQWdCenBELFNBQVMsQ0FBQzhwRCx3QkFBd0IsR0FBRyxZQUFhO0lBRWxFTCxnQkFBZ0J6cEQsU0FBUyxDQUFDd2pELGFBQWEsR0FBRztRQUN4QyxJQUFJLENBQUN1RyxZQUFZLENBQUMsSUFBSSxDQUFDblIsVUFBVSxFQUFFLElBQUksQ0FBQ0MsU0FBUyxFQUFFLElBQUksQ0FBQzZPLFlBQVksRUFBRSxJQUFJLENBQUN0TyxZQUFZLEVBQUUsR0FBRyxFQUFFLEVBQUU7UUFDaEcsSUFBSSxDQUFDNFEsa0JBQWtCO0lBQ3pCO0lBQ0E7O0VBRUEsR0FHQVAsZ0JBQWdCenBELFNBQVMsQ0FBQ2dxRCxrQkFBa0IsR0FBRztRQUM3QyxJQUFJcHFEO1FBQ0osSUFBSUMsTUFBTSxJQUFJLENBQUM4TSxNQUFNLENBQUM3TSxNQUFNO1FBQzVCLElBQUlpMEI7UUFDSixJQUFJbG9CO1FBQ0osSUFBSUMsT0FBTyxJQUFJLENBQUM0OUMsVUFBVSxDQUFDNXBELE1BQU07UUFDakMsSUFBSStGO1FBQ0osSUFBSW9rRCxhQUFhLEVBQUU7UUFDbkIsSUFBSUMsY0FBYztRQUVsQixJQUFLcitDLElBQUksR0FBR0EsSUFBSUMsTUFBTUQsS0FBSyxFQUFHO1lBQzVCaEcsUUFBUSxJQUFJLENBQUM2akQsVUFBVSxDQUFDNzlDLEVBQUU7WUFDMUJxK0MsY0FBYztZQUNkRCxXQUFXbnFELE1BQU0sR0FBRztZQUVwQixJQUFLRixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztnQkFDM0JtMEIsUUFBUSxJQUFJLENBQUNwbkIsTUFBTSxDQUFDL00sRUFBRTtnQkFFdEIsSUFBSW0wQixNQUFNeWEsTUFBTSxDQUFDditCLE9BQU8sQ0FBQ3BLLFdBQVcsQ0FBQyxHQUFHO29CQUN0Q29rRCxXQUFXOW9ELElBQUksQ0FBQzR5QjtvQkFDaEJtMkIsY0FBY24yQixNQUFNMUIsV0FBVyxJQUFJNjNCO2dCQUNyQztZQUNGO1lBRUEsSUFBSUQsV0FBV25xRCxNQUFNLEdBQUcsS0FBS29xRCxhQUFhO2dCQUN4QyxJQUFJLENBQUNDLG1CQUFtQixDQUFDRjtZQUMzQjtRQUNGO0lBQ0Y7SUFFQVIsZ0JBQWdCenBELFNBQVMsQ0FBQ21xRCxtQkFBbUIsR0FBRyxTQUFVeDlDLE1BQU07UUFDOUQsSUFBSS9NO1FBQ0osSUFBSUMsTUFBTThNLE9BQU83TSxNQUFNO1FBRXZCLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCK00sTUFBTSxDQUFDL00sRUFBRSxDQUFDcWdDLGFBQWE7UUFDekI7SUFDRjtJQUVBd3BCLGdCQUFnQnpwRCxTQUFTLENBQUNvcUQsa0JBQWtCLEdBQUcsU0FBVXovQyxJQUFJLEVBQUVtNkMsS0FBSztRQUNsRSx5Q0FBeUM7UUFDekMsSUFBSXVGO1FBQ0osSUFBSTFFLFVBQVUsSUFBSVQsYUFBYXY2QyxNQUFNbTZDO1FBQ3JDLElBQUk4QixjQUFjakIsUUFBUVIsS0FBSztRQUUvQixJQUFJeDZDLEtBQUs0QixFQUFFLEtBQUssTUFBTTtZQUNwQjg5QyxjQUFjLElBQUkzRSxtQkFBbUIsSUFBSSxFQUFFLzZDLE1BQU1nN0M7UUFDbkQsT0FBTyxJQUFJaDdDLEtBQUs0QixFQUFFLEtBQUssTUFBTTtZQUMzQjg5QyxjQUFjLElBQUl6RSxpQkFBaUIsSUFBSSxFQUFFajdDLE1BQU1nN0M7UUFDakQsT0FBTyxJQUFJaDdDLEtBQUs0QixFQUFFLEtBQUssUUFBUTVCLEtBQUs0QixFQUFFLEtBQUssTUFBTTtZQUMvQyxJQUFJKzlDLHNCQUFzQjMvQyxLQUFLNEIsRUFBRSxLQUFLLE9BQU9nNkMsMkJBQTJCaUI7WUFDeEU2QyxjQUFjLElBQUlDLG9CQUFvQixJQUFJLEVBQUUzL0MsTUFBTWc3QztZQUNsRCxJQUFJLENBQUN0ckMsVUFBVSxDQUFDQyxJQUFJLENBQUNoRyxXQUFXLENBQUMrMUMsWUFBWXRELEVBQUU7WUFFL0MsSUFBSXNELFlBQVluRCxNQUFNLEVBQUU7Z0JBQ3RCLElBQUksQ0FBQzdzQyxVQUFVLENBQUNDLElBQUksQ0FBQ2hHLFdBQVcsQ0FBQysxQyxZQUFZL0MsRUFBRTtnQkFDL0MsSUFBSSxDQUFDanRDLFVBQVUsQ0FBQ0MsSUFBSSxDQUFDaEcsV0FBVyxDQUFDKzFDLFlBQVloRCxFQUFFO2dCQUMvQ1QsWUFBWWpsQyxZQUFZLENBQUMsUUFBUSxTQUFTdmlCLG9CQUFvQixNQUFNaXJELFlBQVluRCxNQUFNLEdBQUc7WUFDM0Y7UUFDRixPQUFPLElBQUl2OEMsS0FBSzRCLEVBQUUsS0FBSyxNQUFNO1lBQzNCODlDLGNBQWMsSUFBSXhFLGVBQWUsSUFBSSxFQUFFbDdDLE1BQU1nN0M7UUFDL0M7UUFFQSxJQUFJaDdDLEtBQUs0QixFQUFFLEtBQUssUUFBUTVCLEtBQUs0QixFQUFFLEtBQUssTUFBTTtZQUN4Q3E2QyxZQUFZamxDLFlBQVksQ0FBQyxrQkFBa0IraUMsV0FBVyxDQUFDLzVDLEtBQUt5OEMsRUFBRSxJQUFJLEVBQUU7WUFDcEVSLFlBQVlqbEMsWUFBWSxDQUFDLG1CQUFtQmdqQyxZQUFZLENBQUNoNkMsS0FBS3NqQyxFQUFFLElBQUksRUFBRTtZQUN0RTJZLFlBQVlqbEMsWUFBWSxDQUFDLGdCQUFnQjtZQUV6QyxJQUFJaFgsS0FBS3NqQyxFQUFFLEtBQUssR0FBRztnQkFDakIyWSxZQUFZamxDLFlBQVksQ0FBQyxxQkFBcUJoWCxLQUFLcWpDLEVBQUU7WUFDdkQ7UUFDRjtRQUVBLElBQUlyakMsS0FBS3pDLENBQUMsS0FBSyxHQUFHO1lBQ2hCMCtDLFlBQVlqbEMsWUFBWSxDQUFDLGFBQWE7UUFDeEM7UUFFQSxJQUFJaFgsS0FBS3EzQyxFQUFFLEVBQUU7WUFDWDRFLFlBQVlqbEMsWUFBWSxDQUFDLE1BQU1oWCxLQUFLcTNDLEVBQUU7UUFDeEM7UUFFQSxJQUFJcjNDLEtBQUs0RSxFQUFFLEVBQUU7WUFDWHEzQyxZQUFZamxDLFlBQVksQ0FBQyxTQUFTaFgsS0FBSzRFLEVBQUU7UUFDM0M7UUFFQSxJQUFJNUUsS0FBS3V1QyxFQUFFLEVBQUU7WUFDWDBOLFlBQVkvZ0QsS0FBSyxDQUFDLGlCQUFpQixHQUFHK3dDLGFBQWFqc0MsS0FBS3V1QyxFQUFFO1FBQzVEO1FBRUEsSUFBSSxDQUFDd1EsVUFBVSxDQUFDdm9ELElBQUksQ0FBQ3drRDtRQUNyQixJQUFJLENBQUM0RSxxQkFBcUIsQ0FBQzUvQyxNQUFNMC9DO1FBQ2pDLE9BQU9BO0lBQ1Q7SUFFQVosZ0JBQWdCenBELFNBQVMsQ0FBQ3dxRCxrQkFBa0IsR0FBRyxTQUFVNy9DLElBQUk7UUFDM0QsSUFBSTAvQyxjQUFjLElBQUk1QztRQUV0QixJQUFJOThDLEtBQUtxM0MsRUFBRSxFQUFFO1lBQ1hxSSxZQUFZMUMsRUFBRSxDQUFDaG1DLFlBQVksQ0FBQyxNQUFNaFgsS0FBS3EzQyxFQUFFO1FBQzNDO1FBRUEsSUFBSXIzQyxLQUFLNEUsRUFBRSxFQUFFO1lBQ1g4NkMsWUFBWTFDLEVBQUUsQ0FBQ2htQyxZQUFZLENBQUMsU0FBU2hYLEtBQUs0RSxFQUFFO1FBQzlDO1FBRUEsSUFBSTVFLEtBQUt1dUMsRUFBRSxFQUFFO1lBQ1htUixZQUFZMUMsRUFBRSxDQUFDOWhELEtBQUssQ0FBQyxpQkFBaUIsR0FBRyt3QyxhQUFhanNDLEtBQUt1dUMsRUFBRTtRQUMvRDtRQUVBLE9BQU9tUjtJQUNUO0lBRUFaLGdCQUFnQnpwRCxTQUFTLENBQUN5cUQsc0JBQXNCLEdBQUcsU0FBVTkvQyxJQUFJLEVBQUVzUCxTQUFTO1FBQzFFLElBQUl5d0Msb0JBQW9Cbm9CLHlCQUF5QnFCLG9CQUFvQixDQUFDLElBQUksRUFBRWo1QixNQUFNLElBQUk7UUFDdEYsSUFBSTAvQyxjQUFjLElBQUl6QyxpQkFBaUI4QyxtQkFBbUJBLGtCQUFrQmo5QyxDQUFDLEVBQUV3TTtRQUMvRSxJQUFJLENBQUNzd0MscUJBQXFCLENBQUM1L0MsTUFBTTAvQztRQUNqQyxPQUFPQTtJQUNUO0lBRUFaLGdCQUFnQnpwRCxTQUFTLENBQUMycUQsa0JBQWtCLEdBQUcsU0FBVWhnRCxJQUFJLEVBQUVpZ0QsZUFBZSxFQUFFOUYsS0FBSztRQUNuRixJQUFJdjRDLEtBQUs7UUFFVCxJQUFJNUIsS0FBSzRCLEVBQUUsS0FBSyxNQUFNO1lBQ3BCQSxLQUFLO1FBQ1AsT0FBTyxJQUFJNUIsS0FBSzRCLEVBQUUsS0FBSyxNQUFNO1lBQzNCQSxLQUFLO1FBQ1AsT0FBTyxJQUFJNUIsS0FBSzRCLEVBQUUsS0FBSyxNQUFNO1lBQzNCQSxLQUFLO1FBQ1A7UUFFQSxJQUFJcytDLGdCQUFnQnQyQixxQkFBcUJ3RCxZQUFZLENBQUMsSUFBSSxFQUFFcHRCLE1BQU00QixJQUFJLElBQUk7UUFDMUUsSUFBSTg5QyxjQUFjLElBQUl6RixhQUFhZ0csaUJBQWlCOUYsT0FBTytGO1FBQzNELElBQUksQ0FBQ2wrQyxNQUFNLENBQUN4TCxJQUFJLENBQUNrcEQ7UUFDakIsSUFBSSxDQUFDcEcsbUJBQW1CLENBQUNvRztRQUN6QixJQUFJLENBQUNFLHFCQUFxQixDQUFDNS9DLE1BQU0wL0M7UUFDakMsT0FBT0E7SUFDVDtJQUVBWixnQkFBZ0J6cEQsU0FBUyxDQUFDdXFELHFCQUFxQixHQUFHLFNBQVU1L0MsSUFBSSxFQUFFL0UsT0FBTztRQUN2RSxJQUFJaEcsSUFBSTtRQUNSLElBQUlDLE1BQU0sSUFBSSxDQUFDOHBELGdCQUFnQixDQUFDN3BELE1BQU07UUFFdEMsTUFBT0YsSUFBSUMsSUFBSztZQUNkLElBQUksSUFBSSxDQUFDOHBELGdCQUFnQixDQUFDL3BELEVBQUUsQ0FBQ2dHLE9BQU8sS0FBS0EsU0FBUztnQkFDaEQ7WUFDRjtZQUVBaEcsS0FBSztRQUNQO1FBRUEsSUFBSSxDQUFDK3BELGdCQUFnQixDQUFDeG9ELElBQUksQ0FBQztZQUN6QjJKLElBQUltOUMsb0JBQW9CRyxvQkFBb0IsQ0FBQ3o5QztZQUM3Qy9FLFNBQVNBO1lBQ1QrRSxNQUFNQTtRQUNSO0lBQ0Y7SUFFQTgrQyxnQkFBZ0J6cEQsU0FBUyxDQUFDOHFELGdCQUFnQixHQUFHLFNBQVVULFdBQVc7UUFDaEUsSUFBSTFuRCxNQUFNMG5ELFlBQVk3YixNQUFNO1FBQzVCLElBQUkzaUM7UUFDSixJQUFJQyxPQUFPLElBQUksQ0FBQzQ5QyxVQUFVLENBQUM1cEQsTUFBTTtRQUVqQyxJQUFLK0wsSUFBSSxHQUFHQSxJQUFJQyxNQUFNRCxLQUFLLEVBQUc7WUFDNUIsSUFBSSxDQUFDLElBQUksQ0FBQzY5QyxVQUFVLENBQUM3OUMsRUFBRSxDQUFDeUQsTUFBTSxFQUFFO2dCQUM5QjNNLElBQUl4QixJQUFJLENBQUMsSUFBSSxDQUFDdW9ELFVBQVUsQ0FBQzc5QyxFQUFFO1lBQzdCO1FBQ0Y7SUFDRjtJQUVBNDlDLGdCQUFnQnpwRCxTQUFTLENBQUM4bEMsWUFBWSxHQUFHO1FBQ3ZDLElBQUksQ0FBQzVVLGFBQWEsR0FBRztRQUNyQixJQUFJdHhCO1FBQ0osSUFBSUMsTUFBTSxJQUFJLENBQUNnNUMsU0FBUyxDQUFDLzRDLE1BQU07UUFFL0IsSUFBS0YsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDM0IsSUFBSSxDQUFDOG5ELFlBQVksQ0FBQzluRCxFQUFFLEdBQUcsSUFBSSxDQUFDaTVDLFNBQVMsQ0FBQ2o1QyxFQUFFO1FBQzFDO1FBRUEsSUFBSSxDQUFDbXFELFlBQVksQ0FBQyxJQUFJLENBQUNuUixVQUFVLEVBQUUsSUFBSSxDQUFDQyxTQUFTLEVBQUUsSUFBSSxDQUFDNk8sWUFBWSxFQUFFLElBQUksQ0FBQ3RPLFlBQVksRUFBRSxHQUFHLEVBQUUsRUFBRTtRQUNoRyxJQUFJLENBQUM0USxrQkFBa0I7UUFDdkJucUQsTUFBTSxJQUFJLENBQUN1eUIsaUJBQWlCLENBQUN0eUIsTUFBTTtRQUVuQyxJQUFLRixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQixJQUFJLENBQUN3eUIsaUJBQWlCLENBQUN4eUIsRUFBRSxDQUFDOHhCLFFBQVE7UUFDcEM7UUFFQSxJQUFJLENBQUMyeUIsZUFBZTtJQUN0QjtJQUVBb0YsZ0JBQWdCenBELFNBQVMsQ0FBQytwRCxZQUFZLEdBQUcsU0FBVXBuRCxHQUFHLEVBQUVrMkMsU0FBUyxFQUFFNk8sWUFBWSxFQUFFenRDLFNBQVMsRUFBRTZxQyxLQUFLLEVBQUVELFlBQVksRUFBRWtHLE1BQU07UUFDckgsSUFBSUgsa0JBQWtCLEVBQUUsQ0FBQ3BwQyxNQUFNLENBQUNxakM7UUFDaEMsSUFBSWpsRDtRQUNKLElBQUlDLE1BQU04QyxJQUFJN0MsTUFBTSxHQUFHO1FBQ3ZCLElBQUkrTDtRQUNKLElBQUlDO1FBQ0osSUFBSWsvQyxZQUFZLEVBQUU7UUFDbEIsSUFBSUMsZUFBZSxFQUFFO1FBQ3JCLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUVKLElBQUt4ckQsSUFBSUMsS0FBS0QsS0FBSyxHQUFHQSxLQUFLLEVBQUc7WUFDNUJ3ckQsZUFBZSxJQUFJLENBQUM3RyxzQkFBc0IsQ0FBQzVoRCxHQUFHLENBQUMvQyxFQUFFO1lBRWpELElBQUksQ0FBQ3dyRCxjQUFjO2dCQUNqQnpvRCxHQUFHLENBQUMvQyxFQUFFLENBQUN5bEMsT0FBTyxHQUFHMGxCO1lBQ25CLE9BQU87Z0JBQ0xsUyxTQUFTLENBQUNqNUMsRUFBRSxHQUFHOG5ELFlBQVksQ0FBQzBELGVBQWUsRUFBRTtZQUMvQztZQUVBLElBQUl6b0QsR0FBRyxDQUFDL0MsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLFFBQVE1SixHQUFHLENBQUMvQyxFQUFFLENBQUMyTSxFQUFFLEtBQUssUUFBUTVKLEdBQUcsQ0FBQy9DLEVBQUUsQ0FBQzJNLEVBQUUsS0FBSyxRQUFRNUosR0FBRyxDQUFDL0MsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLFFBQVE1SixHQUFHLENBQUMvQyxFQUFFLENBQUMyTSxFQUFFLEtBQUssTUFBTTtnQkFDOUcsSUFBSSxDQUFDNitDLGNBQWM7b0JBQ2pCdlMsU0FBUyxDQUFDajVDLEVBQUUsR0FBRyxJQUFJLENBQUN3cUQsa0JBQWtCLENBQUN6bkQsR0FBRyxDQUFDL0MsRUFBRSxFQUFFa2xEO2dCQUNqRCxPQUFPO29CQUNMak0sU0FBUyxDQUFDajVDLEVBQUUsQ0FBQ2lHLEtBQUssQ0FBQ3lKLE1BQU0sR0FBRztnQkFDOUI7Z0JBRUEsSUFBSTNNLEdBQUcsQ0FBQy9DLEVBQUUsQ0FBQ3lsQyxPQUFPLEVBQUU7b0JBQ2xCLElBQUl3VCxTQUFTLENBQUNqNUMsRUFBRSxDQUFDaUcsS0FBSyxDQUFDcy9DLEtBQUssQ0FBQ2pWLFVBQVUsS0FBS2oyQixXQUFXO3dCQUNyREEsVUFBVTNGLFdBQVcsQ0FBQ3VrQyxTQUFTLENBQUNqNUMsRUFBRSxDQUFDaUcsS0FBSyxDQUFDcy9DLEtBQUs7b0JBQ2hEO2dCQUNGO2dCQUVBNkYsVUFBVTdwRCxJQUFJLENBQUMwM0MsU0FBUyxDQUFDajVDLEVBQUUsQ0FBQ2lHLEtBQUs7WUFDbkMsT0FBTyxJQUFJbEQsR0FBRyxDQUFDL0MsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLE1BQU07Z0JBQzdCLElBQUksQ0FBQzYrQyxjQUFjO29CQUNqQnZTLFNBQVMsQ0FBQ2o1QyxFQUFFLEdBQUcsSUFBSSxDQUFDNHFELGtCQUFrQixDQUFDN25ELEdBQUcsQ0FBQy9DLEVBQUU7Z0JBQy9DLE9BQU87b0JBQ0xrTSxPQUFPK3NDLFNBQVMsQ0FBQ2o1QyxFQUFFLENBQUM0TixFQUFFLENBQUMxTixNQUFNO29CQUU3QixJQUFLK0wsSUFBSSxHQUFHQSxJQUFJQyxNQUFNRCxLQUFLLEVBQUc7d0JBQzVCZ3RDLFNBQVMsQ0FBQ2o1QyxFQUFFLENBQUM4bkQsWUFBWSxDQUFDNzdDLEVBQUUsR0FBR2d0QyxTQUFTLENBQUNqNUMsRUFBRSxDQUFDNE4sRUFBRSxDQUFDM0IsRUFBRTtvQkFDbkQ7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDaytDLFlBQVksQ0FBQ3BuRCxHQUFHLENBQUMvQyxFQUFFLENBQUM0TixFQUFFLEVBQUVxckMsU0FBUyxDQUFDajVDLEVBQUUsQ0FBQzROLEVBQUUsRUFBRXFyQyxTQUFTLENBQUNqNUMsRUFBRSxDQUFDOG5ELFlBQVksRUFBRTdPLFNBQVMsQ0FBQ2o1QyxFQUFFLENBQUMrbkQsRUFBRSxFQUFFN0MsUUFBUSxHQUFHOEYsaUJBQWlCRztnQkFFdEgsSUFBSXBvRCxHQUFHLENBQUMvQyxFQUFFLENBQUN5bEMsT0FBTyxFQUFFO29CQUNsQixJQUFJd1QsU0FBUyxDQUFDajVDLEVBQUUsQ0FBQytuRCxFQUFFLENBQUN6WCxVQUFVLEtBQUtqMkIsV0FBVzt3QkFDNUNBLFVBQVUzRixXQUFXLENBQUN1a0MsU0FBUyxDQUFDajVDLEVBQUUsQ0FBQytuRCxFQUFFO29CQUN2QztnQkFDRjtZQUNGLE9BQU8sSUFBSWhsRCxHQUFHLENBQUMvQyxFQUFFLENBQUMyTSxFQUFFLEtBQUssTUFBTTtnQkFDN0IsSUFBSSxDQUFDNitDLGNBQWM7b0JBQ2pCdlMsU0FBUyxDQUFDajVDLEVBQUUsR0FBRyxJQUFJLENBQUM2cUQsc0JBQXNCLENBQUM5bkQsR0FBRyxDQUFDL0MsRUFBRSxFQUFFcWE7Z0JBQ3JEO2dCQUVBaXhDLG1CQUFtQnJTLFNBQVMsQ0FBQ2o1QyxFQUFFLENBQUNpNkIsU0FBUztnQkFDekMrd0IsZ0JBQWdCenBELElBQUksQ0FBQytwRDtZQUN2QixPQUFPLElBQUl2b0QsR0FBRyxDQUFDL0MsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLFFBQVE1SixHQUFHLENBQUMvQyxFQUFFLENBQUMyTSxFQUFFLEtBQUssUUFBUTVKLEdBQUcsQ0FBQy9DLEVBQUUsQ0FBQzJNLEVBQUUsS0FBSyxRQUFRNUosR0FBRyxDQUFDL0MsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLE1BQU07Z0JBQy9GLElBQUksQ0FBQzYrQyxjQUFjO29CQUNqQnZTLFNBQVMsQ0FBQ2o1QyxFQUFFLEdBQUcsSUFBSSxDQUFDK3FELGtCQUFrQixDQUFDaG9ELEdBQUcsQ0FBQy9DLEVBQUUsRUFBRWdyRCxpQkFBaUI5RjtnQkFDbEU7Z0JBRUEsSUFBSSxDQUFDZ0csZ0JBQWdCLENBQUNqUyxTQUFTLENBQUNqNUMsRUFBRTtZQUNwQyxPQUFPLElBQUkrQyxHQUFHLENBQUMvQyxFQUFFLENBQUMyTSxFQUFFLEtBQUssUUFBUTVKLEdBQUcsQ0FBQy9DLEVBQUUsQ0FBQzJNLEVBQUUsS0FBSyxRQUFRNUosR0FBRyxDQUFDL0MsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLFFBQVE1SixHQUFHLENBQUMvQyxFQUFFLENBQUMyTSxFQUFFLEtBQUssUUFBUTVKLEdBQUcsQ0FBQy9DLEVBQUUsQ0FBQzJNLEVBQUUsS0FBSyxRQUFRNUosR0FBRyxDQUFDL0MsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLE1BQU07Z0JBQzNJLElBQUksQ0FBQzYrQyxjQUFjO29CQUNqQkQsV0FBV3pyQixlQUFlRyxXQUFXLENBQUNsOUIsR0FBRyxDQUFDL0MsRUFBRSxDQUFDMk0sRUFBRTtvQkFDL0M0K0MsU0FBU3RzQyxJQUFJLENBQUMsSUFBSSxFQUFFbGMsR0FBRyxDQUFDL0MsRUFBRTtvQkFDMUJpNUMsU0FBUyxDQUFDajVDLEVBQUUsR0FBR3VyRDtvQkFDZixJQUFJLENBQUNqSCxjQUFjLENBQUMvaUQsSUFBSSxDQUFDZ3FEO2dCQUMzQixPQUFPO29CQUNMQSxXQUFXdFMsU0FBUyxDQUFDajVDLEVBQUU7b0JBQ3ZCdXJELFNBQVM3N0MsTUFBTSxHQUFHO2dCQUNwQjtnQkFFQTI3QyxhQUFhOXBELElBQUksQ0FBQ2dxRDtZQUNwQixPQUFPLElBQUl4b0QsR0FBRyxDQUFDL0MsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLE1BQU07Z0JBQzdCLElBQUksQ0FBQzYrQyxjQUFjO29CQUNqQkQsV0FBV3pyQixlQUFlRyxXQUFXLENBQUNsOUIsR0FBRyxDQUFDL0MsRUFBRSxDQUFDMk0sRUFBRTtvQkFDL0Nzc0MsU0FBUyxDQUFDajVDLEVBQUUsR0FBR3VyRDtvQkFDZkEsU0FBU3RzQyxJQUFJLENBQUMsSUFBSSxFQUFFbGMsS0FBSy9DLEdBQUdpNUM7b0JBQzVCLElBQUksQ0FBQ3FMLGNBQWMsQ0FBQy9pRCxJQUFJLENBQUNncUQ7b0JBQ3pCSixTQUFTO2dCQUNYLE9BQU87b0JBQ0xJLFdBQVd0UyxTQUFTLENBQUNqNUMsRUFBRTtvQkFDdkJ1ckQsU0FBUzc3QyxNQUFNLEdBQUc7Z0JBQ3BCO2dCQUVBMjdDLGFBQWE5cEQsSUFBSSxDQUFDZ3FEO1lBQ3BCO1lBRUEsSUFBSSxDQUFDMUcsbUJBQW1CLENBQUM5aEQsR0FBRyxDQUFDL0MsRUFBRSxFQUFFQSxJQUFJO1FBQ3ZDO1FBRUFDLE1BQU1tckQsVUFBVWxyRCxNQUFNO1FBRXRCLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCb3JELFNBQVMsQ0FBQ3ByRCxFQUFFLENBQUMwUCxNQUFNLEdBQUc7UUFDeEI7UUFFQXpQLE1BQU1vckQsYUFBYW5yRCxNQUFNO1FBRXpCLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCcXJELFlBQVksQ0FBQ3JyRCxFQUFFLENBQUMwUCxNQUFNLEdBQUc7UUFDM0I7SUFDRjtJQUVBbTZDLGdCQUFnQnpwRCxTQUFTLENBQUN5akQsa0JBQWtCLEdBQUc7UUFDN0MsSUFBSSxDQUFDWSxlQUFlO1FBQ3BCLElBQUl6a0Q7UUFDSixJQUFJQyxNQUFNLElBQUksQ0FBQzZwRCxVQUFVLENBQUM1cEQsTUFBTTtRQUVoQyxJQUFLRixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQixJQUFJLENBQUM4cEQsVUFBVSxDQUFDOXBELEVBQUUsQ0FBQzAxQixLQUFLO1FBQzFCO1FBRUEsSUFBSSxDQUFDKzFCLFdBQVc7UUFFaEIsSUFBS3pyRCxJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQixJQUFJLElBQUksQ0FBQzhwRCxVQUFVLENBQUM5cEQsRUFBRSxDQUFDaXhCLElBQUksSUFBSSxJQUFJLENBQUNLLGFBQWEsRUFBRTtnQkFDakQsSUFBSSxJQUFJLENBQUN3NEIsVUFBVSxDQUFDOXBELEVBQUUsQ0FBQ3dsRCxNQUFNLEVBQUU7b0JBQzdCLElBQUksQ0FBQ3NFLFVBQVUsQ0FBQzlwRCxFQUFFLENBQUN3bEQsTUFBTSxDQUFDempDLFlBQVksQ0FBQyxLQUFLLElBQUksQ0FBQytuQyxVQUFVLENBQUM5cEQsRUFBRSxDQUFDOEksQ0FBQyxHQUFHLGtEQUFrRDtvQkFFckgsSUFBSSxDQUFDZ2hELFVBQVUsQ0FBQzlwRCxFQUFFLENBQUM4SSxDQUFDLEdBQUcsU0FBUyxJQUFJLENBQUNnaEQsVUFBVSxDQUFDOXBELEVBQUUsQ0FBQzhJLENBQUM7Z0JBQ3REO2dCQUVBLElBQUksQ0FBQ2doRCxVQUFVLENBQUM5cEQsRUFBRSxDQUFDdWxELEtBQUssQ0FBQ3hqQyxZQUFZLENBQUMsS0FBSyxJQUFJLENBQUMrbkMsVUFBVSxDQUFDOXBELEVBQUUsQ0FBQzhJLENBQUMsSUFBSTtZQUNyRTtRQUNGO0lBQ0Y7SUFFQStnRCxnQkFBZ0J6cEQsU0FBUyxDQUFDcXJELFdBQVcsR0FBRztRQUN0QyxJQUFJenJEO1FBQ0osSUFBSUMsTUFBTSxJQUFJLENBQUM4cEQsZ0JBQWdCLENBQUM3cEQsTUFBTTtRQUN0QyxJQUFJd3JEO1FBRUosSUFBSzFyRCxJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQjByRCxrQkFBa0IsSUFBSSxDQUFDM0IsZ0JBQWdCLENBQUMvcEQsRUFBRTtZQUUxQyxJQUFJLENBQUMsSUFBSSxDQUFDc3hCLGFBQWEsSUFBSW82QixnQkFBZ0IxbEQsT0FBTyxDQUFDeXNCLFdBQVcsS0FBS2k1QixnQkFBZ0IzZ0QsSUFBSSxLQUFLLE1BQU07Z0JBQ2hHMmdELGdCQUFnQnhnRCxFQUFFLENBQUN3Z0QsZ0JBQWdCM2dELElBQUksRUFBRTJnRCxnQkFBZ0IxbEQsT0FBTyxFQUFFLElBQUksQ0FBQ3NyQixhQUFhO1lBQ3RGO1FBQ0Y7SUFDRjtJQUVBdTRCLGdCQUFnQnpwRCxTQUFTLENBQUNtVixPQUFPLEdBQUc7UUFDbEMsSUFBSSxDQUFDbXRDLGtCQUFrQjtRQUN2QixJQUFJLENBQUMxSixVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7SUFDbkI7SUFFQSxTQUFTMFMsWUFBWTk5QyxDQUFDLEVBQUUrOUMsRUFBRSxFQUFFeFksRUFBRSxFQUFFeVksRUFBRSxFQUFFaHlCLENBQUMsRUFBRW54QixDQUFDO1FBQ3RDLElBQUksQ0FBQ21GLENBQUMsR0FBR0E7UUFDVCxJQUFJLENBQUMrOUMsRUFBRSxHQUFHQTtRQUNWLElBQUksQ0FBQ3hZLEVBQUUsR0FBR0E7UUFDVixJQUFJLENBQUN5WSxFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDaHlCLENBQUMsR0FBR0E7UUFDVCxJQUFJLENBQUNueEIsQ0FBQyxHQUFHQTtRQUNULElBQUksQ0FBQ3VvQixJQUFJLEdBQUc7WUFDVnBqQixHQUFHO1lBQ0grOUMsSUFBSSxDQUFDLENBQUNBO1lBQ054WSxJQUFJLENBQUMsQ0FBQ0E7WUFDTnlZLElBQUksQ0FBQyxDQUFDQTtZQUNOaHlCLEdBQUc7WUFDSG54QixHQUFHO1FBQ0w7SUFDRjtJQUVBaWpELFlBQVl2ckQsU0FBUyxDQUFDMHJELE1BQU0sR0FBRyxTQUFVaitDLENBQUMsRUFBRSs5QyxFQUFFLEVBQUV4WSxFQUFFLEVBQUV5WSxFQUFFLEVBQUVoeUIsQ0FBQyxFQUFFbnhCLENBQUM7UUFDMUQsSUFBSSxDQUFDdW9CLElBQUksQ0FBQ3BqQixDQUFDLEdBQUc7UUFDZCxJQUFJLENBQUNvakIsSUFBSSxDQUFDMjZCLEVBQUUsR0FBRztRQUNmLElBQUksQ0FBQzM2QixJQUFJLENBQUNtaUIsRUFBRSxHQUFHO1FBQ2YsSUFBSSxDQUFDbmlCLElBQUksQ0FBQzQ2QixFQUFFLEdBQUc7UUFDZixJQUFJLENBQUM1NkIsSUFBSSxDQUFDNEksQ0FBQyxHQUFHO1FBQ2QsSUFBSSxDQUFDNUksSUFBSSxDQUFDdm9CLENBQUMsR0FBRztRQUNkLElBQUlxakQsVUFBVTtRQUVkLElBQUksSUFBSSxDQUFDbCtDLENBQUMsS0FBS0EsR0FBRztZQUNoQixJQUFJLENBQUNBLENBQUMsR0FBR0E7WUFDVCxJQUFJLENBQUNvakIsSUFBSSxDQUFDcGpCLENBQUMsR0FBRztZQUNkaytDLFVBQVU7UUFDWjtRQUVBLElBQUksSUFBSSxDQUFDSCxFQUFFLEtBQUtBLElBQUk7WUFDbEIsSUFBSSxDQUFDQSxFQUFFLEdBQUdBO1lBQ1YsSUFBSSxDQUFDMzZCLElBQUksQ0FBQzI2QixFQUFFLEdBQUc7WUFDZkcsVUFBVTtRQUNaO1FBRUEsSUFBSSxJQUFJLENBQUMzWSxFQUFFLEtBQUtBLElBQUk7WUFDbEIsSUFBSSxDQUFDQSxFQUFFLEdBQUdBO1lBQ1YsSUFBSSxDQUFDbmlCLElBQUksQ0FBQ21pQixFQUFFLEdBQUc7WUFDZjJZLFVBQVU7UUFDWjtRQUVBLElBQUksSUFBSSxDQUFDRixFQUFFLEtBQUtBLElBQUk7WUFDbEIsSUFBSSxDQUFDQSxFQUFFLEdBQUdBO1lBQ1YsSUFBSSxDQUFDNTZCLElBQUksQ0FBQzQ2QixFQUFFLEdBQUc7WUFDZkUsVUFBVTtRQUNaO1FBRUEsSUFBSSxJQUFJLENBQUNseUIsQ0FBQyxLQUFLQSxHQUFHO1lBQ2hCLElBQUksQ0FBQ0EsQ0FBQyxHQUFHQTtZQUNULElBQUksQ0FBQzVJLElBQUksQ0FBQzRJLENBQUMsR0FBRztZQUNka3lCLFVBQVU7UUFDWjtRQUVBLElBQUlyakQsRUFBRXhJLE1BQU0sSUFBSyxLQUFJLENBQUN3SSxDQUFDLENBQUMsRUFBRSxLQUFLQSxDQUFDLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQ0EsQ0FBQyxDQUFDLEVBQUUsS0FBS0EsQ0FBQyxDQUFDLEVBQUUsSUFBSSxJQUFJLENBQUNBLENBQUMsQ0FBQyxFQUFFLEtBQUtBLENBQUMsQ0FBQyxFQUFFLElBQUksSUFBSSxDQUFDQSxDQUFDLENBQUMsRUFBRSxLQUFLQSxDQUFDLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQ0EsQ0FBQyxDQUFDLEdBQUcsS0FBS0EsQ0FBQyxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUNBLENBQUMsQ0FBQyxHQUFHLEtBQUtBLENBQUMsQ0FBQyxHQUFHLEdBQUc7WUFDdEosSUFBSSxDQUFDQSxDQUFDLEdBQUdBO1lBQ1QsSUFBSSxDQUFDdW9CLElBQUksQ0FBQ3ZvQixDQUFDLEdBQUc7WUFDZHFqRCxVQUFVO1FBQ1o7UUFFQSxPQUFPQTtJQUNUO0lBRUEsU0FBU0MsYUFBYWpyQyxJQUFJLEVBQUVoVyxJQUFJO1FBQzlCLElBQUksQ0FBQ2toRCxRQUFRLEdBQUcvc0Q7UUFDaEIsSUFBSSxDQUFDZ3RCLEVBQUUsR0FBRztRQUNWLElBQUksQ0FBQzdqQixDQUFDLEdBQUc7UUFDVCxJQUFJLENBQUNtcEIsRUFBRSxHQUFHO1FBQ1YsSUFBSSxDQUFDRixhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDTCxJQUFJLEdBQUc7UUFFWixJQUFJbG1CLEtBQUtqQyxDQUFDLElBQUlpQyxLQUFLakMsQ0FBQyxDQUFDdXBCLEdBQUcsRUFBRTtZQUN4QnRuQixLQUFLakMsQ0FBQyxHQUFHaVksS0FBS3RHLFVBQVUsQ0FBQzZYLFdBQVcsQ0FBQ0YsT0FBTyxDQUFDcm5CLEtBQUtqQyxDQUFDO1FBQ3JEO1FBRUEsSUFBSSxDQUFDaUMsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ2dXLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUN6VCxJQUFJLEdBQUcsSUFBSSxDQUFDeVQsSUFBSSxDQUFDelQsSUFBSTtRQUMxQixJQUFJLENBQUM0K0MsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ2g3QixlQUFlLEdBQUcsRUFBRTtRQUN6QixJQUFJLENBQUNpN0IsV0FBVyxHQUFHO1lBQ2pCQyxRQUFRO1lBQ1JDLFVBQVUsSUFBSSxDQUFDQyxlQUFlO1lBQzlCL2pELEdBQUc7WUFDSG9tQyxRQUFRO1lBQ1JDLFNBQVM7WUFDVCtjLElBQUk7WUFDSjUvQyxHQUFHO1lBQ0h3Z0QsZUFBZTtZQUNmN3lCLEdBQUcsRUFBRTtZQUNMOHlCLElBQUk7WUFDSkMsWUFBWSxFQUFFO1lBQ2RDLElBQUk7WUFDSm5GLElBQUk7WUFDSnIvQyxHQUFHO1lBQ0hnckMsSUFBSTtZQUNKd1ksSUFBSTtZQUNKaGpELEdBQUc7WUFDSHM3QixJQUFJO1lBQ0p4SyxJQUFJO1lBQ0ptekIsSUFBSTtZQUNKQyxlQUFlO1lBQ2ZDLGlCQUFpQjtZQUNqQkMsaUJBQWlCO1lBQ2pCQyxTQUFTO1lBQ1RDLFdBQVc7WUFDWEMsV0FBVyxFQUFFO1lBQ2JDLGlCQUFpQjtZQUNqQnY5QyxZQUFZO1FBQ2Q7UUFDQSxJQUFJLENBQUN3OUMsUUFBUSxDQUFDLElBQUksQ0FBQ2hCLFdBQVcsRUFBRSxJQUFJLENBQUN0aEQsSUFBSSxDQUFDakMsQ0FBQyxDQUFDcUQsQ0FBQyxDQUFDLEVBQUUsQ0FBQy9ELENBQUM7UUFFbEQsSUFBSSxDQUFDLElBQUksQ0FBQ2tsRCxjQUFjLElBQUk7WUFDMUIsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNsQixXQUFXO1FBQ3hDO0lBQ0Y7SUFFQUwsYUFBYTVyRCxTQUFTLENBQUNvc0QsZUFBZSxHQUFHO1FBQUM7UUFBRztLQUFFO0lBRS9DUixhQUFhNXJELFNBQVMsQ0FBQ2l0RCxRQUFRLEdBQUcsU0FBVTdwRCxHQUFHLEVBQUV1SCxJQUFJO1FBQ25ELElBQUssSUFBSTNDLEtBQUsyQyxLQUFNO1lBQ2xCLElBQUl6SyxPQUFPRixTQUFTLENBQUNHLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDdUssTUFBTTNDLElBQUk7Z0JBQ2pENUUsR0FBRyxDQUFDNEUsRUFBRSxHQUFHMkMsSUFBSSxDQUFDM0MsRUFBRTtZQUNsQjtRQUNGO1FBRUEsT0FBTzVFO0lBQ1Q7SUFFQXdvRCxhQUFhNXJELFNBQVMsQ0FBQ290RCxjQUFjLEdBQUcsU0FBVXppRCxJQUFJO1FBQ3BELElBQUksQ0FBQ0EsS0FBSzhFLFVBQVUsRUFBRTtZQUNwQixJQUFJLENBQUMwOUMsZ0JBQWdCLENBQUN4aUQ7UUFDeEI7UUFFQSxJQUFJLENBQUNzaEQsV0FBVyxHQUFHdGhEO1FBQ25CLElBQUksQ0FBQ3NoRCxXQUFXLENBQUNFLFFBQVEsR0FBRyxJQUFJLENBQUNGLFdBQVcsQ0FBQ0UsUUFBUSxJQUFJLElBQUksQ0FBQ0MsZUFBZTtRQUM3RSxJQUFJLENBQUN2N0IsSUFBSSxHQUFHO0lBQ2Q7SUFFQSs2QixhQUFhNXJELFNBQVMsQ0FBQ2t0RCxjQUFjLEdBQUc7UUFDdEMsT0FBTyxJQUFJLENBQUNHLGVBQWU7SUFDN0I7SUFFQXpCLGFBQWE1ckQsU0FBUyxDQUFDcXRELGVBQWUsR0FBRztRQUN2QyxJQUFJLENBQUNqOEIsRUFBRSxHQUFHLElBQUksQ0FBQ3ptQixJQUFJLENBQUNqQyxDQUFDLENBQUNxRCxDQUFDLENBQUNqTSxNQUFNLEdBQUc7UUFFakMsSUFBSSxJQUFJLENBQUNzeEIsRUFBRSxFQUFFO1lBQ1gsSUFBSSxDQUFDQyxTQUFTLENBQUMsSUFBSSxDQUFDaThCLGdCQUFnQixDQUFDdjVDLElBQUksQ0FBQyxJQUFJO1FBQ2hEO1FBRUEsT0FBTyxJQUFJLENBQUNxZCxFQUFFO0lBQ2hCO0lBRUF3NkIsYUFBYTVyRCxTQUFTLENBQUNxeEIsU0FBUyxHQUFHLFNBQVVDLGNBQWM7UUFDekQsSUFBSSxDQUFDTixlQUFlLENBQUM3dkIsSUFBSSxDQUFDbXdCO1FBQzFCLElBQUksQ0FBQzNRLElBQUksQ0FBQzRRLGtCQUFrQixDQUFDLElBQUk7SUFDbkM7SUFFQXE2QixhQUFhNXJELFNBQVMsQ0FBQzB4QixRQUFRLEdBQUcsU0FBVTY3QixXQUFXO1FBQ3JELElBQUksQ0FBQyxJQUFJLENBQUM1c0MsSUFBSSxDQUFDdEcsVUFBVSxDQUFDMFcsT0FBTyxLQUFLLElBQUksQ0FBQ0EsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDQyxlQUFlLENBQUNseEIsTUFBTSxLQUFLLENBQUN5dEQsYUFBYTtZQUNuRztRQUNGO1FBRUEsSUFBSSxDQUFDdEIsV0FBVyxDQUFDempELENBQUMsR0FBRyxJQUFJLENBQUNtQyxJQUFJLENBQUNqQyxDQUFDLENBQUNxRCxDQUFDLENBQUMsSUFBSSxDQUFDKy9DLFNBQVMsQ0FBQyxDQUFDOWpELENBQUMsQ0FBQ1EsQ0FBQztRQUN0RCxJQUFJZ2xELGVBQWUsSUFBSSxDQUFDdkIsV0FBVztRQUNuQyxJQUFJd0IsZUFBZSxJQUFJLENBQUMzQixTQUFTO1FBRWpDLElBQUksSUFBSSxDQUFDNzZCLElBQUksRUFBRTtZQUNiLElBQUksQ0FBQ204QixjQUFjLENBQUMsSUFBSSxDQUFDbkIsV0FBVztZQUNwQztRQUNGO1FBRUEsSUFBSSxDQUFDaDdCLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0osSUFBSSxHQUFHO1FBQ1osSUFBSWp4QjtRQUNKLElBQUlDLE1BQU0sSUFBSSxDQUFDbXhCLGVBQWUsQ0FBQ2x4QixNQUFNO1FBQ3JDLElBQUlxeEIsYUFBYW84QixlQUFlLElBQUksQ0FBQzVpRCxJQUFJLENBQUNqQyxDQUFDLENBQUNxRCxDQUFDLENBQUMsSUFBSSxDQUFDKy9DLFNBQVMsQ0FBQyxDQUFDOWpELENBQUM7UUFFL0QsSUFBS3BJLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCLGdHQUFnRztZQUNoRyxJQUFJNnRELGlCQUFpQixJQUFJLENBQUMzQixTQUFTLEVBQUU7Z0JBQ25DMzZCLGFBQWEsSUFBSSxDQUFDSCxlQUFlLENBQUNweEIsRUFBRSxDQUFDdXhCLFlBQVlBLFdBQVczb0IsQ0FBQztZQUMvRCxPQUFPO2dCQUNMMm9CLGFBQWEsSUFBSSxDQUFDSCxlQUFlLENBQUNweEIsRUFBRSxDQUFDLElBQUksQ0FBQ3FzRCxXQUFXLEVBQUU5NkIsV0FBVzNvQixDQUFDO1lBQ3JFO1FBQ0Y7UUFFQSxJQUFJZ2xELGlCQUFpQnI4QixZQUFZO1lBQy9CLElBQUksQ0FBQ2k4QixjQUFjLENBQUNqOEI7UUFDdEI7UUFFQSxJQUFJLENBQUNscEIsQ0FBQyxHQUFHLElBQUksQ0FBQ2drRCxXQUFXO1FBQ3pCLElBQUksQ0FBQ25nQyxFQUFFLEdBQUcsSUFBSSxDQUFDN2pCLENBQUM7UUFDaEIsSUFBSSxDQUFDZ3BCLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0YsT0FBTyxHQUFHLElBQUksQ0FBQ3BRLElBQUksQ0FBQ3RHLFVBQVUsQ0FBQzBXLE9BQU87SUFDN0M7SUFFQTY2QixhQUFhNXJELFNBQVMsQ0FBQ3N0RCxnQkFBZ0IsR0FBRztRQUN4QyxJQUFJSSxXQUFXLElBQUksQ0FBQy9pRCxJQUFJLENBQUNqQyxDQUFDLENBQUNxRCxDQUFDO1FBQzVCLElBQUkwZixXQUFXLElBQUksQ0FBQzlLLElBQUksQ0FBQ3pULElBQUksQ0FBQ29qQixhQUFhO1FBQzNDLElBQUkxd0IsSUFBSTtRQUNSLElBQUlDLE1BQU02dEQsU0FBUzV0RCxNQUFNO1FBRXpCLE1BQU9GLEtBQUtDLE1BQU0sRUFBRztZQUNuQixJQUFJRCxNQUFNQyxNQUFNLEtBQUs2dEQsUUFBUSxDQUFDOXRELElBQUksRUFBRSxDQUFDNEksQ0FBQyxHQUFHaWpCLFVBQVU7Z0JBQ2pEO1lBQ0Y7WUFFQTdyQixLQUFLO1FBQ1A7UUFFQSxJQUFJLElBQUksQ0FBQ2tzRCxTQUFTLEtBQUtsc0QsR0FBRztZQUN4QixJQUFJLENBQUNrc0QsU0FBUyxHQUFHbHNEO1FBQ25CO1FBRUEsT0FBTyxJQUFJLENBQUMrSyxJQUFJLENBQUNqQyxDQUFDLENBQUNxRCxDQUFDLENBQUMsSUFBSSxDQUFDKy9DLFNBQVMsQ0FBQyxDQUFDOWpELENBQUM7SUFDeEM7SUFFQTRqRCxhQUFhNXJELFNBQVMsQ0FBQzJ0RCxjQUFjLEdBQUcsU0FBVXhiLElBQUk7UUFDcEQsSUFBSXliLGtCQUFrQixFQUFFO1FBQ3hCLElBQUlodUQsSUFBSTtRQUNSLElBQUlDLE1BQU1zeUMsS0FBS3J5QyxNQUFNO1FBQ3JCLElBQUkwMEM7UUFDSixJQUFJSDtRQUNKLElBQUl3WixnQkFBZ0I7UUFDcEIsSUFBSUMsb0JBQW9CO1FBQ3hCLElBQUlDLGVBQWU7UUFFbkIsTUFBT251RCxJQUFJQyxJQUFLO1lBQ2RndUQsZ0JBQWdCQztZQUNoQkEsb0JBQW9CO1lBQ3BCdFosV0FBV3JDLEtBQUtrQixVQUFVLENBQUN6ekM7WUFDM0JtdUQsZUFBZTViLEtBQUs2YixNQUFNLENBQUNwdUQ7WUFFM0IsSUFBSWt2QyxZQUFZOEYsbUJBQW1CLENBQUNKLFdBQVc7Z0JBQzdDcVosZ0JBQWdCLE1BQU0sK0RBQStEO1lBQ3ZGLE9BQU8sSUFBSXJaLFlBQVksVUFBVUEsWUFBWSxRQUFRO2dCQUNuRCxJQUFJMUYsWUFBWWdHLGNBQWMsQ0FBQzNDLE1BQU12eUMsSUFBSTtvQkFDdkNtdUQsZUFBZTViLEtBQUtyM0IsTUFBTSxDQUFDbGIsR0FBRztnQkFDaEMsT0FBTztvQkFDTHkwQyxpQkFBaUJsQyxLQUFLa0IsVUFBVSxDQUFDenpDLElBQUksSUFBSSxvREFBb0Q7b0JBRTdGLElBQUl5MEMsa0JBQWtCLFVBQVVBLGtCQUFrQixRQUFRO3dCQUN4RCxJQUFJdkYsWUFBWXFGLFVBQVUsQ0FBQ0ssVUFBVUgsaUJBQWlCOzRCQUNwRDBaLGVBQWU1YixLQUFLcjNCLE1BQU0sQ0FBQ2xiLEdBQUc7NEJBQzlCaXVELGdCQUFnQjt3QkFDbEIsT0FBTyxJQUFJL2UsWUFBWTZGLFdBQVcsQ0FBQ3hDLEtBQUtyM0IsTUFBTSxDQUFDbGIsR0FBRyxLQUFLOzRCQUNyRG11RCxlQUFlNWIsS0FBS3IzQixNQUFNLENBQUNsYixHQUFHO3dCQUNoQyxPQUFPOzRCQUNMbXVELGVBQWU1YixLQUFLcjNCLE1BQU0sQ0FBQ2xiLEdBQUc7d0JBQ2hDO29CQUNGO2dCQUNGO1lBQ0YsT0FBTyxJQUFJNDBDLFdBQVcsUUFBUTtnQkFDNUJILGlCQUFpQmxDLEtBQUtrQixVQUFVLENBQUN6ekMsSUFBSTtnQkFFckMsSUFBSWt2QyxZQUFZMkYsbUJBQW1CLENBQUNELFdBQVc7b0JBQzdDcVosZ0JBQWdCO2dCQUNsQjtZQUNGLE9BQU8sSUFBSS9lLFlBQVl5RixpQkFBaUIsQ0FBQ0MsV0FBVztnQkFDbERxWixnQkFBZ0I7Z0JBQ2hCQyxvQkFBb0I7WUFDdEI7WUFFQSxJQUFJRCxlQUFlO2dCQUNqQkQsZUFBZSxDQUFDQSxnQkFBZ0I5dEQsTUFBTSxHQUFHLEVBQUUsSUFBSWl1RDtnQkFDL0NGLGdCQUFnQjtZQUNsQixPQUFPO2dCQUNMRCxnQkFBZ0J6c0QsSUFBSSxDQUFDNHNEO1lBQ3ZCO1lBRUFudUQsS0FBS211RCxhQUFhanVELE1BQU07UUFDMUI7UUFFQSxPQUFPOHREO0lBQ1Q7SUFFQWhDLGFBQWE1ckQsU0FBUyxDQUFDbXRELGdCQUFnQixHQUFHLFNBQVVoL0MsWUFBWTtRQUM5REEsYUFBYXNCLFVBQVUsR0FBRztRQUMxQixJQUFJZ00sY0FBYyxJQUFJLENBQUNrRixJQUFJLENBQUN0RyxVQUFVLENBQUNvQixXQUFXO1FBQ2xELElBQUk5USxPQUFPLElBQUksQ0FBQ0EsSUFBSTtRQUNwQixJQUFJc2pELFVBQVUsRUFBRTtRQUNoQixJQUFJcnVEO1FBQ0osSUFBSUM7UUFDSixJQUFJcXVEO1FBQ0osSUFBSXB1QyxRQUFRO1FBQ1osSUFBSTdhO1FBQ0osSUFBSWtwRCxpQkFBaUJ4akQsS0FBSzh1QixDQUFDLENBQUN0eEIsQ0FBQztRQUM3QixJQUFJaW1ELGNBQWM7UUFDbEIsSUFBSUMsYUFBYTtRQUNqQixJQUFJQyxjQUFjO1FBQ2xCLElBQUkvQixhQUFhLEVBQUU7UUFDbkIsSUFBSWdDLFlBQVk7UUFDaEIsSUFBSUMsZUFBZTtRQUNuQixJQUFJM2lEO1FBQ0osSUFBSUM7UUFDSixJQUFJeWlDLFdBQVc5eUIsWUFBWWs0QixhQUFhLENBQUN4bEMsYUFBYTlGLENBQUM7UUFDdkQsSUFBSWtHO1FBQ0osSUFBSXczQyxVQUFVO1FBQ2QsSUFBSXBVLFlBQVlyRCxrQkFBa0JDO1FBQ2xDcGdDLGFBQWF1Z0MsT0FBTyxHQUFHaUQsVUFBVTlDLE1BQU07UUFDdkMxZ0MsYUFBYXNnQyxNQUFNLEdBQUdrRCxVQUFVOXJDLEtBQUs7UUFDckNzSSxhQUFhMitDLFNBQVMsR0FBRzMrQyxhQUFhbkcsQ0FBQztRQUN2Q21HLGFBQWE0K0MsU0FBUyxHQUFHLElBQUksQ0FBQ1ksY0FBYyxDQUFDeC9DLGFBQWEzRixDQUFDO1FBQzNEM0ksTUFBTXNPLGFBQWE0K0MsU0FBUyxDQUFDanRELE1BQU07UUFDbkNxTyxhQUFhNitDLGVBQWUsR0FBRzcrQyxhQUFhbStDLEVBQUU7UUFDOUMsSUFBSW1DLGlCQUFpQnRnRCxhQUFhMjFCLEVBQUUsR0FBRyxPQUFPMzFCLGFBQWEyK0MsU0FBUztRQUNwRSxJQUFJdFk7UUFFSixJQUFJcm1DLGFBQWFtckIsRUFBRSxFQUFFO1lBQ25CLElBQUl0NkIsT0FBTztZQUNYLElBQUltdEQsV0FBV2grQyxhQUFhbXJCLEVBQUUsQ0FBQyxFQUFFO1lBQ2pDLElBQUlvMUIsWUFBWXZnRCxhQUFhbXJCLEVBQUUsQ0FBQyxFQUFFO1lBQ2xDLElBQUlxMUI7WUFDSixJQUFJNUI7WUFFSixNQUFPL3RELEtBQU07Z0JBQ1grdEQsWUFBWSxJQUFJLENBQUNZLGNBQWMsQ0FBQ3gvQyxhQUFhM0YsQ0FBQztnQkFDOUNtbUQsZ0JBQWdCO2dCQUNoQkosWUFBWTtnQkFDWjF1RCxNQUFNa3RELFVBQVVqdEQsTUFBTTtnQkFDdEIydUQsaUJBQWlCdGdELGFBQWEyMUIsRUFBRSxHQUFHLE9BQU8zMUIsYUFBYTIrQyxTQUFTO2dCQUNoRSxJQUFJOEIsaUJBQWlCLENBQUM7Z0JBRXRCLElBQUtodkQsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7b0JBQzNCNDBDLFdBQVd1WSxTQUFTLENBQUNudEQsRUFBRSxDQUFDeXpDLFVBQVUsQ0FBQztvQkFDbkM2YSxjQUFjO29CQUVkLElBQUluQixTQUFTLENBQUNudEQsRUFBRSxLQUFLLEtBQUs7d0JBQ3hCZ3ZELGlCQUFpQmh2RDtvQkFDbkIsT0FBTyxJQUFJNDBDLGFBQWEsTUFBTUEsYUFBYSxHQUFHO3dCQUM1QytaLFlBQVk7d0JBQ1pMLGNBQWM7d0JBQ2RTLGlCQUFpQnhnRCxhQUFhNitDLGVBQWUsSUFBSTcrQyxhQUFhMitDLFNBQVMsR0FBRztvQkFDNUU7b0JBRUEsSUFBSXJ4QyxZQUFZM08sS0FBSyxFQUFFO3dCQUNyQnlCLFdBQVdrTixZQUFZMDNCLFdBQVcsQ0FBQzRaLFNBQVMsQ0FBQ250RCxFQUFFLEVBQUUydUMsU0FBU0UsTUFBTSxFQUFFRixTQUFTc0QsT0FBTzt3QkFDbEZrVSxVQUFVbUksY0FBYyxJQUFJMy9DLFNBQVM0aEIsQ0FBQyxHQUFHaGlCLGFBQWEyK0MsU0FBUyxHQUFHO29CQUNwRSxPQUFPO3dCQUNMLGlFQUFpRTt3QkFDakUvRyxVQUFVdHFDLFlBQVk0MkIsV0FBVyxDQUFDMGEsU0FBUyxDQUFDbnRELEVBQUUsRUFBRXVPLGFBQWE5RixDQUFDLEVBQUU4RixhQUFhMitDLFNBQVM7b0JBQ3hGO29CQUVBLElBQUl5QixZQUFZeEksVUFBVW9HLFlBQVlZLFNBQVMsQ0FBQ250RCxFQUFFLEtBQUssS0FBSzt3QkFDMUQsSUFBSWd2RCxtQkFBbUIsQ0FBQyxHQUFHOzRCQUN6Qi91RCxPQUFPO3dCQUNULE9BQU87NEJBQ0xELElBQUlndkQ7d0JBQ047d0JBRUFELGlCQUFpQnhnRCxhQUFhNitDLGVBQWUsSUFBSTcrQyxhQUFhMitDLFNBQVMsR0FBRzt3QkFDMUVDLFVBQVUvMkMsTUFBTSxDQUFDcFcsR0FBR2d2RCxtQkFBbUJodkQsSUFBSSxJQUFJLEdBQUcsT0FBTyxpR0FBaUc7d0JBRTFKZ3ZELGlCQUFpQixDQUFDO3dCQUNsQkwsWUFBWTtvQkFDZCxPQUFPO3dCQUNMQSxhQUFheEk7d0JBQ2J3SSxhQUFhRTtvQkFDZjtnQkFDRjtnQkFFQUUsaUJBQWlCcGdCLFNBQVMyZCxNQUFNLEdBQUcvOUMsYUFBYTIrQyxTQUFTLEdBQUc7Z0JBRTVELElBQUksSUFBSSxDQUFDZixTQUFTLElBQUk1OUMsYUFBYTIrQyxTQUFTLEdBQUcsSUFBSSxDQUFDZCxlQUFlLElBQUkwQyxZQUFZQyxlQUFlO29CQUNoR3hnRCxhQUFhMitDLFNBQVMsSUFBSTtvQkFDMUIzK0MsYUFBYTYrQyxlQUFlLEdBQUc3K0MsYUFBYTIrQyxTQUFTLEdBQUczK0MsYUFBYW0rQyxFQUFFLEdBQUduK0MsYUFBYW5HLENBQUM7Z0JBQzFGLE9BQU87b0JBQ0xtRyxhQUFhNCtDLFNBQVMsR0FBR0E7b0JBQ3pCbHRELE1BQU1zTyxhQUFhNCtDLFNBQVMsQ0FBQ2p0RCxNQUFNO29CQUNuQ2QsT0FBTztnQkFDVDtZQUNGO1FBQ0Y7UUFFQXV2RCxZQUFZLENBQUNFO1FBQ2IxSSxVQUFVO1FBQ1YsSUFBSThJLG9CQUFvQjtRQUN4QixJQUFJQztRQUVKLElBQUtsdkQsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDM0JzdUQsY0FBYztZQUNkWSxjQUFjM2dELGFBQWE0K0MsU0FBUyxDQUFDbnRELEVBQUU7WUFDdkM0MEMsV0FBV3NhLFlBQVl6YixVQUFVLENBQUM7WUFFbEMsSUFBSW1CLGFBQWEsTUFBTUEsYUFBYSxHQUFHO2dCQUNyQ3FhLG9CQUFvQjtnQkFDcEJ0QyxXQUFXcHJELElBQUksQ0FBQ290RDtnQkFDaEJDLGVBQWVELFlBQVlDLGVBQWVELFlBQVlDO2dCQUN0REQsWUFBWSxDQUFDLElBQUlFO2dCQUNqQnhwRCxNQUFNO2dCQUNOaXBELGNBQWM7Z0JBQ2RJLGVBQWU7WUFDakIsT0FBTztnQkFDTHJwRCxNQUFNNnBEO1lBQ1I7WUFFQSxJQUFJcnpDLFlBQVkzTyxLQUFLLEVBQUU7Z0JBQ3JCeUIsV0FBV2tOLFlBQVkwM0IsV0FBVyxDQUFDMmIsYUFBYXZnQixTQUFTRSxNQUFNLEVBQUVoekIsWUFBWWs0QixhQUFhLENBQUN4bEMsYUFBYTlGLENBQUMsRUFBRXdwQyxPQUFPO2dCQUNsSGtVLFVBQVVtSSxjQUFjLElBQUkzL0MsU0FBUzRoQixDQUFDLEdBQUdoaUIsYUFBYTIrQyxTQUFTLEdBQUc7WUFDcEUsT0FBTztnQkFDTCx3RkFBd0Y7Z0JBQ3hGLDBHQUEwRztnQkFDMUcvRyxVQUFVdHFDLFlBQVk0MkIsV0FBVyxDQUFDcHRDLEtBQUtrSixhQUFhOUYsQ0FBQyxFQUFFOEYsYUFBYTIrQyxTQUFTO1lBQy9FLEVBQUUsRUFBRTtZQUdKLElBQUlnQyxnQkFBZ0IsS0FBSztnQkFDdkJELHFCQUFxQjlJLFVBQVUwSTtZQUNqQyxPQUFPO2dCQUNMRixhQUFheEksVUFBVTBJLGlCQUFpQkk7Z0JBQ3hDQSxvQkFBb0I7WUFDdEI7WUFFQVosUUFBUTlzRCxJQUFJLENBQUM7Z0JBQ1hxNEIsR0FBR3VzQjtnQkFDSGdKLElBQUloSjtnQkFDSmlKLEtBQUtaO2dCQUNMcmhDLEdBQUdtaEM7Z0JBQ0hlLFdBQVcsRUFBRTtnQkFDYmhxRCxLQUFLQTtnQkFDTG9SLE1BQU1pNEM7Z0JBQ05ZLHVCQUF1QjtZQUN6QjtZQUVBLElBQUlmLGtCQUFrQixHQUFHO2dCQUN2Qiw2QkFBNkI7Z0JBQzdCQyxlQUFlckk7Z0JBRWYsSUFBSTlnRCxRQUFRLE1BQU1BLFFBQVEsT0FBT3JGLE1BQU1DLE1BQU0sR0FBRztvQkFDOUMsSUFBSW9GLFFBQVEsTUFBTUEsUUFBUSxLQUFLO3dCQUM3Qm1wRCxlQUFlckk7b0JBQ2pCO29CQUVBLE1BQU9zSSxjQUFjenVELEVBQUc7d0JBQ3RCcXVELE9BQU8sQ0FBQ0ksV0FBVyxDQUFDVSxFQUFFLEdBQUdYO3dCQUN6QkgsT0FBTyxDQUFDSSxXQUFXLENBQUN6aEMsR0FBRyxHQUFHOU07d0JBQzFCbXVDLE9BQU8sQ0FBQ0ksV0FBVyxDQUFDYyxLQUFLLEdBQUdwSjt3QkFDNUJzSSxjQUFjO29CQUNoQjtvQkFFQXZ1QyxTQUFTO29CQUNUc3VDLGNBQWM7Z0JBQ2hCO1lBQ0YsT0FBTyxJQUFJRCxrQkFBa0IsR0FBRztnQkFDOUIsNkJBQTZCO2dCQUM3QkMsZUFBZXJJO2dCQUVmLElBQUk5Z0QsUUFBUSxNQUFNckYsTUFBTUMsTUFBTSxHQUFHO29CQUMvQixJQUFJb0YsUUFBUSxJQUFJO3dCQUNkbXBELGVBQWVySTtvQkFDakI7b0JBRUEsTUFBT3NJLGNBQWN6dUQsRUFBRzt3QkFDdEJxdUQsT0FBTyxDQUFDSSxXQUFXLENBQUNVLEVBQUUsR0FBR1g7d0JBQ3pCSCxPQUFPLENBQUNJLFdBQVcsQ0FBQ3poQyxHQUFHLEdBQUc5TTt3QkFDMUJtdUMsT0FBTyxDQUFDSSxXQUFXLENBQUNjLEtBQUssR0FBR3BKO3dCQUM1QnNJLGNBQWM7b0JBQ2hCO29CQUVBRCxjQUFjO29CQUNkdHVDLFNBQVM7Z0JBQ1g7WUFDRixPQUFPO2dCQUNMbXVDLE9BQU8sQ0FBQ251QyxNQUFNLENBQUM4TSxHQUFHLEdBQUc5TTtnQkFDckJtdUMsT0FBTyxDQUFDbnVDLE1BQU0sQ0FBQ3F2QyxLQUFLLEdBQUc7Z0JBQ3ZCcnZDLFNBQVM7WUFDWDtRQUNGO1FBRUEzUixhQUFhcXJCLENBQUMsR0FBR3kwQjtRQUNqQk8sZUFBZUQsWUFBWUMsZUFBZUQsWUFBWUM7UUFDdERqQyxXQUFXcHJELElBQUksQ0FBQ290RDtRQUVoQixJQUFJcGdELGFBQWFtckIsRUFBRSxFQUFFO1lBQ25CbnJCLGFBQWFnK0MsUUFBUSxHQUFHaCtDLGFBQWFtckIsRUFBRSxDQUFDLEVBQUU7WUFDMUNuckIsYUFBYWsrQyxhQUFhLEdBQUc7UUFDL0IsT0FBTztZQUNMbCtDLGFBQWFnK0MsUUFBUSxHQUFHcUM7WUFFeEIsT0FBUXJnRCxhQUFhdEMsQ0FBQztnQkFDcEIsS0FBSztvQkFDSHNDLGFBQWFrK0MsYUFBYSxHQUFHLENBQUNsK0MsYUFBYWcrQyxRQUFRO29CQUNuRDtnQkFFRixLQUFLO29CQUNIaCtDLGFBQWFrK0MsYUFBYSxHQUFHLENBQUNsK0MsYUFBYWcrQyxRQUFRLEdBQUc7b0JBQ3REO2dCQUVGO29CQUNFaCtDLGFBQWFrK0MsYUFBYSxHQUFHO1lBQ2pDO1FBQ0Y7UUFFQWwrQyxhQUFhbytDLFVBQVUsR0FBR0E7UUFDMUIsSUFBSTZDLFlBQVl6a0QsS0FBS2lFLENBQUM7UUFDdEIsSUFBSXlnRDtRQUNKLElBQUlDO1FBQ0p4akQsT0FBT3NqRCxVQUFVdHZELE1BQU07UUFDdkIsSUFBSXl2RDtRQUNKLElBQUkzaUM7UUFDSixJQUFJNGlDLFVBQVUsRUFBRTtRQUVoQixJQUFLM2pELElBQUksR0FBR0EsSUFBSUMsTUFBTUQsS0FBSyxFQUFHO1lBQzVCd2pELGVBQWVELFNBQVMsQ0FBQ3ZqRCxFQUFFO1lBRTNCLElBQUl3akQsYUFBYXpnRCxDQUFDLENBQUNva0MsRUFBRSxFQUFFO2dCQUNyQjdrQyxhQUFhdytDLGVBQWUsR0FBRztZQUNqQztZQUVBLElBQUkwQyxhQUFhemdELENBQUMsQ0FBQzQ4QyxFQUFFLEVBQUU7Z0JBQ3JCcjlDLGFBQWF5K0MsZUFBZSxHQUFHO1lBQ2pDO1lBRUEsSUFBSXlDLGFBQWF6Z0QsQ0FBQyxDQUFDNjhDLEVBQUUsSUFBSTRELGFBQWF6Z0QsQ0FBQyxDQUFDNmdELEVBQUUsSUFBSUosYUFBYXpnRCxDQUFDLENBQUM4Z0QsRUFBRSxJQUFJTCxhQUFhemdELENBQUMsQ0FBQytnRCxFQUFFLEVBQUU7Z0JBQ3BGeGhELGFBQWF1K0MsYUFBYSxHQUFHO1lBQy9CO1lBRUE5L0IsTUFBTTtZQUNOMmlDLFFBQVFGLGFBQWFybkQsQ0FBQyxDQUFDSSxDQUFDO1lBRXhCLElBQUt4SSxJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztnQkFDM0IwdkQsYUFBYXJCLE9BQU8sQ0FBQ3J1RCxFQUFFO2dCQUN2QjB2RCxXQUFXTCxTQUFTLENBQUNwakQsRUFBRSxHQUFHK2dCO2dCQUUxQixJQUFJMmlDLFNBQVMsS0FBS0QsV0FBV3JxRCxHQUFHLEtBQUssTUFBTXNxRCxTQUFTLEtBQUtELFdBQVdycUQsR0FBRyxLQUFLLE1BQU1xcUQsV0FBV3JxRCxHQUFHLEtBQUssT0FBT3NxRCxTQUFTLEtBQU1ELENBQUFBLFdBQVd2aUMsQ0FBQyxJQUFJdWlDLFdBQVdycUQsR0FBRyxJQUFJLE9BQU9yRixLQUFLQyxNQUFNLE1BQU0wdkQsU0FBUyxLQUFNRCxDQUFBQSxXQUFXdmlDLENBQUMsSUFBSW50QixLQUFLQyxNQUFNLElBQUk7b0JBQ2pPLDZCQUE2QjtvQkFDN0IsSUFBSXd2RCxhQUFhcm5ELENBQUMsQ0FBQzRuRCxFQUFFLEtBQUssR0FBRzt3QkFDM0JKLFFBQVFydUQsSUFBSSxDQUFDeXJCO29CQUNmO29CQUVBQSxPQUFPO2dCQUNUO1lBQ0Y7WUFFQWppQixLQUFLaUUsQ0FBQyxDQUFDL0MsRUFBRSxDQUFDN0QsQ0FBQyxDQUFDNm5ELFVBQVUsR0FBR2pqQztZQUN6QixJQUFJa2pDLGFBQWEsQ0FBQztZQUNsQixJQUFJQztZQUVKLElBQUlWLGFBQWFybkQsQ0FBQyxDQUFDNG5ELEVBQUUsS0FBSyxHQUFHO2dCQUMzQixJQUFLaHdELElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO29CQUMzQjB2RCxhQUFhckIsT0FBTyxDQUFDcnVELEVBQUU7b0JBRXZCLElBQUlrd0QsY0FBY1IsV0FBV0wsU0FBUyxDQUFDcGpELEVBQUUsRUFBRTt3QkFDekMsNkJBQTZCO3dCQUM3QmlrRCxhQUFhUixXQUFXTCxTQUFTLENBQUNwakQsRUFBRTt3QkFDcENra0QsU0FBU1AsUUFBUXg1QyxNQUFNLENBQUM5UixLQUFLSyxLQUFLLENBQUNMLEtBQUthLE1BQU0sS0FBS3lxRCxRQUFRMXZELE1BQU0sR0FBRyxFQUFFLENBQUMsRUFBRTtvQkFDM0U7b0JBRUF3dkQsV0FBV0wsU0FBUyxDQUFDcGpELEVBQUUsR0FBR2trRDtnQkFDNUI7WUFDRjtRQUNGO1FBRUE1aEQsYUFBYTArQyxPQUFPLEdBQUcxK0MsYUFBYTYrQyxlQUFlLElBQUk3K0MsYUFBYTIrQyxTQUFTLEdBQUc7UUFDaEYzK0MsYUFBYXErQyxFQUFFLEdBQUdyK0MsYUFBYXErQyxFQUFFLElBQUk7UUFDckNyK0MsYUFBYSs5QyxNQUFNLEdBQUczZCxTQUFTMmQsTUFBTSxHQUFHLzlDLGFBQWEyK0MsU0FBUyxHQUFHO0lBQ25FO0lBRUFsQixhQUFhNXJELFNBQVMsQ0FBQzZmLGtCQUFrQixHQUFHLFNBQVVtd0MsT0FBTyxFQUFFbHdDLEtBQUs7UUFDbEVBLFFBQVFBLFVBQVV0RixZQUFZLElBQUksQ0FBQ3N4QyxTQUFTLEdBQUdoc0M7UUFDL0MsSUFBSW13QyxRQUFRLElBQUksQ0FBQ2hELFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDdGlELElBQUksQ0FBQ2pDLENBQUMsQ0FBQ3FELENBQUMsQ0FBQytULE1BQU0sQ0FBQzlYLENBQUM7UUFDcERpb0QsUUFBUSxJQUFJLENBQUNoRCxRQUFRLENBQUNnRCxPQUFPRDtRQUM3QixJQUFJLENBQUNybEQsSUFBSSxDQUFDakMsQ0FBQyxDQUFDcUQsQ0FBQyxDQUFDK1QsTUFBTSxDQUFDOVgsQ0FBQyxHQUFHaW9EO1FBQ3pCLElBQUksQ0FBQ0MsV0FBVyxDQUFDcHdDO1FBQ2pCLElBQUksQ0FBQ3N0QyxjQUFjLENBQUM2QztRQUNwQixJQUFJLENBQUN0dkMsSUFBSSxDQUFDNFEsa0JBQWtCLENBQUMsSUFBSTtJQUNuQztJQUVBcTZCLGFBQWE1ckQsU0FBUyxDQUFDa3dELFdBQVcsR0FBRyxTQUFVcHdDLEtBQUs7UUFDbEQsSUFBSW13QyxRQUFRLElBQUksQ0FBQ3RsRCxJQUFJLENBQUNqQyxDQUFDLENBQUNxRCxDQUFDLENBQUMrVCxNQUFNLENBQUM5WCxDQUFDO1FBQ2xDaW9ELE1BQU14Z0QsVUFBVSxHQUFHO1FBQ25CLElBQUksQ0FBQ3E4QyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDNTZCLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNRLFFBQVEsQ0FBQ3UrQjtJQUNoQjtJQUVBckUsYUFBYTVyRCxTQUFTLENBQUNtd0QsYUFBYSxHQUFHLFNBQVVDLFVBQVU7UUFDekQsSUFBSSxDQUFDckUsU0FBUyxHQUFHcUU7UUFDakIsSUFBSSxDQUFDRixXQUFXLENBQUMsSUFBSSxDQUFDcEUsU0FBUztRQUMvQixJQUFJLENBQUNuckMsSUFBSSxDQUFDNFEsa0JBQWtCLENBQUMsSUFBSTtJQUNuQztJQUVBcTZCLGFBQWE1ckQsU0FBUyxDQUFDcXdELGtCQUFrQixHQUFHLFNBQVVDLFVBQVU7UUFDOUQsSUFBSSxDQUFDdEUsZUFBZSxHQUFHOW5ELEtBQUtLLEtBQUssQ0FBQytyRCxlQUFlO1FBQ2pELElBQUksQ0FBQ0osV0FBVyxDQUFDLElBQUksQ0FBQ3BFLFNBQVM7UUFDL0IsSUFBSSxDQUFDbnJDLElBQUksQ0FBQzRRLGtCQUFrQixDQUFDLElBQUk7SUFDbkM7SUFFQSxJQUFJZy9CLG1CQUFtQjtRQUNyQixJQUFJOXJELE1BQU1QLEtBQUtPLEdBQUc7UUFDbEIsSUFBSUUsTUFBTVQsS0FBS1MsR0FBRztRQUNsQixJQUFJSixRQUFRTCxLQUFLSyxLQUFLO1FBRXRCLFNBQVNpc0Qsd0JBQXdCN3ZDLElBQUksRUFBRWhXLElBQUk7WUFDekMsSUFBSSxDQUFDOGxELGtCQUFrQixHQUFHLENBQUM7WUFDM0IsSUFBSSxDQUFDMWtELENBQUMsR0FBRztZQUNULElBQUksQ0FBQ3BCLElBQUksR0FBR0E7WUFDWixJQUFJLENBQUNnVyxJQUFJLEdBQUdBO1lBQ1osSUFBSSxDQUFDelQsSUFBSSxHQUFHeVQsS0FBS3pULElBQUk7WUFDckIsSUFBSSxDQUFDd2pELE1BQU0sR0FBRztZQUNkLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1lBQ2QsSUFBSSxDQUFDcCtCLDRCQUE0QixDQUFDNVI7WUFDbEMsSUFBSSxDQUFDM1ksQ0FBQyxHQUFHK3BCLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUszQyxDQUFDLElBQUk7Z0JBQy9DK0QsR0FBRztZQUNMLEdBQUcsR0FBRyxHQUFHLElBQUk7WUFFYixJQUFJLE9BQU9wQixNQUFNO2dCQUNmLElBQUksQ0FBQ1ksQ0FBQyxHQUFHd21CLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUtZLENBQUMsRUFBRSxHQUFHLEdBQUcsSUFBSTtZQUMzRCxPQUFPO2dCQUNMLElBQUksQ0FBQ0EsQ0FBQyxHQUFHO29CQUNQdEQsR0FBRztnQkFDTDtZQUNGO1lBRUEsSUFBSSxDQUFDd0YsQ0FBQyxHQUFHc2tCLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUs4QyxDQUFDLElBQUk7Z0JBQy9DMUIsR0FBRztZQUNMLEdBQUcsR0FBRyxHQUFHLElBQUk7WUFDYixJQUFJLENBQUM2a0QsRUFBRSxHQUFHNytCLGdCQUFnQkMsT0FBTyxDQUFDclIsTUFBTWhXLEtBQUtpbUQsRUFBRSxJQUFJO2dCQUNqRDdrRCxHQUFHO1lBQ0wsR0FBRyxHQUFHLEdBQUcsSUFBSTtZQUNiLElBQUksQ0FBQzhrRCxFQUFFLEdBQUc5K0IsZ0JBQWdCQyxPQUFPLENBQUNyUixNQUFNaFcsS0FBS2ttRCxFQUFFLElBQUk7Z0JBQ2pEOWtELEdBQUc7WUFDTCxHQUFHLEdBQUcsR0FBRyxJQUFJO1lBQ2IsSUFBSSxDQUFDK2tELEVBQUUsR0FBRy8rQixnQkFBZ0JDLE9BQU8sQ0FBQ3JSLE1BQU1oVyxLQUFLbW1ELEVBQUUsSUFBSTtnQkFDakQva0QsR0FBRztZQUNMLEdBQUcsR0FBRyxHQUFHLElBQUk7WUFDYixJQUFJLENBQUM2QyxDQUFDLEdBQUdtakIsZ0JBQWdCQyxPQUFPLENBQUNyUixNQUFNaFcsS0FBS2lFLENBQUMsRUFBRSxHQUFHLE1BQU0sSUFBSTtZQUU1RCxJQUFJLENBQUMsSUFBSSxDQUFDd2pCLGlCQUFpQixDQUFDdHlCLE1BQU0sRUFBRTtnQkFDbEMsSUFBSSxDQUFDNHhCLFFBQVE7WUFDZjtRQUNGO1FBRUE4K0Isd0JBQXdCeHdELFNBQVMsR0FBRztZQUNsQyt3RCxTQUFTLFNBQVNBLFFBQVFua0MsR0FBRztnQkFDM0IsSUFBSSxJQUFJLENBQUM2akMsa0JBQWtCLEtBQUssSUFBSSxDQUFDOXZDLElBQUksQ0FBQ3F3QyxZQUFZLENBQUMvRSxXQUFXLENBQUN6eUIsQ0FBQyxDQUFDMTVCLE1BQU0sRUFBRTtvQkFDM0UsSUFBSSxDQUFDNHhCLFFBQVE7Z0JBQ2Y7Z0JBRUEsSUFBSWhMLEtBQUs7Z0JBQ1QsSUFBSUMsS0FBSztnQkFDVCxJQUFJQyxLQUFLO2dCQUNULElBQUlDLEtBQUs7Z0JBRVQsSUFBSSxJQUFJLENBQUNncUMsRUFBRSxDQUFDNW9ELENBQUMsR0FBRyxHQUFHO29CQUNqQnllLEtBQUssSUFBSSxDQUFDbXFDLEVBQUUsQ0FBQzVvRCxDQUFDLEdBQUc7Z0JBQ25CLE9BQU87b0JBQ0wwZSxLQUFLLENBQUMsSUFBSSxDQUFDa3FDLEVBQUUsQ0FBQzVvRCxDQUFDLEdBQUc7Z0JBQ3BCO2dCQUVBLElBQUksSUFBSSxDQUFDMm9ELEVBQUUsQ0FBQzNvRCxDQUFDLEdBQUcsR0FBRztvQkFDakIyZSxLQUFLLE1BQU0sSUFBSSxDQUFDZ3FDLEVBQUUsQ0FBQzNvRCxDQUFDLEdBQUc7Z0JBQ3pCLE9BQU87b0JBQ0w0ZSxLQUFLLE1BQU0sSUFBSSxDQUFDK3BDLEVBQUUsQ0FBQzNvRCxDQUFDLEdBQUc7Z0JBQ3pCO2dCQUVBLElBQUlncEQsUUFBUS91QyxjQUFjQyxlQUFlLENBQUN1RSxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJdEMsR0FBRztnQkFDN0QsSUFBSXFNLE9BQU87Z0JBQ1gsSUFBSTVvQixJQUFJLElBQUksQ0FBQzBvRCxNQUFNO2dCQUNuQixJQUFJbmxELElBQUksSUFBSSxDQUFDb2xELE1BQU07Z0JBQ25CLElBQUlyeEQsT0FBTyxJQUFJLENBQUNxTCxJQUFJLENBQUNnakIsRUFBRTtnQkFFdkIsSUFBSXJ1QixTQUFTLEdBQUc7b0JBQ2QsSUFBSWlNLE1BQU12RCxHQUFHO3dCQUNYNG9CLE9BQU9oRSxPQUFPcmhCLElBQUksSUFBSTtvQkFDeEIsT0FBTzt3QkFDTHFsQixPQUFPbnNCLElBQUksR0FBR0UsSUFBSSxNQUFPNEcsQ0FBQUEsSUFBSXZELENBQUFBLElBQUssQ0FBQzRrQixNQUFNNWtCLENBQUFBLElBQU11RCxDQUFBQSxJQUFJdkQsQ0FBQUEsR0FBSTtvQkFDekQ7b0JBRUE0b0IsT0FBT3FnQyxNQUFNcmdDO2dCQUNmLE9BQU8sSUFBSXR4QixTQUFTLEdBQUc7b0JBQ3JCLElBQUlpTSxNQUFNdkQsR0FBRzt3QkFDWDRvQixPQUFPaEUsT0FBT3JoQixJQUFJLElBQUk7b0JBQ3hCLE9BQU87d0JBQ0xxbEIsT0FBTyxJQUFJbnNCLElBQUksR0FBR0UsSUFBSSxNQUFPNEcsQ0FBQUEsSUFBSXZELENBQUFBLElBQUssQ0FBQzRrQixNQUFNNWtCLENBQUFBLElBQU11RCxDQUFBQSxJQUFJdkQsQ0FBQUEsR0FBSTtvQkFDN0Q7b0JBRUE0b0IsT0FBT3FnQyxNQUFNcmdDO2dCQUNmLE9BQU8sSUFBSXR4QixTQUFTLEdBQUc7b0JBQ3JCLElBQUlpTSxNQUFNdkQsR0FBRzt3QkFDWDRvQixPQUFPO29CQUNULE9BQU87d0JBQ0xBLE9BQU9uc0IsSUFBSSxHQUFHRSxJQUFJLE1BQU80RyxDQUFBQSxJQUFJdkQsQ0FBQUEsSUFBSyxDQUFDNGtCLE1BQU01a0IsQ0FBQUEsSUFBTXVELENBQUFBLElBQUl2RCxDQUFBQSxHQUFJO3dCQUV2RCxJQUFJNG9CLE9BQU8sS0FBSzs0QkFDZEEsUUFBUTt3QkFDVixPQUFPOzRCQUNMQSxPQUFPLElBQUksSUFBS0EsQ0FBQUEsT0FBTyxHQUFFO3dCQUMzQjtvQkFDRjtvQkFFQUEsT0FBT3FnQyxNQUFNcmdDO2dCQUNmLE9BQU8sSUFBSXR4QixTQUFTLEdBQUc7b0JBQ3JCLElBQUlpTSxNQUFNdkQsR0FBRzt3QkFDWDRvQixPQUFPO29CQUNULE9BQU87d0JBQ0wsSUFBSXNnQyxNQUFNM2xELElBQUl2RDt3QkFDZDtpRUFDcUQsR0FFckQ0a0IsTUFBTWpvQixJQUFJRixJQUFJLEdBQUdtb0IsTUFBTSxNQUFNNWtCLElBQUl1RCxJQUFJdkQ7d0JBQ3JDLElBQUl3YyxJQUFJLENBQUMwc0MsTUFBTSxJQUFJdGtDO3dCQUNuQixJQUFJaGUsSUFBSXNpRCxNQUFNO3dCQUNkdGdDLE9BQU8xc0IsS0FBS0csSUFBSSxDQUFDLElBQUltZ0IsSUFBSUEsSUFBSzVWLENBQUFBLElBQUlBLENBQUFBO29CQUNwQztvQkFFQWdpQixPQUFPcWdDLE1BQU1yZ0M7Z0JBQ2YsT0FBTyxJQUFJdHhCLFNBQVMsR0FBRztvQkFDckIsSUFBSWlNLE1BQU12RCxHQUFHO3dCQUNYNG9CLE9BQU87b0JBQ1QsT0FBTzt3QkFDTGhFLE1BQU1qb0IsSUFBSUYsSUFBSSxHQUFHbW9CLE1BQU0sTUFBTTVrQixJQUFJdUQsSUFBSXZEO3dCQUNyQzRvQixPQUFPLENBQUMsSUFBSTFzQixLQUFLMnJCLEdBQUcsQ0FBQzNyQixLQUFLb0IsRUFBRSxHQUFHcEIsS0FBS29CLEVBQUUsR0FBRyxJQUFJc25CLE1BQU9yaEIsQ0FBQUEsSUFBSXZELENBQUFBLEVBQUUsSUFBSyxHQUFHLHNCQUFzQjtvQkFDMUY7b0JBRUE0b0IsT0FBT3FnQyxNQUFNcmdDO2dCQUNmLE9BQU87b0JBQ0wsSUFBSWhFLE9BQU9yb0IsTUFBTXlELElBQUk7d0JBQ25CLElBQUk0a0IsTUFBTTVrQixJQUFJLEdBQUc7NEJBQ2Y0b0IsT0FBT25zQixJQUFJLEdBQUdFLElBQUlBLElBQUk0RyxHQUFHLEtBQU12RCxDQUFBQSxJQUFJNGtCLEdBQUUsR0FBSTt3QkFDM0MsT0FBTzs0QkFDTGdFLE9BQU9uc0IsSUFBSSxHQUFHRSxJQUFJNEcsSUFBSXFoQixLQUFLO3dCQUM3QjtvQkFDRjtvQkFFQWdFLE9BQU9xZ0MsTUFBTXJnQztnQkFDZixFQUFFLDZCQUE2QjtnQkFDL0IsMEVBQTBFO2dCQUMxRSw2REFBNkQ7Z0JBQzdELGFBQWE7Z0JBQ2Isc0RBQXNEO2dCQUN0RCw0REFBNEQ7Z0JBQzVELHFCQUFxQjtnQkFDckIsK0JBQStCO2dCQUMvQiwyRUFBMkU7Z0JBQzNFLHFGQUFxRjtnQkFHckYsSUFBSSxJQUFJLENBQUNrZ0MsRUFBRSxDQUFDN29ELENBQUMsS0FBSyxLQUFLO29CQUNyQixJQUFJa3BELGFBQWEsSUFBSSxDQUFDTCxFQUFFLENBQUM3b0QsQ0FBQyxHQUFHO29CQUU3QixJQUFJa3BELGVBQWUsR0FBRzt3QkFDcEJBLGFBQWE7b0JBQ2Y7b0JBRUEsSUFBSUMsWUFBWSxNQUFNRCxhQUFhO29CQUVuQyxJQUFJdmdDLE9BQU93Z0MsV0FBVzt3QkFDcEJ4Z0MsT0FBTztvQkFDVCxPQUFPO3dCQUNMQSxPQUFPLENBQUNBLE9BQU93Z0MsU0FBUSxJQUFLRDt3QkFFNUIsSUFBSXZnQyxPQUFPLEdBQUc7NEJBQ1pBLE9BQU87d0JBQ1Q7b0JBQ0Y7Z0JBQ0Y7Z0JBRUEsT0FBT0EsT0FBTyxJQUFJLENBQUNoaUIsQ0FBQyxDQUFDM0csQ0FBQztZQUN4QjtZQUNBeXBCLFVBQVUsU0FBU0EsU0FBUzIvQixZQUFZO2dCQUN0QyxJQUFJLENBQUMvK0Isd0JBQXdCO2dCQUM3QixJQUFJLENBQUN6QixJQUFJLEdBQUd3Z0MsZ0JBQWdCLElBQUksQ0FBQ3hnQyxJQUFJO2dCQUNyQyxJQUFJLENBQUM0L0Isa0JBQWtCLEdBQUcsSUFBSSxDQUFDOXZDLElBQUksQ0FBQ3F3QyxZQUFZLENBQUMvRSxXQUFXLENBQUN6eUIsQ0FBQyxDQUFDMTVCLE1BQU0sSUFBSTtnQkFFekUsSUFBSXV4RCxnQkFBZ0IsSUFBSSxDQUFDMW1ELElBQUksQ0FBQ3pDLENBQUMsS0FBSyxHQUFHO29CQUNyQyxJQUFJLENBQUNxRCxDQUFDLENBQUN0RCxDQUFDLEdBQUcsSUFBSSxDQUFDd29ELGtCQUFrQjtnQkFDcEM7Z0JBRUEsSUFBSWEsVUFBVSxJQUFJLENBQUMzbUQsSUFBSSxDQUFDekMsQ0FBQyxLQUFLLElBQUksSUFBSSxNQUFNLElBQUksQ0FBQ3lDLElBQUksQ0FBQ2tsRCxVQUFVO2dCQUNoRSxJQUFJcGlELElBQUksSUFBSSxDQUFDQSxDQUFDLENBQUN4RixDQUFDLEdBQUdxcEQ7Z0JBQ25CLElBQUl0cEQsSUFBSSxJQUFJLENBQUNBLENBQUMsQ0FBQ0MsQ0FBQyxHQUFHcXBELFVBQVU3akQ7Z0JBQzdCLElBQUlsQyxJQUFJLElBQUksQ0FBQ0EsQ0FBQyxDQUFDdEQsQ0FBQyxHQUFHcXBELFVBQVU3akQ7Z0JBRTdCLElBQUl6RixJQUFJdUQsR0FBRztvQkFDVCxJQUFJeTFCLEtBQUtoNUI7b0JBQ1RBLElBQUl1RDtvQkFDSkEsSUFBSXkxQjtnQkFDTjtnQkFFQSxJQUFJLENBQUMwdkIsTUFBTSxHQUFHMW9EO2dCQUNkLElBQUksQ0FBQzJvRCxNQUFNLEdBQUdwbEQ7WUFDaEI7UUFDRjtRQUNBOUwsZ0JBQWdCO1lBQUMweUI7U0FBeUIsRUFBRXErQjtRQUU1QyxTQUFTZSxvQkFBb0I1d0MsSUFBSSxFQUFFaFcsSUFBSSxFQUFFaEksR0FBRztZQUMxQyxPQUFPLElBQUk2dEQsd0JBQXdCN3ZDLE1BQU1oVyxNQUFNaEk7UUFDakQ7UUFFQSxPQUFPO1lBQ0w0dUQscUJBQXFCQTtRQUN2QjtJQUNGO0lBRUEsU0FBU0MseUJBQXlCN3dDLElBQUksRUFBRTh3QyxhQUFhLEVBQUV4M0MsU0FBUztRQUM5RCxJQUFJeTNDLGNBQWM7WUFDaEI3bEMsVUFBVTtRQUNaO1FBQ0EsSUFBSW1HLFVBQVVELGdCQUFnQkMsT0FBTztRQUNyQyxJQUFJMi9CLDBCQUEwQkYsY0FBYzdpRCxDQUFDO1FBQzdDLElBQUksQ0FBQ0EsQ0FBQyxHQUFHO1lBQ1AxRyxHQUFHeXBELHdCQUF3QnpwRCxDQUFDLEdBQUc4cEIsUUFBUXJSLE1BQU1neEMsd0JBQXdCenBELENBQUMsRUFBRSxHQUFHN0MsV0FBVzRVLGFBQWF5M0M7WUFDbkc3dUIsSUFBSTh1Qix3QkFBd0I5dUIsRUFBRSxHQUFHN1EsUUFBUXJSLE1BQU1neEMsd0JBQXdCOXVCLEVBQUUsRUFBRSxHQUFHeDlCLFdBQVc0VSxhQUFheTNDO1lBQ3RHOXVCLElBQUkrdUIsd0JBQXdCL3VCLEVBQUUsR0FBRzVRLFFBQVFyUixNQUFNZ3hDLHdCQUF3Qi91QixFQUFFLEVBQUUsR0FBR3Y5QixXQUFXNFUsYUFBYXkzQztZQUN0RzdpRCxJQUFJOGlELHdCQUF3QjlpRCxFQUFFLEdBQUdtakIsUUFBUXJSLE1BQU1neEMsd0JBQXdCOWlELEVBQUUsRUFBRSxHQUFHeEosV0FBVzRVLGFBQWF5M0M7WUFDdEc1aUQsSUFBSTZpRCx3QkFBd0I3aUQsRUFBRSxHQUFHa2pCLFFBQVFyUixNQUFNZ3hDLHdCQUF3QjdpRCxFQUFFLEVBQUUsR0FBR3pKLFdBQVc0VSxhQUFheTNDO1lBQ3RHMXBELEdBQUcycEQsd0JBQXdCM3BELENBQUMsR0FBR2dxQixRQUFRclIsTUFBTWd4Qyx3QkFBd0IzcEQsQ0FBQyxFQUFFLEdBQUcsTUFBTWlTLGFBQWF5M0M7WUFDOUY5aUQsR0FBRytpRCx3QkFBd0IvaUQsQ0FBQyxHQUFHb2pCLFFBQVFyUixNQUFNZ3hDLHdCQUF3Qi9pRCxDQUFDLEVBQUUsR0FBRyxHQUFHcUwsYUFBYXkzQztZQUMzRmprRCxHQUFHa2tELHdCQUF3QmxrRCxDQUFDLEdBQUd1a0IsUUFBUXJSLE1BQU1neEMsd0JBQXdCbGtELENBQUMsRUFBRSxHQUFHLE1BQU13TSxhQUFheTNDO1lBQzlGcHBELEdBQUdxcEQsd0JBQXdCcnBELENBQUMsR0FBRzBwQixRQUFRclIsTUFBTWd4Qyx3QkFBd0JycEQsQ0FBQyxFQUFFLEdBQUcsR0FBRzJSLGFBQWF5M0M7WUFDM0ZsRyxJQUFJbUcsd0JBQXdCbkcsRUFBRSxHQUFHeDVCLFFBQVFyUixNQUFNZ3hDLHdCQUF3Qm5HLEVBQUUsRUFBRSxHQUFHLEdBQUd2eEMsYUFBYXkzQztZQUM5RjFlLElBQUkyZSx3QkFBd0IzZSxFQUFFLEdBQUdoaEIsUUFBUXJSLE1BQU1neEMsd0JBQXdCM2UsRUFBRSxFQUFFLEdBQUcsR0FBRy80QixhQUFheTNDO1lBQzlGakcsSUFBSWtHLHdCQUF3QmxHLEVBQUUsR0FBR3o1QixRQUFRclIsTUFBTWd4Qyx3QkFBd0JsRyxFQUFFLEVBQUUsR0FBRyxHQUFHeHhDLGFBQWF5M0M7WUFDOUZqQyxJQUFJa0Msd0JBQXdCbEMsRUFBRSxHQUFHejlCLFFBQVFyUixNQUFNZ3hDLHdCQUF3QmxDLEVBQUUsRUFBRSxHQUFHLEdBQUd4MUMsYUFBYXkzQztZQUM5RmhDLElBQUlpQyx3QkFBd0JqQyxFQUFFLEdBQUcxOUIsUUFBUXJSLE1BQU1neEMsd0JBQXdCakMsRUFBRSxFQUFFLEdBQUcsTUFBTXoxQyxhQUFheTNDO1lBQ2pHL0IsSUFBSWdDLHdCQUF3QmhDLEVBQUUsR0FBRzM5QixRQUFRclIsTUFBTWd4Qyx3QkFBd0JoQyxFQUFFLEVBQUUsR0FBRyxNQUFNMTFDLGFBQWF5M0M7WUFDakdscEQsR0FBR21wRCx3QkFBd0JucEQsQ0FBQyxHQUFHd3BCLFFBQVFyUixNQUFNZ3hDLHdCQUF3Qm5wRCxDQUFDLEVBQUUsR0FBRyxHQUFHeVIsYUFBYXkzQztRQUM3RjtRQUNBLElBQUksQ0FBQzFwRCxDQUFDLEdBQUd1b0QsaUJBQWlCZ0IsbUJBQW1CLENBQUM1d0MsTUFBTTh3QyxjQUFjenBELENBQUMsRUFBRWlTO1FBQ3JFLElBQUksQ0FBQ2pTLENBQUMsQ0FBQ1EsQ0FBQyxHQUFHaXBELGNBQWN6cEQsQ0FBQyxDQUFDUSxDQUFDO0lBQzlCO0lBRUEsU0FBU29wRCxxQkFBcUJqYixRQUFRLEVBQUVrYixVQUFVLEVBQUVseEMsSUFBSTtRQUN0RCxJQUFJLENBQUN1USxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDNGdDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNqRyxRQUFRLEdBQUcsQ0FBQztRQUNqQixJQUFJLENBQUNrRyxTQUFTLEdBQUdwYjtRQUNqQixJQUFJLENBQUNxYixXQUFXLEdBQUdIO1FBQ25CLElBQUksQ0FBQ0ksS0FBSyxHQUFHdHhDO1FBQ2IsSUFBSSxDQUFDdXhDLGNBQWMsR0FBR2x2RCxpQkFBaUIsSUFBSSxDQUFDK3VELFNBQVMsQ0FBQ25qRCxDQUFDLENBQUM5TyxNQUFNO1FBQzlELElBQUksQ0FBQ3F5RCxTQUFTLEdBQUcsQ0FBQztRQUNsQixJQUFJLENBQUNDLFlBQVksR0FBRztZQUNsQkMsV0FBVyxDQUFDO1FBQ2Q7UUFDQSxJQUFJLENBQUNDLGVBQWUsR0FBRyxFQUFFO1FBQ3pCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDaGdDLDRCQUE0QixDQUFDNVI7SUFDcEM7SUFFQWl4QyxxQkFBcUI1eEQsU0FBUyxDQUFDd3lELGdCQUFnQixHQUFHO1FBQ2hELElBQUk1eUQ7UUFDSixJQUFJQyxNQUFNLElBQUksQ0FBQ2t5RCxTQUFTLENBQUNuakQsQ0FBQyxDQUFDOU8sTUFBTTtRQUNqQyxJQUFJMnhEO1FBQ0osSUFBSXovQixVQUFVRCxnQkFBZ0JDLE9BQU87UUFFckMsSUFBS3B5QixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQjZ4RCxnQkFBZ0IsSUFBSSxDQUFDTSxTQUFTLENBQUNuakQsQ0FBQyxDQUFDaFAsRUFBRTtZQUNuQyxJQUFJLENBQUNzeUQsY0FBYyxDQUFDdHlELEVBQUUsR0FBRyxJQUFJNHhELHlCQUF5QixJQUFJLENBQUNTLEtBQUssRUFBRVIsZUFBZSxJQUFJO1FBQ3ZGO1FBRUEsSUFBSSxJQUFJLENBQUNNLFNBQVMsQ0FBQ3pwRCxDQUFDLElBQUksT0FBTyxJQUFJLENBQUN5cEQsU0FBUyxDQUFDenBELENBQUMsRUFBRTtZQUMvQyxJQUFJLENBQUM2cEQsU0FBUyxHQUFHO2dCQUNmdmpELEdBQUdvakIsUUFBUSxJQUFJLENBQUNpZ0MsS0FBSyxFQUFFLElBQUksQ0FBQ0YsU0FBUyxDQUFDenBELENBQUMsQ0FBQ3NHLENBQUMsRUFBRSxHQUFHLEdBQUcsSUFBSTtnQkFDckR2RyxHQUFHMnBCLFFBQVEsSUFBSSxDQUFDaWdDLEtBQUssRUFBRSxJQUFJLENBQUNGLFNBQVMsQ0FBQ3pwRCxDQUFDLENBQUNELENBQUMsRUFBRSxHQUFHLEdBQUcsSUFBSTtnQkFDckRteEIsR0FBR3hILFFBQVEsSUFBSSxDQUFDaWdDLEtBQUssRUFBRSxJQUFJLENBQUNGLFNBQVMsQ0FBQ3pwRCxDQUFDLENBQUNreEIsQ0FBQyxFQUFFLEdBQUcsR0FBRyxJQUFJO2dCQUNyRHR4QixHQUFHOHBCLFFBQVEsSUFBSSxDQUFDaWdDLEtBQUssRUFBRSxJQUFJLENBQUNGLFNBQVMsQ0FBQ3pwRCxDQUFDLENBQUNKLENBQUMsRUFBRSxHQUFHLEdBQUcsSUFBSTtnQkFDckRJLEdBQUcwcEIsUUFBUSxJQUFJLENBQUNpZ0MsS0FBSyxFQUFFLElBQUksQ0FBQ0YsU0FBUyxDQUFDenBELENBQUMsQ0FBQ0EsQ0FBQyxFQUFFLEdBQUcsR0FBRyxJQUFJO2dCQUNyRG14QixHQUFHLElBQUksQ0FBQ3c0QixLQUFLLENBQUMzWixXQUFXLENBQUNxSCxlQUFlLENBQUMsSUFBSSxDQUFDb1MsU0FBUyxDQUFDenBELENBQUMsQ0FBQ214QixDQUFDO1lBQzlEO1lBQ0EsSUFBSSxDQUFDcTRCLGNBQWMsR0FBRztRQUN4QixPQUFPO1lBQ0wsSUFBSSxDQUFDQSxjQUFjLEdBQUc7UUFDeEI7UUFFQSxJQUFJLENBQUNNLFlBQVksQ0FBQ0MsU0FBUyxHQUFHcmdDLFFBQVEsSUFBSSxDQUFDaWdDLEtBQUssRUFBRSxJQUFJLENBQUNGLFNBQVMsQ0FBQ3Q0QixDQUFDLENBQUM3cUIsQ0FBQyxFQUFFLEdBQUcsR0FBRyxJQUFJO0lBQ2xGO0lBRUFnakQscUJBQXFCNXhELFNBQVMsQ0FBQ3l5RCxXQUFXLEdBQUcsU0FBVXRrRCxZQUFZLEVBQUVva0Qsa0JBQWtCO1FBQ3JGLElBQUksQ0FBQ0Esa0JBQWtCLEdBQUdBO1FBRTFCLElBQUksQ0FBQyxJQUFJLENBQUMxaEMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDSyxhQUFhLElBQUksQ0FBQ3FoQyxzQkFBdUIsRUFBQyxJQUFJLENBQUNULGNBQWMsSUFBSSxDQUFDLElBQUksQ0FBQ0ssU0FBUyxDQUFDMTRCLENBQUMsQ0FBQzVJLElBQUksR0FBRztZQUNoSDtRQUNGO1FBRUEsSUFBSSxDQUFDSyxhQUFhLEdBQUc7UUFDckIsSUFBSW1oQyxZQUFZLElBQUksQ0FBQ0QsWUFBWSxDQUFDQyxTQUFTLENBQUNwcUQsQ0FBQztRQUM3QyxJQUFJbW5ELFlBQVksSUFBSSxDQUFDOEMsY0FBYztRQUNuQyxJQUFJdmIsV0FBVyxJQUFJLENBQUNvYixTQUFTO1FBQzdCLElBQUlXLGVBQWUsSUFBSSxDQUFDdFUsT0FBTztRQUMvQixJQUFJeVQsYUFBYSxJQUFJLENBQUNHLFdBQVc7UUFDakMsSUFBSVcsdUJBQXVCLElBQUksQ0FBQ0wsZUFBZSxDQUFDeHlELE1BQU07UUFDdEQsSUFBSTh5RDtRQUNKLElBQUlDO1FBQ0osSUFBSWp6RDtRQUNKLElBQUlDO1FBQ0osSUFBSW91RCxVQUFVOS9DLGFBQWFxckIsQ0FBQztRQUM1QixJQUFJczVCO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlwcUM7UUFDSixJQUFJNXBCO1FBQ0osSUFBSWkwRDtRQUNKLElBQUlDO1FBQ0osSUFBSXJuQjtRQUNKLElBQUkxbkI7UUFDSixJQUFJL0s7UUFDSixJQUFJMlA7UUFDSixJQUFJekM7UUFDSixJQUFJMEI7UUFDSixJQUFJbXJDO1FBQ0osSUFBSTdUO1FBRUosSUFBSSxJQUFJLENBQUN3UyxjQUFjLEVBQUU7WUFDdkJ4UyxPQUFPLElBQUksQ0FBQzZTLFNBQVMsQ0FBQzE0QixDQUFDO1lBRXZCLElBQUksQ0FBQyxJQUFJLENBQUMwNEIsU0FBUyxDQUFDcGxDLENBQUMsSUFBSSxJQUFJLENBQUNvbEMsU0FBUyxDQUFDdGhDLElBQUksRUFBRTtnQkFDNUMsSUFBSW1FLFFBQVFzcUIsS0FBS3IzQyxDQUFDO2dCQUVsQixJQUFJLElBQUksQ0FBQ2txRCxTQUFTLENBQUNqcUQsQ0FBQyxDQUFDRCxDQUFDLEVBQUU7b0JBQ3RCK3NCLFFBQVFBLE1BQU0xQixPQUFPO2dCQUN2QixFQUFFLDZFQUE2RTtnQkFHL0V3L0IsV0FBVztvQkFDVE0sU0FBUztvQkFDVGg2QyxVQUFVLEVBQUU7Z0JBQ2Q7Z0JBQ0F2WixNQUFNbTFCLE1BQU1yUCxPQUFPLEdBQUc7Z0JBQ3RCLElBQUl3RDtnQkFDSjdDLGNBQWM7Z0JBRWQsSUFBSzFtQixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztvQkFDM0J1cEIsYUFBYWtDLElBQUlyQyxlQUFlLENBQUNnTSxNQUFNL3NCLENBQUMsQ0FBQ3JJLEVBQUUsRUFBRW8xQixNQUFNL3NCLENBQUMsQ0FBQ3JJLElBQUksRUFBRSxFQUFFO3dCQUFDbzFCLE1BQU12bkIsQ0FBQyxDQUFDN04sRUFBRSxDQUFDLEVBQUUsR0FBR28xQixNQUFNL3NCLENBQUMsQ0FBQ3JJLEVBQUUsQ0FBQyxFQUFFO3dCQUFFbzFCLE1BQU12bkIsQ0FBQyxDQUFDN04sRUFBRSxDQUFDLEVBQUUsR0FBR28xQixNQUFNL3NCLENBQUMsQ0FBQ3JJLEVBQUUsQ0FBQyxFQUFFO3FCQUFDLEVBQUU7d0JBQUNvMUIsTUFBTXAxQixDQUFDLENBQUNBLElBQUksRUFBRSxDQUFDLEVBQUUsR0FBR28xQixNQUFNL3NCLENBQUMsQ0FBQ3JJLElBQUksRUFBRSxDQUFDLEVBQUU7d0JBQUVvMUIsTUFBTXAxQixDQUFDLENBQUNBLElBQUksRUFBRSxDQUFDLEVBQUUsR0FBR28xQixNQUFNL3NCLENBQUMsQ0FBQ3JJLElBQUksRUFBRSxDQUFDLEVBQUU7cUJBQUM7b0JBQzNNa3pELFNBQVNNLE9BQU8sSUFBSWpxQyxXQUFXUCxhQUFhO29CQUM1Q2txQyxTQUFTMTVDLFFBQVEsQ0FBQ2pZLElBQUksQ0FBQ2dvQjtvQkFDdkI3QyxlQUFlNkMsV0FBV1AsYUFBYTtnQkFDekM7Z0JBRUFocEIsSUFBSUM7Z0JBRUosSUFBSXkvQyxLQUFLcjNDLENBQUMsQ0FBQ2tILENBQUMsRUFBRTtvQkFDWmdhLGFBQWFrQyxJQUFJckMsZUFBZSxDQUFDZ00sTUFBTS9zQixDQUFDLENBQUNySSxFQUFFLEVBQUVvMUIsTUFBTS9zQixDQUFDLENBQUMsRUFBRSxFQUFFO3dCQUFDK3NCLE1BQU12bkIsQ0FBQyxDQUFDN04sRUFBRSxDQUFDLEVBQUUsR0FBR28xQixNQUFNL3NCLENBQUMsQ0FBQ3JJLEVBQUUsQ0FBQyxFQUFFO3dCQUFFbzFCLE1BQU12bkIsQ0FBQyxDQUFDN04sRUFBRSxDQUFDLEVBQUUsR0FBR28xQixNQUFNL3NCLENBQUMsQ0FBQ3JJLEVBQUUsQ0FBQyxFQUFFO3FCQUFDLEVBQUU7d0JBQUNvMUIsTUFBTXAxQixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBR28xQixNQUFNL3NCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRTt3QkFBRStzQixNQUFNcDFCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHbzFCLE1BQU0vc0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO3FCQUFDO29CQUN2TDZxRCxTQUFTTSxPQUFPLElBQUlqcUMsV0FBV1AsYUFBYTtvQkFDNUNrcUMsU0FBUzE1QyxRQUFRLENBQUNqWSxJQUFJLENBQUNnb0I7b0JBQ3ZCN0MsZUFBZTZDLFdBQVdQLGFBQWE7Z0JBQ3pDO2dCQUVBLElBQUksQ0FBQ3VwQyxTQUFTLENBQUNrQixFQUFFLEdBQUdQO1lBQ3RCO1lBRUFBLFdBQVcsSUFBSSxDQUFDWCxTQUFTLENBQUNrQixFQUFFO1lBQzVCTixnQkFBZ0IsSUFBSSxDQUFDWixTQUFTLENBQUM5cEQsQ0FBQyxDQUFDSixDQUFDO1lBQ2xDaXJELGFBQWE7WUFDYkQsV0FBVztZQUNYcnFDLGdCQUFnQjtZQUNoQjVwQixPQUFPO1lBQ1BvYSxXQUFXMDVDLFNBQVMxNUMsUUFBUTtZQUU1QixJQUFJMjVDLGdCQUFnQixLQUFLelQsS0FBS3IzQyxDQUFDLENBQUNrSCxDQUFDLEVBQUU7Z0JBQ2pDLElBQUkyakQsU0FBU00sT0FBTyxHQUFHbHZELEtBQUtjLEdBQUcsQ0FBQyt0RCxnQkFBZ0I7b0JBQzlDQSxnQkFBZ0IsQ0FBQzd1RCxLQUFLYyxHQUFHLENBQUMrdEQsaUJBQWlCRCxTQUFTTSxPQUFPO2dCQUM3RDtnQkFFQUYsYUFBYTk1QyxTQUFTdFosTUFBTSxHQUFHO2dCQUMvQnFrQixTQUFTL0ssUUFBUSxDQUFDODVDLFdBQVcsQ0FBQy91QyxNQUFNO2dCQUNwQzh1QyxXQUFXOXVDLE9BQU9ya0IsTUFBTSxHQUFHO2dCQUUzQixNQUFPaXpELGdCQUFnQixFQUFHO29CQUN4QkEsaUJBQWlCNXVDLE1BQU0sQ0FBQzh1QyxTQUFTLENBQUNscUMsYUFBYTtvQkFDL0NrcUMsWUFBWTtvQkFFWixJQUFJQSxXQUFXLEdBQUc7d0JBQ2hCQyxjQUFjO3dCQUNkL3VDLFNBQVMvSyxRQUFRLENBQUM4NUMsV0FBVyxDQUFDL3VDLE1BQU07d0JBQ3BDOHVDLFdBQVc5dUMsT0FBT3JrQixNQUFNLEdBQUc7b0JBQzdCO2dCQUNGO1lBQ0Y7WUFFQXFrQixTQUFTL0ssUUFBUSxDQUFDODVDLFdBQVcsQ0FBQy91QyxNQUFNO1lBQ3BDMG5CLFlBQVkxbkIsTUFBTSxDQUFDOHVDLFdBQVcsRUFBRTtZQUNoQ0QsZUFBZTd1QyxNQUFNLENBQUM4dUMsU0FBUztZQUMvQmxxQyxnQkFBZ0JpcUMsYUFBYWpxQyxhQUFhO1FBQzVDO1FBRUFscEIsTUFBTW91RCxRQUFRbnVELE1BQU07UUFDcEI4eUQsT0FBTztRQUNQQyxPQUFPO1FBQ1AsSUFBSVMsT0FBT25sRCxhQUFhMitDLFNBQVMsR0FBRyxNQUFNO1FBQzFDLElBQUl5RyxZQUFZO1FBQ2hCLElBQUk5QjtRQUNKLElBQUkrQjtRQUNKLElBQUkzbkQ7UUFDSixJQUFJQztRQUNKLElBQUkybkQ7UUFDSjNuRCxPQUFPc2pELFVBQVV0dkQsTUFBTTtRQUN2QixJQUFJOHdCO1FBQ0osSUFBSWhFLE1BQU0sQ0FBQztRQUNYLElBQUk4bUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUMsY0FBY2Q7UUFDbEIsSUFBSWUsaUJBQWlCWjtRQUNyQixJQUFJYSxlQUFlZDtRQUNuQixJQUFJM0UsY0FBYyxDQUFDO1FBQ25CLElBQUkwRjtRQUNKLElBQUloaEI7UUFDSixJQUFJd1k7UUFDSixJQUFJQztRQUNKLElBQUkxL0M7UUFDSixJQUFJa29EO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDLFVBQVU7UUFDZCxJQUFJQyxVQUFVLElBQUksQ0FBQ0MsaUJBQWlCO1FBQ3BDLElBQUlDLFNBQVMsRUFBRTtRQUVmLElBQUlwbUQsYUFBYXRDLENBQUMsS0FBSyxLQUFLc0MsYUFBYXRDLENBQUMsS0FBSyxHQUFHO1lBQ2hELElBQUlxakQsd0JBQXdCO1lBQzVCLElBQUlzRiwwQkFBMEI7WUFDOUIsSUFBSUMsb0JBQW9CdG1ELGFBQWF0QyxDQUFDLEtBQUssSUFBSSxDQUFDLE1BQU0sQ0FBQztZQUN2RCxJQUFJbWdCLFlBQVk7WUFDaEIsSUFBSTBvQyxZQUFZO1lBRWhCLElBQUs5MEQsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7Z0JBQzNCLElBQUlxdUQsT0FBTyxDQUFDcnVELEVBQUUsQ0FBQ210QixDQUFDLEVBQUU7b0JBQ2hCLElBQUltaUMsdUJBQXVCO3dCQUN6QkEseUJBQXlCc0Y7b0JBQzNCO29CQUVBLE1BQU94b0MsWUFBWXBzQixFQUFHO3dCQUNwQnF1RCxPQUFPLENBQUNqaUMsVUFBVSxDQUFDa2pDLHFCQUFxQixHQUFHQTt3QkFDM0NsakMsYUFBYTtvQkFDZjtvQkFFQWtqQyx3QkFBd0I7b0JBQ3hCd0YsWUFBWTtnQkFDZCxPQUFPO29CQUNMLElBQUs3b0QsSUFBSSxHQUFHQSxJQUFJQyxNQUFNRCxLQUFLLEVBQUc7d0JBQzVCNGxELGdCQUFnQnJDLFNBQVMsQ0FBQ3ZqRCxFQUFFLENBQUMrQyxDQUFDO3dCQUU5QixJQUFJNmlELGNBQWNqcEQsQ0FBQyxDQUFDcWpCLFFBQVEsRUFBRTs0QkFDNUIsSUFBSTZvQyxhQUFhdm1ELGFBQWF0QyxDQUFDLEtBQUssR0FBRztnQ0FDckMyb0QsMkJBQTJCL0MsY0FBY2pwRCxDQUFDLENBQUNQLENBQUMsR0FBR3dzRDs0QkFDakQ7NEJBRUFqQixtQkFBbUJwRSxTQUFTLENBQUN2akQsRUFBRSxDQUFDN0QsQ0FBQzs0QkFDakM0b0IsT0FBTzRpQyxpQkFBaUJ6QyxPQUFPLENBQUM5QyxPQUFPLENBQUNydUQsRUFBRSxDQUFDcXZELFNBQVMsQ0FBQ3BqRCxFQUFFLEVBQUU4cUMsU0FBUy9uQyxDQUFDLENBQUMvQyxFQUFFLENBQUM3RCxDQUFDLENBQUM2bkQsVUFBVTs0QkFFbkYsSUFBSWovQixLQUFLOXdCLE1BQU0sRUFBRTtnQ0FDZm92RCx5QkFBeUJ1QyxjQUFjanBELENBQUMsQ0FBQ1AsQ0FBQyxHQUFHMm9CLElBQUksQ0FBQyxFQUFFLEdBQUc2akM7NEJBQ3pELE9BQU87Z0NBQ0x2Rix5QkFBeUJ1QyxjQUFjanBELENBQUMsQ0FBQ1AsQ0FBQyxHQUFHMm9CLE9BQU82akM7NEJBQ3REO3dCQUNGO29CQUNGO29CQUVBQyxZQUFZO2dCQUNkO1lBQ0Y7WUFFQSxJQUFJeEYsdUJBQXVCO2dCQUN6QkEseUJBQXlCc0Y7WUFDM0I7WUFFQSxNQUFPeG9DLFlBQVlwc0IsRUFBRztnQkFDcEJxdUQsT0FBTyxDQUFDamlDLFVBQVUsQ0FBQ2tqQyxxQkFBcUIsR0FBR0E7Z0JBQzNDbGpDLGFBQWE7WUFDZjtRQUNGLEVBQUUsRUFBRTtRQUdKLElBQUtwc0IsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDM0I4eUQsYUFBYXA5QixLQUFLO1lBQ2xCMCtCLGNBQWM7WUFFZCxJQUFJL0YsT0FBTyxDQUFDcnVELEVBQUUsQ0FBQ210QixDQUFDLEVBQUU7Z0JBQ2hCNmxDLE9BQU87Z0JBQ1BDLFFBQVExa0QsYUFBYTArQyxPQUFPO2dCQUM1QmdHLFFBQVFVLFlBQVksSUFBSTtnQkFDeEJSLGdCQUFnQmM7Z0JBQ2hCTixZQUFZO2dCQUVaLElBQUksSUFBSSxDQUFDekIsY0FBYyxFQUFFO29CQUN2Qm9CLGFBQWFZO29CQUNiYixXQUFXYztvQkFDWDV2QyxTQUFTL0ssUUFBUSxDQUFDODVDLFdBQVcsQ0FBQy91QyxNQUFNO29CQUNwQzBuQixZQUFZMW5CLE1BQU0sQ0FBQzh1QyxXQUFXLEVBQUU7b0JBQ2hDRCxlQUFlN3VDLE1BQU0sQ0FBQzh1QyxTQUFTO29CQUMvQmxxQyxnQkFBZ0JpcUMsYUFBYWpxQyxhQUFhO29CQUMxQ0gsZ0JBQWdCO2dCQUNsQjtnQkFFQXdyQyxVQUFVO2dCQUNWRCxXQUFXO2dCQUNYRixXQUFXO2dCQUNYTSxVQUFVO2dCQUNWRixVQUFVLElBQUksQ0FBQ0MsaUJBQWlCO1lBQ2xDLE9BQU87Z0JBQ0wsSUFBSSxJQUFJLENBQUN4QyxjQUFjLEVBQUU7b0JBQ3ZCLElBQUl4RCxnQkFBZ0JMLE9BQU8sQ0FBQ3J1RCxFQUFFLENBQUN5VyxJQUFJLEVBQUU7d0JBQ25DLE9BQVFsSSxhQUFhdEMsQ0FBQzs0QkFDcEIsS0FBSztnQ0FDSGtuRCxpQkFBaUJ6c0MsY0FBY25ZLGFBQWFvK0MsVUFBVSxDQUFDMEIsT0FBTyxDQUFDcnVELEVBQUUsQ0FBQ3lXLElBQUksQ0FBQztnQ0FDdkU7NEJBRUYsS0FBSztnQ0FDSDA4QyxpQkFBaUIsQ0FBQ3pzQyxjQUFjblksYUFBYW8rQyxVQUFVLENBQUMwQixPQUFPLENBQUNydUQsRUFBRSxDQUFDeVcsSUFBSSxDQUFDLElBQUk7Z0NBQzVFOzRCQUVGO2dDQUNFO3dCQUNKO3dCQUVBaTRDLGNBQWNMLE9BQU8sQ0FBQ3J1RCxFQUFFLENBQUN5VyxJQUFJO29CQUMvQjtvQkFFQSxJQUFJdVcsUUFBUXFoQyxPQUFPLENBQUNydUQsRUFBRSxDQUFDZ3RCLEdBQUcsRUFBRTt3QkFDMUIsSUFBSXFoQyxPQUFPLENBQUNyaEMsSUFBSSxFQUFFOzRCQUNoQm1tQyxpQkFBaUI5RSxPQUFPLENBQUNyaEMsSUFBSSxDQUFDdWlDLEtBQUs7d0JBQ3JDO3dCQUVBNEQsaUJBQWlCOUUsT0FBTyxDQUFDcnVELEVBQUUsQ0FBQ212RCxFQUFFLEdBQUc7d0JBQ2pDbmlDLE1BQU1xaEMsT0FBTyxDQUFDcnVELEVBQUUsQ0FBQ2d0QixHQUFHO29CQUN0QjtvQkFFQW1tQyxpQkFBaUJWLFNBQVMsQ0FBQyxFQUFFLEdBQUdwRSxPQUFPLENBQUNydUQsRUFBRSxDQUFDbXZELEVBQUUsR0FBRztvQkFDaEQsSUFBSTRGLGlCQUFpQjtvQkFFckIsSUFBSzlvRCxJQUFJLEdBQUdBLElBQUlDLE1BQU1ELEtBQUssRUFBRzt3QkFDNUI0bEQsZ0JBQWdCckMsU0FBUyxDQUFDdmpELEVBQUUsQ0FBQytDLENBQUM7d0JBRTlCLElBQUk2aUQsY0FBY25wRCxDQUFDLENBQUN1akIsUUFBUSxFQUFFOzRCQUM1QjJuQyxtQkFBbUJwRSxTQUFTLENBQUN2akQsRUFBRSxDQUFDN0QsQ0FBQzs0QkFDakM0b0IsT0FBTzRpQyxpQkFBaUJ6QyxPQUFPLENBQUM5QyxPQUFPLENBQUNydUQsRUFBRSxDQUFDcXZELFNBQVMsQ0FBQ3BqRCxFQUFFLEVBQUU4cUMsU0FBUy9uQyxDQUFDLENBQUMvQyxFQUFFLENBQUM3RCxDQUFDLENBQUM2bkQsVUFBVTs0QkFFbkYsSUFBSWovQixLQUFLOXdCLE1BQU0sRUFBRTtnQ0FDZjYwRCxrQkFBa0JsRCxjQUFjbnBELENBQUMsQ0FBQ0wsQ0FBQyxDQUFDLEVBQUUsR0FBRzJvQixJQUFJLENBQUMsRUFBRTs0QkFDbEQsT0FBTztnQ0FDTCtqQyxrQkFBa0JsRCxjQUFjbnBELENBQUMsQ0FBQ0wsQ0FBQyxDQUFDLEVBQUUsR0FBRzJvQjs0QkFDM0M7d0JBQ0Y7d0JBRUEsSUFBSTZnQyxjQUFjN2lELENBQUMsQ0FBQ2lkLFFBQVEsRUFBRTs0QkFDNUIybkMsbUJBQW1CcEUsU0FBUyxDQUFDdmpELEVBQUUsQ0FBQzdELENBQUM7NEJBQ2pDNG9CLE9BQU80aUMsaUJBQWlCekMsT0FBTyxDQUFDOUMsT0FBTyxDQUFDcnVELEVBQUUsQ0FBQ3F2RCxTQUFTLENBQUNwakQsRUFBRSxFQUFFOHFDLFNBQVMvbkMsQ0FBQyxDQUFDL0MsRUFBRSxDQUFDN0QsQ0FBQyxDQUFDNm5ELFVBQVU7NEJBRW5GLElBQUlqL0IsS0FBSzl3QixNQUFNLEVBQUU7Z0NBQ2Y2MEQsa0JBQWtCbEQsY0FBYzdpRCxDQUFDLENBQUMzRyxDQUFDLENBQUMsRUFBRSxHQUFHMm9CLElBQUksQ0FBQyxFQUFFOzRCQUNsRCxPQUFPO2dDQUNMK2pDLGtCQUFrQmxELGNBQWM3aUQsQ0FBQyxDQUFDM0csQ0FBQyxDQUFDLEVBQUUsR0FBRzJvQjs0QkFDM0M7d0JBQ0Y7b0JBQ0Y7b0JBRUE1eEIsT0FBTyxNQUFNLHdEQUF3RDtvQkFFckUsSUFBSSxJQUFJLENBQUNtekQsU0FBUyxDQUFDdmpELENBQUMsQ0FBQzNHLENBQUMsRUFBRTt3QkFDdEI4cUQsZ0JBQWdCOUUsT0FBTyxDQUFDLEVBQUUsQ0FBQ2MsRUFBRSxHQUFHLE1BQU0sQ0FBQ3pvQyxjQUFjLElBQUksQ0FBQzZyQyxTQUFTLENBQUM5cEQsQ0FBQyxDQUFDSixDQUFDLEdBQUdnbUQsT0FBTyxDQUFDLEVBQUUsQ0FBQ2MsRUFBRSxHQUFHLE1BQU1kLE9BQU8sQ0FBQ0EsUUFBUW51RCxNQUFNLEdBQUcsRUFBRSxDQUFDaXZELEVBQUUsR0FBRyxHQUFFLElBQUtuaUMsTUFBTy9zQixDQUFBQSxNQUFNO3dCQUNySmt6RCxpQkFBaUIsSUFBSSxDQUFDWixTQUFTLENBQUM5cEQsQ0FBQyxDQUFDSixDQUFDO29CQUNyQztvQkFFQSxNQUFPakosS0FBTTt3QkFDWCxJQUFJNHBCLGdCQUFnQkcsaUJBQWlCZ3FDLGdCQUFnQjRCLGtCQUFrQixDQUFDeHdDLFFBQVE7NEJBQzlFNkQsT0FBTyxDQUFDK3FDLGdCQUFnQjRCLGlCQUFpQi9yQyxhQUFZLElBQUtvcUMsYUFBYWpxQyxhQUFhOzRCQUNwRjRxQyxXQUFXOW5CLFVBQVUzakIsS0FBSyxDQUFDLEVBQUUsR0FBRyxDQUFDOHFDLGFBQWE5cUMsS0FBSyxDQUFDLEVBQUUsR0FBRzJqQixVQUFVM2pCLEtBQUssQ0FBQyxFQUFFLElBQUlGOzRCQUMvRTRyQyxXQUFXL25CLFVBQVUzakIsS0FBSyxDQUFDLEVBQUUsR0FBRyxDQUFDOHFDLGFBQWE5cUMsS0FBSyxDQUFDLEVBQUUsR0FBRzJqQixVQUFVM2pCLEtBQUssQ0FBQyxFQUFFLElBQUlGOzRCQUMvRTBxQyxhQUFhaDVCLFNBQVMsQ0FBQyxDQUFDMjRCLFNBQVMsQ0FBQyxFQUFFLEdBQUdwRSxPQUFPLENBQUNydUQsRUFBRSxDQUFDbXZELEVBQUUsR0FBRyxPQUFPLENBQUVzRCxDQUFBQSxTQUFTLENBQUMsRUFBRSxHQUFHaUIsSUFBRyxJQUFLOzRCQUN2RnQwRCxPQUFPO3dCQUNULE9BQU8sSUFBSW1sQixRQUFROzRCQUNqQnlFLGlCQUFpQm9xQyxhQUFhanFDLGFBQWE7NEJBQzNDa3FDLFlBQVk7NEJBRVosSUFBSUEsWUFBWTl1QyxPQUFPcmtCLE1BQU0sRUFBRTtnQ0FDN0JtekQsV0FBVztnQ0FDWEMsY0FBYztnQ0FFZCxJQUFJLENBQUM5NUMsUUFBUSxDQUFDODVDLFdBQVcsRUFBRTtvQ0FDekIsSUFBSTVULEtBQUtyM0MsQ0FBQyxDQUFDa0gsQ0FBQyxFQUFFO3dDQUNaOGpELFdBQVc7d0NBQ1hDLGFBQWE7d0NBQ2IvdUMsU0FBUy9LLFFBQVEsQ0FBQzg1QyxXQUFXLENBQUMvdUMsTUFBTTtvQ0FDdEMsT0FBTzt3Q0FDTHlFLGlCQUFpQm9xQyxhQUFhanFDLGFBQWE7d0NBQzNDNUUsU0FBUztvQ0FDWDtnQ0FDRixPQUFPO29DQUNMQSxTQUFTL0ssUUFBUSxDQUFDODVDLFdBQVcsQ0FBQy91QyxNQUFNO2dDQUN0Qzs0QkFDRjs0QkFFQSxJQUFJQSxRQUFRO2dDQUNWMG5CLFlBQVltbkI7Z0NBQ1pBLGVBQWU3dUMsTUFBTSxDQUFDOHVDLFNBQVM7Z0NBQy9CbHFDLGdCQUFnQmlxQyxhQUFhanFDLGFBQWE7NEJBQzVDO3dCQUNGO29CQUNGO29CQUVBMnFDLE9BQU96RixPQUFPLENBQUNydUQsRUFBRSxDQUFDbXZELEVBQUUsR0FBRyxJQUFJZCxPQUFPLENBQUNydUQsRUFBRSxDQUFDb3ZELEdBQUc7b0JBQ3pDMEQsYUFBYWg1QixTQUFTLENBQUMsQ0FBQ2c2QixNQUFNLEdBQUc7Z0JBQ25DLE9BQU87b0JBQ0xBLE9BQU96RixPQUFPLENBQUNydUQsRUFBRSxDQUFDbXZELEVBQUUsR0FBRyxJQUFJZCxPQUFPLENBQUNydUQsRUFBRSxDQUFDb3ZELEdBQUc7b0JBQ3pDMEQsYUFBYWg1QixTQUFTLENBQUMsQ0FBQ2c2QixNQUFNLEdBQUcsSUFBSSxxQkFBcUI7b0JBRTFEaEIsYUFBYWg1QixTQUFTLENBQUMsQ0FBQzI0QixTQUFTLENBQUMsRUFBRSxHQUFHcEUsT0FBTyxDQUFDcnVELEVBQUUsQ0FBQ212RCxFQUFFLEdBQUcsT0FBTyxDQUFDc0QsU0FBUyxDQUFDLEVBQUUsR0FBR2lCLE9BQU8sTUFBTTtnQkFDN0Y7Z0JBRUEsSUFBS3puRCxJQUFJLEdBQUdBLElBQUlDLE1BQU1ELEtBQUssRUFBRztvQkFDNUI0bEQsZ0JBQWdCckMsU0FBUyxDQUFDdmpELEVBQUUsQ0FBQytDLENBQUM7b0JBRTlCLElBQUk2aUQsY0FBY2pwRCxDQUFDLENBQUNxakIsUUFBUSxFQUFFO3dCQUM1QjJuQyxtQkFBbUJwRSxTQUFTLENBQUN2akQsRUFBRSxDQUFDN0QsQ0FBQzt3QkFDakM0b0IsT0FBTzRpQyxpQkFBaUJ6QyxPQUFPLENBQUM5QyxPQUFPLENBQUNydUQsRUFBRSxDQUFDcXZELFNBQVMsQ0FBQ3BqRCxFQUFFLEVBQUU4cUMsU0FBUy9uQyxDQUFDLENBQUMvQyxFQUFFLENBQUM3RCxDQUFDLENBQUM2bkQsVUFBVSxHQUFHLCtIQUErSDt3QkFFck4sSUFBSStDLFNBQVMsS0FBS3prRCxhQUFhdEMsQ0FBQyxLQUFLLEdBQUc7NEJBQ3RDLElBQUksSUFBSSxDQUFDaW1ELGNBQWMsRUFBRTtnQ0FDdkIsSUFBSWxoQyxLQUFLOXdCLE1BQU0sRUFBRTtvQ0FDZml6RCxpQkFBaUJ0QixjQUFjanBELENBQUMsQ0FBQ1AsQ0FBQyxHQUFHMm9CLElBQUksQ0FBQyxFQUFFO2dDQUM5QyxPQUFPO29DQUNMbWlDLGlCQUFpQnRCLGNBQWNqcEQsQ0FBQyxDQUFDUCxDQUFDLEdBQUcyb0I7Z0NBQ3ZDOzRCQUNGLE9BQU8sSUFBSUEsS0FBSzl3QixNQUFNLEVBQUU7Z0NBQ3RCOHlELFFBQVFuQixjQUFjanBELENBQUMsQ0FBQ1AsQ0FBQyxHQUFHMm9CLElBQUksQ0FBQyxFQUFFOzRCQUNyQyxPQUFPO2dDQUNMZ2lDLFFBQVFuQixjQUFjanBELENBQUMsQ0FBQ1AsQ0FBQyxHQUFHMm9COzRCQUM5Qjt3QkFDRjtvQkFDRjtnQkFDRjtnQkFFQSxJQUFJemlCLGFBQWF5K0MsZUFBZSxFQUFFO29CQUNoQ3BCLEtBQUtyOUMsYUFBYXE5QyxFQUFFLElBQUk7Z0JBQzFCO2dCQUVBLElBQUlyOUMsYUFBYXcrQyxlQUFlLEVBQUU7b0JBQ2hDLElBQUl4K0MsYUFBYTZrQyxFQUFFLEVBQUU7d0JBQ25CQSxLQUFLOzRCQUFDN2tDLGFBQWE2a0MsRUFBRSxDQUFDLEVBQUU7NEJBQUU3a0MsYUFBYTZrQyxFQUFFLENBQUMsRUFBRTs0QkFBRTdrQyxhQUFhNmtDLEVBQUUsQ0FBQyxFQUFFO3lCQUFDO29CQUNuRSxPQUFPO3dCQUNMQSxLQUFLOzRCQUFDOzRCQUFHOzRCQUFHO3lCQUFFO29CQUNoQjtnQkFDRjtnQkFFQSxJQUFJN2tDLGFBQWF1K0MsYUFBYSxJQUFJditDLGFBQWFzOUMsRUFBRSxFQUFFO29CQUNqREEsS0FBSzt3QkFBQ3Q5QyxhQUFhczlDLEVBQUUsQ0FBQyxFQUFFO3dCQUFFdDlDLGFBQWFzOUMsRUFBRSxDQUFDLEVBQUU7d0JBQUV0OUMsYUFBYXM5QyxFQUFFLENBQUMsRUFBRTtxQkFBQztnQkFDbkU7Z0JBRUEsSUFBSzUvQyxJQUFJLEdBQUdBLElBQUlDLE1BQU1ELEtBQUssRUFBRztvQkFDNUI0bEQsZ0JBQWdCckMsU0FBUyxDQUFDdmpELEVBQUUsQ0FBQytDLENBQUM7b0JBRTlCLElBQUk2aUQsY0FBYzdpRCxDQUFDLENBQUNpZCxRQUFRLEVBQUU7d0JBQzVCMm5DLG1CQUFtQnBFLFNBQVMsQ0FBQ3ZqRCxFQUFFLENBQUM3RCxDQUFDO3dCQUNqQzRvQixPQUFPNGlDLGlCQUFpQnpDLE9BQU8sQ0FBQzlDLE9BQU8sQ0FBQ3J1RCxFQUFFLENBQUNxdkQsU0FBUyxDQUFDcGpELEVBQUUsRUFBRThxQyxTQUFTL25DLENBQUMsQ0FBQy9DLEVBQUUsQ0FBQzdELENBQUMsQ0FBQzZuRCxVQUFVO3dCQUVuRixJQUFJai9CLEtBQUs5d0IsTUFBTSxFQUFFOzRCQUNmNHlELGFBQWFoNUIsU0FBUyxDQUFDLENBQUMrM0IsY0FBYzdpRCxDQUFDLENBQUMzRyxDQUFDLENBQUMsRUFBRSxHQUFHMm9CLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQzZnQyxjQUFjN2lELENBQUMsQ0FBQzNHLENBQUMsQ0FBQyxFQUFFLEdBQUcyb0IsSUFBSSxDQUFDLEVBQUUsRUFBRTZnQyxjQUFjN2lELENBQUMsQ0FBQzNHLENBQUMsQ0FBQyxFQUFFLEdBQUcyb0IsSUFBSSxDQUFDLEVBQUU7d0JBQ3pILE9BQU87NEJBQ0w4aEMsYUFBYWg1QixTQUFTLENBQUMsQ0FBQyszQixjQUFjN2lELENBQUMsQ0FBQzNHLENBQUMsQ0FBQyxFQUFFLEdBQUcyb0IsTUFBTSxDQUFDNmdDLGNBQWM3aUQsQ0FBQyxDQUFDM0csQ0FBQyxDQUFDLEVBQUUsR0FBRzJvQixNQUFNNmdDLGNBQWM3aUQsQ0FBQyxDQUFDM0csQ0FBQyxDQUFDLEVBQUUsR0FBRzJvQjt3QkFDNUc7b0JBQ0Y7Z0JBQ0Y7Z0JBRUEsSUFBSy9rQixJQUFJLEdBQUdBLElBQUlDLE1BQU1ELEtBQUssRUFBRztvQkFDNUI0bEQsZ0JBQWdCckMsU0FBUyxDQUFDdmpELEVBQUUsQ0FBQytDLENBQUM7b0JBRTlCLElBQUk2aUQsY0FBY3pwRCxDQUFDLENBQUM2akIsUUFBUSxFQUFFO3dCQUM1QjJuQyxtQkFBbUJwRSxTQUFTLENBQUN2akQsRUFBRSxDQUFDN0QsQ0FBQzt3QkFDakM0b0IsT0FBTzRpQyxpQkFBaUJ6QyxPQUFPLENBQUM5QyxPQUFPLENBQUNydUQsRUFBRSxDQUFDcXZELFNBQVMsQ0FBQ3BqRCxFQUFFLEVBQUU4cUMsU0FBUy9uQyxDQUFDLENBQUMvQyxFQUFFLENBQUM3RCxDQUFDLENBQUM2bkQsVUFBVTt3QkFFbkYsSUFBSWovQixLQUFLOXdCLE1BQU0sRUFBRTs0QkFDZjR5RCxhQUFhcjVCLEtBQUssQ0FBQyxJQUFJLENBQUNvNEIsY0FBY3pwRCxDQUFDLENBQUNDLENBQUMsQ0FBQyxFQUFFLEdBQUcsS0FBSzJvQixJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQzZnQyxjQUFjenBELENBQUMsQ0FBQ0MsQ0FBQyxDQUFDLEVBQUUsR0FBRyxLQUFLMm9CLElBQUksQ0FBQyxFQUFFLEVBQUU7d0JBQ3pHLE9BQU87NEJBQ0w4aEMsYUFBYXI1QixLQUFLLENBQUMsSUFBSSxDQUFDbzRCLGNBQWN6cEQsQ0FBQyxDQUFDQyxDQUFDLENBQUMsRUFBRSxHQUFHLEtBQUsyb0IsTUFBTSxJQUFJLENBQUM2Z0MsY0FBY3pwRCxDQUFDLENBQUNDLENBQUMsQ0FBQyxFQUFFLEdBQUcsS0FBSzJvQixNQUFNO3dCQUNuRztvQkFDRjtnQkFDRjtnQkFFQSxJQUFLL2tCLElBQUksR0FBR0EsSUFBSUMsTUFBTUQsS0FBSyxFQUFHO29CQUM1QjRsRCxnQkFBZ0JyQyxTQUFTLENBQUN2akQsRUFBRSxDQUFDK0MsQ0FBQztvQkFDOUI0a0QsbUJBQW1CcEUsU0FBUyxDQUFDdmpELEVBQUUsQ0FBQzdELENBQUM7b0JBQ2pDNG9CLE9BQU80aUMsaUJBQWlCekMsT0FBTyxDQUFDOUMsT0FBTyxDQUFDcnVELEVBQUUsQ0FBQ3F2RCxTQUFTLENBQUNwakQsRUFBRSxFQUFFOHFDLFNBQVMvbkMsQ0FBQyxDQUFDL0MsRUFBRSxDQUFDN0QsQ0FBQyxDQUFDNm5ELFVBQVU7b0JBRW5GLElBQUk0QixjQUFjNWlELEVBQUUsQ0FBQ2dkLFFBQVEsRUFBRTt3QkFDN0IsSUFBSStFLEtBQUs5d0IsTUFBTSxFQUFFOzRCQUNmNHlELGFBQWF0NUIsWUFBWSxDQUFDLENBQUNxNEIsY0FBYzVpRCxFQUFFLENBQUM1RyxDQUFDLEdBQUcyb0IsSUFBSSxDQUFDLEVBQUUsRUFBRTZnQyxjQUFjM2lELEVBQUUsQ0FBQzdHLENBQUMsR0FBRzJvQixJQUFJLENBQUMsRUFBRTt3QkFDdkYsT0FBTzs0QkFDTDhoQyxhQUFhdDVCLFlBQVksQ0FBQyxDQUFDcTRCLGNBQWM1aUQsRUFBRSxDQUFDNUcsQ0FBQyxHQUFHMm9CLE1BQU02Z0MsY0FBYzNpRCxFQUFFLENBQUM3RyxDQUFDLEdBQUcyb0I7d0JBQzdFO29CQUNGO29CQUVBLElBQUk2Z0MsY0FBY3ZwRCxDQUFDLENBQUMyakIsUUFBUSxFQUFFO3dCQUM1QixJQUFJK0UsS0FBSzl3QixNQUFNLEVBQUU7NEJBQ2Y0eUQsYUFBYTE1QixPQUFPLENBQUMsQ0FBQ3k0QixjQUFjdnBELENBQUMsQ0FBQ0QsQ0FBQyxHQUFHMm9CLElBQUksQ0FBQyxFQUFFO3dCQUNuRCxPQUFPOzRCQUNMOGhDLGFBQWExNUIsT0FBTyxDQUFDLENBQUN5NEIsY0FBY3ZwRCxDQUFDLENBQUNELENBQUMsR0FBRzJvQjt3QkFDNUM7b0JBQ0Y7b0JBRUEsSUFBSTZnQyxjQUFjN3VCLEVBQUUsQ0FBQy9XLFFBQVEsRUFBRTt3QkFDN0IsSUFBSStFLEtBQUs5d0IsTUFBTSxFQUFFOzRCQUNmNHlELGFBQWEzNUIsT0FBTyxDQUFDMDRCLGNBQWM3dUIsRUFBRSxDQUFDMzZCLENBQUMsR0FBRzJvQixJQUFJLENBQUMsRUFBRTt3QkFDbkQsT0FBTzs0QkFDTDhoQyxhQUFhMzVCLE9BQU8sQ0FBQzA0QixjQUFjN3VCLEVBQUUsQ0FBQzM2QixDQUFDLEdBQUcyb0I7d0JBQzVDO29CQUNGO29CQUVBLElBQUk2Z0MsY0FBYzV1QixFQUFFLENBQUNoWCxRQUFRLEVBQUU7d0JBQzdCLElBQUkrRSxLQUFLOXdCLE1BQU0sRUFBRTs0QkFDZjR5RCxhQUFhNTVCLE9BQU8sQ0FBQzI0QixjQUFjNXVCLEVBQUUsQ0FBQzU2QixDQUFDLEdBQUcyb0IsSUFBSSxDQUFDLEVBQUU7d0JBQ25ELE9BQU87NEJBQ0w4aEMsYUFBYTU1QixPQUFPLENBQUMyNEIsY0FBYzV1QixFQUFFLENBQUM1NkIsQ0FBQyxHQUFHMm9CO3dCQUM1QztvQkFDRjtvQkFFQSxJQUFJNmdDLGNBQWNoa0QsQ0FBQyxDQUFDb2UsUUFBUSxFQUFFO3dCQUM1QixJQUFJK0UsS0FBSzl3QixNQUFNLEVBQUU7NEJBQ2ZrMEQsZUFBZSxDQUFDdkMsY0FBY2hrRCxDQUFDLENBQUN4RixDQUFDLEdBQUcyb0IsSUFBSSxDQUFDLEVBQUUsR0FBR29qQyxXQUFVLElBQUtwakMsSUFBSSxDQUFDLEVBQUU7d0JBQ3RFLE9BQU87NEJBQ0xvakMsZUFBZSxDQUFDdkMsY0FBY2hrRCxDQUFDLENBQUN4RixDQUFDLEdBQUcyb0IsT0FBT29qQyxXQUFVLElBQUtwakM7d0JBQzVEO29CQUNGO29CQUVBLElBQUl6aUIsYUFBYXkrQyxlQUFlLElBQUk2RSxjQUFjakcsRUFBRSxDQUFDMy9CLFFBQVEsRUFBRTt3QkFDN0QsSUFBSStFLEtBQUs5d0IsTUFBTSxFQUFFOzRCQUNmMHJELE1BQU1pRyxjQUFjakcsRUFBRSxDQUFDdmpELENBQUMsR0FBRzJvQixJQUFJLENBQUMsRUFBRTt3QkFDcEMsT0FBTzs0QkFDTDQ2QixNQUFNaUcsY0FBY2pHLEVBQUUsQ0FBQ3ZqRCxDQUFDLEdBQUcyb0I7d0JBQzdCO29CQUNGO29CQUVBLElBQUl6aUIsYUFBYXcrQyxlQUFlLElBQUk4RSxjQUFjemUsRUFBRSxDQUFDbm5CLFFBQVEsRUFBRTt3QkFDN0QsSUFBSzlmLElBQUksR0FBR0EsSUFBSSxHQUFHQSxLQUFLLEVBQUc7NEJBQ3pCLElBQUk2a0IsS0FBSzl3QixNQUFNLEVBQUU7Z0NBQ2ZrekMsRUFBRSxDQUFDam5DLEVBQUUsSUFBSSxDQUFDMGxELGNBQWN6ZSxFQUFFLENBQUMvcUMsQ0FBQyxDQUFDOEQsRUFBRSxHQUFHaW5DLEVBQUUsQ0FBQ2puQyxFQUFFLElBQUk2a0IsSUFBSSxDQUFDLEVBQUU7NEJBQ3BELE9BQU87Z0NBQ0xvaUIsRUFBRSxDQUFDam5DLEVBQUUsSUFBSSxDQUFDMGxELGNBQWN6ZSxFQUFFLENBQUMvcUMsQ0FBQyxDQUFDOEQsRUFBRSxHQUFHaW5DLEVBQUUsQ0FBQ2puQyxFQUFFLElBQUk2a0I7NEJBQzdDO3dCQUNGO29CQUNGO29CQUVBLElBQUl6aUIsYUFBYXUrQyxhQUFhLElBQUl2K0MsYUFBYXM5QyxFQUFFLEVBQUU7d0JBQ2pELElBQUlnRyxjQUFjaEcsRUFBRSxDQUFDNS9CLFFBQVEsRUFBRTs0QkFDN0IsSUFBSzlmLElBQUksR0FBR0EsSUFBSSxHQUFHQSxLQUFLLEVBQUc7Z0NBQ3pCLElBQUk2a0IsS0FBSzl3QixNQUFNLEVBQUU7b0NBQ2YyckQsRUFBRSxDQUFDMS9DLEVBQUUsSUFBSSxDQUFDMGxELGNBQWNoRyxFQUFFLENBQUN4akQsQ0FBQyxDQUFDOEQsRUFBRSxHQUFHMC9DLEVBQUUsQ0FBQzEvQyxFQUFFLElBQUk2a0IsSUFBSSxDQUFDLEVBQUU7Z0NBQ3BELE9BQU87b0NBQ0w2NkIsRUFBRSxDQUFDMS9DLEVBQUUsSUFBSSxDQUFDMGxELGNBQWNoRyxFQUFFLENBQUN4akQsQ0FBQyxDQUFDOEQsRUFBRSxHQUFHMC9DLEVBQUUsQ0FBQzEvQyxFQUFFLElBQUk2a0I7Z0NBQzdDOzRCQUNGO3dCQUNGO3dCQUVBLElBQUk2Z0MsY0FBY2hDLEVBQUUsQ0FBQzVqQyxRQUFRLEVBQUU7NEJBQzdCLElBQUkrRSxLQUFLOXdCLE1BQU0sRUFBRTtnQ0FDZjJyRCxLQUFLemlELFlBQVl5aUQsSUFBSWdHLGNBQWNoQyxFQUFFLENBQUN4bkQsQ0FBQyxHQUFHMm9CLElBQUksQ0FBQyxFQUFFOzRCQUNuRCxPQUFPO2dDQUNMNjZCLEtBQUt6aUQsWUFBWXlpRCxJQUFJZ0csY0FBY2hDLEVBQUUsQ0FBQ3huRCxDQUFDLEdBQUcyb0I7NEJBQzVDO3dCQUNGO3dCQUVBLElBQUk2Z0MsY0FBYy9CLEVBQUUsQ0FBQzdqQyxRQUFRLEVBQUU7NEJBQzdCLElBQUkrRSxLQUFLOXdCLE1BQU0sRUFBRTtnQ0FDZjJyRCxLQUFLOWlELG1CQUFtQjhpRCxJQUFJZ0csY0FBYy9CLEVBQUUsQ0FBQ3puRCxDQUFDLEdBQUcyb0IsSUFBSSxDQUFDLEVBQUU7NEJBQzFELE9BQU87Z0NBQ0w2NkIsS0FBSzlpRCxtQkFBbUI4aUQsSUFBSWdHLGNBQWMvQixFQUFFLENBQUN6bkQsQ0FBQyxHQUFHMm9COzRCQUNuRDt3QkFDRjt3QkFFQSxJQUFJNmdDLGNBQWM5QixFQUFFLENBQUM5akMsUUFBUSxFQUFFOzRCQUM3QixJQUFJK0UsS0FBSzl3QixNQUFNLEVBQUU7Z0NBQ2YyckQsS0FBSzFpRCxtQkFBbUIwaUQsSUFBSWdHLGNBQWM5QixFQUFFLENBQUMxbkQsQ0FBQyxHQUFHMm9CLElBQUksQ0FBQyxFQUFFOzRCQUMxRCxPQUFPO2dDQUNMNjZCLEtBQUsxaUQsbUJBQW1CMGlELElBQUlnRyxjQUFjOUIsRUFBRSxDQUFDMW5ELENBQUMsR0FBRzJvQjs0QkFDbkQ7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7Z0JBRUEsSUFBSy9rQixJQUFJLEdBQUdBLElBQUlDLE1BQU1ELEtBQUssRUFBRztvQkFDNUI0bEQsZ0JBQWdCckMsU0FBUyxDQUFDdmpELEVBQUUsQ0FBQytDLENBQUM7b0JBRTlCLElBQUk2aUQsY0FBY25wRCxDQUFDLENBQUN1akIsUUFBUSxFQUFFO3dCQUM1QjJuQyxtQkFBbUJwRSxTQUFTLENBQUN2akQsRUFBRSxDQUFDN0QsQ0FBQzt3QkFDakM0b0IsT0FBTzRpQyxpQkFBaUJ6QyxPQUFPLENBQUM5QyxPQUFPLENBQUNydUQsRUFBRSxDQUFDcXZELFNBQVMsQ0FBQ3BqRCxFQUFFLEVBQUU4cUMsU0FBUy9uQyxDQUFDLENBQUMvQyxFQUFFLENBQUM3RCxDQUFDLENBQUM2bkQsVUFBVTt3QkFFbkYsSUFBSSxJQUFJLENBQUNpQyxjQUFjLEVBQUU7NEJBQ3ZCLElBQUlsaEMsS0FBSzl3QixNQUFNLEVBQUU7Z0NBQ2Y0eUQsYUFBYWg1QixTQUFTLENBQUMsR0FBRyszQixjQUFjbnBELENBQUMsQ0FBQ0wsQ0FBQyxDQUFDLEVBQUUsR0FBRzJvQixJQUFJLENBQUMsRUFBRSxFQUFFLENBQUM2Z0MsY0FBY25wRCxDQUFDLENBQUNMLENBQUMsQ0FBQyxFQUFFLEdBQUcyb0IsSUFBSSxDQUFDLEVBQUU7NEJBQzNGLE9BQU87Z0NBQ0w4aEMsYUFBYWg1QixTQUFTLENBQUMsR0FBRyszQixjQUFjbnBELENBQUMsQ0FBQ0wsQ0FBQyxDQUFDLEVBQUUsR0FBRzJvQixNQUFNLENBQUM2Z0MsY0FBY25wRCxDQUFDLENBQUNMLENBQUMsQ0FBQyxFQUFFLEdBQUcyb0I7NEJBQ2pGO3dCQUNGLE9BQU8sSUFBSUEsS0FBSzl3QixNQUFNLEVBQUU7NEJBQ3RCNHlELGFBQWFoNUIsU0FBUyxDQUFDKzNCLGNBQWNucEQsQ0FBQyxDQUFDTCxDQUFDLENBQUMsRUFBRSxHQUFHMm9CLElBQUksQ0FBQyxFQUFFLEVBQUU2Z0MsY0FBY25wRCxDQUFDLENBQUNMLENBQUMsQ0FBQyxFQUFFLEdBQUcyb0IsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDNmdDLGNBQWNucEQsQ0FBQyxDQUFDTCxDQUFDLENBQUMsRUFBRSxHQUFHMm9CLElBQUksQ0FBQyxFQUFFO3dCQUN4SCxPQUFPOzRCQUNMOGhDLGFBQWFoNUIsU0FBUyxDQUFDKzNCLGNBQWNucEQsQ0FBQyxDQUFDTCxDQUFDLENBQUMsRUFBRSxHQUFHMm9CLE1BQU02Z0MsY0FBY25wRCxDQUFDLENBQUNMLENBQUMsQ0FBQyxFQUFFLEdBQUcyb0IsTUFBTSxDQUFDNmdDLGNBQWNucEQsQ0FBQyxDQUFDTCxDQUFDLENBQUMsRUFBRSxHQUFHMm9CO3dCQUMzRztvQkFDRjtnQkFDRjtnQkFFQSxJQUFJemlCLGFBQWF5K0MsZUFBZSxFQUFFO29CQUNoQ3FILFdBQVd6SSxLQUFLLElBQUksSUFBSUE7Z0JBQzFCO2dCQUVBLElBQUlyOUMsYUFBYXcrQyxlQUFlLEVBQUU7b0JBQ2hDdUgsV0FBVyxTQUFTaHdELEtBQUt3QixLQUFLLENBQUNzdEMsRUFBRSxDQUFDLEVBQUUsR0FBRyxPQUFPLE1BQU05dUMsS0FBS3dCLEtBQUssQ0FBQ3N0QyxFQUFFLENBQUMsRUFBRSxHQUFHLE9BQU8sTUFBTTl1QyxLQUFLd0IsS0FBSyxDQUFDc3RDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsT0FBTztnQkFDaEg7Z0JBRUEsSUFBSTdrQyxhQUFhdStDLGFBQWEsSUFBSXYrQyxhQUFhczlDLEVBQUUsRUFBRTtvQkFDakQwSSxXQUFXLFNBQVNqd0QsS0FBS3dCLEtBQUssQ0FBQytsRCxFQUFFLENBQUMsRUFBRSxHQUFHLE9BQU8sTUFBTXZuRCxLQUFLd0IsS0FBSyxDQUFDK2xELEVBQUUsQ0FBQyxFQUFFLEdBQUcsT0FBTyxNQUFNdm5ELEtBQUt3QixLQUFLLENBQUMrbEQsRUFBRSxDQUFDLEVBQUUsR0FBRyxPQUFPO2dCQUNoSDtnQkFFQSxJQUFJLElBQUksQ0FBQ3FHLGNBQWMsRUFBRTtvQkFDdkJZLGFBQWFoNUIsU0FBUyxDQUFDLEdBQUcsQ0FBQ3ZyQixhQUFhcStDLEVBQUU7b0JBQzFDa0csYUFBYWg1QixTQUFTLENBQUMsR0FBRzI0QixTQUFTLENBQUMsRUFBRSxHQUFHaUIsT0FBTyxPQUFPVCxNQUFNO29CQUU3RCxJQUFJLElBQUksQ0FBQ1YsU0FBUyxDQUFDN3BELENBQUMsQ0FBQ0wsQ0FBQyxFQUFFO3dCQUN0QmtyRCxXQUFXLENBQUNILGFBQWE5cUMsS0FBSyxDQUFDLEVBQUUsR0FBRzJqQixVQUFVM2pCLEtBQUssQ0FBQyxFQUFFLElBQUs4cUMsQ0FBQUEsYUFBYTlxQyxLQUFLLENBQUMsRUFBRSxHQUFHMmpCLFVBQVUzakIsS0FBSyxDQUFDLEVBQUU7d0JBQ3JHLElBQUlzakIsTUFBTXRuQyxLQUFLMHdELElBQUksQ0FBQ3pCLFlBQVksTUFBTWp2RCxLQUFLb0IsRUFBRTt3QkFFN0MsSUFBSTB0RCxhQUFhOXFDLEtBQUssQ0FBQyxFQUFFLEdBQUcyakIsVUFBVTNqQixLQUFLLENBQUMsRUFBRSxFQUFFOzRCQUM5Q3NqQixPQUFPO3dCQUNUO3dCQUVBa25CLGFBQWFoNkIsTUFBTSxDQUFDLENBQUM4UyxNQUFNdG5DLEtBQUtvQixFQUFFLEdBQUc7b0JBQ3ZDO29CQUVBb3RELGFBQWFoNUIsU0FBUyxDQUFDaTZCLFVBQVVDLFVBQVU7b0JBQzNDYixpQkFBaUJWLFNBQVMsQ0FBQyxFQUFFLEdBQUdwRSxPQUFPLENBQUNydUQsRUFBRSxDQUFDbXZELEVBQUUsR0FBRztvQkFFaEQsSUFBSWQsT0FBTyxDQUFDcnVELElBQUksRUFBRSxJQUFJZ3RCLFFBQVFxaEMsT0FBTyxDQUFDcnVELElBQUksRUFBRSxDQUFDZ3RCLEdBQUcsRUFBRTt3QkFDaERtbUMsaUJBQWlCOUUsT0FBTyxDQUFDcnVELEVBQUUsQ0FBQ212RCxFQUFFLEdBQUc7d0JBQ2pDZ0UsaUJBQWlCNWtELGFBQWEyMUIsRUFBRSxHQUFHLFFBQVEzMUIsYUFBYTIrQyxTQUFTO29CQUNuRTtnQkFDRixPQUFPO29CQUNMNEYsYUFBYWg1QixTQUFTLENBQUNrNUIsTUFBTUMsTUFBTTtvQkFFbkMsSUFBSTFrRCxhQUFhcytDLEVBQUUsRUFBRTt3QkFDbkIsbUVBQW1FO3dCQUNuRWlHLGFBQWFoNUIsU0FBUyxDQUFDdnJCLGFBQWFzK0MsRUFBRSxDQUFDLEVBQUUsRUFBRXQrQyxhQUFhcytDLEVBQUUsQ0FBQyxFQUFFLEdBQUd0K0MsYUFBYSs5QyxNQUFNLEVBQUU7b0JBQ3ZGO29CQUVBLE9BQVEvOUMsYUFBYXRDLENBQUM7d0JBQ3BCLEtBQUs7NEJBQ0g2bUQsYUFBYWg1QixTQUFTLENBQUN1MEIsT0FBTyxDQUFDcnVELEVBQUUsQ0FBQ3N2RCxxQkFBcUIsR0FBRy9nRCxhQUFhaytDLGFBQWEsR0FBSWwrQyxDQUFBQSxhQUFhZytDLFFBQVEsR0FBR2grQyxhQUFhbytDLFVBQVUsQ0FBQzBCLE9BQU8sQ0FBQ3J1RCxFQUFFLENBQUN5VyxJQUFJLENBQUMsR0FBRyxHQUFHOzRCQUM5Sjt3QkFFRixLQUFLOzRCQUNIcThDLGFBQWFoNUIsU0FBUyxDQUFDdTBCLE9BQU8sQ0FBQ3J1RCxFQUFFLENBQUNzdkQscUJBQXFCLEdBQUcvZ0QsYUFBYWsrQyxhQUFhLEdBQUcsQ0FBQ2wrQyxhQUFhZytDLFFBQVEsR0FBR2grQyxhQUFhbytDLFVBQVUsQ0FBQzBCLE9BQU8sQ0FBQ3J1RCxFQUFFLENBQUN5VyxJQUFJLENBQUMsSUFBSSxHQUFHLEdBQUc7NEJBQ2xLO3dCQUVGOzRCQUNFO29CQUNKO29CQUVBcThDLGFBQWFoNUIsU0FBUyxDQUFDLEdBQUcsQ0FBQ3ZyQixhQUFhcStDLEVBQUU7b0JBQzFDa0csYUFBYWg1QixTQUFTLENBQUNnNkIsTUFBTSxHQUFHO29CQUNoQ2hCLGFBQWFoNUIsU0FBUyxDQUFDMjRCLFNBQVMsQ0FBQyxFQUFFLEdBQUdwRSxPQUFPLENBQUNydUQsRUFBRSxDQUFDbXZELEVBQUUsR0FBRyxPQUFPc0QsU0FBUyxDQUFDLEVBQUUsR0FBR2lCLE9BQU8sTUFBTTtvQkFDekZWLFFBQVEzRSxPQUFPLENBQUNydUQsRUFBRSxDQUFDNDVCLENBQUMsR0FBR3JyQixhQUFhMjFCLEVBQUUsR0FBRyxRQUFRMzFCLGFBQWEyK0MsU0FBUztnQkFDekU7Z0JBRUEsSUFBSStFLGVBQWUsUUFBUTtvQkFDekJ1QyxVQUFVMUIsYUFBYXAxQixLQUFLO2dCQUM5QixPQUFPLElBQUl1MEIsZUFBZSxPQUFPO29CQUMvQnVDLFVBQVUxQixhQUFhajFCLE9BQU87Z0JBQ2hDLE9BQU87b0JBQ0w0MkIsVUFBVTt3QkFBQzNCLGFBQWFqNkIsS0FBSyxDQUFDLEVBQUU7d0JBQUVpNkIsYUFBYWo2QixLQUFLLENBQUMsRUFBRTt3QkFBRWk2QixhQUFhajZCLEtBQUssQ0FBQyxFQUFFO3dCQUFFaTZCLGFBQWFqNkIsS0FBSyxDQUFDLEVBQUU7d0JBQUVpNkIsYUFBYWo2QixLQUFLLENBQUMsRUFBRTt3QkFBRWk2QixhQUFhajZCLEtBQUssQ0FBQyxFQUFFO3dCQUFFaTZCLGFBQWFqNkIsS0FBSyxDQUFDLEVBQUU7d0JBQUVpNkIsYUFBYWo2QixLQUFLLENBQUMsRUFBRTt3QkFBRWk2QixhQUFhajZCLEtBQUssQ0FBQyxFQUFFO3dCQUFFaTZCLGFBQWFqNkIsS0FBSyxDQUFDLEVBQUU7d0JBQUVpNkIsYUFBYWo2QixLQUFLLENBQUMsR0FBRzt3QkFBRWk2QixhQUFhajZCLEtBQUssQ0FBQyxHQUFHO3dCQUFFaTZCLGFBQWFqNkIsS0FBSyxDQUFDLEdBQUc7d0JBQUVpNkIsYUFBYWo2QixLQUFLLENBQUMsR0FBRzt3QkFBRWk2QixhQUFhajZCLEtBQUssQ0FBQyxHQUFHO3dCQUFFaTZCLGFBQWFqNkIsS0FBSyxDQUFDLEdBQUc7cUJBQUM7Z0JBQ2xZO2dCQUVBODdCLFVBQVVQO1lBQ1o7WUFFQSxJQUFJckIsd0JBQXdCL3lELEdBQUc7Z0JBQzdCNnpELGNBQWMsSUFBSWxJLFlBQVlnSixTQUFTTixVQUFVQyxVQUFVQyxVQUFVQyxTQUFTQztnQkFDOUUsSUFBSSxDQUFDL0IsZUFBZSxDQUFDbnhELElBQUksQ0FBQ3N5RDtnQkFDMUJkLHdCQUF3QjtnQkFDeEIsSUFBSSxDQUFDSixrQkFBa0IsR0FBRztZQUM1QixPQUFPO2dCQUNMa0IsY0FBYyxJQUFJLENBQUNuQixlQUFlLENBQUMxeUQsRUFBRTtnQkFDckMsSUFBSSxDQUFDMnlELGtCQUFrQixHQUFHa0IsWUFBWS9ILE1BQU0sQ0FBQzZJLFNBQVNOLFVBQVVDLFVBQVVDLFVBQVVDLFNBQVNDLFlBQVksSUFBSSxDQUFDOUIsa0JBQWtCO1lBQ2xJO1FBQ0Y7SUFDRjtJQUVBWCxxQkFBcUI1eEQsU0FBUyxDQUFDMHhCLFFBQVEsR0FBRztRQUN4QyxJQUFJLElBQUksQ0FBQ3VnQyxLQUFLLENBQUM1M0MsVUFBVSxDQUFDMFcsT0FBTyxLQUFLLElBQUksQ0FBQzg2QixRQUFRLEVBQUU7WUFDbkQ7UUFDRjtRQUVBLElBQUksQ0FBQ0EsUUFBUSxHQUFHLElBQUksQ0FBQ29HLEtBQUssQ0FBQzUzQyxVQUFVLENBQUMwVyxPQUFPO1FBQzdDLElBQUksQ0FBQ3VCLHdCQUF3QjtJQUMvQjtJQUVBcy9CLHFCQUFxQjV4RCxTQUFTLENBQUNvK0MsT0FBTyxHQUFHLElBQUlqbUI7SUFDN0N5NUIscUJBQXFCNXhELFNBQVMsQ0FBQ3MwRCxpQkFBaUIsR0FBRyxFQUFFO0lBQ3JENzBELGdCQUFnQjtRQUFDMHlCO0tBQXlCLEVBQUV5L0I7SUFFNUMsU0FBU2lELGdCQUFnQjtJQUV6QkEsYUFBYTcwRCxTQUFTLENBQUN1akQsV0FBVyxHQUFHLFNBQVU1NEMsSUFBSSxFQUFFMFAsVUFBVSxFQUFFbk4sSUFBSTtRQUNuRSxJQUFJLENBQUNxbEQsa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDam5DLFNBQVM7UUFDZCxJQUFJLENBQUMrdEIsWUFBWSxDQUFDMXVDLE1BQU0wUCxZQUFZbk47UUFDcEMsSUFBSSxDQUFDOGpELFlBQVksR0FBRyxJQUFJcEYsYUFBYSxJQUFJLEVBQUVqaEQsS0FBS25DLENBQUMsRUFBRSxJQUFJLENBQUM0cEIsaUJBQWlCO1FBQ3pFLElBQUksQ0FBQzBpQyxZQUFZLEdBQUcsSUFBSWxELHFCQUFxQmpuRCxLQUFLbkMsQ0FBQyxFQUFFLElBQUksQ0FBQ3FwRCxVQUFVLEVBQUUsSUFBSTtRQUMxRSxJQUFJLENBQUM5VSxhQUFhLENBQUNweUMsTUFBTTBQLFlBQVluTjtRQUNyQyxJQUFJLENBQUNpMkMsYUFBYTtRQUNsQixJQUFJLENBQUMzTixjQUFjO1FBQ25CLElBQUksQ0FBQzhMLG1CQUFtQjtRQUN4QixJQUFJLENBQUNDLHVCQUF1QjtRQUM1QixJQUFJLENBQUNnQiwwQkFBMEI7UUFDL0IsSUFBSSxDQUFDaUIsYUFBYTtRQUNsQixJQUFJLENBQUM5akMsSUFBSTtRQUNULElBQUksQ0FBQ28xQyxZQUFZLENBQUN0QyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNwZ0MsaUJBQWlCO0lBQzNEO0lBRUF5aUMsYUFBYTcwRCxTQUFTLENBQUMwWCxZQUFZLEdBQUcsU0FBVXUrQixHQUFHO1FBQ2pELElBQUksQ0FBQ3BsQixJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNtbEIsc0JBQXNCLENBQUNDO1FBQzVCLElBQUksQ0FBQ3lELGlCQUFpQixDQUFDekQsS0FBSyxJQUFJLENBQUNSLFNBQVM7SUFDNUM7SUFFQW9mLGFBQWE3MEQsU0FBUyxDQUFDKzBELGVBQWUsR0FBRyxTQUFVckMsWUFBWSxFQUFFL2xELE1BQU07UUFDckUsSUFBSWQ7UUFDSixJQUFJQyxPQUFPYSxPQUFPN00sTUFBTTtRQUN4QixJQUFJZ2dEO1FBQ0osSUFBSWtWLFdBQVc7UUFFZixJQUFLbnBELElBQUksR0FBR0EsSUFBSUMsTUFBTUQsS0FBSyxFQUFHO1lBQzVCLElBQUljLE1BQU0sQ0FBQ2QsRUFBRSxDQUFDVSxFQUFFLEtBQUssTUFBTTtnQkFDekJ1ekMsWUFBWW56QyxNQUFNLENBQUNkLEVBQUUsQ0FBQzBCLEVBQUUsQ0FBQ3hCLENBQUM7Z0JBQzFCaXBELFlBQVluTixpQkFBaUIvSCxXQUFXQSxVQUFVbGdELENBQUMsQ0FBQ0UsTUFBTSxFQUFFLE1BQU00eUQ7WUFDcEU7UUFDRjtRQUVBLE9BQU9zQztJQUNUO0lBRUFILGFBQWE3MEQsU0FBUyxDQUFDNmYsa0JBQWtCLEdBQUcsU0FBVW13QyxPQUFPLEVBQUVsd0MsS0FBSztRQUNsRSxJQUFJLENBQUNreEMsWUFBWSxDQUFDbnhDLGtCQUFrQixDQUFDbXdDLFNBQVNsd0M7SUFDaEQ7SUFFQSswQyxhQUFhNzBELFNBQVMsQ0FBQ213RCxhQUFhLEdBQUcsU0FBVUMsVUFBVTtRQUN6RCxJQUFJLENBQUNZLFlBQVksQ0FBQ2IsYUFBYSxDQUFDQztJQUNsQztJQUVBeUUsYUFBYTcwRCxTQUFTLENBQUNxd0Qsa0JBQWtCLEdBQUcsU0FBVTRFLFNBQVM7UUFDN0QsSUFBSSxDQUFDakUsWUFBWSxDQUFDWCxrQkFBa0IsQ0FBQzRFO0lBQ3ZDO0lBRUFKLGFBQWE3MEQsU0FBUyxDQUFDazFELDJCQUEyQixHQUFHLFNBQVUvbUQsWUFBWSxFQUFFdWtELFlBQVksRUFBRXlDLFVBQVUsRUFBRXZDLElBQUksRUFBRUMsSUFBSTtRQUMvRyxJQUFJMWtELGFBQWFzK0MsRUFBRSxFQUFFO1lBQ25CaUcsYUFBYWg1QixTQUFTLENBQUN2ckIsYUFBYXMrQyxFQUFFLENBQUMsRUFBRSxFQUFFdCtDLGFBQWFzK0MsRUFBRSxDQUFDLEVBQUUsR0FBR3QrQyxhQUFhKzlDLE1BQU0sRUFBRTtRQUN2RjtRQUVBd0csYUFBYWg1QixTQUFTLENBQUMsR0FBRyxDQUFDdnJCLGFBQWFxK0MsRUFBRSxFQUFFO1FBRTVDLE9BQVFyK0MsYUFBYXRDLENBQUM7WUFDcEIsS0FBSztnQkFDSDZtRCxhQUFhaDVCLFNBQVMsQ0FBQ3ZyQixhQUFhaytDLGFBQWEsR0FBSWwrQyxDQUFBQSxhQUFhZytDLFFBQVEsR0FBR2grQyxhQUFhbytDLFVBQVUsQ0FBQzRJLFdBQVcsR0FBRyxHQUFHO2dCQUN0SDtZQUVGLEtBQUs7Z0JBQ0h6QyxhQUFhaDVCLFNBQVMsQ0FBQ3ZyQixhQUFhaytDLGFBQWEsR0FBRyxDQUFDbCtDLGFBQWFnK0MsUUFBUSxHQUFHaCtDLGFBQWFvK0MsVUFBVSxDQUFDNEksV0FBVyxJQUFJLEdBQUcsR0FBRztnQkFDMUg7WUFFRjtnQkFDRTtRQUNKO1FBRUF6QyxhQUFhaDVCLFNBQVMsQ0FBQ2s1QixNQUFNQyxNQUFNO0lBQ3JDO0lBRUFnQyxhQUFhNzBELFNBQVMsQ0FBQ28xRCxVQUFVLEdBQUcsU0FBVUMsU0FBUztRQUNyRCxPQUFPLFNBQVNueEQsS0FBS3dCLEtBQUssQ0FBQzJ2RCxTQUFTLENBQUMsRUFBRSxHQUFHLE9BQU8sTUFBTW54RCxLQUFLd0IsS0FBSyxDQUFDMnZELFNBQVMsQ0FBQyxFQUFFLEdBQUcsT0FBTyxNQUFNbnhELEtBQUt3QixLQUFLLENBQUMydkQsU0FBUyxDQUFDLEVBQUUsR0FBRyxPQUFPO0lBQ2pJO0lBRUFSLGFBQWE3MEQsU0FBUyxDQUFDczFELFNBQVMsR0FBRyxJQUFJL0o7SUFFdkNzSixhQUFhNzBELFNBQVMsQ0FBQ21WLE9BQU8sR0FBRyxZQUFhO0lBRTlDMC9DLGFBQWE3MEQsU0FBUyxDQUFDdTFELFlBQVksR0FBRztRQUNwQyxJQUFJLElBQUksQ0FBQ3ZFLFlBQVksQ0FBQ25nQyxJQUFJLElBQUksSUFBSSxDQUFDbWdDLFlBQVksQ0FBQzkvQixhQUFhLEVBQUU7WUFDN0QsSUFBSSxDQUFDc2tDLFlBQVk7WUFDakIsSUFBSSxDQUFDeEUsWUFBWSxDQUFDOS9CLGFBQWEsR0FBRztZQUNsQyxJQUFJLENBQUM4L0IsWUFBWSxDQUFDbmdDLElBQUksR0FBRztRQUMzQjtJQUNGO0lBRUEsSUFBSTRrQyxpQkFBaUI7UUFDbkI5b0QsUUFBUSxFQUFFO0lBQ1o7SUFFQSxTQUFTK29ELHFCQUFxQi9xRCxJQUFJLEVBQUUwUCxVQUFVLEVBQUVuTixJQUFJO1FBQ2xELElBQUksQ0FBQ3lvRCxTQUFTLEdBQUcsRUFBRTtRQUNuQixJQUFJLENBQUM5RCxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDdE8sV0FBVyxDQUFDNTRDLE1BQU0wUCxZQUFZbk47SUFDckM7SUFFQXpOLGdCQUFnQjtRQUFDcTRDO1FBQWFnRjtRQUFrQnVFO1FBQWdCNkI7UUFBa0J6SjtRQUFjNEo7UUFBc0J3UjtLQUFhLEVBQUVhO0lBRXJJQSxxQkFBcUIxMUQsU0FBUyxDQUFDd2pELGFBQWEsR0FBRztRQUM3QyxJQUFJLElBQUksQ0FBQzc0QyxJQUFJLENBQUNpckQsV0FBVyxJQUFJLENBQUMsSUFBSSxDQUFDdjdDLFVBQVUsQ0FBQ29CLFdBQVcsQ0FBQzNPLEtBQUssRUFBRTtZQUMvRCxJQUFJLENBQUMrb0QsYUFBYSxHQUFHOXJELFNBQVM7UUFDaEM7SUFDRjtJQUVBMnJELHFCQUFxQjExRCxTQUFTLENBQUM4MUQsaUJBQWlCLEdBQUcsU0FBVUMsU0FBUztRQUNwRSxJQUFJbjJELElBQUk7UUFDUixJQUFJQyxNQUFNazJELFVBQVVqMkQsTUFBTTtRQUMxQixJQUFJazJELGVBQWUsRUFBRTtRQUNyQixJQUFJQyxxQkFBcUI7UUFFekIsTUFBT3IyRCxJQUFJQyxJQUFLO1lBQ2QsSUFBSWsyRCxTQUFTLENBQUNuMkQsRUFBRSxLQUFLczJELE9BQU9DLFlBQVksQ0FBQyxPQUFPSixTQUFTLENBQUNuMkQsRUFBRSxLQUFLczJELE9BQU9DLFlBQVksQ0FBQyxJQUFJO2dCQUN2RkgsYUFBYTcwRCxJQUFJLENBQUM4MEQ7Z0JBQ2xCQSxxQkFBcUI7WUFDdkIsT0FBTztnQkFDTEEsc0JBQXNCRixTQUFTLENBQUNuMkQsRUFBRTtZQUNwQztZQUVBQSxLQUFLO1FBQ1A7UUFFQW8yRCxhQUFhNzBELElBQUksQ0FBQzgwRDtRQUNsQixPQUFPRDtJQUNUO0lBRUFOLHFCQUFxQjExRCxTQUFTLENBQUNvMkQsY0FBYyxHQUFHLFNBQVV6ckQsSUFBSSxFQUFFMHVCLEtBQUs7UUFDbkUsMEdBQTBHO1FBQzFHLDBGQUEwRjtRQUMxRix5R0FBeUc7UUFDekcscUZBQXFGO1FBQ3JGLElBQUkxdUIsS0FBS2dDLE1BQU0sSUFBSWhDLEtBQUtnQyxNQUFNLENBQUM3TSxNQUFNLEVBQUU7WUFDckMsSUFBSWkwQixRQUFRcHBCLEtBQUtnQyxNQUFNLENBQUMsRUFBRTtZQUUxQixJQUFJb25CLE1BQU12bUIsRUFBRSxFQUFFO2dCQUNaLElBQUk2b0QsWUFBWXRpQyxNQUFNdm1CLEVBQUUsQ0FBQ3VtQixNQUFNdm1CLEVBQUUsQ0FBQzFOLE1BQU0sR0FBRyxFQUFFO2dCQUU3QyxJQUFJdTJELFVBQVVydUQsQ0FBQyxFQUFFO29CQUNmcXVELFVBQVVydUQsQ0FBQyxDQUFDK0QsQ0FBQyxDQUFDLEVBQUUsR0FBR3N0QjtvQkFDbkJnOUIsVUFBVXJ1RCxDQUFDLENBQUMrRCxDQUFDLENBQUMsRUFBRSxHQUFHc3RCO2dCQUNyQjtZQUNGO1FBQ0Y7UUFFQSxPQUFPMXVCO0lBQ1Q7SUFFQStxRCxxQkFBcUIxMUQsU0FBUyxDQUFDdzFELFlBQVksR0FBRztRQUM1QyxJQUFJLENBQUNqa0Msa0JBQWtCLENBQUMsSUFBSTtRQUM1QixJQUFJM3hCO1FBQ0osSUFBSUM7UUFDSixJQUFJc08sZUFBZSxJQUFJLENBQUM2aUQsWUFBWSxDQUFDL0UsV0FBVztRQUNoRCxJQUFJLENBQUNxRyxlQUFlLEdBQUd0dkQsaUJBQWlCbUwsZUFBZUEsYUFBYXFyQixDQUFDLENBQUMxNUIsTUFBTSxHQUFHO1FBRS9FLElBQUlxTyxhQUFhczlDLEVBQUUsRUFBRTtZQUNuQixJQUFJLENBQUNyUyxZQUFZLENBQUN6M0IsWUFBWSxDQUFDLFFBQVEsSUFBSSxDQUFDeXpDLFVBQVUsQ0FBQ2puRCxhQUFhczlDLEVBQUU7UUFDeEUsT0FBTztZQUNMLElBQUksQ0FBQ3JTLFlBQVksQ0FBQ3ozQixZQUFZLENBQUMsUUFBUTtRQUN6QztRQUVBLElBQUl4VCxhQUFhNmtDLEVBQUUsRUFBRTtZQUNuQixJQUFJLENBQUNvRyxZQUFZLENBQUN6M0IsWUFBWSxDQUFDLFVBQVUsSUFBSSxDQUFDeXpDLFVBQVUsQ0FBQ2puRCxhQUFhNmtDLEVBQUU7WUFDeEUsSUFBSSxDQUFDb0csWUFBWSxDQUFDejNCLFlBQVksQ0FBQyxnQkFBZ0J4VCxhQUFhcTlDLEVBQUU7UUFDaEU7UUFFQSxJQUFJLENBQUNwUyxZQUFZLENBQUN6M0IsWUFBWSxDQUFDLGFBQWF4VCxhQUFhMitDLFNBQVM7UUFDbEUsSUFBSXZlLFdBQVcsSUFBSSxDQUFDbDBCLFVBQVUsQ0FBQ29CLFdBQVcsQ0FBQ2s0QixhQUFhLENBQUN4bEMsYUFBYTlGLENBQUM7UUFFdkUsSUFBSWttQyxTQUFTd0QsTUFBTSxFQUFFO1lBQ25CLElBQUksQ0FBQ3FILFlBQVksQ0FBQ3ozQixZQUFZLENBQUMsU0FBUzRzQixTQUFTd0QsTUFBTTtRQUN6RCxPQUFPO1lBQ0wsSUFBSSxDQUFDcUgsWUFBWSxDQUFDejNCLFlBQVksQ0FBQyxlQUFlNHNCLFNBQVNzRCxPQUFPO1lBQzlELElBQUluRCxVQUFVdmdDLGFBQWF1Z0MsT0FBTztZQUNsQyxJQUFJRCxTQUFTdGdDLGFBQWFzZ0MsTUFBTTtZQUNoQyxJQUFJLENBQUMySyxZQUFZLENBQUN6M0IsWUFBWSxDQUFDLGNBQWM4c0I7WUFDN0MsSUFBSSxDQUFDMkssWUFBWSxDQUFDejNCLFlBQVksQ0FBQyxlQUFlK3NCO1FBQ2hEO1FBRUEsSUFBSSxDQUFDMEssWUFBWSxDQUFDejNCLFlBQVksQ0FBQyxjQUFjeFQsYUFBYTNGLENBQUM7UUFDM0QsSUFBSXlsRCxVQUFVOS9DLGFBQWFxckIsQ0FBQyxJQUFJLEVBQUU7UUFDbEMsSUFBSTg4QixhQUFhLENBQUMsQ0FBQyxJQUFJLENBQUNqOEMsVUFBVSxDQUFDb0IsV0FBVyxDQUFDM08sS0FBSztRQUNwRGpOLE1BQU1vdUQsUUFBUW51RCxNQUFNO1FBQ3BCLElBQUl5MkQ7UUFDSixJQUFJN0QsZUFBZSxJQUFJLENBQUN0VSxPQUFPO1FBQy9CLElBQUk0VyxXQUFXO1FBQ2YsSUFBSVksY0FBYyxJQUFJLENBQUNqckQsSUFBSSxDQUFDaXJELFdBQVc7UUFDdkMsSUFBSWhELE9BQU87UUFDWCxJQUFJQyxPQUFPO1FBQ1gsSUFBSVUsWUFBWTtRQUNoQixJQUFJOUUsaUJBQWlCdGdELGFBQWEyMUIsRUFBRSxHQUFHLFFBQVEzMUIsYUFBYTIrQyxTQUFTO1FBRXJFLElBQUk4SSxlQUFlLENBQUNVLGNBQWMsQ0FBQ25vRCxhQUFhbXJCLEVBQUUsRUFBRTtZQUNsRCxJQUFJazlCLFdBQVcsSUFBSSxDQUFDWCxhQUFhO1lBQ2pDLElBQUlZLFVBQVU7WUFFZCxPQUFRdG9ELGFBQWF0QyxDQUFDO2dCQUNwQixLQUFLO29CQUNINHFELFVBQVU7b0JBQ1Y7Z0JBRUYsS0FBSztvQkFDSEEsVUFBVTtvQkFDVjtnQkFFRjtvQkFDRUEsVUFBVTtvQkFDVjtZQUNKO1lBRUFELFNBQVM3MEMsWUFBWSxDQUFDLGVBQWU4MEM7WUFDckNELFNBQVM3MEMsWUFBWSxDQUFDLGtCQUFrQjhzQztZQUN4QyxJQUFJM2MsY0FBYyxJQUFJLENBQUNna0IsaUJBQWlCLENBQUMzbkQsYUFBYTQrQyxTQUFTO1lBQy9EbHRELE1BQU1peUMsWUFBWWh5QyxNQUFNO1lBQ3hCK3lELE9BQU8xa0QsYUFBYXMrQyxFQUFFLEdBQUd0K0MsYUFBYXMrQyxFQUFFLENBQUMsRUFBRSxHQUFHdCtDLGFBQWErOUMsTUFBTSxHQUFHO1lBRXBFLElBQUt0c0QsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7Z0JBQzNCMjJELFFBQVEsSUFBSSxDQUFDWixTQUFTLENBQUMvMUQsRUFBRSxDQUFDODJELElBQUksSUFBSTNzRCxTQUFTO2dCQUMzQ3dzRCxNQUFNemtCLFdBQVcsR0FBR0EsV0FBVyxDQUFDbHlDLEVBQUU7Z0JBQ2xDMjJELE1BQU01MEMsWUFBWSxDQUFDLEtBQUs7Z0JBQ3hCNDBDLE1BQU01MEMsWUFBWSxDQUFDLEtBQUtreEM7Z0JBQ3hCMEQsTUFBTTF3RCxLQUFLLENBQUNJLE9BQU8sR0FBRztnQkFDdEJ1d0QsU0FBU2xpRCxXQUFXLENBQUNpaUQ7Z0JBRXJCLElBQUksQ0FBQyxJQUFJLENBQUNaLFNBQVMsQ0FBQy8xRCxFQUFFLEVBQUU7b0JBQ3RCLElBQUksQ0FBQysxRCxTQUFTLENBQUMvMUQsRUFBRSxHQUFHO3dCQUNsQjgyRCxNQUFNO3dCQUNOQyxPQUFPO29CQUNUO2dCQUNGO2dCQUVBLElBQUksQ0FBQ2hCLFNBQVMsQ0FBQy8xRCxFQUFFLENBQUM4MkQsSUFBSSxHQUFHSDtnQkFDekIxRCxRQUFRMWtELGFBQWE2K0MsZUFBZTtZQUN0QztZQUVBLElBQUksQ0FBQzVULFlBQVksQ0FBQzlrQyxXQUFXLENBQUNraUQ7UUFDaEMsT0FBTztZQUNMLElBQUlJLG9CQUFvQixJQUFJLENBQUNqQixTQUFTLENBQUM3MUQsTUFBTTtZQUM3QyxJQUFJeU87WUFFSixJQUFLM08sSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7Z0JBQzNCLElBQUksQ0FBQyxJQUFJLENBQUMrMUQsU0FBUyxDQUFDLzFELEVBQUUsRUFBRTtvQkFDdEIsSUFBSSxDQUFDKzFELFNBQVMsQ0FBQy8xRCxFQUFFLEdBQUc7d0JBQ2xCODJELE1BQU07d0JBQ05HLFdBQVc7d0JBQ1hGLE9BQU87b0JBQ1Q7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDTCxjQUFjLENBQUNWLGVBQWVoMkQsTUFBTSxHQUFHO29CQUMxQzIyRCxRQUFRSyxvQkFBb0JoM0QsSUFBSSxJQUFJLENBQUMrMUQsU0FBUyxDQUFDLzFELEVBQUUsQ0FBQzgyRCxJQUFJLEdBQUczc0QsU0FBU3VzRCxhQUFhLE1BQU07b0JBRXJGLElBQUlNLHFCQUFxQmgzRCxHQUFHO3dCQUMxQjIyRCxNQUFNNTBDLFlBQVksQ0FBQyxrQkFBa0I7d0JBQ3JDNDBDLE1BQU01MEMsWUFBWSxDQUFDLG1CQUFtQjt3QkFDdEM0MEMsTUFBTTUwQyxZQUFZLENBQUMscUJBQXFCO3dCQUN4QyxJQUFJLENBQUNnMEMsU0FBUyxDQUFDLzFELEVBQUUsQ0FBQzgyRCxJQUFJLEdBQUdIO3dCQUV6QixJQUFJRCxZQUFZOzRCQUNkLElBQUlPLFlBQVk5c0QsU0FBUzs0QkFDekJ3c0QsTUFBTWppRCxXQUFXLENBQUN1aUQ7NEJBQ2xCLElBQUksQ0FBQ2xCLFNBQVMsQ0FBQy8xRCxFQUFFLENBQUNpM0QsU0FBUyxHQUFHQTt3QkFDaEM7d0JBRUEsSUFBSSxDQUFDbEIsU0FBUyxDQUFDLzFELEVBQUUsQ0FBQzgyRCxJQUFJLEdBQUdIO3dCQUN6QixJQUFJLENBQUNuZCxZQUFZLENBQUM5a0MsV0FBVyxDQUFDaWlEO29CQUNoQztvQkFFQUEsTUFBTTF3RCxLQUFLLENBQUNJLE9BQU8sR0FBRztnQkFDeEI7Z0JBRUF5c0QsYUFBYXA5QixLQUFLO2dCQUVsQixJQUFJc2dDLGFBQWE7b0JBQ2YsSUFBSTNILE9BQU8sQ0FBQ3J1RCxFQUFFLENBQUNtdEIsQ0FBQyxFQUFFO3dCQUNoQjZsQyxPQUFPLENBQUNuRTt3QkFDUm9FLFFBQVExa0QsYUFBYTArQyxPQUFPO3dCQUM1QmdHLFFBQVFVLFlBQVksSUFBSTt3QkFDeEJBLFlBQVk7b0JBQ2Q7b0JBRUEsSUFBSSxDQUFDMkIsMkJBQTJCLENBQUMvbUQsY0FBY3VrRCxjQUFjekUsT0FBTyxDQUFDcnVELEVBQUUsQ0FBQ3lXLElBQUksRUFBRXU4QyxNQUFNQztvQkFDcEZELFFBQVEzRSxPQUFPLENBQUNydUQsRUFBRSxDQUFDNDVCLENBQUMsSUFBSSxHQUFHLHVEQUF1RDtvQkFFbEZvNUIsUUFBUW5FO2dCQUNWO2dCQUVBLElBQUk2SCxZQUFZO29CQUNkL25ELFdBQVcsSUFBSSxDQUFDOEwsVUFBVSxDQUFDb0IsV0FBVyxDQUFDMDNCLFdBQVcsQ0FBQ2hsQyxhQUFhNCtDLFNBQVMsQ0FBQ250RCxFQUFFLEVBQUUydUMsU0FBU0UsTUFBTSxFQUFFLElBQUksQ0FBQ3AwQixVQUFVLENBQUNvQixXQUFXLENBQUNrNEIsYUFBYSxDQUFDeGxDLGFBQWE5RixDQUFDLEVBQUV3cEMsT0FBTztvQkFDaEssSUFBSWlsQixjQUFjLHdFQUF3RTtvQkFFMUYsSUFBSXZvRCxTQUFTL0YsQ0FBQyxLQUFLLEdBQUc7d0JBQ3BCc3VELGVBQWUsSUFBSUMsZUFBZXhvRCxTQUFTNUQsSUFBSSxFQUFFLElBQUksQ0FBQzBQLFVBQVUsRUFBRSxJQUFJO29CQUN4RSxPQUFPO3dCQUNMLElBQUkxUCxPQUFPOHFEO3dCQUVYLElBQUlsbkQsU0FBUzVELElBQUksSUFBSTRELFNBQVM1RCxJQUFJLENBQUNnQyxNQUFNLEVBQUU7NEJBQ3pDaEMsT0FBTyxJQUFJLENBQUN5ckQsY0FBYyxDQUFDN25ELFNBQVM1RCxJQUFJLEVBQUV3RCxhQUFhMitDLFNBQVM7d0JBQ2xFO3dCQUVBZ0ssZUFBZSxJQUFJck4sZ0JBQWdCOStDLE1BQU0sSUFBSSxDQUFDMFAsVUFBVSxFQUFFLElBQUk7b0JBQ2hFO29CQUVBLElBQUksSUFBSSxDQUFDczdDLFNBQVMsQ0FBQy8xRCxFQUFFLENBQUMrMkQsS0FBSyxFQUFFO3dCQUMzQixJQUFJQSxRQUFRLElBQUksQ0FBQ2hCLFNBQVMsQ0FBQy8xRCxFQUFFLENBQUMrMkQsS0FBSzt3QkFDbkMsSUFBSSxDQUFDaEIsU0FBUyxDQUFDLzFELEVBQUUsQ0FBQ2kzRCxTQUFTLENBQUMzbEIsV0FBVyxDQUFDeWxCLE1BQU12ZCxZQUFZO3dCQUMxRHVkLE1BQU14aEQsT0FBTztvQkFDZjtvQkFFQSxJQUFJLENBQUN3Z0QsU0FBUyxDQUFDLzFELEVBQUUsQ0FBQysyRCxLQUFLLEdBQUdHO29CQUMxQkEsYUFBYUUsTUFBTSxHQUFHO29CQUN0QkYsYUFBYXAvQyxZQUFZLENBQUM7b0JBQzFCby9DLGFBQWExNUMsV0FBVztvQkFDeEIsSUFBSSxDQUFDdTRDLFNBQVMsQ0FBQy8xRCxFQUFFLENBQUNpM0QsU0FBUyxDQUFDdmlELFdBQVcsQ0FBQ3dpRCxhQUFhMWQsWUFBWSxHQUFHLCtGQUErRjtvQkFDbkssMEVBQTBFO29CQUUxRSxJQUFJN3FDLFNBQVMvRixDQUFDLEtBQUssR0FBRzt3QkFDcEIsSUFBSSxDQUFDbXRELFNBQVMsQ0FBQy8xRCxFQUFFLENBQUNpM0QsU0FBUyxDQUFDbDFDLFlBQVksQ0FBQyxhQUFhLFdBQVd4VCxhQUFhMitDLFNBQVMsR0FBRyxNQUFNLE1BQU0zK0MsYUFBYTIrQyxTQUFTLEdBQUcsTUFBTTtvQkFDdkk7Z0JBQ0YsT0FBTztvQkFDTCxJQUFJOEksYUFBYTt3QkFDZlcsTUFBTTUwQyxZQUFZLENBQUMsYUFBYSxlQUFlK3dDLGFBQWFqNkIsS0FBSyxDQUFDLEdBQUcsR0FBRyxNQUFNaTZCLGFBQWFqNkIsS0FBSyxDQUFDLEdBQUcsR0FBRztvQkFDekc7b0JBRUE4OUIsTUFBTXprQixXQUFXLEdBQUdtYyxPQUFPLENBQUNydUQsRUFBRSxDQUFDcUYsR0FBRztvQkFDbENzeEQsTUFBTXBpRCxjQUFjLENBQUMsd0NBQXdDLGFBQWE7Z0JBQzVFLEVBQUUsRUFBRTtZQUVOO1lBRUEsSUFBSXloRCxlQUFlVyxPQUFPO2dCQUN4QkEsTUFBTTUwQyxZQUFZLENBQUMsS0FBS3F6QztZQUMxQjtRQUNGO1FBRUEsTUFBT3AxRCxJQUFJLElBQUksQ0FBQysxRCxTQUFTLENBQUM3MUQsTUFBTSxDQUFFO1lBQ2hDLElBQUksQ0FBQzYxRCxTQUFTLENBQUMvMUQsRUFBRSxDQUFDODJELElBQUksQ0FBQzd3RCxLQUFLLENBQUNJLE9BQU8sR0FBRztZQUN2Q3JHLEtBQUs7UUFDUDtRQUVBLElBQUksQ0FBQzhoRCxZQUFZLEdBQUc7SUFDdEI7SUFFQWdVLHFCQUFxQjExRCxTQUFTLENBQUN5MkMsZ0JBQWdCLEdBQUc7UUFDaEQsSUFBSSxDQUFDLytCLFlBQVksQ0FBQyxJQUFJLENBQUN4SyxJQUFJLENBQUNvakIsYUFBYSxHQUFHLElBQUksQ0FBQzNsQixJQUFJLENBQUMrRCxFQUFFO1FBQ3hELElBQUksQ0FBQyswQyxrQkFBa0I7UUFFdkIsSUFBSSxJQUFJLENBQUMvQixZQUFZLEVBQUU7WUFDckIsSUFBSSxDQUFDQSxZQUFZLEdBQUc7WUFDcEIsSUFBSXVWLFVBQVUsSUFBSSxDQUFDN2QsWUFBWSxDQUFDeGxDLE9BQU87WUFDdkMsSUFBSSxDQUFDc2pELElBQUksR0FBRztnQkFDVm54RCxLQUFLa3hELFFBQVFucUMsQ0FBQztnQkFDZDltQixNQUFNaXhELFFBQVF6eUMsQ0FBQztnQkFDZnBTLE9BQU82a0QsUUFBUTdrRCxLQUFLO2dCQUNwQkMsUUFBUTRrRCxRQUFRNWtELE1BQU07WUFDeEI7UUFDRjtRQUVBLE9BQU8sSUFBSSxDQUFDNmtELElBQUk7SUFDbEI7SUFFQXhCLHFCQUFxQjExRCxTQUFTLENBQUMweEIsUUFBUSxHQUFHO1FBQ3hDLElBQUk5eEI7UUFDSixJQUFJQyxNQUFNLElBQUksQ0FBQzgxRCxTQUFTLENBQUM3MUQsTUFBTTtRQUMvQixJQUFJZzNEO1FBQ0osSUFBSSxDQUFDeG1DLGFBQWEsR0FBRyxJQUFJLENBQUNwakIsSUFBSSxDQUFDb2pCLGFBQWE7UUFFNUMsSUFBSzF3QixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQmszRCxlQUFlLElBQUksQ0FBQ25CLFNBQVMsQ0FBQy8xRCxFQUFFLENBQUMrMkQsS0FBSztZQUV0QyxJQUFJRyxjQUFjO2dCQUNoQkEsYUFBYXAvQyxZQUFZLENBQUMsSUFBSSxDQUFDeEssSUFBSSxDQUFDb2pCLGFBQWEsR0FBRyxJQUFJLENBQUMzbEIsSUFBSSxDQUFDK0QsRUFBRTtnQkFFaEUsSUFBSW9vRCxhQUFham1DLElBQUksRUFBRTtvQkFDckIsSUFBSSxDQUFDQSxJQUFJLEdBQUc7Z0JBQ2Q7WUFDRjtRQUNGO0lBQ0Y7SUFFQTZrQyxxQkFBcUIxMUQsU0FBUyxDQUFDeWpELGtCQUFrQixHQUFHO1FBQ2xELElBQUksQ0FBQzhSLFlBQVk7UUFFakIsSUFBSSxDQUFDLElBQUksQ0FBQzVxRCxJQUFJLENBQUNpckQsV0FBVyxJQUFJLElBQUksQ0FBQy9rQyxJQUFJLEVBQUU7WUFDdkMsSUFBSSxDQUFDaWtDLFlBQVksQ0FBQ3JDLFdBQVcsQ0FBQyxJQUFJLENBQUN6QixZQUFZLENBQUMvRSxXQUFXLEVBQUUsSUFBSSxDQUFDc0csa0JBQWtCO1lBRXBGLElBQUksSUFBSSxDQUFDQSxrQkFBa0IsSUFBSSxJQUFJLENBQUN1QyxZQUFZLENBQUN2QyxrQkFBa0IsRUFBRTtnQkFDbkUsSUFBSSxDQUFDN1EsWUFBWSxHQUFHO2dCQUNwQixJQUFJOWhEO2dCQUNKLElBQUlDO2dCQUNKLElBQUl5eUQsa0JBQWtCLElBQUksQ0FBQ3dDLFlBQVksQ0FBQ3hDLGVBQWU7Z0JBQ3ZELElBQUlyRSxVQUFVLElBQUksQ0FBQytDLFlBQVksQ0FBQy9FLFdBQVcsQ0FBQ3p5QixDQUFDO2dCQUM3QzM1QixNQUFNb3VELFFBQVFudUQsTUFBTTtnQkFDcEIsSUFBSXEzRDtnQkFDSixJQUFJQztnQkFDSixJQUFJTjtnQkFFSixJQUFLbDNELElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO29CQUMzQixJQUFJLENBQUNxdUQsT0FBTyxDQUFDcnVELEVBQUUsQ0FBQ210QixDQUFDLEVBQUU7d0JBQ2pCb3FDLGlCQUFpQjdFLGVBQWUsQ0FBQzF5RCxFQUFFO3dCQUNuQ3czRCxXQUFXLElBQUksQ0FBQ3pCLFNBQVMsQ0FBQy8xRCxFQUFFLENBQUM4MkQsSUFBSTt3QkFDakNJLGVBQWUsSUFBSSxDQUFDbkIsU0FBUyxDQUFDLzFELEVBQUUsQ0FBQysyRCxLQUFLO3dCQUV0QyxJQUFJRyxjQUFjOzRCQUNoQkEsYUFBYTE1QyxXQUFXO3dCQUMxQjt3QkFFQSxJQUFJKzVDLGVBQWV0bUMsSUFBSSxDQUFDNEksQ0FBQyxFQUFFOzRCQUN6QjI5QixTQUFTejFDLFlBQVksQ0FBQyxhQUFhdzFDLGVBQWUxOUIsQ0FBQzt3QkFDckQ7d0JBRUEsSUFBSTA5QixlQUFldG1DLElBQUksQ0FBQ3BqQixDQUFDLEVBQUU7NEJBQ3pCMnBELFNBQVN6MUMsWUFBWSxDQUFDLFdBQVd3MUMsZUFBZTFwRCxDQUFDO3dCQUNuRDt3QkFFQSxJQUFJMHBELGVBQWV0bUMsSUFBSSxDQUFDMjZCLEVBQUUsRUFBRTs0QkFDMUI0TCxTQUFTejFDLFlBQVksQ0FBQyxnQkFBZ0J3MUMsZUFBZTNMLEVBQUU7d0JBQ3pEO3dCQUVBLElBQUkyTCxlQUFldG1DLElBQUksQ0FBQ21pQixFQUFFLEVBQUU7NEJBQzFCb2tCLFNBQVN6MUMsWUFBWSxDQUFDLFVBQVV3MUMsZUFBZW5rQixFQUFFO3dCQUNuRDt3QkFFQSxJQUFJbWtCLGVBQWV0bUMsSUFBSSxDQUFDNDZCLEVBQUUsRUFBRTs0QkFDMUIyTCxTQUFTejFDLFlBQVksQ0FBQyxRQUFRdzFDLGVBQWUxTCxFQUFFO3dCQUNqRDtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUVBLFNBQVM0TCxjQUFjMXNELElBQUksRUFBRTBQLFVBQVUsRUFBRW5OLElBQUk7UUFDM0MsSUFBSSxDQUFDcTJDLFdBQVcsQ0FBQzU0QyxNQUFNMFAsWUFBWW5OO0lBQ3JDO0lBRUF6TixnQkFBZ0I7UUFBQ2trRDtLQUFjLEVBQUUwVDtJQUVqQ0EsY0FBY3IzRCxTQUFTLENBQUN3akQsYUFBYSxHQUFHO1FBQ3RDLElBQUk3RSxPQUFPNTBDLFNBQVMsU0FBUyxxQ0FBcUM7UUFDbEUsc0NBQXNDO1FBQ3RDLG9DQUFvQztRQUVwQzQwQyxLQUFLaDlCLFlBQVksQ0FBQyxTQUFTLElBQUksQ0FBQ2hYLElBQUksQ0FBQzZnRCxFQUFFO1FBQ3ZDN00sS0FBS2g5QixZQUFZLENBQUMsVUFBVSxJQUFJLENBQUNoWCxJQUFJLENBQUNnakIsRUFBRTtRQUN4Q2d4QixLQUFLaDlCLFlBQVksQ0FBQyxRQUFRLElBQUksQ0FBQ2hYLElBQUksQ0FBQ3FvQyxFQUFFO1FBQ3RDLElBQUksQ0FBQ29HLFlBQVksQ0FBQzlrQyxXQUFXLENBQUNxcUM7SUFDaEM7SUFFQSxTQUFTMlksWUFBWTNzRCxJQUFJLEVBQUUwUCxVQUFVLEVBQUVuTixJQUFJO1FBQ3pDLElBQUksQ0FBQ29lLFNBQVM7UUFDZCxJQUFJLENBQUMrdEIsWUFBWSxDQUFDMXVDLE1BQU0wUCxZQUFZbk47UUFDcEMsSUFBSSxDQUFDb2UsU0FBUztRQUNkLElBQUksQ0FBQ3l4QixhQUFhLENBQUNweUMsTUFBTTBQLFlBQVluTjtRQUNyQyxJQUFJLENBQUNpMkMsYUFBYTtJQUNwQjtJQUVBbVUsWUFBWXQzRCxTQUFTLENBQUMwWCxZQUFZLEdBQUcsU0FBVXUrQixHQUFHO1FBQ2hELElBQUksQ0FBQ3lELGlCQUFpQixDQUFDekQsS0FBSztJQUM5QjtJQUVBcWhCLFlBQVl0M0QsU0FBUyxDQUFDb2QsV0FBVyxHQUFHLFlBQWE7SUFFakRrNkMsWUFBWXQzRCxTQUFTLENBQUMrNUMsY0FBYyxHQUFHO1FBQ3JDLE9BQU87SUFDVDtJQUVBdWQsWUFBWXQzRCxTQUFTLENBQUNtVixPQUFPLEdBQUcsWUFBYTtJQUU3Q21pRCxZQUFZdDNELFNBQVMsQ0FBQ3kyQyxnQkFBZ0IsR0FBRyxZQUFhO0lBRXRENmdCLFlBQVl0M0QsU0FBUyxDQUFDMGYsSUFBSSxHQUFHLFlBQWE7SUFFMUNqZ0IsZ0JBQWdCO1FBQUNxNEM7UUFBYWdGO1FBQWtCb0c7UUFBa0J6SjtLQUFhLEVBQUU2ZDtJQUVqRixTQUFTQyxtQkFBbUI7SUFFNUI5M0QsZ0JBQWdCO1FBQUNxN0M7S0FBYSxFQUFFeWM7SUFFaENBLGdCQUFnQnYzRCxTQUFTLENBQUN1N0MsVUFBVSxHQUFHLFNBQVU1d0MsSUFBSTtRQUNuRCxPQUFPLElBQUkyc0QsWUFBWTNzRCxNQUFNLElBQUksQ0FBQzBQLFVBQVUsRUFBRSxJQUFJO0lBQ3BEO0lBRUFrOUMsZ0JBQWdCdjNELFNBQVMsQ0FBQ3c3QyxXQUFXLEdBQUcsU0FBVTd3QyxJQUFJO1FBQ3BELE9BQU8sSUFBSTgrQyxnQkFBZ0I5K0MsTUFBTSxJQUFJLENBQUMwUCxVQUFVLEVBQUUsSUFBSTtJQUN4RDtJQUVBazlDLGdCQUFnQnYzRCxTQUFTLENBQUN5N0MsVUFBVSxHQUFHLFNBQVU5d0MsSUFBSTtRQUNuRCxPQUFPLElBQUkrcUQscUJBQXFCL3FELE1BQU0sSUFBSSxDQUFDMFAsVUFBVSxFQUFFLElBQUk7SUFDN0Q7SUFFQWs5QyxnQkFBZ0J2M0QsU0FBUyxDQUFDbzdDLFdBQVcsR0FBRyxTQUFVendDLElBQUk7UUFDcEQsT0FBTyxJQUFJZzVDLGNBQWNoNUMsTUFBTSxJQUFJLENBQUMwUCxVQUFVLEVBQUUsSUFBSTtJQUN0RDtJQUVBazlDLGdCQUFnQnYzRCxTQUFTLENBQUNzN0MsV0FBVyxHQUFHLFNBQVUzd0MsSUFBSTtRQUNwRCxPQUFPLElBQUkwc0QsY0FBYzFzRCxNQUFNLElBQUksQ0FBQzBQLFVBQVUsRUFBRSxJQUFJO0lBQ3REO0lBRUFrOUMsZ0JBQWdCdjNELFNBQVMsQ0FBQzBaLGVBQWUsR0FBRyxTQUFVMkMsUUFBUTtRQUM1RCxJQUFJLENBQUNtN0MsVUFBVSxDQUFDNzFDLFlBQVksQ0FBQyxTQUFTO1FBQ3RDLElBQUksQ0FBQzYxQyxVQUFVLENBQUM3MUMsWUFBWSxDQUFDLGVBQWU7UUFFNUMsSUFBSSxJQUFJLENBQUMyMEIsWUFBWSxDQUFDbWhCLFdBQVcsRUFBRTtZQUNqQyxJQUFJLENBQUNELFVBQVUsQ0FBQzcxQyxZQUFZLENBQUMsV0FBVyxJQUFJLENBQUMyMEIsWUFBWSxDQUFDbWhCLFdBQVc7UUFDdkUsT0FBTztZQUNMLElBQUksQ0FBQ0QsVUFBVSxDQUFDNzFDLFlBQVksQ0FBQyxXQUFXLFNBQVN0RixTQUFTOFQsQ0FBQyxHQUFHLE1BQU05VCxTQUFTdFUsQ0FBQztRQUNoRjtRQUVBLElBQUksQ0FBQyxJQUFJLENBQUN1dUMsWUFBWSxDQUFDb2hCLFdBQVcsRUFBRTtZQUNsQyxJQUFJLENBQUNGLFVBQVUsQ0FBQzcxQyxZQUFZLENBQUMsU0FBU3RGLFNBQVM4VCxDQUFDO1lBQ2hELElBQUksQ0FBQ3FuQyxVQUFVLENBQUM3MUMsWUFBWSxDQUFDLFVBQVV0RixTQUFTdFUsQ0FBQztZQUNqRCxJQUFJLENBQUN5dkQsVUFBVSxDQUFDM3hELEtBQUssQ0FBQ3VNLEtBQUssR0FBRztZQUM5QixJQUFJLENBQUNvbEQsVUFBVSxDQUFDM3hELEtBQUssQ0FBQ3dNLE1BQU0sR0FBRztZQUMvQixJQUFJLENBQUNtbEQsVUFBVSxDQUFDM3hELEtBQUssQ0FBQ2cwQixTQUFTLEdBQUc7WUFDbEMsSUFBSSxDQUFDMjlCLFVBQVUsQ0FBQzN4RCxLQUFLLENBQUM4eEQsaUJBQWlCLEdBQUcsSUFBSSxDQUFDcmhCLFlBQVksQ0FBQ3FoQixpQkFBaUI7UUFDL0U7UUFFQSxJQUFJLElBQUksQ0FBQ3JoQixZQUFZLENBQUNsa0MsS0FBSyxFQUFFO1lBQzNCLElBQUksQ0FBQ29sRCxVQUFVLENBQUM3MUMsWUFBWSxDQUFDLFNBQVMsSUFBSSxDQUFDMjBCLFlBQVksQ0FBQ2xrQyxLQUFLO1FBQy9EO1FBRUEsSUFBSSxJQUFJLENBQUNra0MsWUFBWSxDQUFDamtDLE1BQU0sRUFBRTtZQUM1QixJQUFJLENBQUNtbEQsVUFBVSxDQUFDNzFDLFlBQVksQ0FBQyxVQUFVLElBQUksQ0FBQzIwQixZQUFZLENBQUNqa0MsTUFBTTtRQUNqRTtRQUVBLElBQUksSUFBSSxDQUFDaWtDLFlBQVksQ0FBQ3NoQixTQUFTLEVBQUU7WUFDL0IsSUFBSSxDQUFDSixVQUFVLENBQUM3MUMsWUFBWSxDQUFDLFNBQVMsSUFBSSxDQUFDMjBCLFlBQVksQ0FBQ3NoQixTQUFTO1FBQ25FO1FBRUEsSUFBSSxJQUFJLENBQUN0aEIsWUFBWSxDQUFDcnBDLEVBQUUsRUFBRTtZQUN4QixJQUFJLENBQUN1cUQsVUFBVSxDQUFDNzFDLFlBQVksQ0FBQyxNQUFNLElBQUksQ0FBQzIwQixZQUFZLENBQUNycEMsRUFBRTtRQUN6RDtRQUVBLElBQUksSUFBSSxDQUFDcXBDLFlBQVksQ0FBQ3VoQixTQUFTLEtBQUtyOUMsV0FBVztZQUM3QyxJQUFJLENBQUNnOUMsVUFBVSxDQUFDNzFDLFlBQVksQ0FBQyxhQUFhLElBQUksQ0FBQzIwQixZQUFZLENBQUN1aEIsU0FBUztRQUN2RTtRQUVBLElBQUksQ0FBQ0wsVUFBVSxDQUFDNzFDLFlBQVksQ0FBQyx1QkFBdUIsSUFBSSxDQUFDMjBCLFlBQVksQ0FBQ3doQixtQkFBbUIsR0FBRyw0REFBNEQ7UUFDeEosdU1BQXVNO1FBRXZNLElBQUksQ0FBQ3BiLGFBQWEsQ0FBQzFpQyxPQUFPLENBQUMxRixXQUFXLENBQUMsSUFBSSxDQUFDa2pELFVBQVUsR0FBRyxpQkFBaUI7UUFFMUUsSUFBSWw5QyxPQUFPLElBQUksQ0FBQ0QsVUFBVSxDQUFDQyxJQUFJO1FBQy9CLElBQUksQ0FBQ2tpQyxlQUFlLENBQUNuZ0MsVUFBVS9CO1FBQy9CLElBQUksQ0FBQ0QsVUFBVSxDQUFDeWhDLGVBQWUsR0FBRyxJQUFJLENBQUN4RixZQUFZLENBQUN3RixlQUFlO1FBQ25FLElBQUksQ0FBQ254QyxJQUFJLEdBQUcwUjtRQUNaLElBQUlpaUMsY0FBY3YwQyxTQUFTO1FBQzNCLElBQUk0MEMsT0FBTzUwQyxTQUFTO1FBQ3BCNDBDLEtBQUtoOUIsWUFBWSxDQUFDLFNBQVN0RixTQUFTOFQsQ0FBQztRQUNyQ3d1QixLQUFLaDlCLFlBQVksQ0FBQyxVQUFVdEYsU0FBU3RVLENBQUM7UUFDdEM0MkMsS0FBS2g5QixZQUFZLENBQUMsS0FBSztRQUN2Qmc5QixLQUFLaDlCLFlBQVksQ0FBQyxLQUFLO1FBQ3ZCLElBQUl1bEMsU0FBU3YvQztRQUNiMjJDLFlBQVkzOEIsWUFBWSxDQUFDLE1BQU11bEM7UUFDL0I1SSxZQUFZaHFDLFdBQVcsQ0FBQ3FxQztRQUN4QixJQUFJLENBQUN2RixZQUFZLENBQUN6M0IsWUFBWSxDQUFDLGFBQWEsU0FBU3ZpQixvQkFBb0IsTUFBTThuRCxTQUFTO1FBQ3hGNXNDLEtBQUtoRyxXQUFXLENBQUNncUM7UUFDakIsSUFBSSxDQUFDNXlDLE1BQU0sR0FBRzJRLFNBQVMzUSxNQUFNO1FBQzdCLElBQUksQ0FBQ3E1QixRQUFRLEdBQUcvaEMsaUJBQWlCcVosU0FBUzNRLE1BQU0sQ0FBQzVMLE1BQU07SUFDekQ7SUFFQXkzRCxnQkFBZ0J2M0QsU0FBUyxDQUFDbVYsT0FBTyxHQUFHO1FBQ2xDLElBQUksSUFBSSxDQUFDdW5DLGFBQWEsQ0FBQzFpQyxPQUFPLEVBQUU7WUFDOUIsSUFBSSxDQUFDMGlDLGFBQWEsQ0FBQzFpQyxPQUFPLENBQUM4SCxTQUFTLEdBQUc7UUFDekM7UUFFQSxJQUFJLENBQUNzM0IsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQy8rQixVQUFVLENBQUNDLElBQUksR0FBRztRQUN2QixJQUFJMWE7UUFDSixJQUFJQyxNQUFNLElBQUksQ0FBQzZMLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU0sQ0FBQzVMLE1BQU0sR0FBRztRQUU3QyxJQUFLRixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQixJQUFJLElBQUksQ0FBQ21sQyxRQUFRLENBQUNubEMsRUFBRSxJQUFJLElBQUksQ0FBQ21sQyxRQUFRLENBQUNubEMsRUFBRSxDQUFDdVYsT0FBTyxFQUFFO2dCQUNoRCxJQUFJLENBQUM0dkIsUUFBUSxDQUFDbmxDLEVBQUUsQ0FBQ3VWLE9BQU87WUFDMUI7UUFDRjtRQUVBLElBQUksQ0FBQzR2QixRQUFRLENBQUNqbEMsTUFBTSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ2k0RCxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDcmIsYUFBYSxHQUFHO0lBQ3ZCO0lBRUE2YSxnQkFBZ0J2M0QsU0FBUyxDQUFDa2QsbUJBQW1CLEdBQUcsWUFBYTtJQUU3RHE2QyxnQkFBZ0J2M0QsU0FBUyxDQUFDZzRELGNBQWMsR0FBRyxTQUFVcHJDLEdBQUc7UUFDdEQsSUFBSWh0QixJQUFJO1FBQ1IsSUFBSUMsTUFBTSxJQUFJLENBQUM2TCxNQUFNLENBQUM1TCxNQUFNO1FBRTVCLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCLElBQUksSUFBSSxDQUFDOEwsTUFBTSxDQUFDOUwsRUFBRSxDQUFDZ3RCLEdBQUcsS0FBS0EsS0FBSztnQkFDOUIsT0FBT2h0QjtZQUNUO1FBQ0Y7UUFFQSxPQUFPLENBQUM7SUFDVjtJQUVBMjNELGdCQUFnQnYzRCxTQUFTLENBQUNnN0MsU0FBUyxHQUFHLFNBQVVsb0IsR0FBRztRQUNqRCxJQUFJaVMsV0FBVyxJQUFJLENBQUNBLFFBQVE7UUFFNUIsSUFBSUEsUUFBUSxDQUFDalMsSUFBSSxJQUFJLElBQUksQ0FBQ3BuQixNQUFNLENBQUNvbkIsSUFBSSxDQUFDdm1CLEVBQUUsS0FBSyxJQUFJO1lBQy9DO1FBQ0Y7UUFFQXc0QixRQUFRLENBQUNqUyxJQUFJLEdBQUc7UUFDaEIsSUFBSWx0QixVQUFVLElBQUksQ0FBQ3MxQyxVQUFVLENBQUMsSUFBSSxDQUFDeHZDLE1BQU0sQ0FBQ29uQixJQUFJO1FBQzlDaVMsUUFBUSxDQUFDalMsSUFBSSxHQUFHbHRCO1FBRWhCLElBQUk0RCx3QkFBd0I7WUFDMUIsSUFBSSxJQUFJLENBQUNrQyxNQUFNLENBQUNvbkIsSUFBSSxDQUFDdm1CLEVBQUUsS0FBSyxHQUFHO2dCQUM3QixJQUFJLENBQUM4TixVQUFVLENBQUNkLGdCQUFnQixDQUFDakMsbUJBQW1CLENBQUMxUjtZQUN2RDtZQUVBQSxRQUFRZ1csZUFBZTtRQUN6QjtRQUVBLElBQUksQ0FBQ3E4QyxrQkFBa0IsQ0FBQ3J5RCxTQUFTa3RCO1FBRWpDLElBQUksSUFBSSxDQUFDcG5CLE1BQU0sQ0FBQ29uQixJQUFJLENBQUNpdkIsRUFBRSxFQUFFO1lBQ3ZCLElBQUltVyxlQUFlLFFBQVEsSUFBSSxDQUFDeHNELE1BQU0sQ0FBQ29uQixJQUFJLEdBQUcsSUFBSSxDQUFDa2xDLGNBQWMsQ0FBQyxJQUFJLENBQUN0c0QsTUFBTSxDQUFDb25CLElBQUksQ0FBQ3FsQyxFQUFFLElBQUlybEMsTUFBTTtZQUUvRixJQUFJb2xDLGlCQUFpQixDQUFDLEdBQUc7Z0JBQ3ZCO1lBQ0Y7WUFFQSxJQUFJLENBQUMsSUFBSSxDQUFDbnpCLFFBQVEsQ0FBQ216QixhQUFhLElBQUksSUFBSSxDQUFDbnpCLFFBQVEsQ0FBQ216QixhQUFhLEtBQUssTUFBTTtnQkFDeEUsSUFBSSxDQUFDbGQsU0FBUyxDQUFDa2Q7Z0JBQ2YsSUFBSSxDQUFDaGMsaUJBQWlCLENBQUN0MkM7WUFDekIsT0FBTztnQkFDTCxJQUFJNDdDLGVBQWV6YyxRQUFRLENBQUNtekIsYUFBYTtnQkFDekMsSUFBSUUsWUFBWTVXLGFBQWFnQixRQUFRLENBQUMsSUFBSSxDQUFDOTJDLE1BQU0sQ0FBQ29uQixJQUFJLENBQUNpdkIsRUFBRTtnQkFDekRuOEMsUUFBUXE5QyxRQUFRLENBQUNtVjtZQUNuQjtRQUNGO0lBQ0Y7SUFFQWIsZ0JBQWdCdjNELFNBQVMsQ0FBQ2k3QyxvQkFBb0IsR0FBRztRQUMvQyxNQUFPLElBQUksQ0FBQ29CLGVBQWUsQ0FBQ3Y4QyxNQUFNLENBQUU7WUFDbEMsSUFBSThGLFVBQVUsSUFBSSxDQUFDeTJDLGVBQWUsQ0FBQzdhLEdBQUc7WUFDdEM1N0IsUUFBUXc5QyxjQUFjO1lBRXRCLElBQUl4OUMsUUFBUStFLElBQUksQ0FBQ28zQyxFQUFFLEVBQUU7Z0JBQ25CLElBQUluaUQsSUFBSTtnQkFDUixJQUFJQyxNQUFNLElBQUksQ0FBQ2tsQyxRQUFRLENBQUNqbEMsTUFBTTtnQkFFOUIsTUFBT0YsSUFBSUMsSUFBSztvQkFDZCxJQUFJLElBQUksQ0FBQ2tsQyxRQUFRLENBQUNubEMsRUFBRSxLQUFLZ0csU0FBUzt3QkFDaEMsSUFBSXN5RCxlQUFlLFFBQVF0eUQsUUFBUStFLElBQUksR0FBRyxJQUFJLENBQUNxdEQsY0FBYyxDQUFDcHlELFFBQVErRSxJQUFJLENBQUN3dEQsRUFBRSxJQUFJdjRELElBQUk7d0JBQ3JGLElBQUk0aEQsZUFBZSxJQUFJLENBQUN6YyxRQUFRLENBQUNtekIsYUFBYTt3QkFDOUMsSUFBSUUsWUFBWTVXLGFBQWFnQixRQUFRLENBQUMsSUFBSSxDQUFDOTJDLE1BQU0sQ0FBQzlMLEVBQUUsQ0FBQ21pRCxFQUFFO3dCQUN2RG44QyxRQUFRcTlDLFFBQVEsQ0FBQ21WO3dCQUNqQjtvQkFDRjtvQkFFQXg0RCxLQUFLO2dCQUNQO1lBQ0Y7UUFDRjtJQUNGO0lBRUEyM0QsZ0JBQWdCdjNELFNBQVMsQ0FBQ29kLFdBQVcsR0FBRyxTQUFVNjRCLEdBQUc7UUFDbkQsSUFBSSxJQUFJLENBQUMzbEIsYUFBYSxLQUFLMmxCLE9BQU8sSUFBSSxDQUFDOGhCLFNBQVMsRUFBRTtZQUNoRDtRQUNGO1FBRUEsSUFBSTloQixRQUFRLE1BQU07WUFDaEJBLE1BQU0sSUFBSSxDQUFDM2xCLGFBQWE7UUFDMUIsT0FBTztZQUNMLElBQUksQ0FBQ0EsYUFBYSxHQUFHMmxCO1FBQ3ZCLEVBQUUsMEJBQTBCO1FBQzVCLDZCQUE2QjtRQUc3QixJQUFJLENBQUM1N0IsVUFBVSxDQUFDb1IsUUFBUSxHQUFHd3FCO1FBQzNCLElBQUksQ0FBQzU3QixVQUFVLENBQUMwVyxPQUFPLElBQUk7UUFDM0IsSUFBSSxDQUFDMVcsVUFBVSxDQUFDZCxnQkFBZ0IsQ0FBQzNCLFlBQVksR0FBR3ErQjtRQUNoRCxJQUFJLENBQUM1N0IsVUFBVSxDQUFDd1csSUFBSSxHQUFHO1FBQ3ZCLElBQUlqeEI7UUFDSixJQUFJQyxNQUFNLElBQUksQ0FBQzZMLE1BQU0sQ0FBQzVMLE1BQU07UUFFNUIsSUFBSSxDQUFDLElBQUksQ0FBQzJMLGNBQWMsRUFBRTtZQUN4QixJQUFJLENBQUNzdkMsV0FBVyxDQUFDOUU7UUFDbkI7UUFFQSxJQUFLcjJDLElBQUlDLE1BQU0sR0FBR0QsS0FBSyxHQUFHQSxLQUFLLEVBQUc7WUFDaEMsSUFBSSxJQUFJLENBQUM2TCxjQUFjLElBQUksSUFBSSxDQUFDczVCLFFBQVEsQ0FBQ25sQyxFQUFFLEVBQUU7Z0JBQzNDLElBQUksQ0FBQ21sQyxRQUFRLENBQUNubEMsRUFBRSxDQUFDOFgsWUFBWSxDQUFDdStCLE1BQU0sSUFBSSxDQUFDdnFDLE1BQU0sQ0FBQzlMLEVBQUUsQ0FBQzhPLEVBQUU7WUFDdkQ7UUFDRjtRQUVBLElBQUksSUFBSSxDQUFDMkwsVUFBVSxDQUFDd1csSUFBSSxFQUFFO1lBQ3hCLElBQUtqeEIsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7Z0JBQzNCLElBQUksSUFBSSxDQUFDNkwsY0FBYyxJQUFJLElBQUksQ0FBQ3M1QixRQUFRLENBQUNubEMsRUFBRSxFQUFFO29CQUMzQyxJQUFJLENBQUNtbEMsUUFBUSxDQUFDbmxDLEVBQUUsQ0FBQ3dkLFdBQVc7Z0JBQzlCO1lBQ0Y7UUFDRjtJQUNGO0lBRUFtNkMsZ0JBQWdCdjNELFNBQVMsQ0FBQ2k0RCxrQkFBa0IsR0FBRyxTQUFVcnlELE9BQU8sRUFBRWt0QixHQUFHO1FBQ25FLElBQUloTixhQUFhbGdCLFFBQVFtMEMsY0FBYztRQUV2QyxJQUFJLENBQUNqMEIsWUFBWTtZQUNmO1FBQ0Y7UUFFQSxJQUFJbG1CLElBQUk7UUFDUixJQUFJeTREO1FBRUosTUFBT3o0RCxJQUFJa3pCLElBQUs7WUFDZCxJQUFJLElBQUksQ0FBQ2lTLFFBQVEsQ0FBQ25sQyxFQUFFLElBQUksSUFBSSxDQUFDbWxDLFFBQVEsQ0FBQ25sQyxFQUFFLEtBQUssUUFBUSxJQUFJLENBQUNtbEMsUUFBUSxDQUFDbmxDLEVBQUUsQ0FBQ202QyxjQUFjLElBQUk7Z0JBQ3RGc2UsY0FBYyxJQUFJLENBQUN0ekIsUUFBUSxDQUFDbmxDLEVBQUUsQ0FBQ202QyxjQUFjO1lBQy9DO1lBRUFuNkMsS0FBSztRQUNQO1FBRUEsSUFBSXk0RCxhQUFhO1lBQ2YsSUFBSSxDQUFDamYsWUFBWSxDQUFDa2YsWUFBWSxDQUFDeHlDLFlBQVl1eUM7UUFDN0MsT0FBTztZQUNMLElBQUksQ0FBQ2pmLFlBQVksQ0FBQzlrQyxXQUFXLENBQUN3UjtRQUNoQztJQUNGO0lBRUF5eEMsZ0JBQWdCdjNELFNBQVMsQ0FBQzBmLElBQUksR0FBRztRQUMvQixJQUFJLENBQUMwNUIsWUFBWSxDQUFDdnpDLEtBQUssQ0FBQ0ksT0FBTyxHQUFHO0lBQ3BDO0lBRUFzeEQsZ0JBQWdCdjNELFNBQVMsQ0FBQzJmLElBQUksR0FBRztRQUMvQixJQUFJLENBQUN5NUIsWUFBWSxDQUFDdnpDLEtBQUssQ0FBQ0ksT0FBTyxHQUFHO0lBQ3BDO0lBRUEsU0FBU3N5RCxnQkFBZ0I7SUFFekI5NEQsZ0JBQWdCO1FBQUNxNEM7UUFBYWdGO1FBQWtCb0c7UUFBa0J6SjtRQUFjNEo7S0FBcUIsRUFBRWtWO0lBRXZHQSxhQUFhdjRELFNBQVMsQ0FBQ3VqRCxXQUFXLEdBQUcsU0FBVTU0QyxJQUFJLEVBQUUwUCxVQUFVLEVBQUVuTixJQUFJO1FBQ25FLElBQUksQ0FBQ29lLFNBQVM7UUFDZCxJQUFJLENBQUMrdEIsWUFBWSxDQUFDMXVDLE1BQU0wUCxZQUFZbk47UUFDcEMsSUFBSSxDQUFDNnZDLGFBQWEsQ0FBQ3B5QyxNQUFNMFAsWUFBWW5OO1FBQ3JDLElBQUksQ0FBQ3NvQyxjQUFjO1FBQ25CLElBQUksQ0FBQzJOLGFBQWE7UUFDbEIsSUFBSSxDQUFDN0IsbUJBQW1CO1FBQ3hCLElBQUksQ0FBQ0MsdUJBQXVCO1FBQzVCLElBQUksQ0FBQ2dCLDBCQUEwQjtRQUUvQixJQUFJLElBQUksQ0FBQzUzQyxJQUFJLENBQUNnTixFQUFFLElBQUksQ0FBQzBDLFdBQVd5aEMsZUFBZSxFQUFFO1lBQy9DLElBQUksQ0FBQ0YsYUFBYTtRQUNwQjtRQUVBLElBQUksQ0FBQ2w4QixJQUFJO0lBQ1g7SUFDQTs7Ozs7Ozs7OztLQVVHLEdBR0g2NEMsYUFBYXY0RCxTQUFTLENBQUMwWCxZQUFZLEdBQUcsU0FBVXUrQixHQUFHO1FBQ2pELElBQUksQ0FBQ3BsQixJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNtbEIsc0JBQXNCLENBQUNDO1FBQzVCLElBQUksQ0FBQ3lELGlCQUFpQixDQUFDekQsS0FBSyxJQUFJLENBQUNSLFNBQVM7UUFFMUMsSUFBSSxDQUFDLElBQUksQ0FBQ0EsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDOXFDLElBQUksQ0FBQ2dOLEVBQUUsRUFBRTtZQUNwQztRQUNGO1FBRUEsSUFBSSxDQUFDLElBQUksQ0FBQ2IsRUFBRSxDQUFDMGpDLFlBQVksRUFBRTtZQUN6QixJQUFJRyxlQUFlLElBQUksQ0FBQzdqQyxFQUFFLENBQUM3TyxDQUFDO1lBRTVCLElBQUkweUMsaUJBQWlCLElBQUksQ0FBQ2h3QyxJQUFJLENBQUM4RCxFQUFFLEVBQUU7Z0JBQ2pDa3NDLGVBQWUsSUFBSSxDQUFDaHdDLElBQUksQ0FBQzhELEVBQUUsR0FBRztZQUNoQztZQUVBLElBQUksQ0FBQzZoQixhQUFhLEdBQUdxcUI7UUFDdkIsT0FBTztZQUNMLElBQUksQ0FBQ3JxQixhQUFhLEdBQUcybEIsTUFBTSxJQUFJLENBQUN0ckMsSUFBSSxDQUFDZ0UsRUFBRTtRQUN6QztRQUVBLElBQUkvTztRQUNKLElBQUlDLE1BQU0sSUFBSSxDQUFDa2xDLFFBQVEsQ0FBQ2psQyxNQUFNO1FBRTlCLElBQUksQ0FBQyxJQUFJLENBQUMyTCxjQUFjLEVBQUU7WUFDeEIsSUFBSSxDQUFDc3ZDLFdBQVcsQ0FBQyxJQUFJLENBQUN6cUIsYUFBYTtRQUNyQyxFQUFFLDZGQUE2RjtRQUcvRixJQUFLMXdCLElBQUlDLE1BQU0sR0FBR0QsS0FBSyxHQUFHQSxLQUFLLEVBQUc7WUFDaEMsSUFBSSxJQUFJLENBQUM2TCxjQUFjLElBQUksSUFBSSxDQUFDczVCLFFBQVEsQ0FBQ25sQyxFQUFFLEVBQUU7Z0JBQzNDLElBQUksQ0FBQ21sQyxRQUFRLENBQUNubEMsRUFBRSxDQUFDOFgsWUFBWSxDQUFDLElBQUksQ0FBQzRZLGFBQWEsR0FBRyxJQUFJLENBQUM1a0IsTUFBTSxDQUFDOUwsRUFBRSxDQUFDOE8sRUFBRTtnQkFFcEUsSUFBSSxJQUFJLENBQUNxMkIsUUFBUSxDQUFDbmxDLEVBQUUsQ0FBQ2l4QixJQUFJLEVBQUU7b0JBQ3pCLElBQUksQ0FBQ0EsSUFBSSxHQUFHO2dCQUNkO1lBQ0Y7UUFDRjtJQUNGO0lBRUEwbkMsYUFBYXY0RCxTQUFTLENBQUN5akQsa0JBQWtCLEdBQUc7UUFDMUMsSUFBSTdqRDtRQUNKLElBQUlDLE1BQU0sSUFBSSxDQUFDNkwsTUFBTSxDQUFDNUwsTUFBTTtRQUU1QixJQUFLRixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQixJQUFJLElBQUksQ0FBQzZMLGNBQWMsSUFBSSxJQUFJLENBQUNzNUIsUUFBUSxDQUFDbmxDLEVBQUUsRUFBRTtnQkFDM0MsSUFBSSxDQUFDbWxDLFFBQVEsQ0FBQ25sQyxFQUFFLENBQUN3ZCxXQUFXO1lBQzlCO1FBQ0Y7SUFDRjtJQUVBbTdDLGFBQWF2NEQsU0FBUyxDQUFDdzRELFdBQVcsR0FBRyxTQUFVenlCLEtBQUs7UUFDbEQsSUFBSSxDQUFDaEIsUUFBUSxHQUFHZ0I7SUFDbEI7SUFFQXd5QixhQUFhdjRELFNBQVMsQ0FBQ3k0RCxXQUFXLEdBQUc7UUFDbkMsT0FBTyxJQUFJLENBQUMxekIsUUFBUTtJQUN0QjtJQUVBd3pCLGFBQWF2NEQsU0FBUyxDQUFDMDRELGVBQWUsR0FBRztRQUN2QyxJQUFJOTREO1FBQ0osSUFBSUMsTUFBTSxJQUFJLENBQUM2TCxNQUFNLENBQUM1TCxNQUFNO1FBRTVCLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCLElBQUksSUFBSSxDQUFDbWxDLFFBQVEsQ0FBQ25sQyxFQUFFLEVBQUU7Z0JBQ3BCLElBQUksQ0FBQ21sQyxRQUFRLENBQUNubEMsRUFBRSxDQUFDdVYsT0FBTztZQUMxQjtRQUNGO0lBQ0Y7SUFFQW9qRCxhQUFhdjRELFNBQVMsQ0FBQ21WLE9BQU8sR0FBRztRQUMvQixJQUFJLENBQUN1akQsZUFBZTtRQUNwQixJQUFJLENBQUNwVyxrQkFBa0I7SUFDekI7SUFFQSxTQUFTeVUsZUFBZXBzRCxJQUFJLEVBQUUwUCxVQUFVLEVBQUVuTixJQUFJO1FBQzVDLElBQUksQ0FBQ3hCLE1BQU0sR0FBR2YsS0FBS2UsTUFBTTtRQUN6QixJQUFJLENBQUNpdEQsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ2x0RCxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDNHdDLGVBQWUsR0FBRyxFQUFFO1FBQ3pCLElBQUksQ0FBQ3RYLFFBQVEsR0FBRyxJQUFJLENBQUNyNUIsTUFBTSxHQUFHMUksaUJBQWlCLElBQUksQ0FBQzBJLE1BQU0sQ0FBQzVMLE1BQU0sSUFBSSxFQUFFO1FBQ3ZFLElBQUksQ0FBQ3lqRCxXQUFXLENBQUM1NEMsTUFBTTBQLFlBQVluTjtRQUNuQyxJQUFJLENBQUM0SixFQUFFLEdBQUduTSxLQUFLbU0sRUFBRSxHQUFHaWIsZ0JBQWdCQyxPQUFPLENBQUMsSUFBSSxFQUFFcm5CLEtBQUttTSxFQUFFLEVBQUUsR0FBR3VELFdBQVc5QixTQUFTLEVBQUUsSUFBSSxJQUFJO1lBQzFGaWlDLGNBQWM7UUFDaEI7SUFDRjtJQUVBLzZDLGdCQUFnQjtRQUFDODNEO1FBQWlCZ0I7UUFBY2xYO0tBQWUsRUFBRTBWO0lBRWpFQSxlQUFlLzJELFNBQVMsQ0FBQ3E3QyxVQUFVLEdBQUcsU0FBVTF3QyxJQUFJO1FBQ2xELE9BQU8sSUFBSW9zRCxlQUFlcHNELE1BQU0sSUFBSSxDQUFDMFAsVUFBVSxFQUFFLElBQUk7SUFDdkQ7SUFFQSxTQUFTdStDLFlBQVlsYyxhQUFhLEVBQUVtYyxNQUFNO1FBQ3hDLElBQUksQ0FBQ25jLGFBQWEsR0FBR0E7UUFDckIsSUFBSSxDQUFDaHhDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQzRrQixhQUFhLEdBQUcsQ0FBQztRQUN0QixJQUFJLENBQUNrbkMsVUFBVSxHQUFHenRELFNBQVM7UUFDM0IsSUFBSSt1RCxZQUFZO1FBRWhCLElBQUlELFVBQVVBLE9BQU9FLEtBQUssRUFBRTtZQUMxQixJQUFJQyxlQUFlanZELFNBQVM7WUFDNUIsSUFBSWt2RCxVQUFVdHhEO1lBQ2RxeEQsYUFBYXIzQyxZQUFZLENBQUMsTUFBTXMzQztZQUNoQ0QsYUFBYWxuQixXQUFXLEdBQUcrbUIsT0FBT0UsS0FBSztZQUN2QyxJQUFJLENBQUN2QixVQUFVLENBQUNsakQsV0FBVyxDQUFDMGtEO1lBQzVCRixhQUFhRztRQUNmO1FBRUEsSUFBSUosVUFBVUEsT0FBT0ssV0FBVyxFQUFFO1lBQ2hDLElBQUlDLGNBQWNwdkQsU0FBUztZQUMzQixJQUFJcXZELFNBQVN6eEQ7WUFDYnd4RCxZQUFZeDNDLFlBQVksQ0FBQyxNQUFNeTNDO1lBQy9CRCxZQUFZcm5CLFdBQVcsR0FBRyttQixPQUFPSyxXQUFXO1lBQzVDLElBQUksQ0FBQzFCLFVBQVUsQ0FBQ2xqRCxXQUFXLENBQUM2a0Q7WUFDNUJMLGFBQWEsTUFBTU07UUFDckI7UUFFQSxJQUFJTixXQUFXO1lBQ2IsSUFBSSxDQUFDdEIsVUFBVSxDQUFDNzFDLFlBQVksQ0FBQyxtQkFBbUJtM0M7UUFDbEQ7UUFFQSxJQUFJeCtDLE9BQU92USxTQUFTO1FBQ3BCLElBQUksQ0FBQ3l0RCxVQUFVLENBQUNsakQsV0FBVyxDQUFDZ0c7UUFDNUIsSUFBSWdrQyxjQUFjdjBDLFNBQVM7UUFDM0IsSUFBSSxDQUFDeXRELFVBQVUsQ0FBQ2xqRCxXQUFXLENBQUNncUM7UUFDNUIsSUFBSSxDQUFDbEYsWUFBWSxHQUFHa0Y7UUFDcEIsSUFBSSxDQUFDaEksWUFBWSxHQUFHO1lBQ2xCd2hCLHFCQUFxQmUsVUFBVUEsT0FBT2YsbUJBQW1CLElBQUk7WUFDN0RoVSwwQkFBMEIrVSxVQUFVQSxPQUFPL1Usd0JBQXdCLElBQUk7WUFDdkU2VCxtQkFBbUJrQixVQUFVQSxPQUFPbEIsaUJBQWlCLElBQUk7WUFDekQ3YixpQkFBaUIrYyxVQUFVQSxPQUFPL2MsZUFBZSxJQUFJO1lBQ3JEdkYsbUJBQW1CLENBQUVzaUIsQ0FBQUEsVUFBVUEsT0FBT3RpQixpQkFBaUIsS0FBSyxLQUFJO1lBQ2hFbWhCLGFBQWFtQixVQUFVQSxPQUFPbkIsV0FBVyxJQUFJO1lBQzdDRCxhQUFhb0IsVUFBVUEsT0FBT3BCLFdBQVcsSUFBSTtZQUM3Q0csV0FBV2lCLFVBQVVBLE9BQU9qQixTQUFTLElBQUk7WUFDekMzcUQsSUFBSTRyRCxVQUFVQSxPQUFPNXJELEVBQUUsSUFBSTtZQUMzQjRxRCxXQUFXZ0IsVUFBVUEsT0FBT2hCLFNBQVM7WUFDckN3QixZQUFZO2dCQUNWam5ELE9BQU95bUQsVUFBVUEsT0FBT1EsVUFBVSxJQUFJUixPQUFPUSxVQUFVLENBQUNqbkQsS0FBSyxJQUFJO2dCQUNqRUMsUUFBUXdtRCxVQUFVQSxPQUFPUSxVQUFVLElBQUlSLE9BQU9RLFVBQVUsQ0FBQ2huRCxNQUFNLElBQUk7Z0JBQ25FbVMsR0FBR3EwQyxVQUFVQSxPQUFPUSxVQUFVLElBQUlSLE9BQU9RLFVBQVUsQ0FBQzcwQyxDQUFDLElBQUk7Z0JBQ3pEc0ksR0FBRytyQyxVQUFVQSxPQUFPUSxVQUFVLElBQUlSLE9BQU9RLFVBQVUsQ0FBQ3ZzQyxDQUFDLElBQUk7WUFDM0Q7WUFDQTFhLE9BQU95bUQsVUFBVUEsT0FBT3ptRCxLQUFLO1lBQzdCQyxRQUFRd21ELFVBQVVBLE9BQU94bUQsTUFBTTtZQUMvQmluRCxnQkFBZ0IsQ0FBQ1QsVUFBVUEsT0FBT1MsY0FBYyxLQUFLOStDLGFBQWFxK0MsT0FBT1MsY0FBYztRQUN6RjtRQUNBLElBQUksQ0FBQ2ovQyxVQUFVLEdBQUc7WUFDaEJ3VyxNQUFNO1lBQ05wRixVQUFVLENBQUM7WUFDWG5SLE1BQU1BO1lBQ05nOEIsY0FBYyxJQUFJLENBQUNBLFlBQVk7UUFDakM7UUFDQSxJQUFJLENBQUN2UixRQUFRLEdBQUcsRUFBRTtRQUNsQixJQUFJLENBQUNzWCxlQUFlLEdBQUcsRUFBRTtRQUN6QixJQUFJLENBQUMwYixTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDbjdDLFlBQVksR0FBRztJQUN0QjtJQUVBbmQsZ0JBQWdCO1FBQUM4M0Q7S0FBZ0IsRUFBRXFCO0lBRW5DQSxZQUFZNTRELFNBQVMsQ0FBQ3E3QyxVQUFVLEdBQUcsU0FBVTF3QyxJQUFJO1FBQy9DLE9BQU8sSUFBSW9zRCxlQUFlcHNELE1BQU0sSUFBSSxDQUFDMFAsVUFBVSxFQUFFLElBQUk7SUFDdkQ7SUFFQSxTQUFTay9DO1FBQ1AsSUFBSSxDQUFDQyxTQUFTLEdBQUcsQ0FBQztRQUNsQixJQUFJLENBQUNDLFlBQVksR0FBRyxFQUFFO1FBQ3RCLElBQUksQ0FBQ0MsbUJBQW1CLEdBQUc7SUFDN0I7SUFFQUgsc0JBQXNCdjVELFNBQVMsR0FBRztRQUNoQzI1RCxzQkFBc0IsU0FBU0EscUJBQXFCemIsVUFBVTtZQUM1RCxJQUFJdCtDO1lBQ0osSUFBSUMsTUFBTXErQyxXQUFXcCtDLE1BQU07WUFDM0IsSUFBSWtZLE1BQU07WUFFVixJQUFLcFksSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7Z0JBQzNCb1ksT0FBT2ttQyxVQUFVLENBQUN0K0MsRUFBRSxDQUFDaTZCLFNBQVMsQ0FBQzdoQixHQUFHLEdBQUc7WUFDdkM7WUFFQSxJQUFJNGhELFdBQVcsSUFBSSxDQUFDSixTQUFTLENBQUN4aEQsSUFBSTtZQUVsQyxJQUFJLENBQUM0aEQsVUFBVTtnQkFDYkEsV0FBVztvQkFDVDFiLFlBQVksRUFBRSxDQUFDMThCLE1BQU0sQ0FBQzA4QjtvQkFDdEI5SCxnQkFBZ0IsSUFBSWplO29CQUNwQnRILE1BQU07Z0JBQ1I7Z0JBQ0EsSUFBSSxDQUFDMm9DLFNBQVMsQ0FBQ3hoRCxJQUFJLEdBQUc0aEQ7Z0JBQ3RCLElBQUksQ0FBQ0gsWUFBWSxDQUFDdDRELElBQUksQ0FBQ3k0RDtZQUN6QjtZQUVBLE9BQU9BO1FBQ1Q7UUFDQUMsaUJBQWlCLFNBQVNBLGdCQUFnQkQsUUFBUSxFQUFFaGEsWUFBWTtZQUM5RCxJQUFJaGdELElBQUk7WUFDUixJQUFJQyxNQUFNKzVELFNBQVMxYixVQUFVLENBQUNwK0MsTUFBTTtZQUNwQyxJQUFJK3dCLE9BQU8rdUI7WUFFWCxNQUFPaGdELElBQUlDLE9BQU8sQ0FBQysvQyxhQUFjO2dCQUMvQixJQUFJZ2EsU0FBUzFiLFVBQVUsQ0FBQ3QrQyxFQUFFLENBQUNpNkIsU0FBUyxDQUFDME0sTUFBTSxDQUFDMVYsSUFBSSxFQUFFO29CQUNoREEsT0FBTztvQkFDUDtnQkFDRjtnQkFFQWp4QixLQUFLO1lBQ1A7WUFFQSxJQUFJaXhCLE1BQU07Z0JBQ1Irb0MsU0FBU3hqQixjQUFjLENBQUM5Z0IsS0FBSztnQkFFN0IsSUFBSzExQixJQUFJQyxNQUFNLEdBQUdELEtBQUssR0FBR0EsS0FBSyxFQUFHO29CQUNoQ2c2RCxTQUFTeGpCLGNBQWMsQ0FBQ3hhLFFBQVEsQ0FBQ2crQixTQUFTMWIsVUFBVSxDQUFDdCtDLEVBQUUsQ0FBQ2k2QixTQUFTLENBQUMwTSxNQUFNLENBQUN0K0IsQ0FBQztnQkFDNUU7WUFDRjtZQUVBMnhELFNBQVMvb0MsSUFBSSxHQUFHQTtRQUNsQjtRQUNBaXBDLGtCQUFrQixTQUFTQSxpQkFBaUJsYSxZQUFZO1lBQ3RELElBQUloZ0Q7WUFDSixJQUFJQyxNQUFNLElBQUksQ0FBQzQ1RCxZQUFZLENBQUMzNUQsTUFBTTtZQUVsQyxJQUFLRixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztnQkFDM0IsSUFBSSxDQUFDaTZELGVBQWUsQ0FBQyxJQUFJLENBQUNKLFlBQVksQ0FBQzc1RCxFQUFFLEVBQUVnZ0Q7WUFDN0M7UUFDRjtRQUNBbWEsV0FBVyxTQUFTQTtZQUNsQixJQUFJLENBQUNMLG1CQUFtQixJQUFJO1lBQzVCLE9BQU8sTUFBTSxJQUFJLENBQUNBLG1CQUFtQjtRQUN2QztJQUNGO0lBRUEsSUFBSU0sYUFBYSxTQUFTQTtRQUN4QixJQUFJL3NELEtBQUs7UUFDVCxJQUFJZ3RELGFBQWE7UUFDakIsSUFBSUMsZ0JBQWdCO1FBQ3BCLElBQUlDLE1BQU0sTUFBTSxzSEFBc0g7UUFDdEksa0hBQWtIO1FBQ2xILGlIQUFpSDtRQUNqSCx3REFBd0Q7UUFFeEQ7Ozs7Ozs7Ozs7Ozs7OztJQWVBLEdBRUEsU0FBU0M7WUFDUCxJQUFJQyxPQUFPdHdELFNBQVM7WUFFcEIsSUFBSXUyQyxNQUFNdjJDLFNBQVM7WUFDbkIsSUFBSTh4QixTQUFTOXhCLFNBQVM7WUFDdEJ1MkMsSUFBSTMrQixZQUFZLENBQUMsTUFBTTFVO1lBQ3ZCNHVCLE9BQU9sYSxZQUFZLENBQUMsUUFBUTtZQUM1QmthLE9BQU9sYSxZQUFZLENBQUMsK0JBQStCO1lBQ25Ea2EsT0FBT2xhLFlBQVksQ0FBQyxVQUFVO1lBQzlCMitCLElBQUloc0MsV0FBVyxDQUFDdW5CO1lBRWhCdytCLEtBQUsvbEQsV0FBVyxDQUFDZ3NDO1lBRWpCK1osS0FBSzE0QyxZQUFZLENBQUMsTUFBTTFVLEtBQUs7WUFFN0IsSUFBSXV6QyxlQUFlQyxhQUFhLEVBQUU7Z0JBQ2hDNFosS0FBS3gwRCxLQUFLLENBQUNJLE9BQU8sR0FBRztZQUN2QjtZQUVBLE9BQU9vMEQ7UUFDVDtRQUVBLFNBQVNDO1lBQ1AsSUFBSSxDQUFDTCxZQUFZO2dCQUNmRSxNQUFNQztnQkFDTjc2RCxTQUFTcWlCLElBQUksQ0FBQ3ROLFdBQVcsQ0FBQzZsRDtnQkFDMUJGLGFBQWE1NkQsVUFBVTtnQkFDdkI2NkQsZ0JBQWdCRCxXQUFXMW5ELFVBQVUsQ0FBQyxPQUFPLDZGQUE2RjtnQkFFMUkybkQsY0FBYzN4QixNQUFNLEdBQUcsVUFBVXQ3QixLQUFLO2dCQUN0Q2l0RCxjQUFjMW5ELFNBQVMsR0FBRztnQkFDMUIwbkQsY0FBY3puRCxRQUFRLENBQUMsR0FBRyxHQUFHLEdBQUc7WUFDbEM7UUFDRjtRQUVBLFNBQVM4bkQsUUFBUXBvRCxNQUFNO1lBQ3JCLElBQUksQ0FBQzhuRCxZQUFZO2dCQUNmSztZQUNGO1lBRUFMLFdBQVc3bkQsS0FBSyxHQUFHRCxPQUFPQyxLQUFLO1lBQy9CNm5ELFdBQVc1bkQsTUFBTSxHQUFHRixPQUFPRSxNQUFNLEVBQUUsNkZBQTZGO1lBRWhJNm5ELGNBQWMzeEIsTUFBTSxHQUFHLFVBQVV0N0IsS0FBSztZQUN0QyxPQUFPZ3REO1FBQ1Q7UUFFQSxPQUFPO1lBQ0xocEQsTUFBTXFwRDtZQUNOLzFDLEtBQUtnMkM7UUFDUDtJQUNGO0lBRUEsU0FBU0MsYUFBYXBvRCxLQUFLLEVBQUVDLE1BQU07UUFDakMsSUFBSW11QyxlQUFlRSxlQUFlLEVBQUU7WUFDbEMsT0FBTyxJQUFJek8sZ0JBQWdCNy9CLE9BQU9DO1FBQ3BDO1FBRUEsSUFBSUYsU0FBUzlTLFVBQVU7UUFDdkI4UyxPQUFPQyxLQUFLLEdBQUdBO1FBQ2ZELE9BQU9FLE1BQU0sR0FBR0E7UUFDaEIsT0FBT0Y7SUFDVDtJQUVBLElBQUl4QyxjQUFjO1FBQ2hCLE9BQU87WUFDTDhxRCxnQkFBZ0JULFdBQVcvb0QsSUFBSTtZQUMvQnlwRCxlQUFlVixXQUFXejFDLEdBQUc7WUFDN0JpMkMsY0FBY0E7UUFDaEI7SUFDRjtJQUVBLElBQUlHLG9CQUFvQixDQUFDO0lBRXpCLFNBQVNDLFVBQVVqNkMsSUFBSTtRQUNyQixJQUFJL2dCO1FBQ0osSUFBSUMsTUFBTThnQixLQUFLaFcsSUFBSSxDQUFDOHNDLEVBQUUsR0FBRzkyQixLQUFLaFcsSUFBSSxDQUFDOHNDLEVBQUUsQ0FBQzMzQyxNQUFNLEdBQUc7UUFDL0MsSUFBSSxDQUFDaWhELE9BQU8sR0FBRyxFQUFFO1FBQ2pCLElBQUlDO1FBRUosSUFBS3BoRCxJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQm9oRCxnQkFBZ0I7WUFDaEIsSUFBSTFoRCxPQUFPcWhCLEtBQUtoVyxJQUFJLENBQUM4c0MsRUFBRSxDQUFDNzNDLEVBQUUsQ0FBQzJNLEVBQUU7WUFFN0IsSUFBSW91RCxpQkFBaUIsQ0FBQ3I3RCxLQUFLLEVBQUU7Z0JBQzNCLElBQUkyaEQsU0FBUzBaLGlCQUFpQixDQUFDcjdELEtBQUssQ0FBQzRoRCxNQUFNO2dCQUMzQ0YsZ0JBQWdCLElBQUlDLE9BQU90Z0MsS0FBSzQ0QixjQUFjLENBQUM3QixjQUFjLENBQUM5M0MsRUFBRSxFQUFFK2dCO1lBQ3BFO1lBRUEsSUFBSXFnQyxlQUFlO2dCQUNqQixJQUFJLENBQUNELE9BQU8sQ0FBQzUvQyxJQUFJLENBQUM2L0M7WUFDcEI7UUFDRjtRQUVBLElBQUksSUFBSSxDQUFDRCxPQUFPLENBQUNqaEQsTUFBTSxFQUFFO1lBQ3ZCNmdCLEtBQUtrMUIsc0JBQXNCLENBQUMsSUFBSTtRQUNsQztJQUNGO0lBRUEra0IsVUFBVTU2RCxTQUFTLENBQUNvZCxXQUFXLEdBQUcsU0FBVThULGFBQWE7UUFDdkQsSUFBSXR4QjtRQUNKLElBQUlDLE1BQU0sSUFBSSxDQUFDa2hELE9BQU8sQ0FBQ2poRCxNQUFNO1FBRTdCLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCLElBQUksQ0FBQ21oRCxPQUFPLENBQUNuaEQsRUFBRSxDQUFDd2QsV0FBVyxDQUFDOFQ7UUFDOUI7SUFDRjtJQUVBMHBDLFVBQVU1NkQsU0FBUyxDQUFDZytDLFVBQVUsR0FBRyxTQUFVMStDLElBQUk7UUFDN0MsSUFBSU07UUFDSixJQUFJQyxNQUFNLElBQUksQ0FBQ2toRCxPQUFPLENBQUNqaEQsTUFBTTtRQUM3QixJQUFJMDNDLFVBQVUsRUFBRTtRQUVoQixJQUFLNTNDLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCLElBQUksSUFBSSxDQUFDbWhELE9BQU8sQ0FBQ25oRCxFQUFFLENBQUNOLElBQUksS0FBS0EsTUFBTTtnQkFDakNrNEMsUUFBUXIyQyxJQUFJLENBQUMsSUFBSSxDQUFDNC9DLE9BQU8sQ0FBQ25oRCxFQUFFO1lBQzlCO1FBQ0Y7UUFFQSxPQUFPNDNDO0lBQ1Q7SUFFQSxTQUFTcWpCLGVBQWU1dEQsRUFBRSxFQUFFaTBDLE1BQU07UUFDaEN5WixpQkFBaUIsQ0FBQzF0RCxHQUFHLEdBQUc7WUFDdEJpMEMsUUFBUUE7UUFDVjtJQUNGO0lBRUEsU0FBUzRaLGNBQWNud0QsSUFBSSxFQUFFL0UsT0FBTztRQUNsQyxJQUFJLENBQUMrRSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDL0UsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ3dHLGVBQWUsR0FBRyxJQUFJLENBQUN6QixJQUFJLENBQUN5QixlQUFlLElBQUksRUFBRTtRQUN0RCxJQUFJLENBQUNteUMsUUFBUSxHQUFHdjdDLGlCQUFpQixJQUFJLENBQUNvSixlQUFlLENBQUN0TSxNQUFNO1FBQzVELElBQUlGO1FBQ0osSUFBSUMsTUFBTSxJQUFJLENBQUN1TSxlQUFlLENBQUN0TSxNQUFNO1FBQ3JDLElBQUlpN0QsV0FBVztRQUVmLElBQUtuN0QsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDM0IsSUFBSSxJQUFJLENBQUN3TSxlQUFlLENBQUN4TSxFQUFFLENBQUNrM0MsSUFBSSxLQUFLLEtBQUs7Z0JBQ3hDaWtCLFdBQVc7WUFDYjtZQUVBLElBQUksQ0FBQ3hjLFFBQVEsQ0FBQzMrQyxFQUFFLEdBQUcyMEIscUJBQXFCd0QsWUFBWSxDQUFDLElBQUksQ0FBQ255QixPQUFPLEVBQUUsSUFBSSxDQUFDd0csZUFBZSxDQUFDeE0sRUFBRSxFQUFFO1FBQzlGO1FBRUEsSUFBSSxDQUFDbTdELFFBQVEsR0FBR0E7UUFFaEIsSUFBSUEsVUFBVTtZQUNaLElBQUksQ0FBQ24xRCxPQUFPLENBQUNpd0Msc0JBQXNCLENBQUMsSUFBSTtRQUMxQztJQUNGO0lBRUFpbEIsY0FBYzk2RCxTQUFTLENBQUNvZCxXQUFXLEdBQUc7UUFDcEMsSUFBSSxDQUFDLElBQUksQ0FBQzI5QyxRQUFRLEVBQUU7WUFDbEI7UUFDRjtRQUVBLElBQUlsaEMsWUFBWSxJQUFJLENBQUNqMEIsT0FBTyxDQUFDd3dDLGNBQWMsQ0FBQzFULEdBQUc7UUFDL0MsSUFBSXB3QixNQUFNLElBQUksQ0FBQzFNLE9BQU8sQ0FBQ28xRCxhQUFhO1FBQ3BDLElBQUlwN0Q7UUFDSixJQUFJQyxNQUFNLElBQUksQ0FBQ3VNLGVBQWUsQ0FBQ3RNLE1BQU07UUFDckMsSUFBSXVNO1FBQ0osSUFBSXl3QjtRQUNKLElBQUlueUI7UUFDSjJILElBQUkyb0QsU0FBUztRQUViLElBQUtyN0QsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDM0IsSUFBSSxJQUFJLENBQUN3TSxlQUFlLENBQUN4TSxFQUFFLENBQUNrM0MsSUFBSSxLQUFLLEtBQUs7Z0JBQ3hDLElBQUksSUFBSSxDQUFDMXFDLGVBQWUsQ0FBQ3hNLEVBQUUsQ0FBQzBrQyxHQUFHLEVBQUU7b0JBQy9CaHlCLElBQUk0b0QsTUFBTSxDQUFDLEdBQUc7b0JBQ2Q1b0QsSUFBSTZvRCxNQUFNLENBQUMsSUFBSSxDQUFDdjFELE9BQU8sQ0FBQ3lVLFVBQVUsQ0FBQ3NpQyxRQUFRLENBQUN4c0IsQ0FBQyxFQUFFO29CQUMvQzdkLElBQUk2b0QsTUFBTSxDQUFDLElBQUksQ0FBQ3YxRCxPQUFPLENBQUN5VSxVQUFVLENBQUNzaUMsUUFBUSxDQUFDeHNCLENBQUMsRUFBRSxJQUFJLENBQUN2cUIsT0FBTyxDQUFDeVUsVUFBVSxDQUFDc2lDLFFBQVEsQ0FBQzUwQyxDQUFDO29CQUNqRnVLLElBQUk2b0QsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDdjFELE9BQU8sQ0FBQ3lVLFVBQVUsQ0FBQ3NpQyxRQUFRLENBQUM1MEMsQ0FBQztvQkFDaER1SyxJQUFJNm9ELE1BQU0sQ0FBQyxHQUFHO2dCQUNoQjtnQkFFQXh3RCxPQUFPLElBQUksQ0FBQzR6QyxRQUFRLENBQUMzK0MsRUFBRSxDQUFDcUksQ0FBQztnQkFDekJvRSxLQUFLd3RCLFVBQVUrQyxpQkFBaUIsQ0FBQ2p5QixLQUFLMUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUwQyxLQUFLMUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQzdEcUssSUFBSTRvRCxNQUFNLENBQUM3dUQsRUFBRSxDQUFDLEVBQUUsRUFBRUEsRUFBRSxDQUFDLEVBQUU7Z0JBQ3ZCLElBQUlSO2dCQUNKLElBQUlDLE9BQU9uQixLQUFLZ2IsT0FBTztnQkFFdkIsSUFBSzlaLElBQUksR0FBR0EsSUFBSUMsTUFBTUQsS0FBSyxFQUFHO29CQUM1Qml4QixNQUFNakQsVUFBVW1ELG1CQUFtQixDQUFDcnlCLEtBQUs4QyxDQUFDLENBQUM1QixJQUFJLEVBQUUsRUFBRWxCLEtBQUsvSyxDQUFDLENBQUNpTSxFQUFFLEVBQUVsQixLQUFLMUMsQ0FBQyxDQUFDNEQsRUFBRTtvQkFDdkV5RyxJQUFJOG9ELGFBQWEsQ0FBQ3QrQixHQUFHLENBQUMsRUFBRSxFQUFFQSxHQUFHLENBQUMsRUFBRSxFQUFFQSxHQUFHLENBQUMsRUFBRSxFQUFFQSxHQUFHLENBQUMsRUFBRSxFQUFFQSxHQUFHLENBQUMsRUFBRSxFQUFFQSxHQUFHLENBQUMsRUFBRTtnQkFDbEU7Z0JBRUFBLE1BQU1qRCxVQUFVbUQsbUJBQW1CLENBQUNyeUIsS0FBSzhDLENBQUMsQ0FBQzVCLElBQUksRUFBRSxFQUFFbEIsS0FBSy9LLENBQUMsQ0FBQyxFQUFFLEVBQUUrSyxLQUFLMUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQ3ZFcUssSUFBSThvRCxhQUFhLENBQUN0K0IsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUU7WUFDbEU7UUFDRjtRQUVBLElBQUksQ0FBQ2wzQixPQUFPLENBQUN5VSxVQUFVLENBQUN0QixRQUFRLENBQUNzaUQsSUFBSSxDQUFDO1FBQ3RDL29ELElBQUlncEQsSUFBSTtJQUNWO0lBRUFSLGNBQWM5NkQsU0FBUyxDQUFDMi9DLGVBQWUsR0FBR3RCLFlBQVlyK0MsU0FBUyxDQUFDMi9DLGVBQWU7SUFFL0VtYixjQUFjOTZELFNBQVMsQ0FBQ21WLE9BQU8sR0FBRztRQUNoQyxJQUFJLENBQUN2UCxPQUFPLEdBQUc7SUFDakI7SUFFQSxTQUFTMjFELGlCQUFpQjtJQUUxQixJQUFJQyxnQkFBZ0I7UUFDbEIsR0FBRztRQUNILEdBQUc7UUFDSCxHQUFHO1FBQ0gsR0FBRztJQUNMO0lBQ0FELGNBQWN2N0QsU0FBUyxHQUFHO1FBQ3hCeTdELGdCQUFnQixTQUFTQSxrQkFBa0I7UUFDM0NuYSxxQkFBcUIsU0FBU0EsdUJBQXVCO1FBQ3JEQyx5QkFBeUIsU0FBU0E7WUFDaEMsK0ZBQStGO1lBQy9GLDZGQUE2RjtZQUM3RixrSEFBa0g7WUFDbEgsbUdBQW1HO1lBQ25HLG1GQUFtRjtZQUNuRixJQUFJLElBQUksQ0FBQzUyQyxJQUFJLENBQUNvM0MsRUFBRSxJQUFJLEdBQUc7Z0JBQ3JCLElBQUksQ0FBQzJaLE9BQU8sR0FBRyxFQUFFO2dCQUNqQixJQUFJVixnQkFBZ0IsSUFBSSxDQUFDM2dELFVBQVUsQ0FBQzJnRCxhQUFhO2dCQUNqRCxJQUFJVyxlQUFlaHNELFlBQVk2cUQsWUFBWSxDQUFDUSxjQUFjN29ELE1BQU0sQ0FBQ0MsS0FBSyxFQUFFNG9ELGNBQWM3b0QsTUFBTSxDQUFDRSxNQUFNO2dCQUNuRyxJQUFJLENBQUNxcEQsT0FBTyxDQUFDdjZELElBQUksQ0FBQ3c2RDtnQkFDbEIsSUFBSUMsZ0JBQWdCanNELFlBQVk2cUQsWUFBWSxDQUFDUSxjQUFjN29ELE1BQU0sQ0FBQ0MsS0FBSyxFQUFFNG9ELGNBQWM3b0QsTUFBTSxDQUFDRSxNQUFNO2dCQUNwRyxJQUFJLENBQUNxcEQsT0FBTyxDQUFDdjZELElBQUksQ0FBQ3k2RDtnQkFFbEIsSUFBSSxJQUFJLENBQUNqeEQsSUFBSSxDQUFDbzNDLEVBQUUsSUFBSSxLQUFLLENBQUN4aUQsU0FBU3M4RCxRQUFRLEVBQUU7b0JBQzNDbHNELFlBQVk4cUQsY0FBYztnQkFDNUI7WUFDRjtZQUVBLElBQUksQ0FBQ08sYUFBYSxHQUFHLElBQUksQ0FBQzNnRCxVQUFVLENBQUMyZ0QsYUFBYTtZQUNsRCxJQUFJLENBQUNjLGVBQWUsR0FBRyxJQUFJLENBQUN6aEQsVUFBVSxDQUFDeWhELGVBQWU7WUFDdEQsSUFBSSxDQUFDaGUsd0JBQXdCLEdBQUcsSUFBSThjLFVBQVUsSUFBSTtZQUNsRCxJQUFJLENBQUMvYyxzQkFBc0I7UUFDN0I7UUFDQTJGLGVBQWUsU0FBU0EsaUJBQWlCO1FBQ3pDeEssY0FBYyxTQUFTQTtZQUNyQixJQUFJMytCLGFBQWEsSUFBSSxDQUFDQSxVQUFVO1lBRWhDLElBQUlBLFdBQVcwaEQsU0FBUyxLQUFLLElBQUksQ0FBQ3B4RCxJQUFJLENBQUN1dUMsRUFBRSxFQUFFO2dCQUN6QzcrQixXQUFXMGhELFNBQVMsR0FBRyxJQUFJLENBQUNweEQsSUFBSSxDQUFDdXVDLEVBQUU7Z0JBQ25DLElBQUlELGlCQUFpQnJDLGFBQWEsSUFBSSxDQUFDanNDLElBQUksQ0FBQ3V1QyxFQUFFO2dCQUM5QzcrQixXQUFXMmdELGFBQWEsQ0FBQ2dCLHdCQUF3QixHQUFHL2lCO1lBQ3REO1FBQ0Y7UUFDQXNKLDRCQUE0QixTQUFTQTtZQUNuQyxJQUFJLENBQUNqSyxXQUFXLEdBQUcsSUFBSXdpQixjQUFjLElBQUksQ0FBQ253RCxJQUFJLEVBQUUsSUFBSTtZQUNwRCxJQUFJLENBQUNvekMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDRCx3QkFBd0IsQ0FBQ0UsVUFBVSxDQUFDcEIsWUFBWUMsZ0JBQWdCO1FBQy9GO1FBQ0FvZixhQUFhLFNBQVNBO1lBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUN2bUIsTUFBTSxJQUFLLEVBQUMsSUFBSSxDQUFDRCxTQUFTLElBQUksSUFBSSxDQUFDRSxhQUFhLEdBQUc7Z0JBQzNELElBQUksQ0FBQ0QsTUFBTSxHQUFHO1lBQ2hCO1FBQ0Y7UUFDQXdtQixhQUFhLFNBQVNBO1lBQ3BCLElBQUksSUFBSSxDQUFDem1CLFNBQVMsSUFBSSxDQUFDLElBQUksQ0FBQ0UsYUFBYSxFQUFFO2dCQUN6QyxJQUFJLENBQUNELE1BQU0sR0FBRztnQkFDZCxJQUFJLENBQUN4a0IsYUFBYSxHQUFHO2dCQUNyQixJQUFJLENBQUNvbkIsV0FBVyxDQUFDcG5CLGFBQWEsR0FBRztZQUNuQztRQUNGO1FBQ0FpckMsYUFBYSxTQUFTQSxZQUFZbkIsYUFBYTtZQUM3Q0EsY0FBY29CLFNBQVMsQ0FBQyxJQUFJLENBQUNOLGVBQWUsQ0FBQ25pQyxFQUFFLEVBQUUsSUFBSSxDQUFDbWlDLGVBQWUsQ0FBQ3Z2RCxFQUFFLEVBQUUsSUFBSSxDQUFDdXZELGVBQWUsQ0FBQzNyQyxDQUFDLEdBQUcsSUFBSSxDQUFDMnJDLGVBQWUsQ0FBQzVpQyxFQUFFLEVBQUUsSUFBSSxDQUFDNGlDLGVBQWUsQ0FBQy96RCxDQUFDLEdBQUcsSUFBSSxDQUFDK3pELGVBQWUsQ0FBQzNsQyxFQUFFO1FBQzlLO1FBQ0FrbUMsY0FBYyxTQUFTQTtZQUNyQixJQUFJLElBQUksQ0FBQzF4RCxJQUFJLENBQUNvM0MsRUFBRSxJQUFJLEdBQUc7Z0JBQ3JCLElBQUl1YSxTQUFTLElBQUksQ0FBQ1osT0FBTyxDQUFDLEVBQUU7Z0JBQzVCLElBQUlhLFlBQVlELE9BQU8vcEQsVUFBVSxDQUFDO2dCQUNsQyxJQUFJLENBQUM0cEQsV0FBVyxDQUFDSSxZQUFZLHVFQUF1RTtnQkFFcEdBLFVBQVVDLFNBQVMsQ0FBQyxJQUFJLENBQUN4QixhQUFhLENBQUM3b0QsTUFBTSxFQUFFLEdBQUcsSUFBSSw4Q0FBOEM7Z0JBQ3BHLG9GQUFvRjtnQkFFcEYsSUFBSSxDQUFDKzRDLGdCQUFnQixHQUFHLElBQUksQ0FBQzhQLGFBQWEsQ0FBQ3lCLFlBQVk7Z0JBQ3ZELElBQUksQ0FBQ3pCLGFBQWEsQ0FBQ3poQyxZQUFZLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUMvQyxJQUFJLENBQUM0aUMsV0FBVyxDQUFDLElBQUksQ0FBQ25CLGFBQWE7Z0JBQ25DLElBQUksQ0FBQ0EsYUFBYSxDQUFDemhDLFlBQVksQ0FBQyxJQUFJLENBQUMyeEIsZ0JBQWdCO1lBQ3ZEO1FBQ0Y7UUFDQXdSLFdBQVcsU0FBU0E7WUFDbEIsSUFBSSxJQUFJLENBQUMveEQsSUFBSSxDQUFDbzNDLEVBQUUsSUFBSSxHQUFHO2dCQUNyQixJQUFJdWEsU0FBUyxJQUFJLENBQUNaLE9BQU8sQ0FBQyxFQUFFLEVBQUUsd0VBQXdFO2dCQUN0RywrQ0FBK0M7Z0JBQy9DLCtEQUErRDtnQkFFL0QsSUFBSWEsWUFBWUQsT0FBTy9wRCxVQUFVLENBQUM7Z0JBQ2xDLElBQUksQ0FBQzRwRCxXQUFXLENBQUNJO2dCQUNqQkEsVUFBVUMsU0FBUyxDQUFDLElBQUksQ0FBQ3hCLGFBQWEsQ0FBQzdvRCxNQUFNLEVBQUUsR0FBRyxJQUFJLDRCQUE0QjtnQkFFbEYsSUFBSSxDQUFDNm9ELGFBQWEsQ0FBQ3poQyxZQUFZLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO2dCQUMvQyxJQUFJLENBQUM0aUMsV0FBVyxDQUFDLElBQUksQ0FBQ25CLGFBQWE7Z0JBQ25DLElBQUksQ0FBQ0EsYUFBYSxDQUFDemhDLFlBQVksQ0FBQyxJQUFJLENBQUMyeEIsZ0JBQWdCLEdBQUcsbUJBQW1CO2dCQUUzRSxJQUFJNUwsT0FBTyxJQUFJLENBQUNweUMsSUFBSSxDQUFDb3ZDLGNBQWMsQ0FBQyxRQUFRLElBQUksQ0FBQzN4QyxJQUFJLEdBQUcsSUFBSSxDQUFDQSxJQUFJLENBQUN3dEQsRUFBRSxHQUFHLElBQUksQ0FBQ3h0RCxJQUFJLENBQUNpaUIsR0FBRyxHQUFHO2dCQUN2RjB5QixLQUFLbGlDLFdBQVcsQ0FBQyxPQUFPLHNFQUFzRTtnQkFFOUYsSUFBSSxDQUFDNDlDLGFBQWEsQ0FBQ3poQyxZQUFZLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksMkVBQTJFO2dCQUM5SCwyRkFBMkY7Z0JBRTNGLElBQUksSUFBSSxDQUFDNXVCLElBQUksQ0FBQ28zQyxFQUFFLElBQUksS0FBSyxDQUFDeGlELFNBQVNzOEQsUUFBUSxFQUFFO29CQUMzQyxvRkFBb0Y7b0JBQ3BGLG1EQUFtRDtvQkFDbkQsSUFBSTVCLGFBQWF0cUQsWUFBWStxRCxhQUFhLENBQUMsSUFBSSxDQUFDTSxhQUFhLENBQUM3b0QsTUFBTTtvQkFDcEUsSUFBSStuRCxnQkFBZ0JELFdBQVcxbkQsVUFBVSxDQUFDO29CQUMxQzJuRCxjQUFjc0MsU0FBUyxDQUFDLElBQUksQ0FBQ3hCLGFBQWEsQ0FBQzdvRCxNQUFNLEVBQUUsR0FBRztvQkFDdEQsSUFBSSxDQUFDZ3FELFdBQVcsQ0FBQyxJQUFJLENBQUNuQixhQUFhLEdBQUcscURBQXFEO29CQUUzRixJQUFJLENBQUNBLGFBQWEsQ0FBQ3dCLFNBQVMsQ0FBQ3ZDLFlBQVksR0FBRztnQkFDOUM7Z0JBRUEsSUFBSSxDQUFDZSxhQUFhLENBQUNnQix3QkFBd0IsR0FBR1IsYUFBYSxDQUFDLElBQUksQ0FBQzd3RCxJQUFJLENBQUNvM0MsRUFBRSxDQUFDO2dCQUN6RSxJQUFJLENBQUNpWixhQUFhLENBQUN3QixTQUFTLENBQUNGLFFBQVEsR0FBRyxJQUFJLHFGQUFxRjtnQkFDakksNkVBQTZFO2dCQUU3RSxJQUFJLENBQUN0QixhQUFhLENBQUNnQix3QkFBd0IsR0FBRztnQkFDOUMsSUFBSSxDQUFDaEIsYUFBYSxDQUFDd0IsU0FBUyxDQUFDLElBQUksQ0FBQ2QsT0FBTyxDQUFDLEVBQUUsRUFBRSxHQUFHO2dCQUNqRCxJQUFJLENBQUNWLGFBQWEsQ0FBQ3poQyxZQUFZLENBQUMsSUFBSSxDQUFDMnhCLGdCQUFnQixHQUFHLHVGQUF1RjtnQkFFL0ksSUFBSSxDQUFDOFAsYUFBYSxDQUFDZ0Isd0JBQXdCLEdBQUc7WUFDaEQ7UUFDRjtRQUNBNStDLGFBQWEsU0FBU0EsWUFBWTZsQixXQUFXO1lBQzNDLElBQUksSUFBSSxDQUFDeVMsTUFBTSxJQUFJLElBQUksQ0FBQy9xQyxJQUFJLENBQUNzM0MsRUFBRSxFQUFFO2dCQUMvQjtZQUNGO1lBRUEsSUFBSSxJQUFJLENBQUN0M0MsSUFBSSxDQUFDaTNDLEVBQUUsS0FBSyxLQUFLLENBQUMzZSxhQUFhO2dCQUN0QztZQUNGO1lBRUEsSUFBSSxDQUFDcWEsZUFBZTtZQUNwQixJQUFJLENBQUM5RyxnQkFBZ0I7WUFDckIsSUFBSSxDQUFDZ0gsb0JBQW9CO1lBQ3pCLElBQUksQ0FBQ3hFLFlBQVk7WUFDakIsSUFBSTJqQixpQkFBaUIsSUFBSSxDQUFDaHlELElBQUksQ0FBQzRCLEVBQUUsS0FBSztZQUN0QyxJQUFJLENBQUM4dkQsWUFBWTtZQUNqQixJQUFJLENBQUNoaUQsVUFBVSxDQUFDdEIsUUFBUSxDQUFDc2lELElBQUksQ0FBQ3NCO1lBQzlCLElBQUksQ0FBQ3RpRCxVQUFVLENBQUN0QixRQUFRLENBQUM2akQsWUFBWSxDQUFDLElBQUksQ0FBQ3htQixjQUFjLENBQUMrRyxRQUFRLENBQUMxa0IsS0FBSztZQUN4RSxJQUFJLENBQUNwZSxVQUFVLENBQUN0QixRQUFRLENBQUM4akQsVUFBVSxDQUFDLElBQUksQ0FBQ3ptQixjQUFjLENBQUNnSCxZQUFZO1lBQ3BFLElBQUksQ0FBQ3FHLGtCQUFrQjtZQUN2QixJQUFJLENBQUNwcEMsVUFBVSxDQUFDdEIsUUFBUSxDQUFDK2pELE9BQU8sQ0FBQ0g7WUFDakMsSUFBSSxDQUFDRCxTQUFTO1lBRWQsSUFBSSxJQUFJLENBQUNwa0IsV0FBVyxDQUFDeWlCLFFBQVEsRUFBRTtnQkFDN0IsSUFBSSxDQUFDMWdELFVBQVUsQ0FBQ3RCLFFBQVEsQ0FBQytqRCxPQUFPLENBQUM7WUFDbkM7WUFFQSxJQUFJLElBQUksQ0FBQzVyQyxhQUFhLEVBQUU7Z0JBQ3RCLElBQUksQ0FBQ0EsYUFBYSxHQUFHO1lBQ3ZCO1FBQ0Y7UUFDQS9iLFNBQVMsU0FBU0E7WUFDaEIsSUFBSSxDQUFDNmxELGFBQWEsR0FBRztZQUNyQixJQUFJLENBQUNyd0QsSUFBSSxHQUFHO1lBQ1osSUFBSSxDQUFDMFAsVUFBVSxHQUFHO1lBQ2xCLElBQUksQ0FBQ2krQixXQUFXLENBQUNuakMsT0FBTztRQUMxQjtRQUNBaXBDLFNBQVMsSUFBSWptQjtJQUNmO0lBQ0FvakMsY0FBY3Y3RCxTQUFTLENBQUMwZixJQUFJLEdBQUc2N0MsY0FBY3Y3RCxTQUFTLENBQUNpOEQsV0FBVztJQUNsRVYsY0FBY3Y3RCxTQUFTLENBQUMyZixJQUFJLEdBQUc0N0MsY0FBY3Y3RCxTQUFTLENBQUNrOEQsV0FBVztJQUVsRSxTQUFTYSxZQUFZbjNELE9BQU8sRUFBRStFLElBQUksRUFBRTZqQyxNQUFNLEVBQUV3dUIsaUJBQWlCO1FBQzNELElBQUksQ0FBQ0MsWUFBWSxHQUFHLEVBQUU7UUFDdEIsSUFBSSxDQUFDbjVCLEVBQUUsR0FBRztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFFO1FBQzVCLElBQUl2M0IsS0FBSztRQUVULElBQUk1QixLQUFLNEIsRUFBRSxLQUFLLE1BQU07WUFDcEJBLEtBQUs7UUFDUCxPQUFPLElBQUk1QixLQUFLNEIsRUFBRSxLQUFLLE1BQU07WUFDM0JBLEtBQUs7UUFDUCxPQUFPLElBQUk1QixLQUFLNEIsRUFBRSxLQUFLLE1BQU07WUFDM0JBLEtBQUs7UUFDUDtRQUVBLElBQUksQ0FBQ29oQixFQUFFLEdBQUc0RyxxQkFBcUJ3RCxZQUFZLENBQUNueUIsU0FBUytFLE1BQU00QixJQUFJM0c7UUFDL0QsSUFBSWhHO1FBQ0osSUFBSUMsTUFBTTJ1QyxPQUFPMXVDLE1BQU07UUFDdkIsSUFBSW85RDtRQUVKLElBQUt0OUQsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDM0IsSUFBSSxDQUFDNHVDLE1BQU0sQ0FBQzV1QyxFQUFFLENBQUMwUCxNQUFNLEVBQUU7Z0JBQ3JCNHRELGNBQWM7b0JBQ1poZixZQUFZOGUsa0JBQWtCckQsb0JBQW9CLENBQUNuckIsTUFBTSxDQUFDNXVDLEVBQUUsQ0FBQ3MrQyxVQUFVO29CQUN2RWlmLFNBQVMsRUFBRTtnQkFDYjtnQkFDQSxJQUFJLENBQUNGLFlBQVksQ0FBQzk3RCxJQUFJLENBQUMrN0Q7Z0JBQ3ZCMXVCLE1BQU0sQ0FBQzV1QyxFQUFFLENBQUNtbEMsUUFBUSxDQUFDNWpDLElBQUksQ0FBQys3RDtZQUMxQjtRQUNGO0lBQ0Y7SUFFQUgsWUFBWS84RCxTQUFTLENBQUNpZ0MsYUFBYSxHQUFHMmtCLGFBQWE1a0QsU0FBUyxDQUFDaWdDLGFBQWE7SUFFMUUsU0FBU205QixlQUFlenlELElBQUksRUFBRTBQLFVBQVUsRUFBRW5OLElBQUk7UUFDNUMsSUFBSSxDQUFDUCxNQUFNLEdBQUcsRUFBRTtRQUNoQixJQUFJLENBQUNpc0MsVUFBVSxHQUFHanVDLEtBQUtnQyxNQUFNO1FBQzdCLElBQUksQ0FBQys4QyxVQUFVLEdBQUcsRUFBRTtRQUNwQixJQUFJLENBQUM3USxTQUFTLEdBQUcsRUFBRTtRQUNuQixJQUFJLENBQUM2TyxZQUFZLEdBQUcsRUFBRTtRQUN0QixJQUFJLENBQUN4RCxjQUFjLEdBQUcsRUFBRTtRQUN4QixJQUFJLENBQUNNLGlCQUFpQixHQUFHLEVBQUU7UUFDM0IsSUFBSSxDQUFDd1ksaUJBQWlCLEdBQUcsSUFBSXpEO1FBQzdCLElBQUksQ0FBQ2hXLFdBQVcsQ0FBQzU0QyxNQUFNMFAsWUFBWW5OO0lBQ3JDO0lBRUF6TixnQkFBZ0I7UUFBQ3E0QztRQUFhZ0Y7UUFBa0J5ZTtRQUFldlg7UUFBZWQ7UUFBa0J6SjtRQUFjbEU7S0FBa0IsRUFBRTZuQjtJQUNsSUEsZUFBZXA5RCxTQUFTLENBQUN1akQsV0FBVyxHQUFHRixxQkFBcUJyakQsU0FBUyxDQUFDdWpELFdBQVc7SUFDakY2WixlQUFlcDlELFNBQVMsQ0FBQ3E5RCxlQUFlLEdBQUc7UUFDekN6ZixTQUFTO1FBQ1RWLFFBQVE7SUFDVjtJQUNBa2dCLGVBQWVwOUQsU0FBUyxDQUFDczlELFlBQVksR0FBRyxFQUFFO0lBRTFDRixlQUFlcDlELFNBQVMsQ0FBQ3dqRCxhQUFhLEdBQUc7UUFDdkMsSUFBSSxDQUFDdUcsWUFBWSxDQUFDLElBQUksQ0FBQ25SLFVBQVUsRUFBRSxJQUFJLENBQUNDLFNBQVMsRUFBRSxJQUFJLENBQUM2TyxZQUFZLEVBQUUsTUFBTSxFQUFFO0lBQ2hGO0lBRUEwVixlQUFlcDlELFNBQVMsQ0FBQ29xRCxrQkFBa0IsR0FBRyxTQUFVei9DLElBQUksRUFBRXV6QyxVQUFVO1FBQ3RFLElBQUlnTCxZQUFZO1lBQ2R2K0MsTUFBTUE7WUFDTnJMLE1BQU1xTCxLQUFLNEIsRUFBRTtZQUNiZ3hELGVBQWUsSUFBSSxDQUFDUCxpQkFBaUIsQ0FBQ3JELG9CQUFvQixDQUFDemI7WUFDM0RBLFlBQVksRUFBRTtZQUNkblosVUFBVSxFQUFFO1lBQ1p6MUIsUUFBUTNFLEtBQUtzM0MsRUFBRSxLQUFLO1FBQ3RCO1FBQ0EsSUFBSW9JLGNBQWMsQ0FBQztRQUVuQixJQUFJMS9DLEtBQUs0QixFQUFFLEtBQUssUUFBUTVCLEtBQUs0QixFQUFFLEtBQUssTUFBTTtZQUN4Qzg5QyxZQUFZbDdDLENBQUMsR0FBRzRpQixnQkFBZ0JDLE9BQU8sQ0FBQyxJQUFJLEVBQUVybkIsS0FBS3dFLENBQUMsRUFBRSxHQUFHLEtBQUssSUFBSTtZQUVsRSxJQUFJLENBQUNrN0MsWUFBWWw3QyxDQUFDLENBQUNwRCxDQUFDLEVBQUU7Z0JBQ3BCbTlDLFVBQVVzVSxFQUFFLEdBQUcsU0FBU2w1RCxRQUFRK2xELFlBQVlsN0MsQ0FBQyxDQUFDbEgsQ0FBQyxDQUFDLEVBQUUsSUFBSSxNQUFNM0QsUUFBUStsRCxZQUFZbDdDLENBQUMsQ0FBQ2xILENBQUMsQ0FBQyxFQUFFLElBQUksTUFBTTNELFFBQVErbEQsWUFBWWw3QyxDQUFDLENBQUNsSCxDQUFDLENBQUMsRUFBRSxJQUFJO1lBQ2hJO1FBQ0YsT0FBTyxJQUFJMEMsS0FBSzRCLEVBQUUsS0FBSyxRQUFRNUIsS0FBSzRCLEVBQUUsS0FBSyxNQUFNO1lBQy9DODlDLFlBQVlyaUQsQ0FBQyxHQUFHK3BCLGdCQUFnQkMsT0FBTyxDQUFDLElBQUksRUFBRXJuQixLQUFLM0MsQ0FBQyxFQUFFLEdBQUcsTUFBTSxJQUFJO1lBQ25FcWlELFlBQVk5K0MsQ0FBQyxHQUFHd21CLGdCQUFnQkMsT0FBTyxDQUFDLElBQUksRUFBRXJuQixLQUFLWSxDQUFDLEVBQUUsR0FBRyxNQUFNLElBQUk7WUFDbkU4K0MsWUFBWXRpRCxDQUFDLEdBQUdncUIsZ0JBQWdCQyxPQUFPLENBQUMsSUFBSSxFQUFFcm5CLEtBQUs1QyxDQUFDLElBQUk7Z0JBQ3REZ0UsR0FBRztZQUNMLEdBQUcsR0FBRyxNQUFNLElBQUk7WUFDaEJzK0MsWUFBWXo3QyxDQUFDLEdBQUdtakIsZ0JBQWdCQyxPQUFPLENBQUMsSUFBSSxFQUFFcm5CLEtBQUtpRSxDQUFDLElBQUk7Z0JBQ3REN0MsR0FBRztZQUNMLEdBQUcsR0FBRzFHLFdBQVcsSUFBSTtZQUNyQmdsRCxZQUFZbGlELENBQUMsR0FBRyxJQUFJMjlDLGlCQUFpQixJQUFJLEVBQUVuN0MsS0FBS3hDLENBQUMsRUFBRSxJQUFJO1FBQ3pEO1FBRUFraUQsWUFBWTU4QyxDQUFDLEdBQUdza0IsZ0JBQWdCQyxPQUFPLENBQUMsSUFBSSxFQUFFcm5CLEtBQUs4QyxDQUFDLEVBQUUsR0FBRyxNQUFNLElBQUk7UUFFbkUsSUFBSTlDLEtBQUs0QixFQUFFLEtBQUssUUFBUTVCLEtBQUs0QixFQUFFLEtBQUssTUFBTTtZQUN4QzI4QyxVQUFVOUIsRUFBRSxHQUFHMUMsV0FBVyxDQUFDLzVDLEtBQUt5OEMsRUFBRSxJQUFJLEVBQUU7WUFDeEM4QixVQUFVamIsRUFBRSxHQUFHMFcsWUFBWSxDQUFDaDZDLEtBQUtzakMsRUFBRSxJQUFJLEVBQUU7WUFFekMsSUFBSXRqQyxLQUFLc2pDLEVBQUUsSUFBSSxHQUFHO2dCQUNoQiw2QkFBNkI7Z0JBQzdCaWIsVUFBVWxiLEVBQUUsR0FBR3JqQyxLQUFLcWpDLEVBQUU7WUFDeEI7WUFFQXFjLFlBQVlsNkIsQ0FBQyxHQUFHNEIsZ0JBQWdCQyxPQUFPLENBQUMsSUFBSSxFQUFFcm5CLEtBQUt3bEIsQ0FBQyxFQUFFLEdBQUcsTUFBTSxJQUFJO1lBRW5FLElBQUksQ0FBQ2s2QixZQUFZbDZCLENBQUMsQ0FBQ3BrQixDQUFDLEVBQUU7Z0JBQ3BCbTlDLFVBQVV1VSxFQUFFLEdBQUdwVCxZQUFZbDZCLENBQUMsQ0FBQ2xvQixDQUFDO1lBQ2hDO1lBRUEsSUFBSTBDLEtBQUtqQyxDQUFDLEVBQUU7Z0JBQ1YsSUFBSUEsSUFBSSxJQUFJMjhDLGFBQWEsSUFBSSxFQUFFMTZDLEtBQUtqQyxDQUFDLEVBQUUsVUFBVSxJQUFJO2dCQUNyRDJoRCxZQUFZM2hELENBQUMsR0FBR0E7Z0JBRWhCLElBQUksQ0FBQzJoRCxZQUFZM2hELENBQUMsQ0FBQ3FELENBQUMsRUFBRTtvQkFDcEJtOUMsVUFBVXdVLEVBQUUsR0FBR3JULFlBQVkzaEQsQ0FBQyxDQUFDODhDLFNBQVM7b0JBQ3RDMEQsU0FBUyxDQUFDLEtBQUssR0FBR21CLFlBQVkzaEQsQ0FBQyxDQUFDKzhDLFVBQVUsQ0FBQyxFQUFFO2dCQUMvQztZQUNGO1FBQ0YsT0FBTztZQUNMeUQsVUFBVWhoRCxDQUFDLEdBQUd5QyxLQUFLekMsQ0FBQyxLQUFLLElBQUksWUFBWTtRQUMzQztRQUVBLElBQUksQ0FBQ3doRCxVQUFVLENBQUN2b0QsSUFBSSxDQUFDK25EO1FBQ3JCbUIsWUFBWXhrRCxLQUFLLEdBQUdxakQ7UUFDcEIsT0FBT21CO0lBQ1Q7SUFFQStTLGVBQWVwOUQsU0FBUyxDQUFDd3FELGtCQUFrQixHQUFHO1FBQzVDLElBQUlILGNBQWM7WUFDaEI3OEMsSUFBSSxFQUFFO1lBQ05rNkMsY0FBYyxFQUFFO1FBQ2xCO1FBQ0EsT0FBTzJDO0lBQ1Q7SUFFQStTLGVBQWVwOUQsU0FBUyxDQUFDeXFELHNCQUFzQixHQUFHLFNBQVU5L0MsSUFBSTtRQUM5RCxJQUFJMC9DLGNBQWM7WUFDaEJ4d0IsV0FBVztnQkFDVCtqQixTQUFTO2dCQUNUVixRQUFRO2dCQUNSbGxDLEtBQUssSUFBSSxDQUFDZ2xELGlCQUFpQixDQUFDakQsU0FBUztnQkFDckN0ckQsSUFBSXNqQixnQkFBZ0JDLE9BQU8sQ0FBQyxJQUFJLEVBQUVybkIsS0FBSzhDLENBQUMsRUFBRSxHQUFHLE1BQU0sSUFBSTtnQkFDdkQ4NEIsUUFBUWhFLHlCQUF5QnFCLG9CQUFvQixDQUFDLElBQUksRUFBRWo1QixNQUFNLElBQUk7WUFDeEU7UUFDRjtRQUNBLE9BQU8wL0M7SUFDVDtJQUVBK1MsZUFBZXA5RCxTQUFTLENBQUMycUQsa0JBQWtCLEdBQUcsU0FBVWhnRCxJQUFJO1FBQzFELElBQUkwL0MsY0FBYyxJQUFJMFMsWUFBWSxJQUFJLEVBQUVweUQsTUFBTSxJQUFJLENBQUMrK0MsVUFBVSxFQUFFLElBQUksQ0FBQ3NULGlCQUFpQjtRQUNyRixJQUFJLENBQUNyd0QsTUFBTSxDQUFDeEwsSUFBSSxDQUFDa3BEO1FBQ2pCLElBQUksQ0FBQ3BHLG1CQUFtQixDQUFDb0c7UUFDekIsT0FBT0E7SUFDVDtJQUVBK1MsZUFBZXA5RCxTQUFTLENBQUM4bEMsWUFBWSxHQUFHO1FBQ3RDLElBQUksQ0FBQzVVLGFBQWEsR0FBRztRQUNyQixJQUFJdHhCO1FBQ0osSUFBSUMsTUFBTSxJQUFJLENBQUNnNUMsU0FBUyxDQUFDLzRDLE1BQU07UUFFL0IsSUFBS0YsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDM0IsSUFBSSxDQUFDOG5ELFlBQVksQ0FBQzluRCxFQUFFLEdBQUcsSUFBSSxDQUFDaTVDLFNBQVMsQ0FBQ2o1QyxFQUFFO1FBQzFDO1FBRUEsSUFBSSxDQUFDbXFELFlBQVksQ0FBQyxJQUFJLENBQUNuUixVQUFVLEVBQUUsSUFBSSxDQUFDQyxTQUFTLEVBQUUsSUFBSSxDQUFDNk8sWUFBWSxFQUFFLE1BQU0sRUFBRTtRQUM5RTduRCxNQUFNLElBQUksQ0FBQ3V5QixpQkFBaUIsQ0FBQ3R5QixNQUFNO1FBRW5DLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCLElBQUksQ0FBQ3d5QixpQkFBaUIsQ0FBQ3h5QixFQUFFLENBQUM4eEIsUUFBUTtRQUNwQztRQUVBLElBQUksQ0FBQzJ5QixlQUFlO1FBQ3BCLElBQUksQ0FBQzJZLGlCQUFpQixDQUFDbEQsZ0JBQWdCLENBQUMsSUFBSSxDQUFDNW9DLGFBQWE7SUFDNUQ7SUFFQWtzQyxlQUFlcDlELFNBQVMsQ0FBQzI5RCx1QkFBdUIsR0FBRyxTQUFVOWpDLFNBQVM7UUFDcEUsSUFBSWo2QjtRQUNKLElBQUlDLE1BQU0sSUFBSSxDQUFDNnBELFVBQVUsQ0FBQzVwRCxNQUFNO1FBRWhDLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCLElBQUksQ0FBQyxJQUFJLENBQUM4cEQsVUFBVSxDQUFDOXBELEVBQUUsQ0FBQzBQLE1BQU0sRUFBRTtnQkFDOUIsSUFBSSxDQUFDbzZDLFVBQVUsQ0FBQzlwRCxFQUFFLENBQUNzK0MsVUFBVSxDQUFDLzhDLElBQUksQ0FBQzA0QjtZQUNyQztRQUNGO0lBQ0Y7SUFFQXVqQyxlQUFlcDlELFNBQVMsQ0FBQzQ5RCw0QkFBNEIsR0FBRztRQUN0RCxJQUFJaCtEO1FBQ0osSUFBSUMsTUFBTSxJQUFJLENBQUM2cEQsVUFBVSxDQUFDNXBELE1BQU07UUFFaEMsSUFBS0YsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDM0IsSUFBSSxDQUFDLElBQUksQ0FBQzhwRCxVQUFVLENBQUM5cEQsRUFBRSxDQUFDMFAsTUFBTSxFQUFFO2dCQUM5QixJQUFJLENBQUNvNkMsVUFBVSxDQUFDOXBELEVBQUUsQ0FBQ3MrQyxVQUFVLENBQUMxYyxHQUFHO1lBQ25DO1FBQ0Y7SUFDRjtJQUVBNDdCLGVBQWVwOUQsU0FBUyxDQUFDNjlELFdBQVcsR0FBRyxTQUFVcnZCLE1BQU07UUFDckQsSUFBSTV1QztRQUNKLElBQUlDLE1BQU0ydUMsT0FBTzF1QyxNQUFNO1FBRXZCLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCNHVDLE1BQU0sQ0FBQzV1QyxFQUFFLENBQUMwUCxNQUFNLEdBQUc7UUFDckI7SUFDRjtJQUVBOHRELGVBQWVwOUQsU0FBUyxDQUFDK3BELFlBQVksR0FBRyxTQUFVcG5ELEdBQUcsRUFBRWsyQyxTQUFTLEVBQUU2TyxZQUFZLEVBQUVvVyxZQUFZLEVBQUU1ZixVQUFVO1FBQ3RHLElBQUl0K0M7UUFDSixJQUFJQyxNQUFNOEMsSUFBSTdDLE1BQU0sR0FBRztRQUN2QixJQUFJK0w7UUFDSixJQUFJQztRQUNKLElBQUlrL0MsWUFBWSxFQUFFO1FBQ2xCLElBQUlDLGVBQWUsRUFBRTtRQUNyQixJQUFJRztRQUNKLElBQUlEO1FBQ0osSUFBSUQ7UUFDSixJQUFJNlMsZ0JBQWdCLEVBQUUsQ0FBQ3Y4QyxNQUFNLENBQUMwOEI7UUFFOUIsSUFBS3QrQyxJQUFJQyxLQUFLRCxLQUFLLEdBQUdBLEtBQUssRUFBRztZQUM1QndyRCxlQUFlLElBQUksQ0FBQzdHLHNCQUFzQixDQUFDNWhELEdBQUcsQ0FBQy9DLEVBQUU7WUFFakQsSUFBSSxDQUFDd3JELGNBQWM7Z0JBQ2pCem9ELEdBQUcsQ0FBQy9DLEVBQUUsQ0FBQ28rRCxhQUFhLEdBQUdGO1lBQ3pCLE9BQU87Z0JBQ0xqbEIsU0FBUyxDQUFDajVDLEVBQUUsR0FBRzhuRCxZQUFZLENBQUMwRCxlQUFlLEVBQUU7WUFDL0M7WUFFQSxJQUFJem9ELEdBQUcsQ0FBQy9DLEVBQUUsQ0FBQzJNLEVBQUUsS0FBSyxRQUFRNUosR0FBRyxDQUFDL0MsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLFFBQVE1SixHQUFHLENBQUMvQyxFQUFFLENBQUMyTSxFQUFFLEtBQUssUUFBUTVKLEdBQUcsQ0FBQy9DLEVBQUUsQ0FBQzJNLEVBQUUsS0FBSyxNQUFNO2dCQUN4RixJQUFJLENBQUM2K0MsY0FBYztvQkFDakJ2UyxTQUFTLENBQUNqNUMsRUFBRSxHQUFHLElBQUksQ0FBQ3dxRCxrQkFBa0IsQ0FBQ3puRCxHQUFHLENBQUMvQyxFQUFFLEVBQUVtK0Q7Z0JBQ2pELE9BQU87b0JBQ0xsbEIsU0FBUyxDQUFDajVDLEVBQUUsQ0FBQ2lHLEtBQUssQ0FBQ3lKLE1BQU0sR0FBRztnQkFDOUI7Z0JBRUEwN0MsVUFBVTdwRCxJQUFJLENBQUMwM0MsU0FBUyxDQUFDajVDLEVBQUUsQ0FBQ2lHLEtBQUs7WUFDbkMsT0FBTyxJQUFJbEQsR0FBRyxDQUFDL0MsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLE1BQU07Z0JBQzdCLElBQUksQ0FBQzYrQyxjQUFjO29CQUNqQnZTLFNBQVMsQ0FBQ2o1QyxFQUFFLEdBQUcsSUFBSSxDQUFDNHFELGtCQUFrQixDQUFDN25ELEdBQUcsQ0FBQy9DLEVBQUU7Z0JBQy9DLE9BQU87b0JBQ0xrTSxPQUFPK3NDLFNBQVMsQ0FBQ2o1QyxFQUFFLENBQUM0TixFQUFFLENBQUMxTixNQUFNO29CQUU3QixJQUFLK0wsSUFBSSxHQUFHQSxJQUFJQyxNQUFNRCxLQUFLLEVBQUc7d0JBQzVCZ3RDLFNBQVMsQ0FBQ2o1QyxFQUFFLENBQUM4bkQsWUFBWSxDQUFDNzdDLEVBQUUsR0FBR2d0QyxTQUFTLENBQUNqNUMsRUFBRSxDQUFDNE4sRUFBRSxDQUFDM0IsRUFBRTtvQkFDbkQ7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDaytDLFlBQVksQ0FBQ3BuRCxHQUFHLENBQUMvQyxFQUFFLENBQUM0TixFQUFFLEVBQUVxckMsU0FBUyxDQUFDajVDLEVBQUUsQ0FBQzROLEVBQUUsRUFBRXFyQyxTQUFTLENBQUNqNUMsRUFBRSxDQUFDOG5ELFlBQVksRUFBRW9XLGNBQWNDO1lBQ3pGLE9BQU8sSUFBSXA3RCxHQUFHLENBQUMvQyxFQUFFLENBQUMyTSxFQUFFLEtBQUssTUFBTTtnQkFDN0IsSUFBSSxDQUFDNitDLGNBQWM7b0JBQ2pCRixtQkFBbUIsSUFBSSxDQUFDVCxzQkFBc0IsQ0FBQzluRCxHQUFHLENBQUMvQyxFQUFFO29CQUNyRGk1QyxTQUFTLENBQUNqNUMsRUFBRSxHQUFHc3JEO2dCQUNqQjtnQkFFQTZTLGNBQWM1OEQsSUFBSSxDQUFDMDNDLFNBQVMsQ0FBQ2o1QyxFQUFFO2dCQUMvQixJQUFJLENBQUMrOUQsdUJBQXVCLENBQUM5a0IsU0FBUyxDQUFDajVDLEVBQUU7WUFDM0MsT0FBTyxJQUFJK0MsR0FBRyxDQUFDL0MsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLFFBQVE1SixHQUFHLENBQUMvQyxFQUFFLENBQUMyTSxFQUFFLEtBQUssUUFBUTVKLEdBQUcsQ0FBQy9DLEVBQUUsQ0FBQzJNLEVBQUUsS0FBSyxRQUFRNUosR0FBRyxDQUFDL0MsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLE1BQU07Z0JBQy9GLElBQUksQ0FBQzYrQyxjQUFjO29CQUNqQnZTLFNBQVMsQ0FBQ2o1QyxFQUFFLEdBQUcsSUFBSSxDQUFDK3FELGtCQUFrQixDQUFDaG9ELEdBQUcsQ0FBQy9DLEVBQUU7Z0JBQy9DO1lBQ0YsT0FBTyxJQUFJK0MsR0FBRyxDQUFDL0MsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLFFBQVE1SixHQUFHLENBQUMvQyxFQUFFLENBQUMyTSxFQUFFLEtBQUssUUFBUTVKLEdBQUcsQ0FBQy9DLEVBQUUsQ0FBQzJNLEVBQUUsS0FBSyxRQUFRNUosR0FBRyxDQUFDL0MsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLFFBQVE1SixHQUFHLENBQUMvQyxFQUFFLENBQUMyTSxFQUFFLEtBQUssTUFBTTtnQkFDckgsSUFBSSxDQUFDNitDLGNBQWM7b0JBQ2pCRCxXQUFXenJCLGVBQWVHLFdBQVcsQ0FBQ2w5QixHQUFHLENBQUMvQyxFQUFFLENBQUMyTSxFQUFFO29CQUMvQzQrQyxTQUFTdHNDLElBQUksQ0FBQyxJQUFJLEVBQUVsYyxHQUFHLENBQUMvQyxFQUFFO29CQUMxQmk1QyxTQUFTLENBQUNqNUMsRUFBRSxHQUFHdXJEO29CQUNmLElBQUksQ0FBQ2pILGNBQWMsQ0FBQy9pRCxJQUFJLENBQUNncUQ7Z0JBQzNCLE9BQU87b0JBQ0xBLFdBQVd0UyxTQUFTLENBQUNqNUMsRUFBRTtvQkFDdkJ1ckQsU0FBUzc3QyxNQUFNLEdBQUc7Z0JBQ3BCO2dCQUVBMjdDLGFBQWE5cEQsSUFBSSxDQUFDZ3FEO1lBQ3BCLE9BQU8sSUFBSXhvRCxHQUFHLENBQUMvQyxFQUFFLENBQUMyTSxFQUFFLEtBQUssTUFBTTtnQkFDN0IsSUFBSSxDQUFDNitDLGNBQWM7b0JBQ2pCRCxXQUFXenJCLGVBQWVHLFdBQVcsQ0FBQ2w5QixHQUFHLENBQUMvQyxFQUFFLENBQUMyTSxFQUFFO29CQUMvQ3NzQyxTQUFTLENBQUNqNUMsRUFBRSxHQUFHdXJEO29CQUNmQSxTQUFTdHNDLElBQUksQ0FBQyxJQUFJLEVBQUVsYyxLQUFLL0MsR0FBR2k1QztvQkFDNUIsSUFBSSxDQUFDcUwsY0FBYyxDQUFDL2lELElBQUksQ0FBQ2dxRDtvQkFDekIyUyxlQUFlO2dCQUNqQixPQUFPO29CQUNMM1MsV0FBV3RTLFNBQVMsQ0FBQ2o1QyxFQUFFO29CQUN2QnVyRCxTQUFTNzdDLE1BQU0sR0FBRztnQkFDcEI7Z0JBRUEyN0MsYUFBYTlwRCxJQUFJLENBQUNncUQ7WUFDcEI7WUFFQSxJQUFJLENBQUMxRyxtQkFBbUIsQ0FBQzloRCxHQUFHLENBQUMvQyxFQUFFLEVBQUVBLElBQUk7UUFDdkM7UUFFQSxJQUFJLENBQUNnK0QsNEJBQTRCO1FBQ2pDLElBQUksQ0FBQ0MsV0FBVyxDQUFDN1M7UUFDakJuckQsTUFBTW9yRCxhQUFhbnJELE1BQU07UUFFekIsSUFBS0YsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDM0JxckQsWUFBWSxDQUFDcnJELEVBQUUsQ0FBQzBQLE1BQU0sR0FBRztRQUMzQjtJQUNGO0lBRUE4dEQsZUFBZXA5RCxTQUFTLENBQUN5akQsa0JBQWtCLEdBQUc7UUFDNUMsSUFBSSxDQUFDNFosZUFBZSxDQUFDemYsT0FBTyxHQUFHO1FBQy9CLElBQUksQ0FBQ3lmLGVBQWUsQ0FBQ25nQixNQUFNLEdBQUc7UUFDOUIsSUFBSSxDQUFDbUgsZUFBZTtRQUNwQixJQUFJLENBQUMyWSxpQkFBaUIsQ0FBQ2xELGdCQUFnQixDQUFDLElBQUksQ0FBQzVvQyxhQUFhO1FBQzFELElBQUksQ0FBQ202QixXQUFXLENBQUMsSUFBSSxDQUFDZ1MsZUFBZSxFQUFFLElBQUksQ0FBQ3prQixVQUFVLEVBQUUsSUFBSSxDQUFDQyxTQUFTLEVBQUU7SUFDMUU7SUFFQXVrQixlQUFlcDlELFNBQVMsQ0FBQ2krRCxvQkFBb0IsR0FBRyxTQUFVQyxlQUFlLEVBQUVDLGNBQWM7UUFDdkYsSUFBSUQsZ0JBQWdCaGhCLE1BQU0sSUFBSWloQixlQUFlMXZELEVBQUUsQ0FBQ29pQixJQUFJLElBQUksSUFBSSxDQUFDSyxhQUFhLEVBQUU7WUFDMUVpdEMsZUFBZXZnQixPQUFPLEdBQUdzZ0IsZ0JBQWdCdGdCLE9BQU87WUFDaER1Z0IsZUFBZXZnQixPQUFPLElBQUl1Z0IsZUFBZTF2RCxFQUFFLENBQUN4RyxDQUFDO1lBQzdDazJELGVBQWVqaEIsTUFBTSxHQUFHO1FBQzFCO0lBQ0Y7SUFFQWtnQixlQUFlcDlELFNBQVMsQ0FBQ28rRCxTQUFTLEdBQUc7UUFDbkMsSUFBSXgrRDtRQUNKLElBQUlDLE1BQU0sSUFBSSxDQUFDNnBELFVBQVUsQ0FBQzVwRCxNQUFNO1FBQ2hDLElBQUkrTDtRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUkrNUI7UUFDSixJQUFJczRCO1FBQ0osSUFBSXRsRCxXQUFXLElBQUksQ0FBQ3NCLFVBQVUsQ0FBQ3RCLFFBQVE7UUFDdkMsSUFBSXpHLE1BQU0sSUFBSSxDQUFDK0gsVUFBVSxDQUFDMmdELGFBQWE7UUFDdkMsSUFBSTE3RDtRQUNKLElBQUlnL0Q7UUFFSixJQUFLMStELElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCMCtELGVBQWUsSUFBSSxDQUFDNVUsVUFBVSxDQUFDOXBELEVBQUU7WUFDakNOLE9BQU9nL0QsYUFBYWgvRCxJQUFJLEVBQUUsc0JBQXNCO1lBQ2hELHdCQUF3QjtZQUN4Qix3REFBd0Q7WUFDeEQsMkJBQTJCO1lBQzNCLDBCQUEwQjtZQUUxQixJQUFJLENBQUUsRUFBQ0EsU0FBUyxRQUFRQSxTQUFTLElBQUcsS0FBTWcvRCxhQUFhYixFQUFFLEtBQUssS0FBSyxDQUFDYSxhQUFhM3pELElBQUksQ0FBQ3F6RCxhQUFhLElBQUlNLGFBQWFDLElBQUksS0FBSyxLQUFLLElBQUksQ0FBQ2xrRCxVQUFVLENBQUNta0Qsa0JBQWtCLEtBQUssSUFBSTtnQkFDM0t6bEQsU0FBU3NpRCxJQUFJO2dCQUNidDFCLFFBQVF1NEIsYUFBYXY1QixRQUFRO2dCQUU3QixJQUFJemxDLFNBQVMsUUFBUUEsU0FBUyxNQUFNO29CQUNsQ3laLFNBQVMwbEQsY0FBYyxDQUFDbi9ELFNBQVMsT0FBT2cvRCxhQUFhZCxFQUFFLEdBQUdjLGFBQWFJLEdBQUcsR0FBRyx3RUFBd0U7b0JBRXJKM2xELFNBQVM0bEQsWUFBWSxDQUFDTCxhQUFhYixFQUFFLEdBQUcsbUNBQW1DO29CQUUzRTFrRCxTQUFTNmxELFVBQVUsQ0FBQ04sYUFBYWxYLEVBQUUsR0FBRyxpQ0FBaUM7b0JBRXZFcnVDLFNBQVM4bEQsV0FBVyxDQUFDUCxhQUFhcndCLEVBQUUsR0FBRyxrQ0FBa0M7b0JBRXpFbDFCLFNBQVMrbEQsYUFBYSxDQUFDUixhQUFhdHdCLEVBQUUsSUFBSSxJQUFJLHlDQUF5QztnQkFDekYsT0FBTztvQkFDTGoxQixTQUFTZ21ELFlBQVksQ0FBQ3ovRCxTQUFTLE9BQU9nL0QsYUFBYWQsRUFBRSxHQUFHYyxhQUFhSSxHQUFHLEdBQUcsc0VBQXNFO2dCQUNuSjtnQkFFQTNsRCxTQUFTOGpELFVBQVUsQ0FBQ3lCLGFBQWFDLElBQUk7Z0JBRXJDLElBQUlqL0QsU0FBUyxRQUFRQSxTQUFTLE1BQU07b0JBQ2xDZ1QsSUFBSTJvRCxTQUFTO2dCQUNmO2dCQUVBbGlELFNBQVM2akQsWUFBWSxDQUFDMEIsYUFBYWYsYUFBYSxDQUFDbm5CLGNBQWMsQ0FBQzNkLEtBQUs7Z0JBQ3JFM3NCLE9BQU9pNkIsTUFBTWptQyxNQUFNO2dCQUVuQixJQUFLK0wsSUFBSSxHQUFHQSxJQUFJQyxNQUFNRCxLQUFLLEVBQUc7b0JBQzVCLElBQUl2TSxTQUFTLFFBQVFBLFNBQVMsTUFBTTt3QkFDbENnVCxJQUFJMm9ELFNBQVM7d0JBRWIsSUFBSXFELGFBQWFaLEVBQUUsRUFBRTs0QkFDbkJwckQsSUFBSTBzRCxXQUFXLENBQUNWLGFBQWFaLEVBQUU7NEJBQy9CcHJELElBQUkyc0QsY0FBYyxHQUFHWCxZQUFZLENBQUMsS0FBSzt3QkFDekM7b0JBQ0Y7b0JBRUFELFFBQVF0NEIsS0FBSyxDQUFDbDZCLEVBQUUsQ0FBQ3N4RCxPQUFPO29CQUN4Qm54RCxPQUFPcXlELE1BQU12K0QsTUFBTTtvQkFFbkIsSUFBS2lNLElBQUksR0FBR0EsSUFBSUMsTUFBTUQsS0FBSyxFQUFHO3dCQUM1QixJQUFJc3lELEtBQUssQ0FBQ3R5RCxFQUFFLENBQUN2RCxDQUFDLEtBQUssS0FBSzs0QkFDdEI4SixJQUFJNG9ELE1BQU0sQ0FBQ21ELEtBQUssQ0FBQ3R5RCxFQUFFLENBQUN6RCxDQUFDLENBQUMsRUFBRSxFQUFFKzFELEtBQUssQ0FBQ3R5RCxFQUFFLENBQUN6RCxDQUFDLENBQUMsRUFBRTt3QkFDekMsT0FBTyxJQUFJKzFELEtBQUssQ0FBQ3R5RCxFQUFFLENBQUN2RCxDQUFDLEtBQUssS0FBSzs0QkFDN0I4SixJQUFJOG9ELGFBQWEsQ0FBQ2lELEtBQUssQ0FBQ3R5RCxFQUFFLENBQUMrd0IsR0FBRyxDQUFDLEVBQUUsRUFBRXVoQyxLQUFLLENBQUN0eUQsRUFBRSxDQUFDK3dCLEdBQUcsQ0FBQyxFQUFFLEVBQUV1aEMsS0FBSyxDQUFDdHlELEVBQUUsQ0FBQyt3QixHQUFHLENBQUMsRUFBRSxFQUFFdWhDLEtBQUssQ0FBQ3R5RCxFQUFFLENBQUMrd0IsR0FBRyxDQUFDLEVBQUUsRUFBRXVoQyxLQUFLLENBQUN0eUQsRUFBRSxDQUFDK3dCLEdBQUcsQ0FBQyxFQUFFLEVBQUV1aEMsS0FBSyxDQUFDdHlELEVBQUUsQ0FBQyt3QixHQUFHLENBQUMsRUFBRTt3QkFDeEgsT0FBTzs0QkFDTHhxQixJQUFJNHNELFNBQVM7d0JBQ2Y7b0JBQ0Y7b0JBRUEsSUFBSTUvRCxTQUFTLFFBQVFBLFNBQVMsTUFBTTt3QkFDbEMsZ0JBQWdCO3dCQUNoQnlaLFNBQVNvbUQsU0FBUzt3QkFFbEIsSUFBSWIsYUFBYVosRUFBRSxFQUFFOzRCQUNuQnByRCxJQUFJMHNELFdBQVcsQ0FBQyxJQUFJLENBQUMxQixZQUFZO3dCQUNuQztvQkFDRjtnQkFDRjtnQkFFQSxJQUFJaCtELFNBQVMsUUFBUUEsU0FBUyxNQUFNO29CQUNsQyw0QkFBNEI7b0JBQzVCLElBQUksQ0FBQythLFVBQVUsQ0FBQ3RCLFFBQVEsQ0FBQ3FtRCxPQUFPLENBQUNkLGFBQWFwMkQsQ0FBQztnQkFDakQ7Z0JBRUE2USxTQUFTK2pELE9BQU87WUFDbEI7UUFDRjtJQUNGO0lBRUFNLGVBQWVwOUQsU0FBUyxDQUFDcXJELFdBQVcsR0FBRyxTQUFVNlMsZUFBZSxFQUFFNTRCLEtBQUssRUFBRTM2QixJQUFJLEVBQUUwMEQsTUFBTTtRQUNuRixJQUFJei9EO1FBQ0osSUFBSUMsTUFBTXlsQyxNQUFNeGxDLE1BQU0sR0FBRztRQUN6QixJQUFJcStEO1FBQ0pBLGlCQUFpQkQ7UUFFakIsSUFBS3QrRCxJQUFJQyxLQUFLRCxLQUFLLEdBQUdBLEtBQUssRUFBRztZQUM1QixJQUFJMGxDLEtBQUssQ0FBQzFsQyxFQUFFLENBQUMyTSxFQUFFLEtBQUssTUFBTTtnQkFDeEI0eEQsaUJBQWlCeHpELElBQUksQ0FBQy9LLEVBQUUsQ0FBQ2k2QixTQUFTO2dCQUNsQyxJQUFJLENBQUNva0Msb0JBQW9CLENBQUNDLGlCQUFpQkM7WUFDN0MsT0FBTyxJQUFJNzRCLEtBQUssQ0FBQzFsQyxFQUFFLENBQUMyTSxFQUFFLEtBQUssUUFBUSs0QixLQUFLLENBQUMxbEMsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLFFBQVErNEIsS0FBSyxDQUFDMWxDLEVBQUUsQ0FBQzJNLEVBQUUsS0FBSyxRQUFRKzRCLEtBQUssQ0FBQzFsQyxFQUFFLENBQUMyTSxFQUFFLEtBQUssTUFBTTtnQkFDdkcsSUFBSSxDQUFDazhDLFVBQVUsQ0FBQ25qQixLQUFLLENBQUMxbEMsRUFBRSxFQUFFK0ssSUFBSSxDQUFDL0ssRUFBRTtZQUNuQyxPQUFPLElBQUkwbEMsS0FBSyxDQUFDMWxDLEVBQUUsQ0FBQzJNLEVBQUUsS0FBSyxNQUFNO2dCQUMvQixJQUFJLENBQUM4N0MsVUFBVSxDQUFDL2lCLEtBQUssQ0FBQzFsQyxFQUFFLEVBQUUrSyxJQUFJLENBQUMvSyxFQUFFLEVBQUV1K0Q7WUFDckMsT0FBTyxJQUFJNzRCLEtBQUssQ0FBQzFsQyxFQUFFLENBQUMyTSxFQUFFLEtBQUssTUFBTTtnQkFDL0IsSUFBSSxDQUFDaThDLFlBQVksQ0FBQ2xqQixLQUFLLENBQUMxbEMsRUFBRSxFQUFFK0ssSUFBSSxDQUFDL0ssRUFBRSxFQUFFdStEO1lBQ3ZDLE9BQU8sSUFBSTc0QixLQUFLLENBQUMxbEMsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLFFBQVErNEIsS0FBSyxDQUFDMWxDLEVBQUUsQ0FBQzJNLEVBQUUsS0FBSyxNQUFNO2dCQUN2RCxJQUFJLENBQUMreUQsa0JBQWtCLENBQUNoNkIsS0FBSyxDQUFDMWxDLEVBQUUsRUFBRStLLElBQUksQ0FBQy9LLEVBQUUsRUFBRXUrRDtZQUM3QyxPQUFPLElBQUk3NEIsS0FBSyxDQUFDMWxDLEVBQUUsQ0FBQzJNLEVBQUUsS0FBSyxNQUFNO2dCQUMvQixJQUFJLENBQUM4K0MsV0FBVyxDQUFDOFMsZ0JBQWdCNzRCLEtBQUssQ0FBQzFsQyxFQUFFLENBQUM0TixFQUFFLEVBQUU3QyxJQUFJLENBQUMvSyxFQUFFLENBQUM0TixFQUFFO1lBQzFELE9BQU8sSUFBSTgzQixLQUFLLENBQUMxbEMsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLE1BQU0sQ0FDakM7UUFDRjtRQUVBLElBQUk4eUQsUUFBUTtZQUNWLElBQUksQ0FBQ2pCLFNBQVM7UUFDaEI7SUFDRjtJQUVBaEIsZUFBZXA5RCxTQUFTLENBQUN1L0QsaUJBQWlCLEdBQUcsU0FBVXJDLFdBQVcsRUFBRW5wQyxLQUFLO1FBQ3ZFLElBQUksSUFBSSxDQUFDN0MsYUFBYSxJQUFJNkMsTUFBTWxELElBQUksSUFBSXFzQyxZQUFZaGYsVUFBVSxDQUFDcnRCLElBQUksRUFBRTtZQUNuRSxJQUFJMnVDLGFBQWF0QyxZQUFZQyxPQUFPO1lBQ3BDLElBQUlub0MsUUFBUWpCLE1BQU1pQixLQUFLO1lBQ3ZCLElBQUlwMUI7WUFDSixJQUFJQztZQUNKLElBQUlnTTtZQUNKLElBQUlDLE9BQU9rcEIsTUFBTXJQLE9BQU87WUFDeEI2NUMsV0FBVzEvRCxNQUFNLEdBQUc7WUFDcEIsSUFBSTIvRCxvQkFBb0J2QyxZQUFZaGYsVUFBVSxDQUFDOUgsY0FBYztZQUU3RCxJQUFLdnFDLElBQUksR0FBR0EsSUFBSUMsTUFBTUQsS0FBSyxFQUFHO2dCQUM1QixJQUFJaTBDLFlBQVk5cUIsTUFBTXJvQixNQUFNLENBQUNkLEVBQUU7Z0JBRS9CLElBQUlpMEMsYUFBYUEsVUFBVTczQyxDQUFDLEVBQUU7b0JBQzVCcEksTUFBTWlnRCxVQUFVbjZCLE9BQU87b0JBRXZCLElBQUsvbEIsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7d0JBQzNCLElBQUlBLE1BQU0sR0FBRzs0QkFDWDQvRCxXQUFXcitELElBQUksQ0FBQztnQ0FDZHFILEdBQUc7Z0NBQ0hGLEdBQUdtM0Qsa0JBQWtCN2lDLGlCQUFpQixDQUFDa2pCLFVBQVU3M0MsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU2M0MsVUFBVTczQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTs0QkFDL0U7d0JBQ0Y7d0JBRUF1M0QsV0FBV3IrRCxJQUFJLENBQUM7NEJBQ2RxSCxHQUFHOzRCQUNIczBCLEtBQUsyaUMsa0JBQWtCemlDLG1CQUFtQixDQUFDOGlCLFVBQVVyeUMsQ0FBQyxDQUFDN04sSUFBSSxFQUFFLEVBQUVrZ0QsVUFBVWxnRCxDQUFDLENBQUNBLEVBQUUsRUFBRWtnRCxVQUFVNzNDLENBQUMsQ0FBQ3JJLEVBQUU7d0JBQy9GO29CQUNGO29CQUVBLElBQUlDLFFBQVEsR0FBRzt3QkFDYjIvRCxXQUFXcitELElBQUksQ0FBQzs0QkFDZHFILEdBQUc7NEJBQ0hGLEdBQUdtM0Qsa0JBQWtCN2lDLGlCQUFpQixDQUFDa2pCLFVBQVU3M0MsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU2M0MsVUFBVTczQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTt3QkFDL0U7b0JBQ0Y7b0JBRUEsSUFBSTYzQyxVQUFVM3dDLENBQUMsSUFBSXRQLEtBQUs7d0JBQ3RCMi9ELFdBQVdyK0QsSUFBSSxDQUFDOzRCQUNkcUgsR0FBRzs0QkFDSHMwQixLQUFLMmlDLGtCQUFrQnppQyxtQkFBbUIsQ0FBQzhpQixVQUFVcnlDLENBQUMsQ0FBQzdOLElBQUksRUFBRSxFQUFFa2dELFVBQVVsZ0QsQ0FBQyxDQUFDLEVBQUUsRUFBRWtnRCxVQUFVNzNDLENBQUMsQ0FBQyxFQUFFO3dCQUMvRjt3QkFDQXUzRCxXQUFXcitELElBQUksQ0FBQzs0QkFDZHFILEdBQUc7d0JBQ0w7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUVBMDBELFlBQVlDLE9BQU8sR0FBR3FDO1FBQ3hCO0lBQ0Y7SUFFQXBDLGVBQWVwOUQsU0FBUyxDQUFDeW9ELFVBQVUsR0FBRyxTQUFVejVDLFFBQVEsRUFBRTY1QyxRQUFRO1FBQ2hFLElBQUk3NUMsU0FBU2l6QyxFQUFFLEtBQUssUUFBUWp6QyxTQUFTZ3ZELGFBQWEsRUFBRTtZQUNsRCxJQUFJcCtEO1lBQ0osSUFBSUMsTUFBTWdwRCxTQUFTb1UsWUFBWSxDQUFDbjlELE1BQU07WUFFdEMsSUFBS0YsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7Z0JBQzNCLElBQUksQ0FBQzIvRCxpQkFBaUIsQ0FBQzFXLFNBQVNvVSxZQUFZLENBQUNyOUQsRUFBRSxFQUFFaXBELFNBQVNsN0IsRUFBRTtZQUM5RDtRQUNGO0lBQ0Y7SUFFQXl2QyxlQUFlcDlELFNBQVMsQ0FBQ3FvRCxVQUFVLEdBQUcsU0FBVU8sU0FBUyxFQUFFQyxRQUFRLEVBQUVzVixjQUFjO1FBQ2pGLElBQUlqVixZQUFZTCxTQUFTaGpELEtBQUs7UUFFOUIsSUFBSWdqRCxTQUFTMTVDLENBQUMsQ0FBQzBoQixJQUFJLElBQUksSUFBSSxDQUFDSyxhQUFhLEVBQUU7WUFDekNnNEIsVUFBVXNVLEVBQUUsR0FBRyxTQUFTbDVELFFBQVF1a0QsU0FBUzE1QyxDQUFDLENBQUNsSCxDQUFDLENBQUMsRUFBRSxJQUFJLE1BQU0zRCxRQUFRdWtELFNBQVMxNUMsQ0FBQyxDQUFDbEgsQ0FBQyxDQUFDLEVBQUUsSUFBSSxNQUFNM0QsUUFBUXVrRCxTQUFTMTVDLENBQUMsQ0FBQ2xILENBQUMsQ0FBQyxFQUFFLElBQUk7UUFDdkg7UUFFQSxJQUFJNGdELFNBQVNwN0MsQ0FBQyxDQUFDb2pCLElBQUksSUFBSXN0QyxlQUFlamhCLE1BQU0sSUFBSSxJQUFJLENBQUNoc0IsYUFBYSxFQUFFO1lBQ2xFZzRCLFVBQVVxVixJQUFJLEdBQUcxVixTQUFTcDdDLENBQUMsQ0FBQ3hGLENBQUMsR0FBR2syRCxlQUFldmdCLE9BQU87UUFDeEQ7SUFDRjtJQUVBd2YsZUFBZXA5RCxTQUFTLENBQUNzL0Qsa0JBQWtCLEdBQUcsU0FBVTFXLFNBQVMsRUFBRUMsUUFBUSxFQUFFc1YsY0FBYztRQUN6RixJQUFJalYsWUFBWUwsU0FBU2hqRCxLQUFLO1FBQzlCLElBQUk2NEQ7UUFFSixJQUFJLENBQUN4VixVQUFVd1YsR0FBRyxJQUFJN1YsU0FBUzFnRCxDQUFDLENBQUMwb0IsSUFBSSxJQUFJZzRCLFNBQVM3Z0QsQ0FBQyxDQUFDNm9CLElBQUksSUFBSWc0QixTQUFTdDlDLENBQUMsQ0FBQ3NsQixJQUFJLElBQUkrM0IsVUFBVXBnRCxDQUFDLEtBQUssS0FBTXFnRCxDQUFBQSxTQUFTOWdELENBQUMsQ0FBQzhvQixJQUFJLElBQUlnNEIsU0FBU2o2QyxDQUFDLENBQUNpaUIsSUFBSSxHQUFHO1lBQ3hJLElBQUl2ZSxNQUFNLElBQUksQ0FBQytILFVBQVUsQ0FBQzJnRCxhQUFhO1lBQ3ZDLElBQUl0ekMsTUFBTW1oQyxTQUFTN2dELENBQUMsQ0FBQ0MsQ0FBQztZQUN0QixJQUFJMGYsTUFBTWtoQyxTQUFTdDlDLENBQUMsQ0FBQ3RELENBQUM7WUFFdEIsSUFBSTJnRCxVQUFVcGdELENBQUMsS0FBSyxHQUFHO2dCQUNyQmsyRCxNQUFNcHNELElBQUlvdEQsb0JBQW9CLENBQUNoNEMsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUUsRUFBRUMsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUU7WUFDL0QsT0FBTztnQkFDTCxJQUFJeVAsTUFBTWx6QixLQUFLRyxJQUFJLENBQUNILEtBQUtDLEdBQUcsQ0FBQ3VqQixHQUFHLENBQUMsRUFBRSxHQUFHQyxHQUFHLENBQUMsRUFBRSxFQUFFLEtBQUt6akIsS0FBS0MsR0FBRyxDQUFDdWpCLEdBQUcsQ0FBQyxFQUFFLEdBQUdDLEdBQUcsQ0FBQyxFQUFFLEVBQUU7Z0JBQzdFLElBQUk2aEMsTUFBTXRsRCxLQUFLcXJCLEtBQUssQ0FBQzVILEdBQUcsQ0FBQyxFQUFFLEdBQUdELEdBQUcsQ0FBQyxFQUFFLEVBQUVDLEdBQUcsQ0FBQyxFQUFFLEdBQUdELEdBQUcsQ0FBQyxFQUFFO2dCQUNyRCxJQUFJZ0MsVUFBVW0vQixTQUFTOWdELENBQUMsQ0FBQ0UsQ0FBQztnQkFFMUIsSUFBSXloQixXQUFXLEdBQUc7b0JBQ2hCQSxVQUFVO2dCQUNaLE9BQU8sSUFBSUEsV0FBVyxDQUFDLEdBQUc7b0JBQ3hCQSxVQUFVLENBQUM7Z0JBQ2I7Z0JBRUEsSUFBSXhFLE9BQU9rUyxNQUFNMU47Z0JBQ2pCLElBQUlsRixJQUFJdGdCLEtBQUsyckIsR0FBRyxDQUFDMjVCLE1BQU1YLFNBQVNqNkMsQ0FBQyxDQUFDM0csQ0FBQyxJQUFJaWQsT0FBT3dDLEdBQUcsQ0FBQyxFQUFFO2dCQUNwRCxJQUFJb0YsSUFBSTVvQixLQUFLOHFCLEdBQUcsQ0FBQ3c2QixNQUFNWCxTQUFTajZDLENBQUMsQ0FBQzNHLENBQUMsSUFBSWlkLE9BQU93QyxHQUFHLENBQUMsRUFBRTtnQkFDcERnM0MsTUFBTXBzRCxJQUFJcXRELG9CQUFvQixDQUFDbjdDLEdBQUdzSSxHQUFHLEdBQUdwRixHQUFHLENBQUMsRUFBRSxFQUFFQSxHQUFHLENBQUMsRUFBRSxFQUFFMFA7WUFDMUQ7WUFFQSxJQUFJeDNCO1lBQ0osSUFBSUMsTUFBTStvRCxVQUFVemdELENBQUMsQ0FBQ0csQ0FBQztZQUN2QixJQUFJZ2hELFVBQVVULFNBQVMxZ0QsQ0FBQyxDQUFDZ0gsQ0FBQztZQUMxQixJQUFJeXVDLFVBQVU7WUFFZCxJQUFLaCtDLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO2dCQUMzQixJQUFJaXBELFNBQVMxZ0QsQ0FBQyxDQUFDaStDLFdBQVcsSUFBSXlDLFNBQVMxZ0QsQ0FBQyxDQUFDKzlDLFlBQVksRUFBRTtvQkFDckR0SSxVQUFVaUwsU0FBUzFnRCxDQUFDLENBQUNzRixDQUFDLENBQUM3TixJQUFJLElBQUksRUFBRTtnQkFDbkM7Z0JBRUE4K0QsSUFBSWtCLFlBQVksQ0FBQ3RXLE9BQU8sQ0FBQzFwRCxJQUFJLEVBQUUsR0FBRyxLQUFLLFVBQVUwcEQsT0FBTyxDQUFDMXBELElBQUksSUFBSSxFQUFFLEdBQUcsTUFBTTBwRCxPQUFPLENBQUMxcEQsSUFBSSxJQUFJLEVBQUUsR0FBRyxNQUFNMHBELE9BQU8sQ0FBQzFwRCxJQUFJLElBQUksRUFBRSxHQUFHLE1BQU1nK0MsVUFBVTtZQUM5STtZQUVBc0wsVUFBVXdWLEdBQUcsR0FBR0E7UUFDbEI7UUFFQXhWLFVBQVVxVixJQUFJLEdBQUcxVixTQUFTcDdDLENBQUMsQ0FBQ3hGLENBQUMsR0FBR2syRCxlQUFldmdCLE9BQU87SUFDeEQ7SUFFQXdmLGVBQWVwOUQsU0FBUyxDQUFDd29ELFlBQVksR0FBRyxTQUFVSSxTQUFTLEVBQUVDLFFBQVEsRUFBRXNWLGNBQWM7UUFDbkYsSUFBSWpWLFlBQVlMLFNBQVNoakQsS0FBSztRQUM5QixJQUFJNkMsSUFBSW1nRCxTQUFTbmdELENBQUM7UUFFbEIsSUFBSUEsS0FBTUEsQ0FBQUEsRUFBRW1vQixJQUFJLElBQUksSUFBSSxDQUFDSyxhQUFhLEdBQUc7WUFDdkNnNEIsVUFBVXdVLEVBQUUsR0FBR2gxRCxFQUFFODhDLFNBQVM7WUFDMUIwRCxTQUFTLENBQUMsS0FBSyxHQUFHeGdELEVBQUUrOEMsVUFBVSxDQUFDLEVBQUU7UUFDbkM7UUFFQSxJQUFJb0QsU0FBUzE1QyxDQUFDLENBQUMwaEIsSUFBSSxJQUFJLElBQUksQ0FBQ0ssYUFBYSxFQUFFO1lBQ3pDZzRCLFVBQVVzVSxFQUFFLEdBQUcsU0FBU2w1RCxRQUFRdWtELFNBQVMxNUMsQ0FBQyxDQUFDbEgsQ0FBQyxDQUFDLEVBQUUsSUFBSSxNQUFNM0QsUUFBUXVrRCxTQUFTMTVDLENBQUMsQ0FBQ2xILENBQUMsQ0FBQyxFQUFFLElBQUksTUFBTTNELFFBQVF1a0QsU0FBUzE1QyxDQUFDLENBQUNsSCxDQUFDLENBQUMsRUFBRSxJQUFJO1FBQ3ZIO1FBRUEsSUFBSTRnRCxTQUFTcDdDLENBQUMsQ0FBQ29qQixJQUFJLElBQUlzdEMsZUFBZWpoQixNQUFNLElBQUksSUFBSSxDQUFDaHNCLGFBQWEsRUFBRTtZQUNsRWc0QixVQUFVcVYsSUFBSSxHQUFHMVYsU0FBU3A3QyxDQUFDLENBQUN4RixDQUFDLEdBQUdrMkQsZUFBZXZnQixPQUFPO1FBQ3hEO1FBRUEsSUFBSWlMLFNBQVMxNEIsQ0FBQyxDQUFDVSxJQUFJLElBQUksSUFBSSxDQUFDSyxhQUFhLEVBQUU7WUFDekNnNEIsVUFBVXVVLEVBQUUsR0FBRzVVLFNBQVMxNEIsQ0FBQyxDQUFDbG9CLENBQUM7UUFDN0I7SUFDRjtJQUVBbTFELGVBQWVwOUQsU0FBUyxDQUFDbVYsT0FBTyxHQUFHO1FBQ2pDLElBQUksQ0FBQ3lqQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDditCLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUMyZ0QsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ3RSLFVBQVUsQ0FBQzVwRCxNQUFNLEdBQUc7UUFDekIsSUFBSSxDQUFDKzRDLFNBQVMsQ0FBQy80QyxNQUFNLEdBQUc7SUFDMUI7SUFFQSxTQUFTKy9ELGNBQWNsMUQsSUFBSSxFQUFFMFAsVUFBVSxFQUFFbk4sSUFBSTtRQUMzQyxJQUFJLENBQUN5b0QsU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDOUksT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDSCxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDQyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDQyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDa1QsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUMxVCxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDMlQsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ25PLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNsaUMsTUFBTSxHQUFHO1lBQ1pvd0MsTUFBTTtZQUNORCxRQUFRO1lBQ1JHLFFBQVE7WUFDUkMsUUFBUTtRQUNWO1FBQ0EsSUFBSSxDQUFDM2MsV0FBVyxDQUFDNTRDLE1BQU0wUCxZQUFZbk47SUFDckM7SUFFQXpOLGdCQUFnQjtRQUFDcTRDO1FBQWFnRjtRQUFrQnllO1FBQWVyWTtRQUFrQnpKO1FBQWNsRTtRQUFtQnNmO0tBQWEsRUFBRWdMO0lBQ2pJQSxjQUFjNy9ELFNBQVMsQ0FBQzR4QyxPQUFPLEdBQUd2eUMsVUFBVSxVQUFVa1QsVUFBVSxDQUFDO0lBRWpFc3RELGNBQWM3L0QsU0FBUyxDQUFDdzFELFlBQVksR0FBRztRQUNyQyxJQUFJcm5ELGVBQWUsSUFBSSxDQUFDNmlELFlBQVksQ0FBQy9FLFdBQVc7UUFDaEQsSUFBSSxDQUFDcUcsZUFBZSxHQUFHdHZELGlCQUFpQm1MLGFBQWFxckIsQ0FBQyxHQUFHcnJCLGFBQWFxckIsQ0FBQyxDQUFDMTVCLE1BQU0sR0FBRztRQUNqRixJQUFJcWdFLFVBQVU7UUFFZCxJQUFJaHlELGFBQWFzOUMsRUFBRSxFQUFFO1lBQ25CMFUsVUFBVTtZQUNWLElBQUksQ0FBQ3h3QyxNQUFNLENBQUNvd0MsSUFBSSxHQUFHLElBQUksQ0FBQzNLLFVBQVUsQ0FBQ2puRCxhQUFhczlDLEVBQUU7UUFDcEQsT0FBTztZQUNMLElBQUksQ0FBQzk3QixNQUFNLENBQUNvd0MsSUFBSSxHQUFHO1FBQ3JCO1FBRUEsSUFBSSxDQUFDQSxJQUFJLEdBQUdJO1FBQ1osSUFBSUMsWUFBWTtRQUVoQixJQUFJanlELGFBQWE2a0MsRUFBRSxFQUFFO1lBQ25Cb3RCLFlBQVk7WUFDWixJQUFJLENBQUN6d0MsTUFBTSxDQUFDbXdDLE1BQU0sR0FBRyxJQUFJLENBQUMxSyxVQUFVLENBQUNqbkQsYUFBYTZrQyxFQUFFO1lBQ3BELElBQUksQ0FBQ3JqQixNQUFNLENBQUNzd0MsTUFBTSxHQUFHOXhELGFBQWFxOUMsRUFBRTtRQUN0QztRQUVBLElBQUlqZCxXQUFXLElBQUksQ0FBQ2wwQixVQUFVLENBQUNvQixXQUFXLENBQUNrNEIsYUFBYSxDQUFDeGxDLGFBQWE5RixDQUFDO1FBQ3ZFLElBQUl6STtRQUNKLElBQUlDO1FBQ0osSUFBSW91RCxVQUFVOS9DLGFBQWFxckIsQ0FBQztRQUM1QixJQUFJazVCLGVBQWUsSUFBSSxDQUFDdFUsT0FBTztRQUMvQixJQUFJLENBQUMwaEIsTUFBTSxHQUFHTTtRQUNkLElBQUksQ0FBQ3p3QyxNQUFNLENBQUN1d0MsTUFBTSxHQUFHL3hELGFBQWEyK0MsU0FBUyxHQUFHLFFBQVEsSUFBSSxDQUFDenlDLFVBQVUsQ0FBQ29CLFdBQVcsQ0FBQ2s0QixhQUFhLENBQUN4bEMsYUFBYTlGLENBQUMsRUFBRXdwQyxPQUFPO1FBQ3ZIaHlDLE1BQU1zTyxhQUFhNCtDLFNBQVMsQ0FBQ2p0RCxNQUFNLEVBQUUsMENBQTBDO1FBRS9FLElBQUl5TztRQUNKLElBQUkrWjtRQUNKLElBQUl2YztRQUNKLElBQUlDO1FBQ0osSUFBSVc7UUFDSixJQUFJZDtRQUNKLElBQUlDO1FBQ0osSUFBSWcwQztRQUNKLElBQUl1Z0I7UUFDSixJQUFJQztRQUNKLElBQUkxSyxjQUFjLElBQUksQ0FBQ2pyRCxJQUFJLENBQUNpckQsV0FBVztRQUN2QyxJQUFJbkgsaUJBQWlCdGdELGFBQWEyMUIsRUFBRSxHQUFHLFFBQVEzMUIsYUFBYTIrQyxTQUFTO1FBQ3JFLElBQUk4RixPQUFPO1FBQ1gsSUFBSUMsT0FBTztRQUNYLElBQUlVLFlBQVk7UUFDaEIsSUFBSTUvQixNQUFNO1FBRVYsSUFBSy96QixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQjJPLFdBQVcsSUFBSSxDQUFDOEwsVUFBVSxDQUFDb0IsV0FBVyxDQUFDMDNCLFdBQVcsQ0FBQ2hsQyxhQUFhNCtDLFNBQVMsQ0FBQ250RCxFQUFFLEVBQUUydUMsU0FBU0UsTUFBTSxFQUFFLElBQUksQ0FBQ3AwQixVQUFVLENBQUNvQixXQUFXLENBQUNrNEIsYUFBYSxDQUFDeGxDLGFBQWE5RixDQUFDLEVBQUV3cEMsT0FBTztZQUNoS3ZwQixZQUFZL1osWUFBWUEsU0FBUzVELElBQUksSUFBSSxDQUFDO1lBQzFDK25ELGFBQWFwOUIsS0FBSztZQUVsQixJQUFJc2dDLGVBQWUzSCxPQUFPLENBQUNydUQsRUFBRSxDQUFDbXRCLENBQUMsRUFBRTtnQkFDL0I2bEMsT0FBTyxDQUFDbkU7Z0JBQ1JvRSxRQUFRMWtELGFBQWEwK0MsT0FBTztnQkFDNUJnRyxRQUFRVSxZQUFZLElBQUk7Z0JBQ3hCQSxZQUFZO1lBQ2Q7WUFFQTVtRCxTQUFTMmIsVUFBVTNiLE1BQU0sR0FBRzJiLFVBQVUzYixNQUFNLENBQUMsRUFBRSxDQUFDYSxFQUFFLEdBQUcsRUFBRTtZQUN2RDFCLE9BQU9hLE9BQU83TSxNQUFNO1lBQ3BCNHlELGFBQWFyNUIsS0FBSyxDQUFDbHJCLGFBQWEyK0MsU0FBUyxHQUFHLEtBQUszK0MsYUFBYTIrQyxTQUFTLEdBQUc7WUFFMUUsSUFBSThJLGFBQWE7Z0JBQ2YsSUFBSSxDQUFDViwyQkFBMkIsQ0FBQy9tRCxjQUFjdWtELGNBQWN6RSxPQUFPLENBQUNydUQsRUFBRSxDQUFDeVcsSUFBSSxFQUFFdThDLE1BQU1DO1lBQ3RGO1lBRUF3TixXQUFXcjlELGlCQUFpQjhJLE9BQU87WUFDbkMsSUFBSXkwRCxrQkFBa0I7WUFFdEIsSUFBSzEwRCxJQUFJLEdBQUdBLElBQUlDLE1BQU1ELEtBQUssRUFBRztnQkFDNUIsSUFBSWMsTUFBTSxDQUFDZCxFQUFFLENBQUNVLEVBQUUsS0FBSyxNQUFNO29CQUN6QlAsT0FBT1csTUFBTSxDQUFDZCxFQUFFLENBQUMwQixFQUFFLENBQUN4QixDQUFDLENBQUNuTSxDQUFDLENBQUNFLE1BQU07b0JBQzlCZ2dELFlBQVluekMsTUFBTSxDQUFDZCxFQUFFLENBQUMwQixFQUFFLENBQUN4QixDQUFDO29CQUMxQnUwRCxVQUFVLEVBQUU7b0JBRVosSUFBS3YwRCxJQUFJLEdBQUdBLElBQUlDLE1BQU1ELEtBQUssRUFBRzt3QkFDNUIsSUFBSUEsTUFBTSxHQUFHOzRCQUNYdTBELFFBQVFuL0QsSUFBSSxDQUFDdXhELGFBQWFyMkIsUUFBUSxDQUFDeWpCLFVBQVU3M0MsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU2M0MsVUFBVTczQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxJQUFJeXFELGFBQWFwMkIsUUFBUSxDQUFDd2pCLFVBQVU3M0MsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU2M0MsVUFBVTczQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTt3QkFDM0k7d0JBRUFxNEQsUUFBUW4vRCxJQUFJLENBQUN1eEQsYUFBYXIyQixRQUFRLENBQUN5akIsVUFBVXJ5QyxDQUFDLENBQUMxQixJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUUrekMsVUFBVXJ5QyxDQUFDLENBQUMxQixJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUUsSUFBSTJtRCxhQUFhcDJCLFFBQVEsQ0FBQ3dqQixVQUFVcnlDLENBQUMsQ0FBQzFCLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRSt6QyxVQUFVcnlDLENBQUMsQ0FBQzFCLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRSxJQUFJMm1ELGFBQWFyMkIsUUFBUSxDQUFDeWpCLFVBQVVsZ0QsQ0FBQyxDQUFDbU0sRUFBRSxDQUFDLEVBQUUsRUFBRSt6QyxVQUFVbGdELENBQUMsQ0FBQ21NLEVBQUUsQ0FBQyxFQUFFLEVBQUUsSUFBSTJtRCxhQUFhcDJCLFFBQVEsQ0FBQ3dqQixVQUFVbGdELENBQUMsQ0FBQ21NLEVBQUUsQ0FBQyxFQUFFLEVBQUUrekMsVUFBVWxnRCxDQUFDLENBQUNtTSxFQUFFLENBQUMsRUFBRSxFQUFFLElBQUkybUQsYUFBYXIyQixRQUFRLENBQUN5akIsVUFBVTczQyxDQUFDLENBQUM4RCxFQUFFLENBQUMsRUFBRSxFQUFFK3pDLFVBQVU3M0MsQ0FBQyxDQUFDOEQsRUFBRSxDQUFDLEVBQUUsRUFBRSxJQUFJMm1ELGFBQWFwMkIsUUFBUSxDQUFDd2pCLFVBQVU3M0MsQ0FBQyxDQUFDOEQsRUFBRSxDQUFDLEVBQUUsRUFBRSt6QyxVQUFVNzNDLENBQUMsQ0FBQzhELEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQzNaO29CQUVBdTBELFFBQVFuL0QsSUFBSSxDQUFDdXhELGFBQWFyMkIsUUFBUSxDQUFDeWpCLFVBQVVyeUMsQ0FBQyxDQUFDMUIsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFK3pDLFVBQVVyeUMsQ0FBQyxDQUFDMUIsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFLElBQUkybUQsYUFBYXAyQixRQUFRLENBQUN3akIsVUFBVXJ5QyxDQUFDLENBQUMxQixJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUUrekMsVUFBVXJ5QyxDQUFDLENBQUMxQixJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUUsSUFBSTJtRCxhQUFhcjJCLFFBQVEsQ0FBQ3lqQixVQUFVbGdELENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFa2dELFVBQVVsZ0QsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsSUFBSTh5RCxhQUFhcDJCLFFBQVEsQ0FBQ3dqQixVQUFVbGdELENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFa2dELFVBQVVsZ0QsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsSUFBSTh5RCxhQUFhcjJCLFFBQVEsQ0FBQ3lqQixVQUFVNzNDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFNjNDLFVBQVU3M0MsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsSUFBSXlxRCxhQUFhcDJCLFFBQVEsQ0FBQ3dqQixVQUFVNzNDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFNjNDLFVBQVU3M0MsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQ3pabzRELFFBQVEsQ0FBQ0UsZ0JBQWdCLEdBQUdEO29CQUM1QkMsbUJBQW1CO2dCQUNyQjtZQUNGO1lBRUEsSUFBSTNLLGFBQWE7Z0JBQ2ZoRCxRQUFRM0UsT0FBTyxDQUFDcnVELEVBQUUsQ0FBQzQ1QixDQUFDO2dCQUNwQm81QixRQUFRbkU7WUFDVjtZQUVBLElBQUksSUFBSSxDQUFDa0gsU0FBUyxDQUFDaGlDLElBQUksRUFBRTtnQkFDdkIsSUFBSSxDQUFDZ2lDLFNBQVMsQ0FBQ2hpQyxJQUFJLENBQUNoVCxJQUFJLEdBQUcwL0M7WUFDN0IsT0FBTztnQkFDTCxJQUFJLENBQUMxSyxTQUFTLENBQUNoaUMsSUFBSSxHQUFHO29CQUNwQmhULE1BQU0wL0M7Z0JBQ1I7WUFDRjtZQUVBMXNDLE9BQU87UUFDVDtJQUNGO0lBRUFrc0MsY0FBYzcvRCxTQUFTLENBQUN5akQsa0JBQWtCLEdBQUc7UUFDM0MsSUFBSSxDQUFDOFIsWUFBWTtRQUNqQixJQUFJampELE1BQU0sSUFBSSxDQUFDMG9ELGFBQWE7UUFDNUIxb0QsSUFBSXU5QixJQUFJLEdBQUcsSUFBSSxDQUFDbGdCLE1BQU0sQ0FBQ3V3QyxNQUFNO1FBQzdCLElBQUksQ0FBQzdsRCxVQUFVLENBQUN0QixRQUFRLENBQUM2bEQsVUFBVSxDQUFDLFNBQVMsd0JBQXdCO1FBRXJFLElBQUksQ0FBQ3ZrRCxVQUFVLENBQUN0QixRQUFRLENBQUM4bEQsV0FBVyxDQUFDLFVBQVUsMEJBQTBCO1FBRXpFLElBQUksQ0FBQ3hrRCxVQUFVLENBQUN0QixRQUFRLENBQUMrbEQsYUFBYSxDQUFDLElBQUksc0JBQXNCO1FBRWpFLElBQUksQ0FBQyxJQUFJLENBQUNuMEQsSUFBSSxDQUFDaXJELFdBQVcsRUFBRTtZQUMxQixJQUFJLENBQUNkLFlBQVksQ0FBQ3JDLFdBQVcsQ0FBQyxJQUFJLENBQUN6QixZQUFZLENBQUMvRSxXQUFXLEVBQUUsSUFBSSxDQUFDc0csa0JBQWtCO1FBQ3RGO1FBRUEsSUFBSTN5RDtRQUNKLElBQUlDO1FBQ0osSUFBSWdNO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSXNtRCxrQkFBa0IsSUFBSSxDQUFDd0MsWUFBWSxDQUFDeEMsZUFBZTtRQUN2RCxJQUFJckUsVUFBVSxJQUFJLENBQUMrQyxZQUFZLENBQUMvRSxXQUFXLENBQUN6eUIsQ0FBQztRQUM3QzM1QixNQUFNb3VELFFBQVFudUQsTUFBTTtRQUNwQixJQUFJcTNEO1FBQ0osSUFBSXFKLFdBQVc7UUFDZixJQUFJQyxhQUFhO1FBQ2pCLElBQUlDLGNBQWM7UUFDbEIsSUFBSUw7UUFDSixJQUFJQztRQUNKLElBQUl2bkQsV0FBVyxJQUFJLENBQUNzQixVQUFVLENBQUN0QixRQUFRO1FBRXZDLElBQUtuWixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQixJQUFJLENBQUNxdUQsT0FBTyxDQUFDcnVELEVBQUUsQ0FBQ210QixDQUFDLEVBQUU7Z0JBQ2pCb3FDLGlCQUFpQjdFLGVBQWUsQ0FBQzF5RCxFQUFFO2dCQUVuQyxJQUFJdTNELGdCQUFnQjtvQkFDbEJwK0MsU0FBU3NpRCxJQUFJO29CQUNidGlELFNBQVM2akQsWUFBWSxDQUFDekYsZUFBZTd1RCxDQUFDO29CQUN0Q3lRLFNBQVM4akQsVUFBVSxDQUFDMUYsZUFBZTFwRCxDQUFDO2dCQUN0QztnQkFFQSxJQUFJLElBQUksQ0FBQ3N5RCxJQUFJLEVBQUU7b0JBQ2IsSUFBSTVJLGtCQUFrQkEsZUFBZTFMLEVBQUUsRUFBRTt3QkFDdkMsSUFBSStVLGFBQWFySixlQUFlMUwsRUFBRSxFQUFFOzRCQUNsQzF5QyxTQUFTZ21ELFlBQVksQ0FBQzVILGVBQWUxTCxFQUFFOzRCQUN2QytVLFdBQVdySixlQUFlMUwsRUFBRSxFQUFFLHFDQUFxQzt3QkFDckU7b0JBQ0YsT0FBTyxJQUFJK1UsYUFBYSxJQUFJLENBQUM3d0MsTUFBTSxDQUFDb3dDLElBQUksRUFBRTt3QkFDeENTLFdBQVcsSUFBSSxDQUFDN3dDLE1BQU0sQ0FBQ293QyxJQUFJO3dCQUMzQmhuRCxTQUFTZ21ELFlBQVksQ0FBQyxJQUFJLENBQUNwdkMsTUFBTSxDQUFDb3dDLElBQUksR0FBRyxvQ0FBb0M7b0JBQy9FO29CQUVBTSxXQUFXLElBQUksQ0FBQzFLLFNBQVMsQ0FBQy8xRCxFQUFFLENBQUMrZ0IsSUFBSTtvQkFDakM3VSxPQUFPdTBELFNBQVN2Z0UsTUFBTTtvQkFDdEIsSUFBSSxDQUFDdWEsVUFBVSxDQUFDMmdELGFBQWEsQ0FBQ0MsU0FBUztvQkFFdkMsSUFBS3B2RCxJQUFJLEdBQUdBLElBQUlDLE1BQU1ELEtBQUssRUFBRzt3QkFDNUJ5MEQsVUFBVUQsUUFBUSxDQUFDeDBELEVBQUU7d0JBQ3JCRyxPQUFPczBELFFBQVF4Z0UsTUFBTTt3QkFDckIsSUFBSSxDQUFDdWEsVUFBVSxDQUFDMmdELGFBQWEsQ0FBQ0UsTUFBTSxDQUFDb0YsT0FBTyxDQUFDLEVBQUUsRUFBRUEsT0FBTyxDQUFDLEVBQUU7d0JBRTNELElBQUt2MEQsSUFBSSxHQUFHQSxJQUFJQyxNQUFNRCxLQUFLLEVBQUc7NEJBQzVCLElBQUksQ0FBQ3NPLFVBQVUsQ0FBQzJnRCxhQUFhLENBQUNJLGFBQWEsQ0FBQ2tGLE9BQU8sQ0FBQ3YwRCxFQUFFLEVBQUV1MEQsT0FBTyxDQUFDdjBELElBQUksRUFBRSxFQUFFdTBELE9BQU8sQ0FBQ3YwRCxJQUFJLEVBQUUsRUFBRXUwRCxPQUFPLENBQUN2MEQsSUFBSSxFQUFFLEVBQUV1MEQsT0FBTyxDQUFDdjBELElBQUksRUFBRSxFQUFFdTBELE9BQU8sQ0FBQ3YwRCxJQUFJLEVBQUU7d0JBQ3hJO29CQUNGO29CQUVBLElBQUksQ0FBQ3NPLFVBQVUsQ0FBQzJnRCxhQUFhLENBQUNrRSxTQUFTO29CQUN2Q25tRCxTQUFTcW1ELE9BQU8sSUFBSSx3Q0FBd0M7Z0JBQzVELDRDQUE0QztnQkFDOUM7Z0JBRUEsSUFBSSxJQUFJLENBQUNVLE1BQU0sRUFBRTtvQkFDZixJQUFJM0ksa0JBQWtCQSxlQUFlM0wsRUFBRSxFQUFFO3dCQUN2QyxJQUFJa1YsZ0JBQWdCdkosZUFBZTNMLEVBQUUsRUFBRTs0QkFDckNrVixjQUFjdkosZUFBZTNMLEVBQUU7NEJBQy9CenlDLFNBQVM0bEQsWUFBWSxDQUFDeEgsZUFBZTNMLEVBQUUsR0FBRyxxQ0FBcUM7d0JBQ2pGO29CQUNGLE9BQU8sSUFBSWtWLGdCQUFnQixJQUFJLENBQUMvd0MsTUFBTSxDQUFDc3dDLE1BQU0sRUFBRTt3QkFDN0NTLGNBQWMsSUFBSSxDQUFDL3dDLE1BQU0sQ0FBQ3N3QyxNQUFNO3dCQUNoQ2xuRCxTQUFTNGxELFlBQVksQ0FBQyxJQUFJLENBQUNodkMsTUFBTSxDQUFDc3dDLE1BQU0sR0FBRyxzQ0FBc0M7b0JBQ25GO29CQUVBLElBQUk5SSxrQkFBa0JBLGVBQWVua0IsRUFBRSxFQUFFO3dCQUN2QyxJQUFJeXRCLGVBQWV0SixlQUFlbmtCLEVBQUUsRUFBRTs0QkFDcEN5dEIsYUFBYXRKLGVBQWVua0IsRUFBRTs0QkFDOUJqNkIsU0FBUzBsRCxjQUFjLENBQUN0SCxlQUFlbmtCLEVBQUUsR0FBRyx1Q0FBdUM7d0JBQ3JGO29CQUNGLE9BQU8sSUFBSXl0QixlQUFlLElBQUksQ0FBQzl3QyxNQUFNLENBQUNtd0MsTUFBTSxFQUFFO3dCQUM1Q1csYUFBYSxJQUFJLENBQUM5d0MsTUFBTSxDQUFDbXdDLE1BQU07d0JBQy9CL21ELFNBQVMwbEQsY0FBYyxDQUFDLElBQUksQ0FBQzl1QyxNQUFNLENBQUNtd0MsTUFBTSxHQUFHLHdDQUF3QztvQkFDdkY7b0JBRUFPLFdBQVcsSUFBSSxDQUFDMUssU0FBUyxDQUFDLzFELEVBQUUsQ0FBQytnQixJQUFJO29CQUNqQzdVLE9BQU91MEQsU0FBU3ZnRSxNQUFNO29CQUN0QixJQUFJLENBQUN1YSxVQUFVLENBQUMyZ0QsYUFBYSxDQUFDQyxTQUFTO29CQUV2QyxJQUFLcHZELElBQUksR0FBR0EsSUFBSUMsTUFBTUQsS0FBSyxFQUFHO3dCQUM1QnkwRCxVQUFVRCxRQUFRLENBQUN4MEQsRUFBRTt3QkFDckJHLE9BQU9zMEQsUUFBUXhnRSxNQUFNO3dCQUNyQixJQUFJLENBQUN1YSxVQUFVLENBQUMyZ0QsYUFBYSxDQUFDRSxNQUFNLENBQUNvRixPQUFPLENBQUMsRUFBRSxFQUFFQSxPQUFPLENBQUMsRUFBRTt3QkFFM0QsSUFBS3YwRCxJQUFJLEdBQUdBLElBQUlDLE1BQU1ELEtBQUssRUFBRzs0QkFDNUIsSUFBSSxDQUFDc08sVUFBVSxDQUFDMmdELGFBQWEsQ0FBQ0ksYUFBYSxDQUFDa0YsT0FBTyxDQUFDdjBELEVBQUUsRUFBRXUwRCxPQUFPLENBQUN2MEQsSUFBSSxFQUFFLEVBQUV1MEQsT0FBTyxDQUFDdjBELElBQUksRUFBRSxFQUFFdTBELE9BQU8sQ0FBQ3YwRCxJQUFJLEVBQUUsRUFBRXUwRCxPQUFPLENBQUN2MEQsSUFBSSxFQUFFLEVBQUV1MEQsT0FBTyxDQUFDdjBELElBQUksRUFBRTt3QkFDeEk7b0JBQ0Y7b0JBRUEsSUFBSSxDQUFDc08sVUFBVSxDQUFDMmdELGFBQWEsQ0FBQ2tFLFNBQVM7b0JBQ3ZDbm1ELFNBQVNvbUQsU0FBUyxJQUFJLDBDQUEwQztnQkFDaEUsdUNBQXVDO2dCQUN6QztnQkFFQSxJQUFJaEksZ0JBQWdCO29CQUNsQixJQUFJLENBQUM5OEMsVUFBVSxDQUFDdEIsUUFBUSxDQUFDK2pELE9BQU87Z0JBQ2xDO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsU0FBUzZELGVBQWVoMkQsSUFBSSxFQUFFMFAsVUFBVSxFQUFFbk4sSUFBSTtRQUM1QyxJQUFJLENBQUNnRyxTQUFTLEdBQUdtSCxXQUFXb0YsWUFBWSxDQUFDOVUsS0FBSzhCLEtBQUs7UUFDbkQsSUFBSSxDQUFDK0csR0FBRyxHQUFHNkcsV0FBV3kvQixXQUFXLENBQUM1a0MsUUFBUSxDQUFDLElBQUksQ0FBQ2hDLFNBQVM7UUFDekQsSUFBSSxDQUFDcXdDLFdBQVcsQ0FBQzU0QyxNQUFNMFAsWUFBWW5OO0lBQ3JDO0lBRUF6TixnQkFBZ0I7UUFBQ3E0QztRQUFhZ0Y7UUFBa0J5ZTtRQUFlclk7UUFBa0J6SjtRQUFjbEU7S0FBa0IsRUFBRW9yQjtJQUNuSEEsZUFBZTNnRSxTQUFTLENBQUN1akQsV0FBVyxHQUFHa0csZ0JBQWdCenBELFNBQVMsQ0FBQ3VqRCxXQUFXO0lBQzVFb2QsZUFBZTNnRSxTQUFTLENBQUMwWCxZQUFZLEdBQUdpc0MsY0FBYzNqRCxTQUFTLENBQUMwWCxZQUFZO0lBRTVFaXBELGVBQWUzZ0UsU0FBUyxDQUFDd2pELGFBQWEsR0FBRztRQUN2QyxJQUFJLElBQUksQ0FBQ2h3QyxHQUFHLENBQUNwQixLQUFLLElBQUssS0FBSSxDQUFDYyxTQUFTLENBQUNpZCxDQUFDLEtBQUssSUFBSSxDQUFDM2MsR0FBRyxDQUFDcEIsS0FBSyxJQUFJLElBQUksQ0FBQ2MsU0FBUyxDQUFDbkwsQ0FBQyxLQUFLLElBQUksQ0FBQ3lMLEdBQUcsQ0FBQ25CLE1BQU0sR0FBRztZQUNuRyxJQUFJRixTQUFTOVMsVUFBVTtZQUN2QjhTLE9BQU9DLEtBQUssR0FBRyxJQUFJLENBQUNjLFNBQVMsQ0FBQ2lkLENBQUM7WUFDL0JoZSxPQUFPRSxNQUFNLEdBQUcsSUFBSSxDQUFDYSxTQUFTLENBQUNuTCxDQUFDO1lBQ2hDLElBQUl1SyxNQUFNSCxPQUFPSSxVQUFVLENBQUM7WUFDNUIsSUFBSXF1RCxPQUFPLElBQUksQ0FBQ3B0RCxHQUFHLENBQUNwQixLQUFLO1lBQ3pCLElBQUl5dUQsT0FBTyxJQUFJLENBQUNydEQsR0FBRyxDQUFDbkIsTUFBTTtZQUMxQixJQUFJeXVELFNBQVNGLE9BQU9DO1lBQ3BCLElBQUlFLFlBQVksSUFBSSxDQUFDN3RELFNBQVMsQ0FBQ2lkLENBQUMsR0FBRyxJQUFJLENBQUNqZCxTQUFTLENBQUNuTCxDQUFDO1lBQ25ELElBQUlpNUQ7WUFDSixJQUFJQztZQUNKLElBQUlDLE1BQU0sSUFBSSxDQUFDaHVELFNBQVMsQ0FBQzJ3QyxFQUFFLElBQUksSUFBSSxDQUFDeHBDLFVBQVUsQ0FBQ2k4QixZQUFZLENBQUN3Tix3QkFBd0I7WUFFcEYsSUFBSWdkLFNBQVNDLGFBQWFHLFFBQVEsb0JBQW9CSixTQUFTQyxhQUFhRyxRQUFRLGtCQUFrQjtnQkFDcEdELGFBQWFKO2dCQUNiRyxZQUFZQyxhQUFhRjtZQUMzQixPQUFPO2dCQUNMQyxZQUFZSjtnQkFDWkssYUFBYUQsWUFBWUQ7WUFDM0I7WUFFQXp1RCxJQUFJa3FELFNBQVMsQ0FBQyxJQUFJLENBQUNocEQsR0FBRyxFQUFFLENBQUNvdEQsT0FBT0ksU0FBUSxJQUFLLEdBQUcsQ0FBQ0gsT0FBT0ksVUFBUyxJQUFLLEdBQUdELFdBQVdDLFlBQVksR0FBRyxHQUFHLElBQUksQ0FBQy90RCxTQUFTLENBQUNpZCxDQUFDLEVBQUUsSUFBSSxDQUFDamQsU0FBUyxDQUFDbkwsQ0FBQztZQUN4SSxJQUFJLENBQUN5TCxHQUFHLEdBQUdyQjtRQUNiO0lBQ0Y7SUFFQXd1RCxlQUFlM2dFLFNBQVMsQ0FBQ3lqRCxrQkFBa0IsR0FBRztRQUM1QyxJQUFJLENBQUN1WCxhQUFhLENBQUN3QixTQUFTLENBQUMsSUFBSSxDQUFDaHBELEdBQUcsRUFBRSxHQUFHO0lBQzVDO0lBRUFtdEQsZUFBZTNnRSxTQUFTLENBQUNtVixPQUFPLEdBQUc7UUFDakMsSUFBSSxDQUFDM0IsR0FBRyxHQUFHO0lBQ2I7SUFFQSxTQUFTMnRELGVBQWV4MkQsSUFBSSxFQUFFMFAsVUFBVSxFQUFFbk4sSUFBSTtRQUM1QyxJQUFJLENBQUNxMkMsV0FBVyxDQUFDNTRDLE1BQU0wUCxZQUFZbk47SUFDckM7SUFFQXpOLGdCQUFnQjtRQUFDcTRDO1FBQWFnRjtRQUFrQnllO1FBQWVyWTtRQUFrQnpKO1FBQWNsRTtLQUFrQixFQUFFNHJCO0lBQ25IQSxlQUFlbmhFLFNBQVMsQ0FBQ3VqRCxXQUFXLEdBQUdrRyxnQkFBZ0J6cEQsU0FBUyxDQUFDdWpELFdBQVc7SUFDNUU0ZCxlQUFlbmhFLFNBQVMsQ0FBQzBYLFlBQVksR0FBR2lzQyxjQUFjM2pELFNBQVMsQ0FBQzBYLFlBQVk7SUFFNUV5cEQsZUFBZW5oRSxTQUFTLENBQUN5akQsa0JBQWtCLEdBQUc7UUFDNUMsZ0NBQWdDO1FBQ2hDLElBQUksQ0FBQ3BwQyxVQUFVLENBQUN0QixRQUFRLENBQUNnbUQsWUFBWSxDQUFDLElBQUksQ0FBQ3AwRCxJQUFJLENBQUNxb0MsRUFBRSxHQUFHLGdDQUFnQztRQUVyRixJQUFJLENBQUMzNEIsVUFBVSxDQUFDdEIsUUFBUSxDQUFDcW9ELFdBQVcsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDejJELElBQUksQ0FBQzZnRCxFQUFFLEVBQUUsSUFBSSxDQUFDN2dELElBQUksQ0FBQ2dqQixFQUFFLEdBQUcsa0RBQWtEO0lBQzFILEVBQUU7SUFDSjtJQUVBLFNBQVMwekMsc0JBQXNCO0lBRS9CNWhFLGdCQUFnQjtRQUFDcTdDO0tBQWEsRUFBRXVtQjtJQUVoQ0EsbUJBQW1CcmhFLFNBQVMsQ0FBQ3c3QyxXQUFXLEdBQUcsU0FBVTd3QyxJQUFJO1FBQ3ZELE9BQU8sSUFBSXl5RCxlQUFlenlELE1BQU0sSUFBSSxDQUFDMFAsVUFBVSxFQUFFLElBQUk7SUFDdkQ7SUFFQWduRCxtQkFBbUJyaEUsU0FBUyxDQUFDeTdDLFVBQVUsR0FBRyxTQUFVOXdDLElBQUk7UUFDdEQsT0FBTyxJQUFJazFELGNBQWNsMUQsTUFBTSxJQUFJLENBQUMwUCxVQUFVLEVBQUUsSUFBSTtJQUN0RDtJQUVBZ25ELG1CQUFtQnJoRSxTQUFTLENBQUNvN0MsV0FBVyxHQUFHLFNBQVV6d0MsSUFBSTtRQUN2RCxPQUFPLElBQUlnMkQsZUFBZWgyRCxNQUFNLElBQUksQ0FBQzBQLFVBQVUsRUFBRSxJQUFJO0lBQ3ZEO0lBRUFnbkQsbUJBQW1CcmhFLFNBQVMsQ0FBQ3M3QyxXQUFXLEdBQUcsU0FBVTN3QyxJQUFJO1FBQ3ZELE9BQU8sSUFBSXcyRCxlQUFleDJELE1BQU0sSUFBSSxDQUFDMFAsVUFBVSxFQUFFLElBQUk7SUFDdkQ7SUFFQWduRCxtQkFBbUJyaEUsU0FBUyxDQUFDdTdDLFVBQVUsR0FBR3FkLFlBQVk1NEQsU0FBUyxDQUFDdTdDLFVBQVU7SUFFMUU4bEIsbUJBQW1CcmhFLFNBQVMsQ0FBQzQ4RCxZQUFZLEdBQUcsU0FBVW5rQyxLQUFLO1FBQ3pELElBQUlBLEtBQUssQ0FBQyxFQUFFLEtBQUssS0FBS0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLQSxLQUFLLENBQUMsRUFBRSxLQUFLLEtBQUtBLEtBQUssQ0FBQyxFQUFFLEtBQUssS0FBS0EsS0FBSyxDQUFDLEdBQUcsS0FBSyxLQUFLQSxLQUFLLENBQUMsR0FBRyxLQUFLLEdBQUc7WUFDOUc7UUFDRjtRQUVBLElBQUksQ0FBQ3VpQyxhQUFhLENBQUNuaEMsU0FBUyxDQUFDcEIsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEVBQUUsRUFBRUEsS0FBSyxDQUFDLEdBQUcsRUFBRUEsS0FBSyxDQUFDLEdBQUc7SUFDM0Y7SUFFQTRvQyxtQkFBbUJyaEUsU0FBUyxDQUFDNjhELFVBQVUsR0FBRyxTQUFVcHVELEVBQUU7UUFDcEQsSUFBSSxDQUFDdXNELGFBQWEsQ0FBQ3NHLFdBQVcsSUFBSTd5RCxLQUFLLElBQUksSUFBSUE7SUFDakQ7SUFFQTR5RCxtQkFBbUJyaEUsU0FBUyxDQUFDKytELFlBQVksR0FBRyxTQUFVNS9ELEtBQUs7UUFDekQsSUFBSSxDQUFDNjdELGFBQWEsQ0FBQ3hvRCxTQUFTLEdBQUdyVDtJQUNqQztJQUVBa2lFLG1CQUFtQnJoRSxTQUFTLENBQUN5K0QsY0FBYyxHQUFHLFNBQVV0L0QsS0FBSztRQUMzRCxJQUFJLENBQUM2N0QsYUFBYSxDQUFDdUcsV0FBVyxHQUFHcGlFO0lBQ25DO0lBRUFraUUsbUJBQW1CcmhFLFNBQVMsQ0FBQzIrRCxZQUFZLEdBQUcsU0FBVXgvRCxLQUFLO1FBQ3pELElBQUksQ0FBQzY3RCxhQUFhLENBQUN6TSxTQUFTLEdBQUdwdkQ7SUFDakM7SUFFQWtpRSxtQkFBbUJyaEUsU0FBUyxDQUFDNCtELFVBQVUsR0FBRyxTQUFVei9ELEtBQUs7UUFDdkQsSUFBSSxDQUFDNjdELGFBQWEsQ0FBQ3dHLE9BQU8sR0FBR3JpRTtJQUMvQjtJQUVBa2lFLG1CQUFtQnJoRSxTQUFTLENBQUM2K0QsV0FBVyxHQUFHLFNBQVUxL0QsS0FBSztRQUN4RCxJQUFJLENBQUM2N0QsYUFBYSxDQUFDanVCLFFBQVEsR0FBRzV0QztJQUNoQztJQUVBa2lFLG1CQUFtQnJoRSxTQUFTLENBQUM4K0QsYUFBYSxHQUFHLFNBQVUzL0QsS0FBSztRQUMxRCxJQUFJLENBQUM2N0QsYUFBYSxDQUFDaHVCLFVBQVUsR0FBRzd0QztJQUNsQztJQUVBa2lFLG1CQUFtQnJoRSxTQUFTLENBQUNvL0QsT0FBTyxHQUFHLFNBQVVxQyxJQUFJO1FBQ25ELElBQUksQ0FBQ3pHLGFBQWEsQ0FBQytFLElBQUksQ0FBQzBCO0lBQzFCO0lBRUFKLG1CQUFtQnJoRSxTQUFTLENBQUNvaEUsV0FBVyxHQUFHLFNBQVU1OEMsQ0FBQyxFQUFFc0ksQ0FBQyxFQUFFcUQsQ0FBQyxFQUFFcG9CLENBQUM7UUFDN0QsSUFBSSxDQUFDaXpELGFBQWEsQ0FBQ3ZvRCxRQUFRLENBQUMrUixHQUFHc0ksR0FBR3FELEdBQUdwb0I7SUFDdkM7SUFFQXM1RCxtQkFBbUJyaEUsU0FBUyxDQUFDbS9ELFNBQVMsR0FBRztRQUN2QyxJQUFJLENBQUNuRSxhQUFhLENBQUM4RSxNQUFNO0lBQzNCO0lBRUF1QixtQkFBbUJyaEUsU0FBUyxDQUFDczFCLEtBQUssR0FBRztRQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDZ2hCLFlBQVksQ0FBQzZsQixXQUFXLEVBQUU7WUFDbEMsSUFBSSxDQUFDbkIsYUFBYSxDQUFDOEIsT0FBTztZQUMxQjtRQUNGO1FBRUEsSUFBSSxDQUFDNEUsV0FBVyxDQUFDcHNDLEtBQUs7SUFDeEI7SUFFQStyQyxtQkFBbUJyaEUsU0FBUyxDQUFDcTdELElBQUksR0FBRztRQUNsQyxJQUFJLENBQUNMLGFBQWEsQ0FBQ0ssSUFBSTtJQUN6QjtJQUVBZ0csbUJBQW1CcmhFLFNBQVMsQ0FBQzg4RCxPQUFPLEdBQUcsU0FBVTZFLFVBQVU7UUFDekQsSUFBSSxDQUFDLElBQUksQ0FBQ3JyQixZQUFZLENBQUM2bEIsV0FBVyxFQUFFO1lBQ2xDLElBQUksQ0FBQ25CLGFBQWEsQ0FBQzhCLE9BQU87WUFDMUI7UUFDRjtRQUVBLElBQUk2RSxZQUFZO1lBQ2QsSUFBSSxDQUFDdG5ELFVBQVUsQ0FBQzBoRCxTQUFTLEdBQUc7UUFDOUI7UUFFQSxJQUFJLENBQUMyRixXQUFXLENBQUM1RSxPQUFPLENBQUM2RTtJQUMzQjtJQUVBTixtQkFBbUJyaEUsU0FBUyxDQUFDMFosZUFBZSxHQUFHLFNBQVUyQyxRQUFRO1FBQy9ELElBQUksSUFBSSxDQUFDcWdDLGFBQWEsQ0FBQzFpQyxPQUFPLEVBQUU7WUFDOUIsSUFBSSxDQUFDMGlDLGFBQWEsQ0FBQ3ppQyxTQUFTLEdBQUc1YSxVQUFVO1lBQ3pDLElBQUl1aUUsaUJBQWlCLElBQUksQ0FBQ2xsQixhQUFhLENBQUN6aUMsU0FBUyxDQUFDcFUsS0FBSztZQUN2RCs3RCxlQUFleHZELEtBQUssR0FBRztZQUN2Qnd2RCxlQUFldnZELE1BQU0sR0FBRztZQUN4QixJQUFJVCxTQUFTO1lBQ2Jnd0QsZUFBZTE3RCxlQUFlLEdBQUcwTDtZQUNqQ2d3RCxlQUFlQyxrQkFBa0IsR0FBR2p3RDtZQUNwQ2d3RCxlQUFlejdELHFCQUFxQixHQUFHeUw7WUFDdkNnd0QsY0FBYyxDQUFDLG9CQUFvQixHQUFHaHdEO1lBQ3RDZ3dELGVBQWVqSyxpQkFBaUIsR0FBRyxJQUFJLENBQUNyaEIsWUFBWSxDQUFDcWhCLGlCQUFpQjtZQUN0RSxJQUFJLENBQUNqYixhQUFhLENBQUMxaUMsT0FBTyxDQUFDMUYsV0FBVyxDQUFDLElBQUksQ0FBQ29vQyxhQUFhLENBQUN6aUMsU0FBUztZQUNuRSxJQUFJLENBQUMrZ0QsYUFBYSxHQUFHLElBQUksQ0FBQ3RlLGFBQWEsQ0FBQ3ppQyxTQUFTLENBQUMxSCxVQUFVLENBQUM7WUFFN0QsSUFBSSxJQUFJLENBQUMrakMsWUFBWSxDQUFDc2hCLFNBQVMsRUFBRTtnQkFDL0IsSUFBSSxDQUFDbGIsYUFBYSxDQUFDemlDLFNBQVMsQ0FBQzBILFlBQVksQ0FBQyxTQUFTLElBQUksQ0FBQzIwQixZQUFZLENBQUNzaEIsU0FBUztZQUNoRjtZQUVBLElBQUksSUFBSSxDQUFDdGhCLFlBQVksQ0FBQ3JwQyxFQUFFLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQ3l2QyxhQUFhLENBQUN6aUMsU0FBUyxDQUFDMEgsWUFBWSxDQUFDLE1BQU0sSUFBSSxDQUFDMjBCLFlBQVksQ0FBQ3JwQyxFQUFFO1lBQ3RFO1FBQ0YsT0FBTztZQUNMLElBQUksQ0FBQyt0RCxhQUFhLEdBQUcsSUFBSSxDQUFDMWtCLFlBQVksQ0FBQ3dyQixPQUFPO1FBQ2hEO1FBRUEsSUFBSSxDQUFDSixXQUFXLENBQUNLLFVBQVUsQ0FBQyxJQUFJLENBQUMvRyxhQUFhO1FBQzlDLElBQUksQ0FBQ3J3RCxJQUFJLEdBQUcwUjtRQUNaLElBQUksQ0FBQzNRLE1BQU0sR0FBRzJRLFNBQVMzUSxNQUFNO1FBQzdCLElBQUksQ0FBQ293RCxlQUFlLEdBQUc7WUFDckIzckMsR0FBRzlULFNBQVM4VCxDQUFDO1lBQ2Jwb0IsR0FBR3NVLFNBQVN0VSxDQUFDO1lBQ2JteEIsSUFBSTtZQUNKL0MsSUFBSTtZQUNKd0QsSUFBSTtZQUNKcHRCLElBQUk7UUFDTjtRQUNBLElBQUksQ0FBQ2l3QyxlQUFlLENBQUNuZ0MsVUFBVTljLFNBQVNxaUIsSUFBSTtRQUM1QyxJQUFJLENBQUN2SCxVQUFVLENBQUMyZ0QsYUFBYSxHQUFHLElBQUksQ0FBQ0EsYUFBYTtRQUNsRCxJQUFJLENBQUMzZ0QsVUFBVSxDQUFDdEIsUUFBUSxHQUFHLElBQUk7UUFDL0IsSUFBSSxDQUFDc0IsVUFBVSxDQUFDMm5ELFFBQVEsR0FBRztRQUMzQixJQUFJLENBQUMzbkQsVUFBVSxDQUFDeWhDLGVBQWUsR0FBRyxJQUFJLENBQUN4RixZQUFZLENBQUN3RixlQUFlO1FBQ25FLElBQUksQ0FBQ3poQyxVQUFVLENBQUN5aEQsZUFBZSxHQUFHLElBQUksQ0FBQ0EsZUFBZTtRQUN0RCxJQUFJLENBQUMvMkIsUUFBUSxHQUFHL2hDLGlCQUFpQnFaLFNBQVMzUSxNQUFNLENBQUM1TCxNQUFNO1FBQ3ZELElBQUksQ0FBQ29kLG1CQUFtQjtJQUMxQjtJQUVBbWtELG1CQUFtQnJoRSxTQUFTLENBQUNrZCxtQkFBbUIsR0FBRyxTQUFVOUssS0FBSyxFQUFFQyxNQUFNO1FBQ3hFLElBQUksQ0FBQ2lqQixLQUFLO1FBQ1YsSUFBSTJzQztRQUNKLElBQUlDO1FBRUosSUFBSTl2RCxPQUFPO1lBQ1Q2dkQsZUFBZTd2RDtZQUNmOHZELGdCQUFnQjd2RDtZQUNoQixJQUFJLENBQUMyb0QsYUFBYSxDQUFDN29ELE1BQU0sQ0FBQ0MsS0FBSyxHQUFHNnZEO1lBQ2xDLElBQUksQ0FBQ2pILGFBQWEsQ0FBQzdvRCxNQUFNLENBQUNFLE1BQU0sR0FBRzZ2RDtRQUNyQyxPQUFPO1lBQ0wsSUFBSSxJQUFJLENBQUN4bEIsYUFBYSxDQUFDMWlDLE9BQU8sSUFBSSxJQUFJLENBQUMwaUMsYUFBYSxDQUFDemlDLFNBQVMsRUFBRTtnQkFDOURnb0QsZUFBZSxJQUFJLENBQUN2bEIsYUFBYSxDQUFDMWlDLE9BQU8sQ0FBQzAyQixXQUFXO2dCQUNyRHd4QixnQkFBZ0IsSUFBSSxDQUFDeGxCLGFBQWEsQ0FBQzFpQyxPQUFPLENBQUNtb0QsWUFBWTtZQUN6RCxPQUFPO2dCQUNMRixlQUFlLElBQUksQ0FBQ2pILGFBQWEsQ0FBQzdvRCxNQUFNLENBQUNDLEtBQUs7Z0JBQzlDOHZELGdCQUFnQixJQUFJLENBQUNsSCxhQUFhLENBQUM3b0QsTUFBTSxDQUFDRSxNQUFNO1lBQ2xEO1lBRUEsSUFBSSxDQUFDMm9ELGFBQWEsQ0FBQzdvRCxNQUFNLENBQUNDLEtBQUssR0FBRzZ2RCxlQUFlLElBQUksQ0FBQzNyQixZQUFZLENBQUM4ckIsR0FBRztZQUN0RSxJQUFJLENBQUNwSCxhQUFhLENBQUM3b0QsTUFBTSxDQUFDRSxNQUFNLEdBQUc2dkQsZ0JBQWdCLElBQUksQ0FBQzVyQixZQUFZLENBQUM4ckIsR0FBRztRQUMxRTtRQUVBLElBQUlDO1FBQ0osSUFBSUM7UUFFSixJQUFJLElBQUksQ0FBQ2hzQixZQUFZLENBQUN3aEIsbUJBQW1CLENBQUM3bkQsT0FBTyxDQUFDLFlBQVksQ0FBQyxLQUFLLElBQUksQ0FBQ3FtQyxZQUFZLENBQUN3aEIsbUJBQW1CLENBQUM3bkQsT0FBTyxDQUFDLGFBQWEsQ0FBQyxHQUFHO1lBQ2pJLElBQUlpeEQsTUFBTSxJQUFJLENBQUM1cUIsWUFBWSxDQUFDd2hCLG1CQUFtQixDQUFDaHFELEtBQUssQ0FBQztZQUN0RCxJQUFJeTBELFdBQVdyQixHQUFHLENBQUMsRUFBRSxJQUFJO1lBQ3pCLElBQUlwdUMsTUFBTW91QyxHQUFHLENBQUMsRUFBRSxJQUFJO1lBQ3BCLElBQUl0TyxPQUFPOS9CLElBQUloWSxNQUFNLENBQUMsR0FBRztZQUN6QixJQUFJKzNDLE9BQU8vL0IsSUFBSWhZLE1BQU0sQ0FBQztZQUN0QnVuRCxhQUFhSixlQUFlQztZQUM1QkksZUFBZSxJQUFJLENBQUN4RyxlQUFlLENBQUMzckMsQ0FBQyxHQUFHLElBQUksQ0FBQzJyQyxlQUFlLENBQUMvekQsQ0FBQztZQUU5RCxJQUFJdTZELGVBQWVELGNBQWNFLGFBQWEsVUFBVUQsZUFBZUQsY0FBY0UsYUFBYSxTQUFTO2dCQUN6RyxJQUFJLENBQUN6RyxlQUFlLENBQUM1aUMsRUFBRSxHQUFHK29DLGVBQWdCLEtBQUksQ0FBQ25HLGVBQWUsQ0FBQzNyQyxDQUFDLEdBQUcsSUFBSSxDQUFDbW1CLFlBQVksQ0FBQzhyQixHQUFHO2dCQUN4RixJQUFJLENBQUN0RyxlQUFlLENBQUMzbEMsRUFBRSxHQUFHOHJDLGVBQWdCLEtBQUksQ0FBQ25HLGVBQWUsQ0FBQzNyQyxDQUFDLEdBQUcsSUFBSSxDQUFDbW1CLFlBQVksQ0FBQzhyQixHQUFHO1lBQzFGLE9BQU87Z0JBQ0wsSUFBSSxDQUFDdEcsZUFBZSxDQUFDNWlDLEVBQUUsR0FBR2dwQyxnQkFBaUIsS0FBSSxDQUFDcEcsZUFBZSxDQUFDL3pELENBQUMsR0FBRyxJQUFJLENBQUN1dUMsWUFBWSxDQUFDOHJCLEdBQUc7Z0JBQ3pGLElBQUksQ0FBQ3RHLGVBQWUsQ0FBQzNsQyxFQUFFLEdBQUcrckMsZ0JBQWlCLEtBQUksQ0FBQ3BHLGVBQWUsQ0FBQy96RCxDQUFDLEdBQUcsSUFBSSxDQUFDdXVDLFlBQVksQ0FBQzhyQixHQUFHO1lBQzNGO1lBRUEsSUFBSXhQLFNBQVMsVUFBVzBQLENBQUFBLGVBQWVELGNBQWNFLGFBQWEsVUFBVUQsZUFBZUQsY0FBY0UsYUFBYSxPQUFNLEdBQUk7Z0JBQzlILElBQUksQ0FBQ3pHLGVBQWUsQ0FBQ25pQyxFQUFFLEdBQUcsQ0FBQ3NvQyxlQUFlLElBQUksQ0FBQ25HLGVBQWUsQ0FBQzNyQyxDQUFDLEdBQUkreEMsQ0FBQUEsZ0JBQWdCLElBQUksQ0FBQ3BHLGVBQWUsQ0FBQy96RCxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUN1dUMsWUFBWSxDQUFDOHJCLEdBQUc7WUFDMUksT0FBTyxJQUFJeFAsU0FBUyxVQUFXMFAsQ0FBQUEsZUFBZUQsY0FBY0UsYUFBYSxVQUFVRCxlQUFlRCxjQUFjRSxhQUFhLE9BQU0sR0FBSTtnQkFDckksSUFBSSxDQUFDekcsZUFBZSxDQUFDbmlDLEVBQUUsR0FBRyxDQUFDc29DLGVBQWUsSUFBSSxDQUFDbkcsZUFBZSxDQUFDM3JDLENBQUMsR0FBSSt4QyxDQUFBQSxnQkFBZ0IsSUFBSSxDQUFDcEcsZUFBZSxDQUFDL3pELENBQUMsS0FBSyxJQUFJLENBQUN1dUMsWUFBWSxDQUFDOHJCLEdBQUc7WUFDdEksT0FBTztnQkFDTCxJQUFJLENBQUN0RyxlQUFlLENBQUNuaUMsRUFBRSxHQUFHO1lBQzVCO1lBRUEsSUFBSWs1QixTQUFTLFVBQVd5UCxDQUFBQSxlQUFlRCxjQUFjRSxhQUFhLFVBQVVELGVBQWVELGNBQWNFLGFBQWEsT0FBTSxHQUFJO2dCQUM5SCxJQUFJLENBQUN6RyxlQUFlLENBQUN2dkQsRUFBRSxHQUFHLENBQUMyMUQsZ0JBQWdCLElBQUksQ0FBQ3BHLGVBQWUsQ0FBQy96RCxDQUFDLEdBQUlrNkQsQ0FBQUEsZUFBZSxJQUFJLENBQUNuRyxlQUFlLENBQUMzckMsQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDbW1CLFlBQVksQ0FBQzhyQixHQUFHO1lBQzFJLE9BQU8sSUFBSXZQLFNBQVMsVUFBV3lQLENBQUFBLGVBQWVELGNBQWNFLGFBQWEsVUFBVUQsZUFBZUQsY0FBY0UsYUFBYSxPQUFNLEdBQUk7Z0JBQ3JJLElBQUksQ0FBQ3pHLGVBQWUsQ0FBQ3Z2RCxFQUFFLEdBQUcsQ0FBQzIxRCxnQkFBZ0IsSUFBSSxDQUFDcEcsZUFBZSxDQUFDL3pELENBQUMsR0FBSWs2RCxDQUFBQSxlQUFlLElBQUksQ0FBQ25HLGVBQWUsQ0FBQzNyQyxDQUFDLEtBQUssSUFBSSxDQUFDbW1CLFlBQVksQ0FBQzhyQixHQUFHO1lBQ3RJLE9BQU87Z0JBQ0wsSUFBSSxDQUFDdEcsZUFBZSxDQUFDdnZELEVBQUUsR0FBRztZQUM1QjtRQUNGLE9BQU8sSUFBSSxJQUFJLENBQUMrcEMsWUFBWSxDQUFDd2hCLG1CQUFtQixLQUFLLFFBQVE7WUFDM0QsSUFBSSxDQUFDZ0UsZUFBZSxDQUFDNWlDLEVBQUUsR0FBRytvQyxlQUFnQixLQUFJLENBQUNuRyxlQUFlLENBQUMzckMsQ0FBQyxHQUFHLElBQUksQ0FBQ21tQixZQUFZLENBQUM4ckIsR0FBRztZQUN4RixJQUFJLENBQUN0RyxlQUFlLENBQUMzbEMsRUFBRSxHQUFHK3JDLGdCQUFpQixLQUFJLENBQUNwRyxlQUFlLENBQUMvekQsQ0FBQyxHQUFHLElBQUksQ0FBQ3V1QyxZQUFZLENBQUM4ckIsR0FBRztZQUN6RixJQUFJLENBQUN0RyxlQUFlLENBQUNuaUMsRUFBRSxHQUFHO1lBQzFCLElBQUksQ0FBQ21pQyxlQUFlLENBQUN2dkQsRUFBRSxHQUFHO1FBQzVCLE9BQU87WUFDTCxJQUFJLENBQUN1dkQsZUFBZSxDQUFDNWlDLEVBQUUsR0FBRyxJQUFJLENBQUNvZCxZQUFZLENBQUM4ckIsR0FBRztZQUMvQyxJQUFJLENBQUN0RyxlQUFlLENBQUMzbEMsRUFBRSxHQUFHLElBQUksQ0FBQ21nQixZQUFZLENBQUM4ckIsR0FBRztZQUMvQyxJQUFJLENBQUN0RyxlQUFlLENBQUNuaUMsRUFBRSxHQUFHO1lBQzFCLElBQUksQ0FBQ21pQyxlQUFlLENBQUN2dkQsRUFBRSxHQUFHO1FBQzVCO1FBRUEsSUFBSSxDQUFDdXZELGVBQWUsQ0FBQ3JqQyxLQUFLLEdBQUc7WUFBQyxJQUFJLENBQUNxakMsZUFBZSxDQUFDNWlDLEVBQUU7WUFBRTtZQUFHO1lBQUc7WUFBRztZQUFHLElBQUksQ0FBQzRpQyxlQUFlLENBQUMzbEMsRUFBRTtZQUFFO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHLElBQUksQ0FBQzJsQyxlQUFlLENBQUNuaUMsRUFBRTtZQUFFLElBQUksQ0FBQ21pQyxlQUFlLENBQUN2dkQsRUFBRTtZQUFFO1lBQUc7U0FBRTtRQUNySzs7Ozs7UUFLSSxHQUVKLElBQUksQ0FBQ3F3RCxZQUFZLENBQUMsSUFBSSxDQUFDZCxlQUFlLENBQUNyakMsS0FBSztRQUM1QyxJQUFJLENBQUN1aUMsYUFBYSxDQUFDQyxTQUFTO1FBQzVCLElBQUksQ0FBQ0QsYUFBYSxDQUFDcmMsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUNtZCxlQUFlLENBQUMzckMsQ0FBQyxFQUFFLElBQUksQ0FBQzJyQyxlQUFlLENBQUMvekQsQ0FBQztRQUM1RSxJQUFJLENBQUNpekQsYUFBYSxDQUFDa0UsU0FBUztRQUM1QixJQUFJLENBQUNsRSxhQUFhLENBQUNNLElBQUk7UUFDdkIsSUFBSSxDQUFDbCtDLFdBQVcsQ0FBQyxJQUFJLENBQUNrVCxhQUFhLEVBQUU7SUFDdkM7SUFFQSt3QyxtQkFBbUJyaEUsU0FBUyxDQUFDbVYsT0FBTyxHQUFHO1FBQ3JDLElBQUksSUFBSSxDQUFDbWhDLFlBQVksQ0FBQzZsQixXQUFXLElBQUksSUFBSSxDQUFDemYsYUFBYSxDQUFDMWlDLE9BQU8sRUFBRTtZQUMvRCxJQUFJLENBQUMwaUMsYUFBYSxDQUFDMWlDLE9BQU8sQ0FBQzhILFNBQVMsR0FBRztRQUN6QztRQUVBLElBQUlsaUI7UUFDSixJQUFJQyxNQUFNLElBQUksQ0FBQzZMLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU0sQ0FBQzVMLE1BQU0sR0FBRztRQUU3QyxJQUFLRixJQUFJQyxNQUFNLEdBQUdELEtBQUssR0FBR0EsS0FBSyxFQUFHO1lBQ2hDLElBQUksSUFBSSxDQUFDbWxDLFFBQVEsQ0FBQ25sQyxFQUFFLElBQUksSUFBSSxDQUFDbWxDLFFBQVEsQ0FBQ25sQyxFQUFFLENBQUN1VixPQUFPLEVBQUU7Z0JBQ2hELElBQUksQ0FBQzR2QixRQUFRLENBQUNubEMsRUFBRSxDQUFDdVYsT0FBTztZQUMxQjtRQUNGO1FBRUEsSUFBSSxDQUFDNHZCLFFBQVEsQ0FBQ2psQyxNQUFNLEdBQUc7UUFDdkIsSUFBSSxDQUFDdWEsVUFBVSxDQUFDMmdELGFBQWEsR0FBRztRQUNoQyxJQUFJLENBQUN0ZSxhQUFhLENBQUN6aUMsU0FBUyxHQUFHO1FBQy9CLElBQUksQ0FBQzg5QyxTQUFTLEdBQUc7SUFDbkI7SUFFQXNKLG1CQUFtQnJoRSxTQUFTLENBQUNvZCxXQUFXLEdBQUcsU0FBVTY0QixHQUFHLEVBQUVoVCxXQUFXO1FBQ25FLElBQUksSUFBSSxDQUFDM1MsYUFBYSxLQUFLMmxCLE9BQU8sSUFBSSxDQUFDSyxZQUFZLENBQUM2bEIsV0FBVyxLQUFLLFFBQVEsQ0FBQ2w1QixlQUFlLElBQUksQ0FBQzgwQixTQUFTLElBQUk5aEIsUUFBUSxDQUFDLEdBQUc7WUFDeEg7UUFDRjtRQUVBLElBQUksQ0FBQzNsQixhQUFhLEdBQUcybEI7UUFDckIsSUFBSSxDQUFDNTdCLFVBQVUsQ0FBQ29SLFFBQVEsR0FBR3dxQixNQUFNLElBQUksQ0FBQ3lHLGFBQWEsQ0FBQ3hyQixhQUFhO1FBQ2pFLElBQUksQ0FBQzdXLFVBQVUsQ0FBQzBXLE9BQU8sSUFBSTtRQUMzQixJQUFJLENBQUMxVyxVQUFVLENBQUN3VyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUN5bEIsWUFBWSxDQUFDNmxCLFdBQVcsSUFBSWw1QjtRQUN6RCxJQUFJLENBQUM1b0IsVUFBVSxDQUFDZCxnQkFBZ0IsQ0FBQzNCLFlBQVksR0FBR3ErQixLQUFLLDJCQUEyQjtRQUNoRiw0QkFBNEI7UUFFNUIsSUFBSXIyQztRQUNKLElBQUlDLE1BQU0sSUFBSSxDQUFDNkwsTUFBTSxDQUFDNUwsTUFBTTtRQUU1QixJQUFJLENBQUMsSUFBSSxDQUFDMkwsY0FBYyxFQUFFO1lBQ3hCLElBQUksQ0FBQ3N2QyxXQUFXLENBQUM5RTtRQUNuQjtRQUVBLElBQUtyMkMsSUFBSUMsTUFBTSxHQUFHRCxLQUFLLEdBQUdBLEtBQUssRUFBRztZQUNoQyxJQUFJLElBQUksQ0FBQzZMLGNBQWMsSUFBSSxJQUFJLENBQUNzNUIsUUFBUSxDQUFDbmxDLEVBQUUsRUFBRTtnQkFDM0MsSUFBSSxDQUFDbWxDLFFBQVEsQ0FBQ25sQyxFQUFFLENBQUM4WCxZQUFZLENBQUN1K0IsTUFBTSxJQUFJLENBQUN2cUMsTUFBTSxDQUFDOUwsRUFBRSxDQUFDOE8sRUFBRTtZQUN2RDtRQUNGO1FBRUEsSUFBSSxJQUFJLENBQUMyTCxVQUFVLENBQUN3VyxJQUFJLEVBQUU7WUFDeEIsSUFBSSxJQUFJLENBQUN5bEIsWUFBWSxDQUFDNmxCLFdBQVcsS0FBSyxNQUFNO2dCQUMxQyxJQUFJLENBQUNuQixhQUFhLENBQUNvQixTQUFTLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQ04sZUFBZSxDQUFDM3JDLENBQUMsRUFBRSxJQUFJLENBQUMyckMsZUFBZSxDQUFDL3pELENBQUM7WUFDbkYsT0FBTztnQkFDTCxJQUFJLENBQUNzekQsSUFBSTtZQUNYO1lBRUEsSUFBS3o3RCxJQUFJQyxNQUFNLEdBQUdELEtBQUssR0FBR0EsS0FBSyxFQUFHO2dCQUNoQyxJQUFJLElBQUksQ0FBQzZMLGNBQWMsSUFBSSxJQUFJLENBQUNzNUIsUUFBUSxDQUFDbmxDLEVBQUUsRUFBRTtvQkFDM0MsSUFBSSxDQUFDbWxDLFFBQVEsQ0FBQ25sQyxFQUFFLENBQUN3ZCxXQUFXO2dCQUM5QjtZQUNGO1lBRUEsSUFBSSxJQUFJLENBQUNrNUIsWUFBWSxDQUFDNmxCLFdBQVcsS0FBSyxNQUFNO2dCQUMxQyxJQUFJLENBQUNXLE9BQU87WUFDZDtRQUNGO0lBQ0Y7SUFFQXVFLG1CQUFtQnJoRSxTQUFTLENBQUNnN0MsU0FBUyxHQUFHLFNBQVVsb0IsR0FBRztRQUNwRCxJQUFJaVMsV0FBVyxJQUFJLENBQUNBLFFBQVE7UUFFNUIsSUFBSUEsUUFBUSxDQUFDalMsSUFBSSxJQUFJLElBQUksQ0FBQ3BuQixNQUFNLENBQUNvbkIsSUFBSSxDQUFDdm1CLEVBQUUsS0FBSyxJQUFJO1lBQy9DO1FBQ0Y7UUFFQSxJQUFJM0csVUFBVSxJQUFJLENBQUNzMUMsVUFBVSxDQUFDLElBQUksQ0FBQ3h2QyxNQUFNLENBQUNvbkIsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUN6WSxVQUFVO1FBQ3JFMHFCLFFBQVEsQ0FBQ2pTLElBQUksR0FBR2x0QjtRQUNoQkEsUUFBUWdXLGVBQWU7SUFDdkI7O1FBRUksR0FDTjtJQUVBeWxELG1CQUFtQnJoRSxTQUFTLENBQUNpN0Msb0JBQW9CLEdBQUc7UUFDbEQsTUFBTyxJQUFJLENBQUNvQixlQUFlLENBQUN2OEMsTUFBTSxDQUFFO1lBQ2xDLElBQUk4RixVQUFVLElBQUksQ0FBQ3kyQyxlQUFlLENBQUM3YSxHQUFHO1lBQ3RDNTdCLFFBQVF3OUMsY0FBYztRQUN4QjtJQUNGO0lBRUFpZSxtQkFBbUJyaEUsU0FBUyxDQUFDMGYsSUFBSSxHQUFHO1FBQ2xDLElBQUksQ0FBQ2c5QixhQUFhLENBQUN6aUMsU0FBUyxDQUFDcFUsS0FBSyxDQUFDSSxPQUFPLEdBQUc7SUFDL0M7SUFFQW83RCxtQkFBbUJyaEUsU0FBUyxDQUFDMmYsSUFBSSxHQUFHO1FBQ2xDLElBQUksQ0FBQys4QixhQUFhLENBQUN6aUMsU0FBUyxDQUFDcFUsS0FBSyxDQUFDSSxPQUFPLEdBQUc7SUFDL0M7SUFFQSxTQUFTdThEO1FBQ1AsSUFBSSxDQUFDNWtCLE9BQU8sR0FBRyxDQUFDO1FBQ2hCLElBQUksQ0FBQy9qQixTQUFTLEdBQUdwM0IsaUJBQWlCLFdBQVc7UUFDN0MsSUFBSSxDQUFDK1AsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQyt1RCxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDaFQsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ2lULE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ3owQixRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDLy9CLEVBQUUsR0FBRy9JLEtBQUthLE1BQU07SUFDdkI7SUFFQSxTQUFTMDlEO1FBQ1AsSUFBSSxDQUFDQyxLQUFLLEdBQUcsRUFBRTtRQUNmLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxHQUFHLEdBQUcsSUFBSXpxQztRQUNmLElBQUl2NEI7UUFDSixJQUFJQyxNQUFNO1FBRVYsSUFBS0QsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDM0IsSUFBSW83RCxnQkFBZ0IsSUFBSXdIO1lBQ3hCLElBQUksQ0FBQ0UsS0FBSyxDQUFDOWlFLEVBQUUsR0FBR283RDtRQUNsQjtRQUVBLElBQUksQ0FBQ3IxQyxPQUFPLEdBQUc5bEI7UUFDZixJQUFJLENBQUNnakUsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsWUFBWSxHQUFHLElBQUkzcUM7UUFDeEIsSUFBSSxDQUFDNHFDLGNBQWMsR0FBRyxHQUFHLEVBQUU7UUFFM0IsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUNDLGdCQUFnQixHQUFHLElBQUksRUFBRTtRQUU5QixJQUFJLENBQUNDLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUcsSUFBSSxFQUFFO1FBRWhDLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxJQUFJLEVBQUU7UUFFOUIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxjQUFjLEdBQUcsSUFBSSxFQUFFO1FBRTVCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLElBQUksRUFBRTtRQUU3QixJQUFJLENBQUNDLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7SUFDM0I7SUFFQWxCLGNBQWN6aUUsU0FBUyxDQUFDNGpFLFNBQVMsR0FBRztRQUNsQyxJQUFJQyxZQUFZLElBQUksQ0FBQ2wrQyxPQUFPLEdBQUc7UUFDL0IsSUFBSS9sQixJQUFJO1FBRVIsSUFBS0EsSUFBSSxJQUFJLENBQUMrbEIsT0FBTyxFQUFFL2xCLElBQUlpa0UsV0FBV2prRSxLQUFLLEVBQUc7WUFDNUMsSUFBSSxDQUFDOGlFLEtBQUssQ0FBQzlpRSxFQUFFLEdBQUcsSUFBSTRpRTtRQUN0QjtRQUVBLElBQUksQ0FBQzc4QyxPQUFPLEdBQUdrK0M7SUFDakI7SUFFQXBCLGNBQWN6aUUsU0FBUyxDQUFDczFCLEtBQUssR0FBRztRQUM5QixJQUFJLENBQUNxdEMsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxHQUFHLENBQUN0dEMsS0FBSztRQUNkLElBQUksQ0FBQ290QyxLQUFLLENBQUMsSUFBSSxDQUFDQyxPQUFPLENBQUMsQ0FBQy9rQixPQUFPLEdBQUc7SUFDckM7SUFFQTZrQixjQUFjemlFLFNBQVMsQ0FBQzg4RCxPQUFPLEdBQUcsU0FBVWdILFlBQVk7UUFDdEQsSUFBSSxDQUFDbkIsT0FBTyxJQUFJO1FBQ2hCLElBQUlvQixpQkFBaUIsSUFBSSxDQUFDckIsS0FBSyxDQUFDLElBQUksQ0FBQ0MsT0FBTyxDQUFDO1FBQzdDLElBQUk5b0MsWUFBWWtxQyxlQUFlbHFDLFNBQVM7UUFDeEMsSUFBSWo2QjtRQUNKLElBQUkrQyxNQUFNLElBQUksQ0FBQ2lnRSxHQUFHLENBQUNucUMsS0FBSztRQUV4QixJQUFLNzRCLElBQUksR0FBR0EsSUFBSSxJQUFJQSxLQUFLLEVBQUc7WUFDMUIrQyxHQUFHLENBQUMvQyxFQUFFLEdBQUdpNkIsU0FBUyxDQUFDajZCLEVBQUU7UUFDdkI7UUFFQSxJQUFJa2tFLGNBQWM7WUFDaEIsSUFBSSxDQUFDakIsYUFBYSxDQUFDL0YsT0FBTztZQUMxQixJQUFJa0gsWUFBWSxJQUFJLENBQUN0QixLQUFLLENBQUMsSUFBSSxDQUFDQyxPQUFPLEdBQUcsRUFBRTtZQUM1QyxJQUFJLENBQUNNLGdCQUFnQixHQUFHZSxVQUFVeHhELFNBQVM7WUFDM0MsSUFBSSxDQUFDMndELGtCQUFrQixHQUFHYSxVQUFVekMsV0FBVztZQUMvQyxJQUFJLENBQUM4QixnQkFBZ0IsR0FBR1csVUFBVXpWLFNBQVM7WUFDM0MsSUFBSSxDQUFDZ1YsY0FBYyxHQUFHUyxVQUFVeEMsT0FBTztZQUN2QyxJQUFJLENBQUNpQyxlQUFlLEdBQUdPLFVBQVVqM0IsUUFBUTtZQUN6QyxJQUFJLENBQUMyMkIsaUJBQWlCLEdBQUdNLFVBQVVoM0IsVUFBVTtRQUMvQztRQUVBLElBQUksQ0FBQzYxQixhQUFhLENBQUN0cEMsWUFBWSxDQUFDTSxTQUFTLENBQUMsRUFBRSxFQUFFQSxTQUFTLENBQUMsRUFBRSxFQUFFQSxTQUFTLENBQUMsRUFBRSxFQUFFQSxTQUFTLENBQUMsRUFBRSxFQUFFQSxTQUFTLENBQUMsR0FBRyxFQUFFQSxTQUFTLENBQUMsR0FBRztRQUVwSCxJQUFJaXFDLGdCQUFnQkMsZUFBZW5tQixPQUFPLEtBQUssQ0FBQyxLQUFLLElBQUksQ0FBQ21sQixjQUFjLEtBQUtnQixlQUFlbm1CLE9BQU8sRUFBRTtZQUNuRyxJQUFJLENBQUNpbEIsYUFBYSxDQUFDdkIsV0FBVyxHQUFHeUMsZUFBZW5tQixPQUFPO1lBQ3ZELElBQUksQ0FBQ21sQixjQUFjLEdBQUdnQixlQUFlbm1CLE9BQU87UUFDOUM7UUFFQSxJQUFJLENBQUNvbEIsZ0JBQWdCLEdBQUdlLGVBQWV2eEQsU0FBUztRQUNoRCxJQUFJLENBQUMwd0Qsa0JBQWtCLEdBQUdhLGVBQWV4QyxXQUFXO1FBQ3BELElBQUksQ0FBQzZCLGdCQUFnQixHQUFHVyxlQUFleFYsU0FBUztRQUNoRCxJQUFJLENBQUMrVSxjQUFjLEdBQUdTLGVBQWV2QyxPQUFPO1FBQzVDLElBQUksQ0FBQ2dDLGVBQWUsR0FBR08sZUFBZWgzQixRQUFRO1FBQzlDLElBQUksQ0FBQzQyQixpQkFBaUIsR0FBR0ksZUFBZS8yQixVQUFVO0lBQ3BEO0lBRUF5MUIsY0FBY3ppRSxTQUFTLENBQUNxN0QsSUFBSSxHQUFHLFNBQVU0SSxnQkFBZ0I7UUFDdkQsSUFBSUEsa0JBQWtCO1lBQ3BCLElBQUksQ0FBQ3BCLGFBQWEsQ0FBQ3hILElBQUk7UUFDekI7UUFFQSxJQUFJNWlDLFFBQVEsSUFBSSxDQUFDbXFDLEdBQUcsQ0FBQ25xQyxLQUFLO1FBRTFCLElBQUksSUFBSSxDQUFDOVMsT0FBTyxJQUFJLElBQUksQ0FBQ2c5QyxPQUFPLEVBQUU7WUFDaEMsSUFBSSxDQUFDaUIsU0FBUztRQUNoQjtRQUVBLElBQUlNLGVBQWUsSUFBSSxDQUFDeEIsS0FBSyxDQUFDLElBQUksQ0FBQ0MsT0FBTyxDQUFDO1FBQzNDLElBQUkvaUU7UUFFSixJQUFLQSxJQUFJLEdBQUdBLElBQUksSUFBSUEsS0FBSyxFQUFHO1lBQzFCc2tFLGFBQWFycUMsU0FBUyxDQUFDajZCLEVBQUUsR0FBRzY0QixLQUFLLENBQUM3NEIsRUFBRTtRQUN0QztRQUVBLElBQUksQ0FBQytpRSxPQUFPLElBQUk7UUFDaEIsSUFBSXdCLFdBQVcsSUFBSSxDQUFDekIsS0FBSyxDQUFDLElBQUksQ0FBQ0MsT0FBTyxDQUFDO1FBQ3ZDd0IsU0FBU3ZtQixPQUFPLEdBQUdzbUIsYUFBYXRtQixPQUFPO1FBQ3ZDdW1CLFNBQVMzeEQsU0FBUyxHQUFHMHhELGFBQWExeEQsU0FBUztRQUMzQzJ4RCxTQUFTNUMsV0FBVyxHQUFHMkMsYUFBYTNDLFdBQVc7UUFDL0M0QyxTQUFTNVYsU0FBUyxHQUFHMlYsYUFBYTNWLFNBQVM7UUFDM0M0VixTQUFTM0MsT0FBTyxHQUFHMEMsYUFBYTFDLE9BQU87UUFDdkMyQyxTQUFTcDNCLFFBQVEsR0FBR20zQixhQUFhbjNCLFFBQVE7UUFDekNvM0IsU0FBU24zQixVQUFVLEdBQUdrM0IsYUFBYWwzQixVQUFVO0lBQy9DO0lBRUF5MUIsY0FBY3ppRSxTQUFTLENBQUNva0UsVUFBVSxHQUFHLFNBQVVqbEUsS0FBSztRQUNsRCxJQUFJLENBQUN1akUsS0FBSyxDQUFDLElBQUksQ0FBQ0MsT0FBTyxDQUFDLENBQUMva0IsT0FBTyxHQUFHeitDO0lBQ3JDO0lBRUFzakUsY0FBY3ppRSxTQUFTLENBQUMraEUsVUFBVSxHQUFHLFNBQVU1aUUsS0FBSztRQUNsRCxJQUFJLENBQUMwakUsYUFBYSxHQUFHMWpFO0lBQ3ZCO0lBRUFzakUsY0FBY3ppRSxTQUFTLENBQUN3UyxTQUFTLEdBQUcsU0FBVXJULEtBQUs7UUFDakQsSUFBSSxJQUFJLENBQUN1akUsS0FBSyxDQUFDLElBQUksQ0FBQ0MsT0FBTyxDQUFDLENBQUNud0QsU0FBUyxLQUFLclQsT0FBTztZQUNoRCxJQUFJLENBQUM2akUsZ0JBQWdCLEdBQUc3akU7WUFDeEIsSUFBSSxDQUFDdWpFLEtBQUssQ0FBQyxJQUFJLENBQUNDLE9BQU8sQ0FBQyxDQUFDbndELFNBQVMsR0FBR3JUO1FBQ3ZDO0lBQ0Y7SUFFQXNqRSxjQUFjemlFLFNBQVMsQ0FBQ3VoRSxXQUFXLEdBQUcsU0FBVXBpRSxLQUFLO1FBQ25ELElBQUksSUFBSSxDQUFDdWpFLEtBQUssQ0FBQyxJQUFJLENBQUNDLE9BQU8sQ0FBQyxDQUFDcEIsV0FBVyxLQUFLcGlFLE9BQU87WUFDbEQsSUFBSSxDQUFDK2pFLGtCQUFrQixHQUFHL2pFO1lBQzFCLElBQUksQ0FBQ3VqRSxLQUFLLENBQUMsSUFBSSxDQUFDQyxPQUFPLENBQUMsQ0FBQ3BCLFdBQVcsR0FBR3BpRTtRQUN6QztJQUNGO0lBRUFzakUsY0FBY3ppRSxTQUFTLENBQUN1dUQsU0FBUyxHQUFHLFNBQVVwdkQsS0FBSztRQUNqRCxJQUFJLElBQUksQ0FBQ3VqRSxLQUFLLENBQUMsSUFBSSxDQUFDQyxPQUFPLENBQUMsQ0FBQ3BVLFNBQVMsS0FBS3B2RCxPQUFPO1lBQ2hELElBQUksQ0FBQ2lrRSxnQkFBZ0IsR0FBR2prRTtZQUN4QixJQUFJLENBQUN1akUsS0FBSyxDQUFDLElBQUksQ0FBQ0MsT0FBTyxDQUFDLENBQUNwVSxTQUFTLEdBQUdwdkQ7UUFDdkM7SUFDRjtJQUVBc2pFLGNBQWN6aUUsU0FBUyxDQUFDd2hFLE9BQU8sR0FBRyxTQUFVcmlFLEtBQUs7UUFDL0MsSUFBSSxJQUFJLENBQUN1akUsS0FBSyxDQUFDLElBQUksQ0FBQ0MsT0FBTyxDQUFDLENBQUNuQixPQUFPLEtBQUtyaUUsT0FBTztZQUM5QyxJQUFJLENBQUNta0UsY0FBYyxHQUFHbmtFO1lBQ3RCLElBQUksQ0FBQ3VqRSxLQUFLLENBQUMsSUFBSSxDQUFDQyxPQUFPLENBQUMsQ0FBQ25CLE9BQU8sR0FBR3JpRTtRQUNyQztJQUNGO0lBRUFzakUsY0FBY3ppRSxTQUFTLENBQUMrc0MsUUFBUSxHQUFHLFNBQVU1dEMsS0FBSztRQUNoRCxJQUFJLElBQUksQ0FBQ3VqRSxLQUFLLENBQUMsSUFBSSxDQUFDQyxPQUFPLENBQUMsQ0FBQzUxQixRQUFRLEtBQUs1dEMsT0FBTztZQUMvQyxJQUFJLENBQUNxa0UsZUFBZSxHQUFHcmtFO1lBQ3ZCLElBQUksQ0FBQ3VqRSxLQUFLLENBQUMsSUFBSSxDQUFDQyxPQUFPLENBQUMsQ0FBQzUxQixRQUFRLEdBQUc1dEM7UUFDdEM7SUFDRjtJQUVBc2pFLGNBQWN6aUUsU0FBUyxDQUFDZ3RDLFVBQVUsR0FBRyxTQUFVN3RDLEtBQUs7UUFDbEQsSUFBSSxJQUFJLENBQUN1akUsS0FBSyxDQUFDLElBQUksQ0FBQ0MsT0FBTyxDQUFDLENBQUMzMUIsVUFBVSxLQUFLN3RDLE9BQU87WUFDakQsSUFBSSxDQUFDd2tFLGlCQUFpQixHQUFHeGtFO1lBQ3pCLElBQUksQ0FBQ3VqRSxLQUFLLENBQUMsSUFBSSxDQUFDQyxPQUFPLENBQUMsQ0FBQzMxQixVQUFVLEdBQUc3dEM7UUFDeEM7SUFDRjtJQUVBc2pFLGNBQWN6aUUsU0FBUyxDQUFDNjVCLFNBQVMsR0FBRyxTQUFVcEIsS0FBSztRQUNqRCxJQUFJLENBQUNxcUMsWUFBWSxDQUFDM21DLGNBQWMsQ0FBQzFELFFBQVEsc0VBQXNFO1FBRS9HLElBQUl5eUIsbUJBQW1CLElBQUksQ0FBQzBYLEdBQUcsRUFBRSxvR0FBb0c7UUFFckksSUFBSSxDQUFDRSxZQUFZLENBQUNsbkMsUUFBUSxDQUFDc3ZCLG1CQUFtQiw0REFBNEQ7UUFFMUdBLGlCQUFpQi91QixjQUFjLENBQUMsSUFBSSxDQUFDMm1DLFlBQVksQ0FBQ3JxQyxLQUFLO1FBQ3ZELElBQUk0ckMsVUFBVW5aLGlCQUFpQnp5QixLQUFLLEVBQUUsMkNBQTJDO1FBRWpGLElBQUksQ0FBQ29xQyxhQUFhLENBQUN0cEMsWUFBWSxDQUFDOHFDLE9BQU8sQ0FBQyxFQUFFLEVBQUVBLE9BQU8sQ0FBQyxFQUFFLEVBQUVBLE9BQU8sQ0FBQyxFQUFFLEVBQUVBLE9BQU8sQ0FBQyxFQUFFLEVBQUVBLE9BQU8sQ0FBQyxHQUFHLEVBQUVBLE9BQU8sQ0FBQyxHQUFHO0lBQzFHO0lBRUE1QixjQUFjemlFLFNBQVMsQ0FBQzQ5QyxPQUFPLEdBQUcsU0FBVW52QyxFQUFFO1FBQzVDLElBQUlzMEQsaUJBQWlCLElBQUksQ0FBQ0wsS0FBSyxDQUFDLElBQUksQ0FBQ0MsT0FBTyxDQUFDLENBQUMva0IsT0FBTztRQUNyRG1sQixrQkFBa0J0MEQsS0FBSyxJQUFJLElBQUlBO1FBRS9CLElBQUksSUFBSSxDQUFDaTBELEtBQUssQ0FBQyxJQUFJLENBQUNDLE9BQU8sQ0FBQyxDQUFDL2tCLE9BQU8sS0FBS21sQixnQkFBZ0I7WUFDdkQsSUFBSSxJQUFJLENBQUNBLGNBQWMsS0FBS3QwRCxJQUFJO2dCQUM5QixJQUFJLENBQUNvMEQsYUFBYSxDQUFDdkIsV0FBVyxHQUFHN3lEO2dCQUNqQyxJQUFJLENBQUNzMEQsY0FBYyxHQUFHdDBEO1lBQ3hCO1lBRUEsSUFBSSxDQUFDaTBELEtBQUssQ0FBQyxJQUFJLENBQUNDLE9BQU8sQ0FBQyxDQUFDL2tCLE9BQU8sR0FBR21sQjtRQUNyQztJQUNGO0lBRUFOLGNBQWN6aUUsU0FBUyxDQUFDKy9ELElBQUksR0FBRyxTQUFVMEIsSUFBSTtRQUMzQyxJQUFJLElBQUksQ0FBQ3dCLGdCQUFnQixLQUFLLElBQUksQ0FBQ0QsZ0JBQWdCLEVBQUU7WUFDbkQsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUNELGdCQUFnQjtZQUM3QyxJQUFJLENBQUNILGFBQWEsQ0FBQ3J3RCxTQUFTLEdBQUcsSUFBSSxDQUFDeXdELGdCQUFnQjtRQUN0RDtRQUVBLElBQUksQ0FBQ0osYUFBYSxDQUFDOUMsSUFBSSxDQUFDMEI7SUFDMUI7SUFFQWdCLGNBQWN6aUUsU0FBUyxDQUFDeVMsUUFBUSxHQUFHLFNBQVUrUixDQUFDLEVBQUVzSSxDQUFDLEVBQUVxRCxDQUFDLEVBQUVwb0IsQ0FBQztRQUNyRCxJQUFJLElBQUksQ0FBQ2s3RCxnQkFBZ0IsS0FBSyxJQUFJLENBQUNELGdCQUFnQixFQUFFO1lBQ25ELElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDRCxnQkFBZ0I7WUFDN0MsSUFBSSxDQUFDSCxhQUFhLENBQUNyd0QsU0FBUyxHQUFHLElBQUksQ0FBQ3l3RCxnQkFBZ0I7UUFDdEQ7UUFFQSxJQUFJLENBQUNKLGFBQWEsQ0FBQ3B3RCxRQUFRLENBQUMrUixHQUFHc0ksR0FBR3FELEdBQUdwb0I7SUFDdkM7SUFFQTA2RCxjQUFjemlFLFNBQVMsQ0FBQzgvRCxNQUFNLEdBQUc7UUFDL0IsSUFBSSxJQUFJLENBQUNxRCxrQkFBa0IsS0FBSyxJQUFJLENBQUNELGtCQUFrQixFQUFFO1lBQ3ZELElBQUksQ0FBQ0Msa0JBQWtCLEdBQUcsSUFBSSxDQUFDRCxrQkFBa0I7WUFDakQsSUFBSSxDQUFDTCxhQUFhLENBQUN0QixXQUFXLEdBQUcsSUFBSSxDQUFDNEIsa0JBQWtCO1FBQzFEO1FBRUEsSUFBSSxJQUFJLENBQUNFLGdCQUFnQixLQUFLLElBQUksQ0FBQ0QsZ0JBQWdCLEVBQUU7WUFDbkQsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUNELGdCQUFnQjtZQUM3QyxJQUFJLENBQUNQLGFBQWEsQ0FBQ3RVLFNBQVMsR0FBRyxJQUFJLENBQUM4VSxnQkFBZ0I7UUFDdEQ7UUFFQSxJQUFJLElBQUksQ0FBQ0UsY0FBYyxLQUFLLElBQUksQ0FBQ0QsY0FBYyxFQUFFO1lBQy9DLElBQUksQ0FBQ0MsY0FBYyxHQUFHLElBQUksQ0FBQ0QsY0FBYztZQUN6QyxJQUFJLENBQUNULGFBQWEsQ0FBQ3JCLE9BQU8sR0FBRyxJQUFJLENBQUMrQixjQUFjO1FBQ2xEO1FBRUEsSUFBSSxJQUFJLENBQUNFLGVBQWUsS0FBSyxJQUFJLENBQUNELGVBQWUsRUFBRTtZQUNqRCxJQUFJLENBQUNDLGVBQWUsR0FBRyxJQUFJLENBQUNELGVBQWU7WUFDM0MsSUFBSSxDQUFDWCxhQUFhLENBQUM5MUIsUUFBUSxHQUFHLElBQUksQ0FBQzAyQixlQUFlO1FBQ3BEO1FBRUEsSUFBSSxJQUFJLENBQUNDLGlCQUFpQixLQUFLLElBQUksQ0FBQ0MsaUJBQWlCLEVBQUU7WUFDckQsSUFBSSxDQUFDRCxpQkFBaUIsR0FBRyxJQUFJLENBQUNDLGlCQUFpQjtZQUMvQyxJQUFJLENBQUNkLGFBQWEsQ0FBQzcxQixVQUFVLEdBQUcsSUFBSSxDQUFDMDJCLGlCQUFpQjtRQUN4RDtRQUVBLElBQUksQ0FBQ2IsYUFBYSxDQUFDL0MsTUFBTTtJQUMzQjtJQUVBLFNBQVN3RSxjQUFjMzVELElBQUksRUFBRTBQLFVBQVUsRUFBRW5OLElBQUk7UUFDM0MsSUFBSSxDQUFDekIsY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsTUFBTSxHQUFHZixLQUFLZSxNQUFNO1FBQ3pCLElBQUksQ0FBQzJ3QyxlQUFlLEdBQUcsRUFBRTtRQUN6QixJQUFJLENBQUN0WCxRQUFRLEdBQUcvaEMsaUJBQWlCLElBQUksQ0FBQzBJLE1BQU0sQ0FBQzVMLE1BQU07UUFDbkQsSUFBSSxDQUFDeWpELFdBQVcsQ0FBQzU0QyxNQUFNMFAsWUFBWW5OO1FBQ25DLElBQUksQ0FBQzRKLEVBQUUsR0FBR25NLEtBQUttTSxFQUFFLEdBQUdpYixnQkFBZ0JDLE9BQU8sQ0FBQyxJQUFJLEVBQUVybkIsS0FBS21NLEVBQUUsRUFBRSxHQUFHdUQsV0FBVzlCLFNBQVMsRUFBRSxJQUFJLElBQUk7WUFDMUZpaUMsY0FBYztRQUNoQjtJQUNGO0lBRUEvNkMsZ0JBQWdCO1FBQUM0aEU7UUFBb0I5STtRQUFjZ0Q7S0FBYyxFQUFFK0k7SUFFbkVBLGNBQWN0a0UsU0FBUyxDQUFDeWpELGtCQUFrQixHQUFHO1FBQzNDLElBQUlueEMsTUFBTSxJQUFJLENBQUMwb0QsYUFBYTtRQUM1QjFvRCxJQUFJMm9ELFNBQVM7UUFDYjNvRCxJQUFJNG9ELE1BQU0sQ0FBQyxHQUFHO1FBQ2Q1b0QsSUFBSTZvRCxNQUFNLENBQUMsSUFBSSxDQUFDeHdELElBQUksQ0FBQ3dsQixDQUFDLEVBQUU7UUFDeEI3ZCxJQUFJNm9ELE1BQU0sQ0FBQyxJQUFJLENBQUN4d0QsSUFBSSxDQUFDd2xCLENBQUMsRUFBRSxJQUFJLENBQUN4bEIsSUFBSSxDQUFDNUMsQ0FBQztRQUNuQ3VLLElBQUk2b0QsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDeHdELElBQUksQ0FBQzVDLENBQUM7UUFDekJ1SyxJQUFJNm9ELE1BQU0sQ0FBQyxHQUFHO1FBQ2Q3b0QsSUFBSWdwRCxJQUFJO1FBQ1IsSUFBSTE3RDtRQUNKLElBQUlDLE1BQU0sSUFBSSxDQUFDNkwsTUFBTSxDQUFDNUwsTUFBTTtRQUU1QixJQUFLRixJQUFJQyxNQUFNLEdBQUdELEtBQUssR0FBR0EsS0FBSyxFQUFHO1lBQ2hDLElBQUksSUFBSSxDQUFDNkwsY0FBYyxJQUFJLElBQUksQ0FBQ3M1QixRQUFRLENBQUNubEMsRUFBRSxFQUFFO2dCQUMzQyxJQUFJLENBQUNtbEMsUUFBUSxDQUFDbmxDLEVBQUUsQ0FBQ3dkLFdBQVc7WUFDOUI7UUFDRjtJQUNGO0lBRUFrbkQsY0FBY3RrRSxTQUFTLENBQUNtVixPQUFPLEdBQUc7UUFDaEMsSUFBSXZWO1FBQ0osSUFBSUMsTUFBTSxJQUFJLENBQUM2TCxNQUFNLENBQUM1TCxNQUFNO1FBRTVCLElBQUtGLElBQUlDLE1BQU0sR0FBR0QsS0FBSyxHQUFHQSxLQUFLLEVBQUc7WUFDaEMsSUFBSSxJQUFJLENBQUNtbEMsUUFBUSxDQUFDbmxDLEVBQUUsRUFBRTtnQkFDcEIsSUFBSSxDQUFDbWxDLFFBQVEsQ0FBQ25sQyxFQUFFLENBQUN1VixPQUFPO1lBQzFCO1FBQ0Y7UUFFQSxJQUFJLENBQUN6SixNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNxNUIsUUFBUSxHQUFHO0lBQ2xCO0lBRUF1L0IsY0FBY3RrRSxTQUFTLENBQUNxN0MsVUFBVSxHQUFHLFNBQVUxd0MsSUFBSTtRQUNqRCxPQUFPLElBQUkyNUQsY0FBYzM1RCxNQUFNLElBQUksQ0FBQzBQLFVBQVUsRUFBRSxJQUFJO0lBQ3REO0lBRUEsU0FBU2txRCxlQUFlN25CLGFBQWEsRUFBRW1jLE1BQU07UUFDM0MsSUFBSSxDQUFDbmMsYUFBYSxHQUFHQTtRQUNyQixJQUFJLENBQUNwRyxZQUFZLEdBQUc7WUFDbEI2bEIsYUFBYXRELFVBQVVBLE9BQU9zRCxXQUFXLEtBQUszaEQsWUFBWXErQyxPQUFPc0QsV0FBVyxHQUFHO1lBQy9FMkYsU0FBU2pKLFVBQVVBLE9BQU9pSixPQUFPLElBQUk7WUFDckNobUIsaUJBQWlCK2MsVUFBVUEsT0FBTy9jLGVBQWUsSUFBSTtZQUNyRGdjLHFCQUFxQmUsVUFBVUEsT0FBT2YsbUJBQW1CLElBQUk7WUFDN0RoVSwwQkFBMEIrVSxVQUFVQSxPQUFPL1Usd0JBQXdCLElBQUk7WUFDdkU2VCxtQkFBbUJrQixVQUFVQSxPQUFPbEIsaUJBQWlCLElBQUk7WUFDekRDLFdBQVdpQixVQUFVQSxPQUFPakIsU0FBUyxJQUFJO1lBQ3pDM3FELElBQUk0ckQsVUFBVUEsT0FBTzVyRCxFQUFFLElBQUk7WUFDM0Jxc0QsZ0JBQWdCLENBQUNULFVBQVVBLE9BQU9TLGNBQWMsS0FBSzkrQyxhQUFhcStDLE9BQU9TLGNBQWM7UUFDekY7UUFDQSxJQUFJLENBQUNoakIsWUFBWSxDQUFDOHJCLEdBQUcsR0FBR3ZKLFVBQVVBLE9BQU91SixHQUFHLElBQUk7UUFFaEQsSUFBSSxJQUFJLENBQUMxbEIsYUFBYSxDQUFDMWlDLE9BQU8sRUFBRTtZQUM5QixJQUFJLENBQUNzOEIsWUFBWSxDQUFDOHJCLEdBQUcsR0FBR3ZKLFVBQVVBLE9BQU91SixHQUFHLElBQUkxZ0UsT0FBTzhpRSxnQkFBZ0IsSUFBSTtRQUM3RTtRQUVBLElBQUksQ0FBQ2wwQyxhQUFhLEdBQUcsQ0FBQztRQUN0QixJQUFJLENBQUNqVyxVQUFVLEdBQUc7WUFDaEJvUixVQUFVLENBQUM7WUFDWG9GLE1BQU07WUFDTnlsQixjQUFjLElBQUksQ0FBQ0EsWUFBWTtZQUMvQmtvQixvQkFBb0IsQ0FBQztRQUN2QjtRQUNBLElBQUksQ0FBQ2tELFdBQVcsR0FBRyxJQUFJZTtRQUN2QixJQUFJLENBQUMxOUIsUUFBUSxHQUFHLEVBQUU7UUFDbEIsSUFBSSxDQUFDc1gsZUFBZSxHQUFHLEVBQUU7UUFDekIsSUFBSSxDQUFDeW1CLFlBQVksR0FBRyxJQUFJM3FDO1FBQ3hCLElBQUksQ0FBQzFzQixjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDbVIsWUFBWSxHQUFHO1FBRXBCLElBQUksSUFBSSxDQUFDMDVCLFlBQVksQ0FBQzZsQixXQUFXLEVBQUU7WUFDakMsSUFBSSxDQUFDUyxZQUFZLEdBQUcsSUFBSSxDQUFDOEUsV0FBVyxDQUFDN25DLFNBQVMsQ0FBQzlsQixJQUFJLENBQUMsSUFBSSxDQUFDMnRELFdBQVc7WUFDcEUsSUFBSSxDQUFDN0UsVUFBVSxHQUFHLElBQUksQ0FBQzZFLFdBQVcsQ0FBQzlqQixPQUFPLENBQUM3cEMsSUFBSSxDQUFDLElBQUksQ0FBQzJ0RCxXQUFXO1lBQ2hFLElBQUksQ0FBQzNDLFlBQVksR0FBRyxJQUFJLENBQUMyQyxXQUFXLENBQUNsdkQsU0FBUyxDQUFDdUIsSUFBSSxDQUFDLElBQUksQ0FBQzJ0RCxXQUFXO1lBQ3BFLElBQUksQ0FBQ2pELGNBQWMsR0FBRyxJQUFJLENBQUNpRCxXQUFXLENBQUNILFdBQVcsQ0FBQ3h0RCxJQUFJLENBQUMsSUFBSSxDQUFDMnRELFdBQVc7WUFDeEUsSUFBSSxDQUFDL0MsWUFBWSxHQUFHLElBQUksQ0FBQytDLFdBQVcsQ0FBQ25ULFNBQVMsQ0FBQ3g2QyxJQUFJLENBQUMsSUFBSSxDQUFDMnRELFdBQVc7WUFDcEUsSUFBSSxDQUFDOUMsVUFBVSxHQUFHLElBQUksQ0FBQzhDLFdBQVcsQ0FBQ0YsT0FBTyxDQUFDenRELElBQUksQ0FBQyxJQUFJLENBQUMydEQsV0FBVztZQUNoRSxJQUFJLENBQUM3QyxXQUFXLEdBQUcsSUFBSSxDQUFDNkMsV0FBVyxDQUFDMzBCLFFBQVEsQ0FBQ2g1QixJQUFJLENBQUMsSUFBSSxDQUFDMnRELFdBQVc7WUFDbEUsSUFBSSxDQUFDNUMsYUFBYSxHQUFHLElBQUksQ0FBQzRDLFdBQVcsQ0FBQzEwQixVQUFVLENBQUNqNUIsSUFBSSxDQUFDLElBQUksQ0FBQzJ0RCxXQUFXO1lBQ3RFLElBQUksQ0FBQ3RDLE9BQU8sR0FBRyxJQUFJLENBQUNzQyxXQUFXLENBQUMzQixJQUFJLENBQUNoc0QsSUFBSSxDQUFDLElBQUksQ0FBQzJ0RCxXQUFXO1lBQzFELElBQUksQ0FBQ04sV0FBVyxHQUFHLElBQUksQ0FBQ00sV0FBVyxDQUFDanZELFFBQVEsQ0FBQ3NCLElBQUksQ0FBQyxJQUFJLENBQUMydEQsV0FBVztZQUNsRSxJQUFJLENBQUN2QyxTQUFTLEdBQUcsSUFBSSxDQUFDdUMsV0FBVyxDQUFDNUIsTUFBTSxDQUFDL3JELElBQUksQ0FBQyxJQUFJLENBQUMydEQsV0FBVztZQUM5RCxJQUFJLENBQUNyRyxJQUFJLEdBQUcsSUFBSSxDQUFDcUcsV0FBVyxDQUFDckcsSUFBSSxDQUFDdG5ELElBQUksQ0FBQyxJQUFJLENBQUMydEQsV0FBVztRQUN6RDtJQUNGO0lBRUFqaUUsZ0JBQWdCO1FBQUM0aEU7S0FBbUIsRUFBRWtEO0lBRXRDQSxlQUFldmtFLFNBQVMsQ0FBQ3E3QyxVQUFVLEdBQUcsU0FBVTF3QyxJQUFJO1FBQ2xELE9BQU8sSUFBSTI1RCxjQUFjMzVELE1BQU0sSUFBSSxDQUFDMFAsVUFBVSxFQUFFLElBQUk7SUFDdEQ7SUFFQSxTQUFTb3FELGdCQUFnQjtJQUV6QkEsYUFBYXprRSxTQUFTLEdBQUc7UUFDdkIwa0UsZ0JBQWdCLFNBQVNBLGtCQUFrQjtRQUMzQ3BqQixxQkFBcUIsU0FBU0E7WUFDNUIsSUFBSSxDQUFDbkksV0FBVyxHQUFHOTVDLFVBQVUsSUFBSSxDQUFDc0wsSUFBSSxDQUFDZzZELEVBQUUsSUFBSTtZQUU3QyxJQUFJLElBQUksQ0FBQ2g2RCxJQUFJLENBQUN1QixPQUFPLEVBQUU7Z0JBQ3JCLElBQUksQ0FBQ3NyRCxVQUFVLEdBQUd6dEQsU0FBUztnQkFDM0IsSUFBSSxDQUFDcXZDLFlBQVksR0FBR3J2QyxTQUFTO2dCQUM3QixJQUFJLENBQUMyMUMsYUFBYSxHQUFHLElBQUksQ0FBQ3RHLFlBQVk7Z0JBQ3RDLElBQUksQ0FBQ29lLFVBQVUsQ0FBQ2xqRCxXQUFXLENBQUMsSUFBSSxDQUFDOGtDLFlBQVk7Z0JBQzdDLElBQUksQ0FBQ0QsV0FBVyxDQUFDN2tDLFdBQVcsQ0FBQyxJQUFJLENBQUNrakQsVUFBVTtZQUM5QyxPQUFPO2dCQUNMLElBQUksQ0FBQ3BlLFlBQVksR0FBRyxJQUFJLENBQUNELFdBQVc7WUFDdEM7WUFFQXh6QyxTQUFTLElBQUksQ0FBQ3d6QyxXQUFXO1FBQzNCO1FBQ0FvSSx5QkFBeUIsU0FBU0E7WUFDaEMsSUFBSSxDQUFDekQsd0JBQXdCLEdBQUcsSUFBSThjLFVBQVUsSUFBSTtZQUNsRCxJQUFJLENBQUNuWixrQkFBa0IsR0FBRyxJQUFJLENBQUN0SSxXQUFXO1lBQzFDLElBQUksQ0FBQ3VHLGFBQWEsR0FBRyxJQUFJLENBQUN0RyxZQUFZO1lBRXRDLElBQUksSUFBSSxDQUFDenVDLElBQUksQ0FBQ3EzQyxFQUFFLEVBQUU7Z0JBQ2hCLElBQUksQ0FBQzVJLFlBQVksQ0FBQ3ozQixZQUFZLENBQUMsTUFBTSxJQUFJLENBQUNoWCxJQUFJLENBQUNxM0MsRUFBRTtZQUNuRDtZQUVBLElBQUksSUFBSSxDQUFDcjNDLElBQUksQ0FBQzRFLEVBQUUsRUFBRTtnQkFDaEIsSUFBSSxDQUFDNnBDLFlBQVksQ0FBQ3ozQixZQUFZLENBQUMsU0FBUyxJQUFJLENBQUNoWCxJQUFJLENBQUM0RSxFQUFFO1lBQ3REO1lBRUEsSUFBSSxJQUFJLENBQUM1RSxJQUFJLENBQUN1dUMsRUFBRSxLQUFLLEdBQUc7Z0JBQ3RCLElBQUksQ0FBQ0YsWUFBWTtZQUNuQjtRQUNGO1FBQ0FxSixlQUFlLFNBQVNBO1lBQ3RCLElBQUl1aUIsMEJBQTBCLElBQUksQ0FBQ25qQixrQkFBa0IsR0FBRyxJQUFJLENBQUNBLGtCQUFrQixDQUFDNTdDLEtBQUssR0FBRyxDQUFDO1lBRXpGLElBQUksSUFBSSxDQUFDdXdDLGNBQWMsQ0FBQzRHLE9BQU8sRUFBRTtnQkFDL0IsSUFBSTZuQixjQUFjLElBQUksQ0FBQ3p1QixjQUFjLENBQUMxVCxHQUFHLENBQUNwRixLQUFLO2dCQUMvQ3NuQyx3QkFBd0IvcUMsU0FBUyxHQUFHZ3JDO2dCQUNwQ0Qsd0JBQXdCRSxlQUFlLEdBQUdEO1lBQzVDO1lBRUEsSUFBSSxJQUFJLENBQUN6dUIsY0FBYyxDQUFDOEcsTUFBTSxFQUFFO2dCQUM5QjBuQix3QkFBd0JobkIsT0FBTyxHQUFHLElBQUksQ0FBQ3hILGNBQWMsQ0FBQ0MsS0FBSyxDQUFDNW9DLENBQUMsQ0FBQ3hGLENBQUM7WUFDakU7UUFDRjtRQUNBbVYsYUFBYSxTQUFTQTtZQUNwQixtRUFBbUU7WUFDbkUseUNBQXlDO1lBQ3pDLElBQUksSUFBSSxDQUFDelMsSUFBSSxDQUFDczNDLEVBQUUsSUFBSSxJQUFJLENBQUN2TSxNQUFNLEVBQUU7Z0JBQy9CO1lBQ0Y7WUFFQSxJQUFJLENBQUM0SCxlQUFlO1lBQ3BCLElBQUksQ0FBQzlHLGdCQUFnQjtZQUNyQixJQUFJLENBQUM2TCxhQUFhO1lBQ2xCLElBQUksQ0FBQ29CLGtCQUFrQjtZQUV2QixJQUFJLElBQUksQ0FBQ3Z5QixhQUFhLEVBQUU7Z0JBQ3RCLElBQUksQ0FBQ0EsYUFBYSxHQUFHO1lBQ3ZCO1FBQ0Y7UUFDQS9iLFNBQVMsU0FBU0E7WUFDaEIsSUFBSSxDQUFDaWtDLFlBQVksR0FBRztZQUNwQixJQUFJLENBQUNxSSxrQkFBa0IsR0FBRztZQUUxQixJQUFJLElBQUksQ0FBQ0QsWUFBWSxFQUFFO2dCQUNyQixJQUFJLENBQUNBLFlBQVksR0FBRztZQUN0QjtZQUVBLElBQUksSUFBSSxDQUFDbEosV0FBVyxFQUFFO2dCQUNwQixJQUFJLENBQUNBLFdBQVcsQ0FBQ25qQyxPQUFPO2dCQUN4QixJQUFJLENBQUNtakMsV0FBVyxHQUFHO1lBQ3JCO1FBQ0Y7UUFDQWlLLDRCQUE0QixTQUFTQTtZQUNuQyxJQUFJLENBQUNqSyxXQUFXLEdBQUcsSUFBSStGLFlBQVksSUFBSSxDQUFDMXpDLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDMFAsVUFBVTtRQUNyRTtRQUNBMHFELFlBQVksU0FBU0EsY0FBYztRQUNuQzloQixVQUFVLFNBQVNBLFlBQVk7SUFDakM7SUFDQXdoQixhQUFhemtFLFNBQVMsQ0FBQys1QyxjQUFjLEdBQUdzSCxlQUFlcmhELFNBQVMsQ0FBQys1QyxjQUFjO0lBQy9FMHFCLGFBQWF6a0UsU0FBUyxDQUFDc2lELGtCQUFrQixHQUFHbWlCLGFBQWF6a0UsU0FBUyxDQUFDbVYsT0FBTztJQUMxRXN2RCxhQUFhemtFLFNBQVMsQ0FBQys3QyxxQkFBcUIsR0FBR2pCLGFBQWE5NkMsU0FBUyxDQUFDKzdDLHFCQUFxQjtJQUUzRixTQUFTaXBCLGNBQWNyNkQsSUFBSSxFQUFFMFAsVUFBVSxFQUFFbk4sSUFBSTtRQUMzQyxJQUFJLENBQUNxMkMsV0FBVyxDQUFDNTRDLE1BQU0wUCxZQUFZbk47SUFDckM7SUFFQXpOLGdCQUFnQjtRQUFDcTRDO1FBQWFnRjtRQUFrQjJuQjtRQUFjdmhCO1FBQWtCeko7UUFBYzRKO0tBQXFCLEVBQUUyaEI7SUFFckhBLGNBQWNobEUsU0FBUyxDQUFDd2pELGFBQWEsR0FBRztRQUN0QyxJQUFJN0U7UUFFSixJQUFJLElBQUksQ0FBQ2gwQyxJQUFJLENBQUN1QixPQUFPLEVBQUU7WUFDckJ5eUMsT0FBTzUwQyxTQUFTO1lBQ2hCNDBDLEtBQUtoOUIsWUFBWSxDQUFDLFNBQVMsSUFBSSxDQUFDaFgsSUFBSSxDQUFDNmdELEVBQUU7WUFDdkM3TSxLQUFLaDlCLFlBQVksQ0FBQyxVQUFVLElBQUksQ0FBQ2hYLElBQUksQ0FBQ2dqQixFQUFFO1lBQ3hDZ3hCLEtBQUtoOUIsWUFBWSxDQUFDLFFBQVEsSUFBSSxDQUFDaFgsSUFBSSxDQUFDcW9DLEVBQUU7WUFDdEMsSUFBSSxDQUFDd2tCLFVBQVUsQ0FBQzcxQyxZQUFZLENBQUMsU0FBUyxJQUFJLENBQUNoWCxJQUFJLENBQUM2Z0QsRUFBRTtZQUNsRCxJQUFJLENBQUNnTSxVQUFVLENBQUM3MUMsWUFBWSxDQUFDLFVBQVUsSUFBSSxDQUFDaFgsSUFBSSxDQUFDZ2pCLEVBQUU7UUFDckQsT0FBTztZQUNMZ3hCLE9BQU90L0MsVUFBVTtZQUNqQnMvQyxLQUFLOTRDLEtBQUssQ0FBQ3VNLEtBQUssR0FBRyxJQUFJLENBQUN6SCxJQUFJLENBQUM2Z0QsRUFBRSxHQUFHO1lBQ2xDN00sS0FBSzk0QyxLQUFLLENBQUN3TSxNQUFNLEdBQUcsSUFBSSxDQUFDMUgsSUFBSSxDQUFDZ2pCLEVBQUUsR0FBRztZQUNuQ2d4QixLQUFLOTRDLEtBQUssQ0FBQ28vRCxlQUFlLEdBQUcsSUFBSSxDQUFDdDZELElBQUksQ0FBQ3FvQyxFQUFFO1FBQzNDO1FBRUEsSUFBSSxDQUFDb0csWUFBWSxDQUFDOWtDLFdBQVcsQ0FBQ3FxQztJQUNoQztJQUVBLFNBQVN1bUIsY0FBY3Y2RCxJQUFJLEVBQUUwUCxVQUFVLEVBQUVuTixJQUFJO1FBQzNDLDRCQUE0QjtRQUM1QixJQUFJLENBQUNQLE1BQU0sR0FBRyxFQUFFLEVBQUUsa0JBQWtCO1FBRXBDLElBQUksQ0FBQ2lzQyxVQUFVLEdBQUdqdUMsS0FBS2dDLE1BQU0sRUFBRSxnREFBZ0Q7UUFFL0UsSUFBSSxDQUFDKzhDLFVBQVUsR0FBRyxFQUFFLEVBQUUsbURBQW1EO1FBRXpFLElBQUksQ0FBQ3hGLGNBQWMsR0FBRyxFQUFFLEVBQUUsOEJBQThCO1FBRXhELElBQUksQ0FBQ3JMLFNBQVMsR0FBRyxFQUFFLEVBQUUsdUNBQXVDO1FBRTVELElBQUksQ0FBQzJMLGlCQUFpQixHQUFHLEVBQUUsRUFBRSw4QkFBOEI7UUFFM0QsSUFBSSxDQUFDbUYsZ0JBQWdCLEdBQUcsRUFBRTtRQUMxQixJQUFJLENBQUN3YixlQUFlLEdBQUdwN0QsU0FBUztRQUNoQyxJQUFJLENBQUN3NUMsV0FBVyxDQUFDNTRDLE1BQU0wUCxZQUFZbk4sT0FBTyxtSUFBbUk7UUFDN0ssMENBQTBDO1FBRTFDLElBQUksQ0FBQ3c2QyxZQUFZLEdBQUcsRUFBRTtRQUN0QixJQUFJLENBQUMwZCxXQUFXLEdBQUc7WUFDakI1Z0QsR0FBRztZQUNIc0ksR0FBRyxDQUFDO1lBQ0ova0IsR0FBRztZQUNIb29CLEdBQUc7UUFDTDtJQUNGO0lBRUExd0IsZ0JBQWdCO1FBQUNxNEM7UUFBYWdGO1FBQWtCa29CO1FBQWV2YjtRQUFpQmdiO1FBQWN2aEI7UUFBa0J6SjtRQUFjbEU7S0FBa0IsRUFBRTJ2QjtJQUNsSkEsY0FBY2xsRSxTQUFTLENBQUNxbEUsaUJBQWlCLEdBQUdILGNBQWNsbEUsU0FBUyxDQUFDeWpELGtCQUFrQjtJQUV0RnloQixjQUFjbGxFLFNBQVMsQ0FBQ3dqRCxhQUFhLEdBQUc7UUFDdEMsSUFBSWhlO1FBQ0osSUFBSSxDQUFDMlQsV0FBVyxDQUFDdHpDLEtBQUssQ0FBQ3dxQyxRQUFRLEdBQUc7UUFFbEMsSUFBSSxJQUFJLENBQUMxbEMsSUFBSSxDQUFDdUIsT0FBTyxFQUFFO1lBQ3JCLElBQUksQ0FBQ2t0QyxZQUFZLENBQUM5a0MsV0FBVyxDQUFDLElBQUksQ0FBQzZ3RCxlQUFlO1lBQ2xEMy9CLE9BQU8sSUFBSSxDQUFDZ3lCLFVBQVU7UUFDeEIsT0FBTztZQUNMaHlCLE9BQU96N0IsU0FBUztZQUNoQixJQUFJa2xDLE9BQU8sSUFBSSxDQUFDL2hDLElBQUksQ0FBQ3ZDLElBQUksR0FBRyxJQUFJLENBQUN1QyxJQUFJLENBQUN2QyxJQUFJLEdBQUcsSUFBSSxDQUFDMFAsVUFBVSxDQUFDc2lDLFFBQVE7WUFDckVuWCxLQUFLN2pCLFlBQVksQ0FBQyxTQUFTc3RCLEtBQUs5ZSxDQUFDO1lBQ2pDcVYsS0FBSzdqQixZQUFZLENBQUMsVUFBVXN0QixLQUFLbG5DLENBQUM7WUFDbEN5OUIsS0FBS2x4QixXQUFXLENBQUMsSUFBSSxDQUFDNndELGVBQWU7WUFDckMsSUFBSSxDQUFDL3JCLFlBQVksQ0FBQzlrQyxXQUFXLENBQUNreEI7UUFDaEM7UUFFQSxJQUFJLENBQUN1a0IsWUFBWSxDQUFDLElBQUksQ0FBQ25SLFVBQVUsRUFBRSxJQUFJLENBQUNDLFNBQVMsRUFBRSxJQUFJLENBQUM2TyxZQUFZLEVBQUUsSUFBSSxDQUFDeWQsZUFBZSxFQUFFLEdBQUcsRUFBRSxFQUFFO1FBQ25HLElBQUksQ0FBQ25iLGtCQUFrQjtRQUN2QixJQUFJLENBQUNzYixTQUFTLEdBQUc5L0I7SUFDbkI7SUFFQTAvQixjQUFjbGxFLFNBQVMsQ0FBQ3VsRSxtQkFBbUIsR0FBRyxTQUFVMWdCLFlBQVksRUFBRTM4QixLQUFLO1FBQ3pFLElBQUl0b0I7UUFDSixJQUFJQyxNQUFNZ2xELGFBQWEva0QsTUFBTTtRQUU3QixJQUFLRixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQnNvQixRQUFRMjhCLFlBQVksQ0FBQ2psRCxFQUFFLENBQUMybUMsTUFBTSxDQUFDdCtCLENBQUMsQ0FBQzIwQixpQkFBaUIsQ0FBQzFVLEtBQUssQ0FBQyxFQUFFLEVBQUVBLEtBQUssQ0FBQyxFQUFFLEVBQUU7UUFDekU7UUFFQSxPQUFPQTtJQUNUO0lBRUFnOUMsY0FBY2xsRSxTQUFTLENBQUN3bEUseUJBQXlCLEdBQUcsU0FBVUMsSUFBSSxFQUFFMzhCLFdBQVc7UUFDN0UsSUFBSS9VLFFBQVEweEMsS0FBSzkzQyxFQUFFLENBQUMxbEIsQ0FBQztRQUNyQixJQUFJNDhDLGVBQWU0Z0IsS0FBSzVnQixZQUFZO1FBQ3BDLElBQUlqbEQ7UUFDSixJQUFJQyxNQUFNazBCLE1BQU1wTyxPQUFPO1FBQ3ZCLElBQUkrL0M7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFFSixJQUFJaG1FLE9BQU8sR0FBRztZQUNaO1FBQ0Y7UUFFQSxJQUFLRCxJQUFJLEdBQUdBLElBQUlDLE1BQU0sR0FBR0QsS0FBSyxFQUFHO1lBQy9COGxFLFNBQVMsSUFBSSxDQUFDSCxtQkFBbUIsQ0FBQzFnQixjQUFjOXdCLE1BQU05ckIsQ0FBQyxDQUFDckksRUFBRTtZQUMxRCtsRSxTQUFTLElBQUksQ0FBQ0osbUJBQW1CLENBQUMxZ0IsY0FBYzl3QixNQUFNdG1CLENBQUMsQ0FBQzdOLEVBQUU7WUFDMURnbUUsYUFBYSxJQUFJLENBQUNMLG1CQUFtQixDQUFDMWdCLGNBQWM5d0IsTUFBTW4wQixDQUFDLENBQUNBLElBQUksRUFBRTtZQUNsRWltRSxhQUFhLElBQUksQ0FBQ04sbUJBQW1CLENBQUMxZ0IsY0FBYzl3QixNQUFNOXJCLENBQUMsQ0FBQ3JJLElBQUksRUFBRTtZQUNsRSxJQUFJLENBQUNrbUUsV0FBVyxDQUFDSixRQUFRQyxRQUFRQyxZQUFZQyxZQUFZLzhCO1FBQzNEO1FBRUEsSUFBSS9VLE1BQU01a0IsQ0FBQyxFQUFFO1lBQ1h1MkQsU0FBUyxJQUFJLENBQUNILG1CQUFtQixDQUFDMWdCLGNBQWM5d0IsTUFBTTlyQixDQUFDLENBQUNySSxFQUFFO1lBQzFEK2xFLFNBQVMsSUFBSSxDQUFDSixtQkFBbUIsQ0FBQzFnQixjQUFjOXdCLE1BQU10bUIsQ0FBQyxDQUFDN04sRUFBRTtZQUMxRGdtRSxhQUFhLElBQUksQ0FBQ0wsbUJBQW1CLENBQUMxZ0IsY0FBYzl3QixNQUFNbjBCLENBQUMsQ0FBQyxFQUFFO1lBQzlEaW1FLGFBQWEsSUFBSSxDQUFDTixtQkFBbUIsQ0FBQzFnQixjQUFjOXdCLE1BQU05ckIsQ0FBQyxDQUFDLEVBQUU7WUFDOUQsSUFBSSxDQUFDNjlELFdBQVcsQ0FBQ0osUUFBUUMsUUFBUUMsWUFBWUMsWUFBWS84QjtRQUMzRDtJQUNGO0lBRUFvOEIsY0FBY2xsRSxTQUFTLENBQUM4bEUsV0FBVyxHQUFHLFNBQVVKLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLFVBQVUsRUFBRS84QixXQUFXO1FBQ2pHLElBQUksQ0FBQ2k5QixnQkFBZ0IsQ0FBQ0wsUUFBUUMsUUFBUUMsWUFBWUM7UUFDbEQsSUFBSWg5QixTQUFTLElBQUksQ0FBQ205QixnQkFBZ0I7UUFDbENsOUIsWUFBWXRrQixDQUFDLEdBQUc5ZixNQUFNbWtDLE9BQU83aUMsSUFBSSxFQUFFOGlDLFlBQVl0a0IsQ0FBQztRQUNoRHNrQixZQUFZbTlCLElBQUksR0FBR3poRSxNQUFNcWtDLE9BQU9FLEtBQUssRUFBRUQsWUFBWW05QixJQUFJO1FBQ3ZEbjlCLFlBQVloYyxDQUFDLEdBQUdwb0IsTUFBTW1rQyxPQUFPOWlDLEdBQUcsRUFBRStpQyxZQUFZaGMsQ0FBQztRQUMvQ2djLFlBQVlvOUIsSUFBSSxHQUFHMWhFLE1BQU1xa0MsT0FBT0csTUFBTSxFQUFFRixZQUFZbzlCLElBQUk7SUFDMUQ7SUFFQWhCLGNBQWNsbEUsU0FBUyxDQUFDZ21FLGdCQUFnQixHQUFHO1FBQ3pDaGdFLE1BQU07UUFDTitpQyxPQUFPO1FBQ1BoakMsS0FBSztRQUNMaWpDLFFBQVE7SUFDVjtJQUNBazhCLGNBQWNsbEUsU0FBUyxDQUFDbW1FLGVBQWUsR0FBRztRQUN4QzNoRCxHQUFHO1FBQ0h5aEQsTUFBTTtRQUNObjVDLEdBQUc7UUFDSG81QyxNQUFNO1FBQ045ekQsT0FBTztRQUNQQyxRQUFRO0lBQ1Y7SUFFQTZ5RCxjQUFjbGxFLFNBQVMsQ0FBQytsRSxnQkFBZ0IsR0FBRyxTQUFVbndDLEVBQUUsRUFBRUMsRUFBRSxFQUFFK0UsRUFBRSxFQUFFNE0sRUFBRTtRQUNqRSxJQUFJcUIsU0FBUztZQUFDO2dCQUFDalQsRUFBRSxDQUFDLEVBQUU7Z0JBQUU0UixFQUFFLENBQUMsRUFBRTthQUFDO1lBQUU7Z0JBQUM1UixFQUFFLENBQUMsRUFBRTtnQkFBRTRSLEVBQUUsQ0FBQyxFQUFFO2FBQUM7U0FBQztRQUU3QyxJQUFLLElBQUk1NEIsR0FBR3hHLEdBQUcrRyxHQUFHM0csR0FBRzQ5RCxNQUFNejhDLElBQUl5ZixJQUFJeHBDLElBQUksR0FBR0EsSUFBSSxHQUFHLEVBQUVBLEVBQUc7WUFDcEQsa0NBQWtDO1lBQ2xDd0ksSUFBSSxJQUFJd3RCLEVBQUUsQ0FBQ2gyQixFQUFFLEdBQUcsS0FBS2kyQixFQUFFLENBQUNqMkIsRUFBRSxHQUFHLElBQUlnN0IsRUFBRSxDQUFDaDdCLEVBQUU7WUFDdENnUCxJQUFJLENBQUMsSUFBSWduQixFQUFFLENBQUNoMkIsRUFBRSxHQUFHLElBQUlpMkIsRUFBRSxDQUFDajJCLEVBQUUsR0FBRyxJQUFJZzdCLEVBQUUsQ0FBQ2g3QixFQUFFLEdBQUcsSUFBSTRuQyxFQUFFLENBQUM1bkMsRUFBRTtZQUNsRHVQLElBQUksSUFBSTBtQixFQUFFLENBQUNqMkIsRUFBRSxHQUFHLElBQUlnMkIsRUFBRSxDQUFDaDJCLEVBQUU7WUFDekJ3SSxLQUFLLEdBQUcsaUNBQWlDO1lBRXpDd0csS0FBSyxHQUFHLGlDQUFpQztZQUV6Q08sS0FBSyxHQUFHLGlDQUFpQztZQUV6QyxJQUFJUCxNQUFNLEtBQUt4RyxNQUFNLEdBQUcsQ0FDeEIsT0FBTyxJQUFJd0csTUFBTSxHQUFHO2dCQUNsQnBHLElBQUksQ0FBQzJHLElBQUkvRztnQkFFVCxJQUFJSSxJQUFJLEtBQUtBLElBQUksR0FBRztvQkFDbEJxZ0MsTUFBTSxDQUFDanBDLEVBQUUsQ0FBQ3VCLElBQUksQ0FBQyxJQUFJLENBQUNrbEUsVUFBVSxDQUFDNzlELEdBQUdvdEIsSUFBSUMsSUFBSStFLElBQUk0TSxJQUFJNW5DO2dCQUNwRDtZQUNGLE9BQU87Z0JBQ0x3bUUsT0FBT2grRCxJQUFJQSxJQUFJLElBQUkrRyxJQUFJUDtnQkFFdkIsSUFBSXczRCxRQUFRLEdBQUc7b0JBQ2J6OEMsS0FBSyxDQUFDLENBQUN2aEIsSUFBSWhFLE9BQU9naUUsS0FBSSxJQUFNLEtBQUl4M0QsQ0FBQUE7b0JBQ2hDLElBQUkrYSxLQUFLLEtBQUtBLEtBQUssR0FBR2tmLE1BQU0sQ0FBQ2pwQyxFQUFFLENBQUN1QixJQUFJLENBQUMsSUFBSSxDQUFDa2xFLFVBQVUsQ0FBQzE4QyxJQUFJaU0sSUFBSUMsSUFBSStFLElBQUk0TSxJQUFJNW5DO29CQUN6RXdwQyxLQUFLLENBQUMsQ0FBQ2hoQyxJQUFJaEUsT0FBT2dpRSxLQUFJLElBQU0sS0FBSXgzRCxDQUFBQTtvQkFDaEMsSUFBSXc2QixLQUFLLEtBQUtBLEtBQUssR0FBR1AsTUFBTSxDQUFDanBDLEVBQUUsQ0FBQ3VCLElBQUksQ0FBQyxJQUFJLENBQUNrbEUsVUFBVSxDQUFDajlCLElBQUl4VCxJQUFJQyxJQUFJK0UsSUFBSTRNLElBQUk1bkM7Z0JBQzNFO1lBQ0Y7UUFDRjtRQUVBLElBQUksQ0FBQ29tRSxnQkFBZ0IsQ0FBQ2hnRSxJQUFJLEdBQUd0QixNQUFNeEIsS0FBSyxDQUFDLE1BQU0ybEMsTUFBTSxDQUFDLEVBQUU7UUFDeEQsSUFBSSxDQUFDbTlCLGdCQUFnQixDQUFDamdFLEdBQUcsR0FBR3JCLE1BQU14QixLQUFLLENBQUMsTUFBTTJsQyxNQUFNLENBQUMsRUFBRTtRQUN2RCxJQUFJLENBQUNtOUIsZ0JBQWdCLENBQUNqOUIsS0FBSyxHQUFHdmtDLE1BQU10QixLQUFLLENBQUMsTUFBTTJsQyxNQUFNLENBQUMsRUFBRTtRQUN6RCxJQUFJLENBQUNtOUIsZ0JBQWdCLENBQUNoOUIsTUFBTSxHQUFHeGtDLE1BQU10QixLQUFLLENBQUMsTUFBTTJsQyxNQUFNLENBQUMsRUFBRTtJQUM1RDtJQUVBcThCLGNBQWNsbEUsU0FBUyxDQUFDcW1FLFVBQVUsR0FBRyxTQUFVNzlELENBQUMsRUFBRW90QixFQUFFLEVBQUVDLEVBQUUsRUFBRStFLEVBQUUsRUFBRTRNLEVBQUUsRUFBRTVuQyxDQUFDO1FBQ2pFLE9BQU9xRSxNQUFNLElBQUl1RSxHQUFHLEtBQUtvdEIsRUFBRSxDQUFDaDJCLEVBQUUsR0FBRyxJQUFJcUUsTUFBTSxJQUFJdUUsR0FBRyxLQUFLQSxJQUFJcXRCLEVBQUUsQ0FBQ2oyQixFQUFFLEdBQUcsSUFBSyxLQUFJNEksQ0FBQUEsSUFBS3ZFLE1BQU11RSxHQUFHLEtBQUtveUIsRUFBRSxDQUFDaDdCLEVBQUUsR0FBR3FFLE1BQU11RSxHQUFHLEtBQUtnL0IsRUFBRSxDQUFDNW5DLEVBQUU7SUFDNUg7SUFFQXNsRSxjQUFjbGxFLFNBQVMsQ0FBQ3NtRSxvQkFBb0IsR0FBRyxTQUFVenRCLFNBQVMsRUFBRS9QLFdBQVc7UUFDN0UsSUFBSWxwQztRQUNKLElBQUlDLE1BQU1nNUMsVUFBVS80QyxNQUFNO1FBRTFCLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCLElBQUlpNUMsU0FBUyxDQUFDajVDLEVBQUUsSUFBSWk1QyxTQUFTLENBQUNqNUMsRUFBRSxDQUFDK3RCLEVBQUUsRUFBRTtnQkFDbkMsSUFBSSxDQUFDNjNDLHlCQUF5QixDQUFDM3NCLFNBQVMsQ0FBQ2o1QyxFQUFFLEVBQUVrcEM7WUFDL0MsT0FBTyxJQUFJK1AsU0FBUyxDQUFDajVDLEVBQUUsSUFBSWk1QyxTQUFTLENBQUNqNUMsRUFBRSxDQUFDNE4sRUFBRSxFQUFFO2dCQUMxQyxJQUFJLENBQUM4NEQsb0JBQW9CLENBQUN6dEIsU0FBUyxDQUFDajVDLEVBQUUsQ0FBQzROLEVBQUUsRUFBRXM3QjtZQUM3QyxPQUFPLElBQUkrUCxTQUFTLENBQUNqNUMsRUFBRSxJQUFJaTVDLFNBQVMsQ0FBQ2o1QyxFQUFFLENBQUNpRyxLQUFLLElBQUlnekMsU0FBUyxDQUFDajVDLEVBQUUsQ0FBQ3V3QixDQUFDLEVBQUU7Z0JBQy9ELElBQUksQ0FBQ28yQyx1QkFBdUIsQ0FBQzF0QixTQUFTLENBQUNqNUMsRUFBRSxDQUFDdXdCLENBQUMsRUFBRTJZO1lBQy9DO1FBQ0Y7SUFDRjtJQUVBbzhCLGNBQWNsbEUsU0FBUyxDQUFDdW1FLHVCQUF1QixHQUFHLFNBQVVDLGFBQWEsRUFBRTE5QixXQUFXO1FBQ3BGLElBQUkxMkIsUUFBUTtRQUVaLElBQUlvMEQsY0FBY3Y2QyxTQUFTLEVBQUU7WUFDM0IsSUFBSyxJQUFJcnNCLElBQUksR0FBR0EsSUFBSTRtRSxjQUFjdjZDLFNBQVMsQ0FBQ25zQixNQUFNLEVBQUVGLEtBQUssRUFBRztnQkFDMUQsSUFBSTZtRSxNQUFNRCxjQUFjdjZDLFNBQVMsQ0FBQ3JzQixFQUFFLENBQUNvSSxDQUFDO2dCQUV0QyxJQUFJeStELE1BQU1yMEQsT0FBTztvQkFDZkEsUUFBUXEwRDtnQkFDVjtZQUNGO1lBRUFyMEQsU0FBU28wRCxjQUFjNTFDLElBQUk7UUFDN0IsT0FBTztZQUNMeGUsUUFBUW8wRCxjQUFjditELENBQUMsR0FBR3UrRCxjQUFjNTFDLElBQUk7UUFDOUM7UUFFQWtZLFlBQVl0a0IsQ0FBQyxJQUFJcFM7UUFDakIwMkIsWUFBWW05QixJQUFJLElBQUk3ekQ7UUFDcEIwMkIsWUFBWWhjLENBQUMsSUFBSTFhO1FBQ2pCMDJCLFlBQVlvOUIsSUFBSSxJQUFJOXpEO0lBQ3RCO0lBRUE4eUQsY0FBY2xsRSxTQUFTLENBQUMwbUUsa0JBQWtCLEdBQUcsU0FBVS95RCxHQUFHO1FBQ3hELE9BQU8sSUFBSSxDQUFDeXhELFdBQVcsQ0FBQzVnRCxDQUFDLElBQUk3USxJQUFJNlEsQ0FBQyxJQUFJLElBQUksQ0FBQzRnRCxXQUFXLENBQUN0NEMsQ0FBQyxJQUFJblosSUFBSW1aLENBQUMsSUFBSSxJQUFJLENBQUNzNEMsV0FBVyxDQUFDaHpELEtBQUssR0FBRyxJQUFJLENBQUNnekQsV0FBVyxDQUFDNWdELENBQUMsSUFBSTdRLElBQUk2USxDQUFDLEdBQUc3USxJQUFJdkIsS0FBSyxJQUFJLElBQUksQ0FBQ2d6RCxXQUFXLENBQUMveUQsTUFBTSxHQUFHLElBQUksQ0FBQyt5RCxXQUFXLENBQUN0NEMsQ0FBQyxJQUFJblosSUFBSW1aLENBQUMsR0FBR25aLElBQUl0QixNQUFNO0lBQzdNO0lBRUE2eUQsY0FBY2xsRSxTQUFTLENBQUN5akQsa0JBQWtCLEdBQUc7UUFDM0MsSUFBSSxDQUFDNGhCLGlCQUFpQjtRQUV0QixJQUFJLENBQUMsSUFBSSxDQUFDM3ZCLE1BQU0sSUFBSyxLQUFJLENBQUN4a0IsYUFBYSxJQUFJLElBQUksQ0FBQ0wsSUFBSSxHQUFHO1lBQ3JELElBQUlzMUMsa0JBQWtCLElBQUksQ0FBQ0EsZUFBZTtZQUMxQyxJQUFJMWhFLE1BQU07WUFDVjBoRSxnQkFBZ0IzaEQsQ0FBQyxHQUFHL2Y7WUFDcEIwaEUsZ0JBQWdCRixJQUFJLEdBQUcsQ0FBQ3hoRTtZQUN4QjBoRSxnQkFBZ0JyNUMsQ0FBQyxHQUFHcm9CO1lBQ3BCMGhFLGdCQUFnQkQsSUFBSSxHQUFHLENBQUN6aEU7WUFDeEIsSUFBSSxDQUFDNmhFLG9CQUFvQixDQUFDLElBQUksQ0FBQ3p0QixTQUFTLEVBQUVzdEI7WUFDMUNBLGdCQUFnQi96RCxLQUFLLEdBQUcrekQsZ0JBQWdCRixJQUFJLEdBQUdFLGdCQUFnQjNoRCxDQUFDLEdBQUcsSUFBSTJoRCxnQkFBZ0JGLElBQUksR0FBR0UsZ0JBQWdCM2hELENBQUM7WUFDL0cyaEQsZ0JBQWdCOXpELE1BQU0sR0FBRzh6RCxnQkFBZ0JELElBQUksR0FBR0MsZ0JBQWdCcjVDLENBQUMsR0FBRyxJQUFJcTVDLGdCQUFnQkQsSUFBSSxHQUFHQyxnQkFBZ0JyNUMsQ0FBQyxFQUFFLGtEQUFrRDtZQUVwSyxJQUFJLElBQUksQ0FBQzQ1QyxrQkFBa0IsQ0FBQ1Asa0JBQWtCO2dCQUM1QztZQUNGO1lBRUEsSUFBSVEsVUFBVTtZQUVkLElBQUksSUFBSSxDQUFDdkIsV0FBVyxDQUFDajFDLENBQUMsS0FBS2cyQyxnQkFBZ0IvekQsS0FBSyxFQUFFO2dCQUNoRCxJQUFJLENBQUNnekQsV0FBVyxDQUFDajFDLENBQUMsR0FBR2cyQyxnQkFBZ0IvekQsS0FBSztnQkFDMUMsSUFBSSxDQUFDa3pELFNBQVMsQ0FBQzNqRCxZQUFZLENBQUMsU0FBU3drRCxnQkFBZ0IvekQsS0FBSztnQkFDMUR1MEQsVUFBVTtZQUNaO1lBRUEsSUFBSSxJQUFJLENBQUN2QixXQUFXLENBQUNyOUQsQ0FBQyxLQUFLbytELGdCQUFnQjl6RCxNQUFNLEVBQUU7Z0JBQ2pELElBQUksQ0FBQyt5RCxXQUFXLENBQUNyOUQsQ0FBQyxHQUFHbytELGdCQUFnQjl6RCxNQUFNO2dCQUMzQyxJQUFJLENBQUNpekQsU0FBUyxDQUFDM2pELFlBQVksQ0FBQyxVQUFVd2tELGdCQUFnQjl6RCxNQUFNO2dCQUM1RHMwRCxVQUFVO1lBQ1o7WUFFQSxJQUFJQSxXQUFXLElBQUksQ0FBQ3ZCLFdBQVcsQ0FBQzVnRCxDQUFDLEtBQUsyaEQsZ0JBQWdCM2hELENBQUMsSUFBSSxJQUFJLENBQUM0Z0QsV0FBVyxDQUFDdDRDLENBQUMsS0FBS3E1QyxnQkFBZ0JyNUMsQ0FBQyxFQUFFO2dCQUNuRyxJQUFJLENBQUNzNEMsV0FBVyxDQUFDajFDLENBQUMsR0FBR2cyQyxnQkFBZ0IvekQsS0FBSztnQkFDMUMsSUFBSSxDQUFDZ3pELFdBQVcsQ0FBQ3I5RCxDQUFDLEdBQUdvK0QsZ0JBQWdCOXpELE1BQU07Z0JBQzNDLElBQUksQ0FBQyt5RCxXQUFXLENBQUM1Z0QsQ0FBQyxHQUFHMmhELGdCQUFnQjNoRCxDQUFDO2dCQUN0QyxJQUFJLENBQUM0Z0QsV0FBVyxDQUFDdDRDLENBQUMsR0FBR3E1QyxnQkFBZ0JyNUMsQ0FBQztnQkFDdEMsSUFBSSxDQUFDdzRDLFNBQVMsQ0FBQzNqRCxZQUFZLENBQUMsV0FBVyxJQUFJLENBQUN5akQsV0FBVyxDQUFDNWdELENBQUMsR0FBRyxNQUFNLElBQUksQ0FBQzRnRCxXQUFXLENBQUN0NEMsQ0FBQyxHQUFHLE1BQU0sSUFBSSxDQUFDczRDLFdBQVcsQ0FBQ2oxQyxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUNpMUMsV0FBVyxDQUFDcjlELENBQUM7Z0JBQzFJLElBQUk2K0QsYUFBYSxJQUFJLENBQUN0QixTQUFTLENBQUN6L0QsS0FBSztnQkFDckMsSUFBSWdoRSxpQkFBaUIsZUFBZSxJQUFJLENBQUN6QixXQUFXLENBQUM1Z0QsQ0FBQyxHQUFHLFFBQVEsSUFBSSxDQUFDNGdELFdBQVcsQ0FBQ3Q0QyxDQUFDLEdBQUc7Z0JBQ3RGODVDLFdBQVcvc0MsU0FBUyxHQUFHZ3RDO2dCQUN2QkQsV0FBVzlCLGVBQWUsR0FBRytCO1lBQy9CO1FBQ0Y7SUFDRjtJQUVBLFNBQVNDLGFBQWFuOEQsSUFBSSxFQUFFMFAsVUFBVSxFQUFFbk4sSUFBSTtRQUMxQyxJQUFJLENBQUN5b0QsU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDb1IsU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDM0IsV0FBVyxHQUFHO1lBQ2pCNWdELEdBQUc7WUFDSHNJLEdBQUcsQ0FBQztZQUNKL2tCLEdBQUc7WUFDSG9vQixHQUFHO1FBQ0w7UUFDQSxJQUFJLENBQUMwaEMsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ21WLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUN6akIsV0FBVyxDQUFDNTRDLE1BQU0wUCxZQUFZbk47SUFDckM7SUFFQXpOLGdCQUFnQjtRQUFDcTRDO1FBQWFnRjtRQUFrQjJuQjtRQUFjdmhCO1FBQWtCeko7UUFBYzRKO1FBQXNCd1I7S0FBYSxFQUFFaVM7SUFFbklBLGFBQWE5bUUsU0FBUyxDQUFDd2pELGFBQWEsR0FBRztRQUNyQyxJQUFJLENBQUN3akIsUUFBUSxHQUFHLElBQUksQ0FBQ2p2QixVQUFVO1FBRS9CLElBQUksSUFBSSxDQUFDaXZCLFFBQVEsRUFBRTtZQUNqQixJQUFJLENBQUNuVixVQUFVLEdBQUc7WUFDbEIsSUFBSSxDQUFDb1YsS0FBSyxHQUFHLElBQUksQ0FBQy81RCxJQUFJLENBQUN2QyxJQUFJLENBQUN3bEIsQ0FBQztZQUM3QixJQUFJLENBQUMrMkMsS0FBSyxHQUFHLElBQUksQ0FBQ2g2RCxJQUFJLENBQUN2QyxJQUFJLENBQUM1QyxDQUFDO1lBQzdCLElBQUksQ0FBQ3l2RCxVQUFVLENBQUM3MUMsWUFBWSxDQUFDLFNBQVMsSUFBSSxDQUFDc2xELEtBQUs7WUFDaEQsSUFBSSxDQUFDelAsVUFBVSxDQUFDNzFDLFlBQVksQ0FBQyxVQUFVLElBQUksQ0FBQ3VsRCxLQUFLO1lBQ2pELElBQUkvK0QsSUFBSTRCLFNBQVM7WUFDakIsSUFBSSxDQUFDMjFDLGFBQWEsQ0FBQ3ByQyxXQUFXLENBQUNuTTtZQUMvQixJQUFJLENBQUN1N0MsU0FBUyxHQUFHdjdDO1FBQ25CLE9BQU87WUFDTCxJQUFJLENBQUMwcEQsVUFBVSxHQUFHO1lBQ2xCLElBQUksQ0FBQ25PLFNBQVMsR0FBRyxJQUFJLENBQUN0SyxZQUFZO1FBQ3BDO1FBRUEsSUFBSSxDQUFDZ0ssY0FBYztJQUNyQjtJQUVBMGpCLGFBQWE5bUUsU0FBUyxDQUFDdzFELFlBQVksR0FBRztRQUNwQyxJQUFJcm5ELGVBQWUsSUFBSSxDQUFDNmlELFlBQVksQ0FBQy9FLFdBQVc7UUFDaEQsSUFBSSxDQUFDcUcsZUFBZSxHQUFHdHZELGlCQUFpQm1MLGFBQWFxckIsQ0FBQyxHQUFHcnJCLGFBQWFxckIsQ0FBQyxDQUFDMTVCLE1BQU0sR0FBRztRQUNqRixJQUFJcW5FLGlCQUFpQixJQUFJLENBQUN6akIsU0FBUyxDQUFDNzlDLEtBQUs7UUFDekMsSUFBSXVoRSxZQUFZajVELGFBQWFzOUMsRUFBRSxHQUFHLElBQUksQ0FBQzJKLFVBQVUsQ0FBQ2puRCxhQUFhczlDLEVBQUUsSUFBSTtRQUNyRTBiLGVBQWVwSCxJQUFJLEdBQUdxSDtRQUN0QkQsZUFBZXYrRCxLQUFLLEdBQUd3K0Q7UUFFdkIsSUFBSWo1RCxhQUFhNmtDLEVBQUUsRUFBRTtZQUNuQm0wQixlQUFlckgsTUFBTSxHQUFHLElBQUksQ0FBQzFLLFVBQVUsQ0FBQ2puRCxhQUFhNmtDLEVBQUU7WUFDdkRtMEIsZUFBZUUsV0FBVyxHQUFHbDVELGFBQWFxOUMsRUFBRSxHQUFHO1FBQ2pEO1FBRUEsSUFBSWpkLFdBQVcsSUFBSSxDQUFDbDBCLFVBQVUsQ0FBQ29CLFdBQVcsQ0FBQ2s0QixhQUFhLENBQUN4bEMsYUFBYTlGLENBQUM7UUFFdkUsSUFBSSxDQUFDLElBQUksQ0FBQ2dTLFVBQVUsQ0FBQ29CLFdBQVcsQ0FBQzNPLEtBQUssRUFBRTtZQUN0Q3E2RCxlQUFlOTJCLFFBQVEsR0FBR2xpQyxhQUFhMitDLFNBQVMsR0FBRztZQUNuRHFhLGVBQWVHLFVBQVUsR0FBR241RCxhQUFhMitDLFNBQVMsR0FBRztZQUVyRCxJQUFJdmUsU0FBU3dELE1BQU0sRUFBRTtnQkFDbkIsSUFBSSxDQUFDMlIsU0FBUyxDQUFDa1UsU0FBUyxHQUFHcnBCLFNBQVN3RCxNQUFNO1lBQzVDLE9BQU87Z0JBQ0xvMUIsZUFBZWgzQixVQUFVLEdBQUc1QixTQUFTc0QsT0FBTztnQkFDNUMsSUFBSW5ELFVBQVV2Z0MsYUFBYXVnQyxPQUFPO2dCQUNsQyxJQUFJRCxTQUFTdGdDLGFBQWFzZ0MsTUFBTTtnQkFDaEMwNEIsZUFBZTUyQixTQUFTLEdBQUc5QjtnQkFDM0IwNEIsZUFBZTMyQixVQUFVLEdBQUc5QjtZQUM5QjtRQUNGO1FBRUEsSUFBSTl1QztRQUNKLElBQUlDO1FBQ0osSUFBSW91RCxVQUFVOS9DLGFBQWFxckIsQ0FBQztRQUM1QjM1QixNQUFNb3VELFFBQVFudUQsTUFBTTtRQUNwQixJQUFJeTJEO1FBQ0osSUFBSWdSO1FBQ0osSUFBSUM7UUFDSixJQUFJOVUsZUFBZSxJQUFJLENBQUN0VSxPQUFPO1FBQy9CLElBQUl6eEM7UUFDSixJQUFJcW9ELFdBQVc7UUFDZixJQUFJcmhDLE1BQU07UUFFVixJQUFLL3pCLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCLElBQUksSUFBSSxDQUFDeWEsVUFBVSxDQUFDb0IsV0FBVyxDQUFDM08sS0FBSyxFQUFFO2dCQUNyQyxJQUFJLENBQUMsSUFBSSxDQUFDaTZELFNBQVMsQ0FBQ3B6QyxJQUFJLEVBQUU7b0JBQ3hCNGlDLFFBQVF4c0QsU0FBUztvQkFDakJ3c0QsTUFBTTUwQyxZQUFZLENBQUMsa0JBQWtCK2lDLFdBQVcsQ0FBQyxFQUFFO29CQUNuRDZSLE1BQU01MEMsWUFBWSxDQUFDLG1CQUFtQmdqQyxZQUFZLENBQUMsRUFBRTtvQkFDckQ0UixNQUFNNTBDLFlBQVksQ0FBQyxxQkFBcUI7Z0JBQzFDLE9BQU87b0JBQ0w0MEMsUUFBUSxJQUFJLENBQUN3USxTQUFTLENBQUNwekMsSUFBSTtnQkFDN0I7Z0JBRUEsSUFBSSxDQUFDLElBQUksQ0FBQ3F6QyxRQUFRLEVBQUU7b0JBQ2xCLElBQUksSUFBSSxDQUFDclIsU0FBUyxDQUFDaGlDLElBQUksRUFBRTt3QkFDdkI0ekMsVUFBVSxJQUFJLENBQUM1UixTQUFTLENBQUNoaUMsSUFBSTt3QkFDN0I2ekMsUUFBUUQsUUFBUUUsUUFBUSxDQUFDLEVBQUU7b0JBQzdCLE9BQU87d0JBQ0xGLFVBQVVsb0UsVUFBVTt3QkFDcEJrb0UsUUFBUTFoRSxLQUFLLENBQUN5aEUsVUFBVSxHQUFHO3dCQUMzQkUsUUFBUXo5RCxTQUFTO3dCQUNqQnk5RCxNQUFNbHpELFdBQVcsQ0FBQ2lpRDt3QkFDbEI1d0QsU0FBUzRoRTtvQkFDWDtnQkFDRjtZQUNGLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQ1AsUUFBUSxFQUFFO2dCQUN6QixJQUFJLElBQUksQ0FBQ3JSLFNBQVMsQ0FBQ2hpQyxJQUFJLEVBQUU7b0JBQ3ZCNHpDLFVBQVUsSUFBSSxDQUFDNVIsU0FBUyxDQUFDaGlDLElBQUk7b0JBQzdCNGlDLFFBQVEsSUFBSSxDQUFDd1EsU0FBUyxDQUFDcHpDLElBQUk7Z0JBQzdCLE9BQU87b0JBQ0w0ekMsVUFBVWxvRSxVQUFVO29CQUNwQnNHLFNBQVM0aEU7b0JBQ1RoUixRQUFRbDNELFVBQVU7b0JBQ2xCc0csU0FBUzR3RDtvQkFDVGdSLFFBQVFqekQsV0FBVyxDQUFDaWlEO2dCQUN0QjtZQUNGLE9BQU87Z0JBQ0xBLFFBQVEsSUFBSSxDQUFDd1EsU0FBUyxDQUFDcHpDLElBQUksR0FBRyxJQUFJLENBQUNvekMsU0FBUyxDQUFDcHpDLElBQUksR0FBRzVwQixTQUFTO1lBQy9ELEVBQUUsOENBQThDO1lBR2hELElBQUksSUFBSSxDQUFDc1EsVUFBVSxDQUFDb0IsV0FBVyxDQUFDM08sS0FBSyxFQUFFO2dCQUNyQyxJQUFJeUIsV0FBVyxJQUFJLENBQUM4TCxVQUFVLENBQUNvQixXQUFXLENBQUMwM0IsV0FBVyxDQUFDaGxDLGFBQWE0K0MsU0FBUyxDQUFDbnRELEVBQUUsRUFBRTJ1QyxTQUFTRSxNQUFNLEVBQUUsSUFBSSxDQUFDcDBCLFVBQVUsQ0FBQ29CLFdBQVcsQ0FBQ2s0QixhQUFhLENBQUN4bEMsYUFBYTlGLENBQUMsRUFBRXdwQyxPQUFPO2dCQUNwSyxJQUFJdnBCO2dCQUVKLElBQUkvWixVQUFVO29CQUNaK1osWUFBWS9aLFNBQVM1RCxJQUFJO2dCQUMzQixPQUFPO29CQUNMMmQsWUFBWTtnQkFDZDtnQkFFQW9xQyxhQUFhcDlCLEtBQUs7Z0JBRWxCLElBQUloTixhQUFhQSxVQUFVM2IsTUFBTSxJQUFJMmIsVUFBVTNiLE1BQU0sQ0FBQzdNLE1BQU0sRUFBRTtvQkFDNUQ2TSxTQUFTMmIsVUFBVTNiLE1BQU0sQ0FBQyxFQUFFLENBQUNhLEVBQUU7b0JBQy9Ca2xELGFBQWFyNUIsS0FBSyxDQUFDbHJCLGFBQWEyK0MsU0FBUyxHQUFHLEtBQUszK0MsYUFBYTIrQyxTQUFTLEdBQUc7b0JBQzFFa0ksV0FBVyxJQUFJLENBQUNELGVBQWUsQ0FBQ3JDLGNBQWMvbEQ7b0JBQzlDNHBELE1BQU01MEMsWUFBWSxDQUFDLEtBQUtxekM7Z0JBQzFCO2dCQUVBLElBQUksQ0FBQyxJQUFJLENBQUNnUyxRQUFRLEVBQUU7b0JBQ2xCLElBQUksQ0FBQ3RqQixTQUFTLENBQUNwdkMsV0FBVyxDQUFDaXpEO29CQUUzQixJQUFJai9DLGFBQWFBLFVBQVUzYixNQUFNLEVBQUU7d0JBQ2pDLG9FQUFvRTt3QkFDcEVwTixTQUFTcWlCLElBQUksQ0FBQ3ROLFdBQVcsQ0FBQ2t6RDt3QkFDMUIsSUFBSTErQixjQUFjMCtCLE1BQU01ekQsT0FBTzt3QkFDL0I0ekQsTUFBTTdsRCxZQUFZLENBQUMsU0FBU21uQixZQUFZMTJCLEtBQUssR0FBRzt3QkFDaERvMUQsTUFBTTdsRCxZQUFZLENBQUMsVUFBVW1uQixZQUFZejJCLE1BQU0sR0FBRzt3QkFDbERtMUQsTUFBTTdsRCxZQUFZLENBQUMsV0FBV21uQixZQUFZdGtCLENBQUMsR0FBRyxJQUFJLE1BQU9za0IsQ0FBQUEsWUFBWWhjLENBQUMsR0FBRyxLQUFLLE1BQU9nYyxDQUFBQSxZQUFZMTJCLEtBQUssR0FBRyxLQUFLLE1BQU8wMkIsQ0FBQUEsWUFBWXoyQixNQUFNLEdBQUc7d0JBQzFJLElBQUlxMUQsYUFBYUYsTUFBTTNoRSxLQUFLO3dCQUM1QixJQUFJOGhFLG1CQUFtQixlQUFnQjcrQixDQUFBQSxZQUFZdGtCLENBQUMsR0FBRyxLQUFLLFFBQVNza0IsQ0FBQUEsWUFBWWhjLENBQUMsR0FBRyxLQUFLO3dCQUMxRjQ2QyxXQUFXN3RDLFNBQVMsR0FBRzh0Qzt3QkFDdkJELFdBQVc1QyxlQUFlLEdBQUc2Qzt3QkFDN0IxWixPQUFPLENBQUNydUQsRUFBRSxDQUFDaXRELE9BQU8sR0FBRy9qQixZQUFZaGMsQ0FBQyxHQUFHO29CQUN2QyxPQUFPO3dCQUNMMDZDLE1BQU03bEQsWUFBWSxDQUFDLFNBQVM7d0JBQzVCNmxELE1BQU03bEQsWUFBWSxDQUFDLFVBQVU7b0JBQy9CO29CQUVBNGxELFFBQVFqekQsV0FBVyxDQUFDa3pEO2dCQUN0QixPQUFPO29CQUNMLElBQUksQ0FBQzlqQixTQUFTLENBQUNwdkMsV0FBVyxDQUFDaWlEO2dCQUM3QjtZQUNGLE9BQU87Z0JBQ0xBLE1BQU16a0IsV0FBVyxHQUFHbWMsT0FBTyxDQUFDcnVELEVBQUUsQ0FBQ3FGLEdBQUc7Z0JBQ2xDc3hELE1BQU1waUQsY0FBYyxDQUFDLHdDQUF3QyxhQUFhO2dCQUUxRSxJQUFJLENBQUMsSUFBSSxDQUFDNnlELFFBQVEsRUFBRTtvQkFDbEIsSUFBSSxDQUFDdGpCLFNBQVMsQ0FBQ3B2QyxXQUFXLENBQUNpekQsVUFBVSxFQUFFO29CQUV2QyxJQUFJSyxTQUFTclIsTUFBTTF3RCxLQUFLO29CQUN4QixJQUFJZ2lFLG1CQUFtQixtQkFBbUIsQ0FBQzE1RCxhQUFhMitDLFNBQVMsR0FBRyxNQUFNO29CQUMxRThhLE9BQU8vdEMsU0FBUyxHQUFHZ3VDO29CQUNuQkQsT0FBTzlDLGVBQWUsR0FBRytDO2dCQUMzQixPQUFPO29CQUNMLElBQUksQ0FBQ25rQixTQUFTLENBQUNwdkMsV0FBVyxDQUFDaWlEO2dCQUM3QjtZQUNGLEVBQUUsRUFBRTtZQUdKLElBQUksQ0FBQyxJQUFJLENBQUN5USxRQUFRLEVBQUU7Z0JBQ2xCLElBQUksQ0FBQ3JSLFNBQVMsQ0FBQ2hpQyxJQUFJLEdBQUc0ekM7WUFDeEIsT0FBTztnQkFDTCxJQUFJLENBQUM1UixTQUFTLENBQUNoaUMsSUFBSSxHQUFHNGlDO1lBQ3hCO1lBRUEsSUFBSSxDQUFDWixTQUFTLENBQUNoaUMsSUFBSSxDQUFDOXRCLEtBQUssQ0FBQ0ksT0FBTyxHQUFHO1lBQ3BDLElBQUksQ0FBQzhnRSxTQUFTLENBQUNwekMsSUFBSSxHQUFHNGlDO1lBQ3RCNWlDLE9BQU87UUFDVDtRQUVBLE1BQU9BLE1BQU0sSUFBSSxDQUFDZ2lDLFNBQVMsQ0FBQzcxRCxNQUFNLENBQUU7WUFDbEMsSUFBSSxDQUFDNjFELFNBQVMsQ0FBQ2hpQyxJQUFJLENBQUM5dEIsS0FBSyxDQUFDSSxPQUFPLEdBQUc7WUFDcEMwdEIsT0FBTztRQUNUO0lBQ0Y7SUFFQW16QyxhQUFhOW1FLFNBQVMsQ0FBQ3lqRCxrQkFBa0IsR0FBRztRQUMxQyxJQUFJLENBQUM4UixZQUFZO1FBQ2pCLElBQUl1UztRQUVKLElBQUksSUFBSSxDQUFDbjlELElBQUksQ0FBQ2lyRCxXQUFXLEVBQUU7WUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQzFrQyxhQUFhLElBQUksQ0FBQyxJQUFJLENBQUNxaEMsa0JBQWtCLEVBQUU7Z0JBQ25EO1lBQ0Y7WUFFQSxJQUFJLElBQUksQ0FBQ3lVLFFBQVEsSUFBSSxJQUFJLENBQUM1d0IsY0FBYyxDQUFDNEcsT0FBTyxFQUFFO2dCQUNoRCxzREFBc0Q7Z0JBQ3RELElBQUksQ0FBQ3dhLFVBQVUsQ0FBQzcxQyxZQUFZLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQ3kwQixjQUFjLENBQUNDLEtBQUssQ0FBQy90QyxDQUFDLENBQUNMLENBQUMsQ0FBQyxFQUFFLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQ211QyxjQUFjLENBQUNDLEtBQUssQ0FBQy90QyxDQUFDLENBQUNMLENBQUMsQ0FBQyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUNnL0QsS0FBSyxHQUFHLE1BQU0sSUFBSSxDQUFDQyxLQUFLO2dCQUN6SlksV0FBVyxJQUFJLENBQUN0USxVQUFVLENBQUMzeEQsS0FBSztnQkFDaEMsSUFBSWtpRSxjQUFjLGVBQWUsQ0FBQyxJQUFJLENBQUMzeEIsY0FBYyxDQUFDQyxLQUFLLENBQUMvdEMsQ0FBQyxDQUFDTCxDQUFDLENBQUMsRUFBRSxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUNtdUMsY0FBYyxDQUFDQyxLQUFLLENBQUMvdEMsQ0FBQyxDQUFDTCxDQUFDLENBQUMsRUFBRSxHQUFHO2dCQUNqSDYvRCxTQUFTanVDLFNBQVMsR0FBR2t1QztnQkFDckJELFNBQVNoRCxlQUFlLEdBQUdpRDtZQUM3QjtRQUNGO1FBRUEsSUFBSSxDQUFDalQsWUFBWSxDQUFDckMsV0FBVyxDQUFDLElBQUksQ0FBQ3pCLFlBQVksQ0FBQy9FLFdBQVcsRUFBRSxJQUFJLENBQUNzRyxrQkFBa0I7UUFFcEYsSUFBSSxDQUFDLElBQUksQ0FBQ0Esa0JBQWtCLElBQUksQ0FBQyxJQUFJLENBQUN1QyxZQUFZLENBQUN2QyxrQkFBa0IsRUFBRTtZQUNyRTtRQUNGO1FBRUEsSUFBSTN5RDtRQUNKLElBQUlDO1FBQ0osSUFBSXdzQyxRQUFRO1FBQ1osSUFBSWltQixrQkFBa0IsSUFBSSxDQUFDd0MsWUFBWSxDQUFDeEMsZUFBZTtRQUN2RCxJQUFJckUsVUFBVSxJQUFJLENBQUMrQyxZQUFZLENBQUMvRSxXQUFXLENBQUN6eUIsQ0FBQztRQUM3QzM1QixNQUFNb3VELFFBQVFudUQsTUFBTTtRQUNwQixJQUFJcTNEO1FBQ0osSUFBSUM7UUFDSixJQUFJNFE7UUFFSixJQUFLcG9FLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCLElBQUlxdUQsT0FBTyxDQUFDcnVELEVBQUUsQ0FBQ210QixDQUFDLEVBQUU7Z0JBQ2hCc2YsU0FBUztZQUNYLE9BQU87Z0JBQ0wrcUIsV0FBVyxJQUFJLENBQUN6QixTQUFTLENBQUMvMUQsRUFBRTtnQkFDNUJvb0UsV0FBVyxJQUFJLENBQUNqQixTQUFTLENBQUNubkUsRUFBRTtnQkFDNUJ1M0QsaUJBQWlCN0UsZUFBZSxDQUFDam1CLE1BQU07Z0JBQ3ZDQSxTQUFTO2dCQUVULElBQUk4cUIsZUFBZXRtQyxJQUFJLENBQUM0SSxDQUFDLEVBQUU7b0JBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUN1dEMsUUFBUSxFQUFFO3dCQUNsQjVQLFNBQVN2eEQsS0FBSyxDQUFDaS9ELGVBQWUsR0FBRzNOLGVBQWUxOUIsQ0FBQzt3QkFDakQyOUIsU0FBU3Z4RCxLQUFLLENBQUNnMEIsU0FBUyxHQUFHczlCLGVBQWUxOUIsQ0FBQztvQkFDN0MsT0FBTzt3QkFDTDI5QixTQUFTejFDLFlBQVksQ0FBQyxhQUFhdzFDLGVBQWUxOUIsQ0FBQztvQkFDckQ7Z0JBQ0YsRUFBRSx1REFBdUQ7Z0JBR3pEMjlCLFNBQVN2eEQsS0FBSyxDQUFDKzNDLE9BQU8sR0FBR3VaLGVBQWUxcEQsQ0FBQztnQkFFekMsSUFBSTBwRCxlQUFlM0wsRUFBRSxJQUFJMkwsZUFBZXRtQyxJQUFJLENBQUMyNkIsRUFBRSxFQUFFO29CQUMvQ3djLFNBQVNybUQsWUFBWSxDQUFDLGdCQUFnQncxQyxlQUFlM0wsRUFBRTtnQkFDekQ7Z0JBRUEsSUFBSTJMLGVBQWVua0IsRUFBRSxJQUFJbWtCLGVBQWV0bUMsSUFBSSxDQUFDbWlCLEVBQUUsRUFBRTtvQkFDL0NnMUIsU0FBU3JtRCxZQUFZLENBQUMsVUFBVXcxQyxlQUFlbmtCLEVBQUU7Z0JBQ25EO2dCQUVBLElBQUlta0IsZUFBZTFMLEVBQUUsSUFBSTBMLGVBQWV0bUMsSUFBSSxDQUFDNDZCLEVBQUUsRUFBRTtvQkFDL0N1YyxTQUFTcm1ELFlBQVksQ0FBQyxRQUFRdzFDLGVBQWUxTCxFQUFFO29CQUMvQ3VjLFNBQVNuaUUsS0FBSyxDQUFDK0MsS0FBSyxHQUFHdXVELGVBQWUxTCxFQUFFO2dCQUMxQztZQUNGO1FBQ0Y7UUFFQSxJQUFJLElBQUksQ0FBQy9ILFNBQVMsQ0FBQzl2QyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM4aEMsTUFBTSxJQUFLLEtBQUksQ0FBQ3hrQixhQUFhLElBQUksSUFBSSxDQUFDTCxJQUFJLEdBQUc7WUFDL0UsSUFBSWlZLGNBQWMsSUFBSSxDQUFDNGEsU0FBUyxDQUFDOXZDLE9BQU87WUFFeEMsSUFBSSxJQUFJLENBQUN3eEQsV0FBVyxDQUFDajFDLENBQUMsS0FBSzJZLFlBQVkxMkIsS0FBSyxFQUFFO2dCQUM1QyxJQUFJLENBQUNnekQsV0FBVyxDQUFDajFDLENBQUMsR0FBRzJZLFlBQVkxMkIsS0FBSztnQkFDdEMsSUFBSSxDQUFDb2xELFVBQVUsQ0FBQzcxQyxZQUFZLENBQUMsU0FBU21uQixZQUFZMTJCLEtBQUs7WUFDekQ7WUFFQSxJQUFJLElBQUksQ0FBQ2d6RCxXQUFXLENBQUNyOUQsQ0FBQyxLQUFLK2dDLFlBQVl6MkIsTUFBTSxFQUFFO2dCQUM3QyxJQUFJLENBQUMreUQsV0FBVyxDQUFDcjlELENBQUMsR0FBRytnQyxZQUFZejJCLE1BQU07Z0JBQ3ZDLElBQUksQ0FBQ21sRCxVQUFVLENBQUM3MUMsWUFBWSxDQUFDLFVBQVVtbkIsWUFBWXoyQixNQUFNO1lBQzNEO1lBRUEsSUFBSTQxRCxTQUFTO1lBRWIsSUFBSSxJQUFJLENBQUM3QyxXQUFXLENBQUNqMUMsQ0FBQyxLQUFLMlksWUFBWTEyQixLQUFLLEdBQUc2MUQsU0FBUyxLQUFLLElBQUksQ0FBQzdDLFdBQVcsQ0FBQ3I5RCxDQUFDLEtBQUsrZ0MsWUFBWXoyQixNQUFNLEdBQUc0MUQsU0FBUyxLQUFLLElBQUksQ0FBQzdDLFdBQVcsQ0FBQzVnRCxDQUFDLEtBQUtza0IsWUFBWXRrQixDQUFDLEdBQUd5akQsVUFBVSxJQUFJLENBQUM3QyxXQUFXLENBQUN0NEMsQ0FBQyxLQUFLZ2MsWUFBWWhjLENBQUMsR0FBR203QyxRQUFRO2dCQUNyTixJQUFJLENBQUM3QyxXQUFXLENBQUNqMUMsQ0FBQyxHQUFHMlksWUFBWTEyQixLQUFLLEdBQUc2MUQsU0FBUztnQkFDbEQsSUFBSSxDQUFDN0MsV0FBVyxDQUFDcjlELENBQUMsR0FBRytnQyxZQUFZejJCLE1BQU0sR0FBRzQxRCxTQUFTO2dCQUNuRCxJQUFJLENBQUM3QyxXQUFXLENBQUM1Z0QsQ0FBQyxHQUFHc2tCLFlBQVl0a0IsQ0FBQyxHQUFHeWpEO2dCQUNyQyxJQUFJLENBQUM3QyxXQUFXLENBQUN0NEMsQ0FBQyxHQUFHZ2MsWUFBWWhjLENBQUMsR0FBR203QztnQkFDckMsSUFBSSxDQUFDelEsVUFBVSxDQUFDNzFDLFlBQVksQ0FBQyxXQUFXLElBQUksQ0FBQ3lqRCxXQUFXLENBQUM1Z0QsQ0FBQyxHQUFHLE1BQU0sSUFBSSxDQUFDNGdELFdBQVcsQ0FBQ3Q0QyxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUNzNEMsV0FBVyxDQUFDajFDLENBQUMsR0FBRyxNQUFNLElBQUksQ0FBQ2kxQyxXQUFXLENBQUNyOUQsQ0FBQztnQkFDM0krL0QsV0FBVyxJQUFJLENBQUN0USxVQUFVLENBQUMzeEQsS0FBSztnQkFDaEMsSUFBSXFpRSxlQUFlLGVBQWUsSUFBSSxDQUFDOUMsV0FBVyxDQUFDNWdELENBQUMsR0FBRyxRQUFRLElBQUksQ0FBQzRnRCxXQUFXLENBQUN0NEMsQ0FBQyxHQUFHO2dCQUNwRmc3QyxTQUFTanVDLFNBQVMsR0FBR3F1QztnQkFDckJKLFNBQVNoRCxlQUFlLEdBQUdvRDtZQUM3QjtRQUNGO0lBQ0Y7SUFFQSxTQUFTQyxlQUFleDlELElBQUksRUFBRTBQLFVBQVUsRUFBRW5OLElBQUk7UUFDNUMsSUFBSSxDQUFDb2UsU0FBUztRQUNkLElBQUksQ0FBQyt0QixZQUFZLENBQUMxdUMsTUFBTTBQLFlBQVluTjtRQUNwQyxJQUFJLENBQUNpMkMsYUFBYTtRQUNsQixJQUFJbnhCLFVBQVVELGdCQUFnQkMsT0FBTztRQUNyQyxJQUFJLENBQUNvMkMsRUFBRSxHQUFHcDJDLFFBQVEsSUFBSSxFQUFFcm5CLEtBQUt5OUQsRUFBRSxFQUFFLEdBQUcsR0FBRyxJQUFJO1FBRTNDLElBQUl6OUQsS0FBSzRDLEVBQUUsQ0FBQ2pGLENBQUMsQ0FBQ04sQ0FBQyxFQUFFO1lBQ2YsSUFBSSxDQUFDODZCLEVBQUUsR0FBRzlRLFFBQVEsSUFBSSxFQUFFcm5CLEtBQUs0QyxFQUFFLENBQUNqRixDQUFDLENBQUNrYyxDQUFDLEVBQUUsR0FBRyxHQUFHLElBQUk7WUFDL0MsSUFBSSxDQUFDdWUsRUFBRSxHQUFHL1EsUUFBUSxJQUFJLEVBQUVybkIsS0FBSzRDLEVBQUUsQ0FBQ2pGLENBQUMsQ0FBQ3drQixDQUFDLEVBQUUsR0FBRyxHQUFHLElBQUk7WUFDL0MsSUFBSSxDQUFDa1csRUFBRSxHQUFHaFIsUUFBUSxJQUFJLEVBQUVybkIsS0FBSzRDLEVBQUUsQ0FBQ2pGLENBQUMsQ0FBQzhuQixDQUFDLEVBQUUsR0FBRyxHQUFHLElBQUk7UUFDakQsT0FBTztZQUNMLElBQUksQ0FBQzluQixDQUFDLEdBQUcwcEIsUUFBUSxJQUFJLEVBQUVybkIsS0FBSzRDLEVBQUUsQ0FBQ2pGLENBQUMsRUFBRSxHQUFHLEdBQUcsSUFBSTtRQUM5QztRQUVBLElBQUlxQyxLQUFLNEMsRUFBRSxDQUFDcUIsQ0FBQyxFQUFFO1lBQ2IsSUFBSSxDQUFDQSxDQUFDLEdBQUdvakIsUUFBUSxJQUFJLEVBQUVybkIsS0FBSzRDLEVBQUUsQ0FBQ3FCLENBQUMsRUFBRSxHQUFHLEdBQUcsSUFBSTtRQUM5QztRQUVBLElBQUlqRSxLQUFLNEMsRUFBRSxDQUFDa3BCLEVBQUUsQ0FBQzFxQixDQUFDLENBQUNqTSxNQUFNLElBQUk2SyxLQUFLNEMsRUFBRSxDQUFDa3BCLEVBQUUsQ0FBQzFxQixDQUFDLENBQUMsRUFBRSxDQUFDMmdCLEVBQUUsRUFBRTtZQUM3QyxJQUFJOXNCO1lBQ0osSUFBSUMsTUFBTThLLEtBQUs0QyxFQUFFLENBQUNrcEIsRUFBRSxDQUFDMXFCLENBQUMsQ0FBQ2pNLE1BQU07WUFFN0IsSUFBS0YsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7Z0JBQzNCK0ssS0FBSzRDLEVBQUUsQ0FBQ2twQixFQUFFLENBQUMxcUIsQ0FBQyxDQUFDbk0sRUFBRSxDQUFDOHNCLEVBQUUsR0FBRztnQkFDckIvaEIsS0FBSzRDLEVBQUUsQ0FBQ2twQixFQUFFLENBQUMxcUIsQ0FBQyxDQUFDbk0sRUFBRSxDQUFDK3NCLEVBQUUsR0FBRztZQUN2QjtRQUNGO1FBRUEsSUFBSSxDQUFDOEosRUFBRSxHQUFHekUsUUFBUSxJQUFJLEVBQUVybkIsS0FBSzRDLEVBQUUsQ0FBQ2twQixFQUFFLEVBQUUsR0FBR3B4QixXQUFXLElBQUk7UUFDdEQsSUFBSSxDQUFDb3hCLEVBQUUsQ0FBQzlJLEVBQUUsR0FBRztRQUNiLElBQUksQ0FBQ2tWLEVBQUUsR0FBRzdRLFFBQVEsSUFBSSxFQUFFcm5CLEtBQUs0QyxFQUFFLENBQUNzMUIsRUFBRSxFQUFFLEdBQUd4OUIsV0FBVyxJQUFJO1FBQ3RELElBQUksQ0FBQ3U5QixFQUFFLEdBQUc1USxRQUFRLElBQUksRUFBRXJuQixLQUFLNEMsRUFBRSxDQUFDcTFCLEVBQUUsRUFBRSxHQUFHdjlCLFdBQVcsSUFBSTtRQUN0RCxJQUFJLENBQUNzOUIsRUFBRSxHQUFHM1EsUUFBUSxJQUFJLEVBQUVybkIsS0FBSzRDLEVBQUUsQ0FBQ28xQixFQUFFLEVBQUUsR0FBR3Q5QixXQUFXLElBQUk7UUFDdEQsSUFBSSxDQUFDcTlCLEdBQUcsR0FBRyxJQUFJdks7UUFDZixJQUFJLENBQUNrd0MsUUFBUSxHQUFHLElBQUlsd0M7UUFDcEIsSUFBSSxDQUFDakgsYUFBYSxHQUFHLE1BQU0sdUhBQXVIO1FBRWxKLElBQUksQ0FBQ2tsQixjQUFjLEdBQUc7WUFDcEJDLE9BQU8sSUFBSTtRQUNiO0lBQ0Y7SUFFQTUyQyxnQkFBZ0I7UUFBQ3E0QztRQUFhMkI7UUFBY3lKO0tBQWlCLEVBQUVpbEI7SUFFL0RBLGVBQWVub0UsU0FBUyxDQUFDc29FLEtBQUssR0FBRztRQUMvQixJQUFJMW9FO1FBQ0osSUFBSUMsTUFBTSxJQUFJLENBQUNxTixJQUFJLENBQUNxN0QsY0FBYyxDQUFDem9FLE1BQU07UUFDekMsSUFBSW9OO1FBQ0osSUFBSXM3RDtRQUNKLElBQUk1RztRQUVKLElBQUtoaUUsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDM0IsOEJBQThCO1lBQzlCc04sT0FBTyxJQUFJLENBQUNBLElBQUksQ0FBQ3E3RCxjQUFjLENBQUMzb0UsRUFBRTtZQUVsQyxJQUFJc04sS0FBSzVOLElBQUksS0FBSyxNQUFNO2dCQUN0QmtwRSxtQkFBbUJ0N0QsS0FBS3U3RCxlQUFlLENBQUM1aUUsS0FBSztnQkFDN0MrN0QsaUJBQWlCMTBELEtBQUsrTSxTQUFTLENBQUNwVSxLQUFLO2dCQUNyQyxJQUFJNmlFLGNBQWMsSUFBSSxDQUFDTixFQUFFLENBQUNuZ0UsQ0FBQyxHQUFHO2dCQUM5QixJQUFJMkosU0FBUztnQkFDYixJQUFJaXFCLFNBQVM7Z0JBQ2Iyc0MsaUJBQWlCRSxXQUFXLEdBQUdBO2dCQUMvQkYsaUJBQWlCRyxpQkFBaUIsR0FBR0Q7Z0JBQ3JDOUcsZUFBZTE3RCxlQUFlLEdBQUcwTDtnQkFDakNnd0QsZUFBZUMsa0JBQWtCLEdBQUdqd0Q7Z0JBQ3BDZ3dELGVBQWV6N0QscUJBQXFCLEdBQUd5TDtnQkFDdkM0MkQsaUJBQWlCM3VDLFNBQVMsR0FBR2dDO2dCQUM3QjJzQyxpQkFBaUIxRCxlQUFlLEdBQUdqcEM7WUFDckM7UUFDRjtJQUNGO0lBRUFzc0MsZUFBZW5vRSxTQUFTLENBQUN5N0QsY0FBYyxHQUFHLFlBQWE7SUFFdkQwTSxlQUFlbm9FLFNBQVMsQ0FBQzBmLElBQUksR0FBRyxZQUFhO0lBRTdDeW9ELGVBQWVub0UsU0FBUyxDQUFDb2QsV0FBVyxHQUFHO1FBQ3JDLElBQUl5VCxPQUFPLElBQUksQ0FBQ0ssYUFBYTtRQUM3QixJQUFJdHhCO1FBQ0osSUFBSUM7UUFFSixJQUFJLElBQUksQ0FBQ284QyxTQUFTLEVBQUU7WUFDbEJwOEMsTUFBTSxJQUFJLENBQUNvOEMsU0FBUyxDQUFDbjhDLE1BQU07WUFFM0IsSUFBS0YsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7Z0JBQzNCaXhCLE9BQU8sSUFBSSxDQUFDb3JCLFNBQVMsQ0FBQ3I4QyxFQUFFLENBQUN3MkMsY0FBYyxDQUFDQyxLQUFLLENBQUN4bEIsSUFBSSxJQUFJQTtZQUN4RDtRQUNGO1FBRUEsSUFBSUEsUUFBUSxJQUFJLENBQUN1M0MsRUFBRSxDQUFDdjNDLElBQUksSUFBSSxJQUFJLENBQUN2b0IsQ0FBQyxJQUFJLElBQUksQ0FBQ0EsQ0FBQyxDQUFDdW9CLElBQUksSUFBSSxJQUFJLENBQUNpUyxFQUFFLElBQUssS0FBSSxDQUFDQSxFQUFFLENBQUNqUyxJQUFJLElBQUksSUFBSSxDQUFDa1MsRUFBRSxDQUFDbFMsSUFBSSxJQUFJLElBQUksQ0FBQ21TLEVBQUUsQ0FBQ25TLElBQUksS0FBSyxJQUFJLENBQUNnUyxFQUFFLENBQUNoUyxJQUFJLElBQUksSUFBSSxDQUFDK1IsRUFBRSxDQUFDL1IsSUFBSSxJQUFJLElBQUksQ0FBQzhSLEVBQUUsQ0FBQzlSLElBQUksSUFBSSxJQUFJLENBQUM0RixFQUFFLENBQUM1RixJQUFJLElBQUksSUFBSSxDQUFDamlCLENBQUMsSUFBSSxJQUFJLENBQUNBLENBQUMsQ0FBQ2lpQixJQUFJLEVBQUU7WUFDdk0sSUFBSSxDQUFDNlIsR0FBRyxDQUFDcE4sS0FBSztZQUVkLElBQUksSUFBSSxDQUFDMm1CLFNBQVMsRUFBRTtnQkFDbEJwOEMsTUFBTSxJQUFJLENBQUNvOEMsU0FBUyxDQUFDbjhDLE1BQU0sR0FBRztnQkFFOUIsSUFBS0YsSUFBSUMsS0FBS0QsS0FBSyxHQUFHQSxLQUFLLEVBQUc7b0JBQzVCLElBQUlncEUsVUFBVSxJQUFJLENBQUMzc0IsU0FBUyxDQUFDcjhDLEVBQUUsQ0FBQ3cyQyxjQUFjLENBQUNDLEtBQUs7b0JBQ3BELElBQUksQ0FBQzNULEdBQUcsQ0FBQ2hKLFNBQVMsQ0FBQyxDQUFDa3ZDLFFBQVF0Z0UsQ0FBQyxDQUFDTCxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMyZ0UsUUFBUXRnRSxDQUFDLENBQUNMLENBQUMsQ0FBQyxFQUFFLEVBQUUyZ0UsUUFBUXRnRSxDQUFDLENBQUNMLENBQUMsQ0FBQyxFQUFFO29CQUNuRSxJQUFJLENBQUN5NkIsR0FBRyxDQUFDNUosT0FBTyxDQUFDLENBQUM4dkMsUUFBUW55QyxFQUFFLENBQUN4dUIsQ0FBQyxDQUFDLEVBQUUsRUFBRTh3QixPQUFPLENBQUMsQ0FBQzZ2QyxRQUFRbnlDLEVBQUUsQ0FBQ3h1QixDQUFDLENBQUMsRUFBRSxFQUFFK3dCLE9BQU8sQ0FBQzR2QyxRQUFRbnlDLEVBQUUsQ0FBQ3h1QixDQUFDLENBQUMsRUFBRTtvQkFDcEYsSUFBSSxDQUFDeTZCLEdBQUcsQ0FBQzVKLE9BQU8sQ0FBQyxDQUFDOHZDLFFBQVEvbEMsRUFBRSxDQUFDNTZCLENBQUMsRUFBRTh3QixPQUFPLENBQUMsQ0FBQzZ2QyxRQUFRaG1DLEVBQUUsQ0FBQzM2QixDQUFDLEVBQUUrd0IsT0FBTyxDQUFDNHZDLFFBQVFqbUMsRUFBRSxDQUFDMTZCLENBQUM7b0JBQzNFLElBQUksQ0FBQ3k2QixHQUFHLENBQUNySixLQUFLLENBQUMsSUFBSXV2QyxRQUFRNWdFLENBQUMsQ0FBQ0MsQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJMmdFLFFBQVE1Z0UsQ0FBQyxDQUFDQyxDQUFDLENBQUMsRUFBRSxFQUFFLElBQUkyZ0UsUUFBUTVnRSxDQUFDLENBQUNDLENBQUMsQ0FBQyxFQUFFO29CQUN6RSxJQUFJLENBQUN5NkIsR0FBRyxDQUFDaEosU0FBUyxDQUFDa3ZDLFFBQVFoNkQsQ0FBQyxDQUFDM0csQ0FBQyxDQUFDLEVBQUUsRUFBRTJnRSxRQUFRaDZELENBQUMsQ0FBQzNHLENBQUMsQ0FBQyxFQUFFLEVBQUUyZ0UsUUFBUWg2RCxDQUFDLENBQUMzRyxDQUFDLENBQUMsRUFBRTtnQkFDbkU7WUFDRjtZQUVBLElBQUksSUFBSSxDQUFDSyxDQUFDLEVBQUU7Z0JBQ1YsSUFBSSxDQUFDbzZCLEdBQUcsQ0FBQ2hKLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQ3B4QixDQUFDLENBQUNMLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUNLLENBQUMsQ0FBQ0wsQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUNLLENBQUMsQ0FBQ0wsQ0FBQyxDQUFDLEVBQUU7WUFDNUQsT0FBTztnQkFDTCxJQUFJLENBQUN5NkIsR0FBRyxDQUFDaEosU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDb0osRUFBRSxDQUFDNzZCLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQzg2QixFQUFFLENBQUM5NkIsQ0FBQyxFQUFFLElBQUksQ0FBQys2QixFQUFFLENBQUMvNkIsQ0FBQztZQUN0RDtZQUVBLElBQUksSUFBSSxDQUFDMkcsQ0FBQyxFQUFFO2dCQUNWLElBQUlpNkQ7Z0JBRUosSUFBSSxJQUFJLENBQUN2Z0UsQ0FBQyxFQUFFO29CQUNWdWdFLGFBQWE7d0JBQUMsSUFBSSxDQUFDdmdFLENBQUMsQ0FBQ0wsQ0FBQyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMyRyxDQUFDLENBQUMzRyxDQUFDLENBQUMsRUFBRTt3QkFBRSxJQUFJLENBQUNLLENBQUMsQ0FBQ0wsQ0FBQyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMyRyxDQUFDLENBQUMzRyxDQUFDLENBQUMsRUFBRTt3QkFBRSxJQUFJLENBQUNLLENBQUMsQ0FBQ0wsQ0FBQyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMyRyxDQUFDLENBQUMzRyxDQUFDLENBQUMsRUFBRTtxQkFBQztnQkFDaEcsT0FBTztvQkFDTDRnRSxhQUFhO3dCQUFDLElBQUksQ0FBQy9sQyxFQUFFLENBQUM3NkIsQ0FBQyxHQUFHLElBQUksQ0FBQzJHLENBQUMsQ0FBQzNHLENBQUMsQ0FBQyxFQUFFO3dCQUFFLElBQUksQ0FBQzg2QixFQUFFLENBQUM5NkIsQ0FBQyxHQUFHLElBQUksQ0FBQzJHLENBQUMsQ0FBQzNHLENBQUMsQ0FBQyxFQUFFO3dCQUFFLElBQUksQ0FBQys2QixFQUFFLENBQUMvNkIsQ0FBQyxHQUFHLElBQUksQ0FBQzJHLENBQUMsQ0FBQzNHLENBQUMsQ0FBQyxFQUFFO3FCQUFDO2dCQUMxRjtnQkFFQSxJQUFJNmdFLE1BQU01a0UsS0FBS0csSUFBSSxDQUFDSCxLQUFLQyxHQUFHLENBQUMwa0UsVUFBVSxDQUFDLEVBQUUsRUFBRSxLQUFLM2tFLEtBQUtDLEdBQUcsQ0FBQzBrRSxVQUFVLENBQUMsRUFBRSxFQUFFLEtBQUsza0UsS0FBS0MsR0FBRyxDQUFDMGtFLFVBQVUsQ0FBQyxFQUFFLEVBQUUsS0FBSyxzRUFBc0U7Z0JBRWpMLElBQUlFLFVBQVU7b0JBQUNGLFVBQVUsQ0FBQyxFQUFFLEdBQUdDO29CQUFLRCxVQUFVLENBQUMsRUFBRSxHQUFHQztvQkFBS0QsVUFBVSxDQUFDLEVBQUUsR0FBR0M7aUJBQUk7Z0JBQzdFLElBQUlFLGlCQUFpQjlrRSxLQUFLRyxJQUFJLENBQUMwa0UsT0FBTyxDQUFDLEVBQUUsR0FBR0EsT0FBTyxDQUFDLEVBQUUsR0FBR0EsT0FBTyxDQUFDLEVBQUUsR0FBR0EsT0FBTyxDQUFDLEVBQUU7Z0JBQ2hGLElBQUlFLGFBQWEva0UsS0FBS3FyQixLQUFLLENBQUN3NUMsT0FBTyxDQUFDLEVBQUUsRUFBRUM7Z0JBQ3hDLElBQUlFLGFBQWFobEUsS0FBS3FyQixLQUFLLENBQUN3NUMsT0FBTyxDQUFDLEVBQUUsRUFBRSxDQUFDQSxPQUFPLENBQUMsRUFBRTtnQkFDbkQsSUFBSSxDQUFDcm1DLEdBQUcsQ0FBQzNKLE9BQU8sQ0FBQ213QyxZQUFZcHdDLE9BQU8sQ0FBQyxDQUFDbXdDO1lBQ3hDO1lBRUEsSUFBSSxDQUFDdm1DLEdBQUcsQ0FBQzVKLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQytKLEVBQUUsQ0FBQzU2QixDQUFDLEVBQUU4d0IsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDNkosRUFBRSxDQUFDMzZCLENBQUMsRUFBRSt3QixPQUFPLENBQUMsSUFBSSxDQUFDMkosRUFBRSxDQUFDMTZCLENBQUM7WUFDbEUsSUFBSSxDQUFDeTZCLEdBQUcsQ0FBQzVKLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQ3JDLEVBQUUsQ0FBQ3h1QixDQUFDLENBQUMsRUFBRSxFQUFFOHdCLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQ3RDLEVBQUUsQ0FBQ3h1QixDQUFDLENBQUMsRUFBRSxFQUFFK3dCLE9BQU8sQ0FBQyxJQUFJLENBQUN2QyxFQUFFLENBQUN4dUIsQ0FBQyxDQUFDLEVBQUU7WUFDM0UsSUFBSSxDQUFDeTZCLEdBQUcsQ0FBQ2hKLFNBQVMsQ0FBQyxJQUFJLENBQUNyZixVQUFVLENBQUNzaUMsUUFBUSxDQUFDeHNCLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQzlWLFVBQVUsQ0FBQ3NpQyxRQUFRLENBQUM1MEMsQ0FBQyxHQUFHLEdBQUc7WUFDbkYsSUFBSSxDQUFDMjZCLEdBQUcsQ0FBQ2hKLFNBQVMsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDMHVDLEVBQUUsQ0FBQ25nRSxDQUFDO1lBQ2xDLElBQUlraEUsbUJBQW1CLENBQUMsSUFBSSxDQUFDZCxRQUFRLENBQUNwc0MsTUFBTSxDQUFDLElBQUksQ0FBQ3lHLEdBQUc7WUFFckQsSUFBSSxDQUFDeW1DLG9CQUFvQixJQUFJLENBQUNmLEVBQUUsQ0FBQ3YzQyxJQUFJLEtBQUssSUFBSSxDQUFDM2pCLElBQUksQ0FBQ3E3RCxjQUFjLEVBQUU7Z0JBQ2xFMW9FLE1BQU0sSUFBSSxDQUFDcU4sSUFBSSxDQUFDcTdELGNBQWMsQ0FBQ3pvRSxNQUFNO2dCQUNyQyxJQUFJb047Z0JBQ0osSUFBSXM3RDtnQkFDSixJQUFJNUc7Z0JBRUosSUFBS2hpRSxJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztvQkFDM0JzTixPQUFPLElBQUksQ0FBQ0EsSUFBSSxDQUFDcTdELGNBQWMsQ0FBQzNvRSxFQUFFO29CQUVsQyxJQUFJc04sS0FBSzVOLElBQUksS0FBSyxNQUFNO3dCQUN0QixJQUFJNnBFLGtCQUFrQjs0QkFDcEIsSUFBSUMsV0FBVyxJQUFJLENBQUMxbUMsR0FBRyxDQUFDcEYsS0FBSzs0QkFDN0Jza0MsaUJBQWlCMTBELEtBQUsrTSxTQUFTLENBQUNwVSxLQUFLOzRCQUNyQys3RCxlQUFlL25DLFNBQVMsR0FBR3V2Qzs0QkFDM0J4SCxlQUFla0QsZUFBZSxHQUFHc0U7d0JBQ25DO3dCQUVBLElBQUksSUFBSSxDQUFDaEIsRUFBRSxDQUFDdjNDLElBQUksRUFBRTs0QkFDaEIyM0MsbUJBQW1CdDdELEtBQUt1N0QsZUFBZSxDQUFDNWlFLEtBQUs7NEJBQzdDMmlFLGlCQUFpQkUsV0FBVyxHQUFHLElBQUksQ0FBQ04sRUFBRSxDQUFDbmdFLENBQUMsR0FBRzs0QkFDM0N1Z0UsaUJBQWlCRyxpQkFBaUIsR0FBRyxJQUFJLENBQUNQLEVBQUUsQ0FBQ25nRSxDQUFDLEdBQUc7d0JBQ25EO29CQUNGO2dCQUNGO2dCQUVBLElBQUksQ0FBQ3k2QixHQUFHLENBQUM1TyxLQUFLLENBQUMsSUFBSSxDQUFDdTBDLFFBQVE7WUFDOUI7UUFDRjtRQUVBLElBQUksQ0FBQ24zQyxhQUFhLEdBQUc7SUFDdkI7SUFFQWkzQyxlQUFlbm9FLFNBQVMsQ0FBQzBYLFlBQVksR0FBRyxTQUFVdStCLEdBQUc7UUFDbkQsSUFBSSxDQUFDeUQsaUJBQWlCLENBQUN6RCxLQUFLO0lBQzlCO0lBRUFreUIsZUFBZW5vRSxTQUFTLENBQUNtVixPQUFPLEdBQUcsWUFBYTtJQUVoRGd6RCxlQUFlbm9FLFNBQVMsQ0FBQys1QyxjQUFjLEdBQUc7UUFDeEMsT0FBTztJQUNUO0lBRUEsU0FBU3N2QixjQUFjMStELElBQUksRUFBRTBQLFVBQVUsRUFBRW5OLElBQUk7UUFDM0MsSUFBSSxDQUFDZ0csU0FBUyxHQUFHbUgsV0FBV29GLFlBQVksQ0FBQzlVLEtBQUs4QixLQUFLO1FBQ25ELElBQUksQ0FBQzgyQyxXQUFXLENBQUM1NEMsTUFBTTBQLFlBQVluTjtJQUNyQztJQUVBek4sZ0JBQWdCO1FBQUNxNEM7UUFBYWdGO1FBQWtCMm5CO1FBQWNPO1FBQWU5aEI7UUFBa0J6SjtRQUFjbEU7S0FBa0IsRUFBRTh6QjtJQUVqSUEsY0FBY3JwRSxTQUFTLENBQUN3akQsYUFBYSxHQUFHO1FBQ3RDLElBQUkvaEQsWUFBWSxJQUFJLENBQUM0WSxVQUFVLENBQUNwSCxhQUFhLENBQUMsSUFBSSxDQUFDQyxTQUFTO1FBQzVELElBQUlNLE1BQU0sSUFBSTgxRDtRQUVkLElBQUksSUFBSSxDQUFDMytELElBQUksQ0FBQ3VCLE9BQU8sRUFBRTtZQUNyQixJQUFJLENBQUNxOUQsU0FBUyxHQUFHeC9ELFNBQVM7WUFDMUIsSUFBSSxDQUFDdy9ELFNBQVMsQ0FBQzVuRCxZQUFZLENBQUMsU0FBUyxJQUFJLENBQUN6TyxTQUFTLENBQUNpZCxDQUFDLEdBQUc7WUFDeEQsSUFBSSxDQUFDbzVDLFNBQVMsQ0FBQzVuRCxZQUFZLENBQUMsVUFBVSxJQUFJLENBQUN6TyxTQUFTLENBQUNuTCxDQUFDLEdBQUc7WUFDekQsSUFBSSxDQUFDd2hFLFNBQVMsQ0FBQ3AxRCxjQUFjLENBQUMsZ0NBQWdDLFFBQVExUztZQUN0RSxJQUFJLENBQUMyM0MsWUFBWSxDQUFDOWtDLFdBQVcsQ0FBQyxJQUFJLENBQUNpMUQsU0FBUztZQUM1QyxJQUFJLENBQUNwd0IsV0FBVyxDQUFDeDNCLFlBQVksQ0FBQyxTQUFTLElBQUksQ0FBQ3pPLFNBQVMsQ0FBQ2lkLENBQUM7WUFDdkQsSUFBSSxDQUFDZ3BCLFdBQVcsQ0FBQ3gzQixZQUFZLENBQUMsVUFBVSxJQUFJLENBQUN6TyxTQUFTLENBQUNuTCxDQUFDO1FBQzFELE9BQU87WUFDTCxJQUFJLENBQUNxeEMsWUFBWSxDQUFDOWtDLFdBQVcsQ0FBQ2Q7UUFDaEM7UUFFQUEsSUFBSWdCLFdBQVcsR0FBRztRQUNsQmhCLElBQUk1UixHQUFHLEdBQUdIO1FBRVYsSUFBSSxJQUFJLENBQUNrSixJQUFJLENBQUNxM0MsRUFBRSxFQUFFO1lBQ2hCLElBQUksQ0FBQzdJLFdBQVcsQ0FBQ3gzQixZQUFZLENBQUMsTUFBTSxJQUFJLENBQUNoWCxJQUFJLENBQUNxM0MsRUFBRTtRQUNsRDtJQUNGO0lBRUEsU0FBU3duQixtQkFBbUI5c0IsYUFBYSxFQUFFbWMsTUFBTTtRQUMvQyxJQUFJLENBQUNuYyxhQUFhLEdBQUdBO1FBQ3JCLElBQUksQ0FBQ2h4QyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUM0a0IsYUFBYSxHQUFHLENBQUM7UUFDdEIsSUFBSSxDQUFDZ21CLFlBQVksR0FBRztZQUNsQnNoQixXQUFXaUIsVUFBVUEsT0FBT2pCLFNBQVMsSUFBSTtZQUN6QzlULDBCQUEwQitVLFVBQVVBLE9BQU8vVSx3QkFBd0IsSUFBSTtZQUN2RXZOLG1CQUFtQixDQUFFc2lCLENBQUFBLFVBQVVBLE9BQU90aUIsaUJBQWlCLEtBQUssS0FBSTtZQUNoRThpQixZQUFZO2dCQUNWam5ELE9BQU95bUQsVUFBVUEsT0FBT1EsVUFBVSxJQUFJUixPQUFPUSxVQUFVLENBQUNqbkQsS0FBSyxJQUFJO2dCQUNqRUMsUUFBUXdtRCxVQUFVQSxPQUFPUSxVQUFVLElBQUlSLE9BQU9RLFVBQVUsQ0FBQ2huRCxNQUFNLElBQUk7Z0JBQ25FbVMsR0FBR3EwQyxVQUFVQSxPQUFPUSxVQUFVLElBQUlSLE9BQU9RLFVBQVUsQ0FBQzcwQyxDQUFDLElBQUk7Z0JBQ3pEc0ksR0FBRytyQyxVQUFVQSxPQUFPUSxVQUFVLElBQUlSLE9BQU9RLFVBQVUsQ0FBQ3ZzQyxDQUFDLElBQUk7WUFDM0Q7UUFDRjtRQUNBLElBQUksQ0FBQ3pTLFVBQVUsR0FBRztZQUNoQndXLE1BQU07WUFDTnBGLFVBQVUsQ0FBQztZQUNYNnFCLGNBQWMsSUFBSSxDQUFDQSxZQUFZO1FBQ2pDO1FBQ0EsSUFBSSxDQUFDK0YsZUFBZSxHQUFHLEVBQUU7UUFDekIsSUFBSSxDQUFDdFgsUUFBUSxHQUFHLEVBQUU7UUFDbEIsSUFBSSxDQUFDd2pDLGNBQWMsR0FBRyxFQUFFO1FBQ3hCLElBQUksQ0FBQ3hRLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUMwUixNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUM5USxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDLzdDLFlBQVksR0FBRztJQUN0QjtJQUVBbmQsZ0JBQWdCO1FBQUNxN0M7S0FBYSxFQUFFMHVCO0lBQ2hDQSxtQkFBbUJ4cEUsU0FBUyxDQUFDZzdDLFNBQVMsR0FBRzRkLFlBQVk1NEQsU0FBUyxDQUFDZzdDLFNBQVM7SUFFeEV3dUIsbUJBQW1CeHBFLFNBQVMsQ0FBQ2k3QyxvQkFBb0IsR0FBRztRQUNsRCxNQUFPLElBQUksQ0FBQ29CLGVBQWUsQ0FBQ3Y4QyxNQUFNLENBQUU7WUFDbEMsSUFBSThGLFVBQVUsSUFBSSxDQUFDeTJDLGVBQWUsQ0FBQzdhLEdBQUc7WUFDdEM1N0IsUUFBUXc5QyxjQUFjO1FBQ3hCO0lBQ0Y7SUFFQW9tQixtQkFBbUJ4cEUsU0FBUyxDQUFDaTRELGtCQUFrQixHQUFHLFNBQVVyeUQsT0FBTyxFQUFFa3RCLEdBQUc7UUFDdEUsSUFBSTQyQyxnQkFBZ0I5akUsUUFBUW0wQyxjQUFjO1FBRTFDLElBQUksQ0FBQzJ2QixlQUFlO1lBQ2xCO1FBQ0Y7UUFFQSxJQUFJdnVCLFFBQVEsSUFBSSxDQUFDenZDLE1BQU0sQ0FBQ29uQixJQUFJO1FBRTVCLElBQUksQ0FBQ3FvQixNQUFNd3VCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQ2hSLFVBQVUsRUFBRTtZQUNsQyxJQUFJLElBQUksQ0FBQzRQLGNBQWMsRUFBRTtnQkFDdkIsSUFBSSxDQUFDcUIsZ0JBQWdCLENBQUNGLGVBQWU1MkM7WUFDdkMsT0FBTztnQkFDTCxJQUFJbHpCLElBQUk7Z0JBQ1IsSUFBSWlxRTtnQkFDSixJQUFJQztnQkFDSixJQUFJQztnQkFFSixNQUFPbnFFLElBQUlrekIsSUFBSztvQkFDZCxJQUFJLElBQUksQ0FBQ2lTLFFBQVEsQ0FBQ25sQyxFQUFFLElBQUksSUFBSSxDQUFDbWxDLFFBQVEsQ0FBQ25sQyxFQUFFLEtBQUssUUFBUSxJQUFJLENBQUNtbEMsUUFBUSxDQUFDbmxDLEVBQUUsQ0FBQ202QyxjQUFjLEVBQUU7d0JBQ3BGK3ZCLFlBQVksSUFBSSxDQUFDL2tDLFFBQVEsQ0FBQ25sQyxFQUFFO3dCQUM1Qm1xRSxnQkFBZ0IsSUFBSSxDQUFDcitELE1BQU0sQ0FBQzlMLEVBQUUsQ0FBQytwRSxHQUFHLEdBQUcsSUFBSSxDQUFDSyx1QkFBdUIsQ0FBQ3BxRSxLQUFLa3FFLFVBQVUvdkIsY0FBYzt3QkFDL0Y4dkIsaUJBQWlCRSxpQkFBaUJGO29CQUNwQztvQkFFQWpxRSxLQUFLO2dCQUNQO2dCQUVBLElBQUlpcUUsZ0JBQWdCO29CQUNsQixJQUFJLENBQUMxdUIsTUFBTXd1QixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUNoUixVQUFVLEVBQUU7d0JBQ2xDLElBQUksQ0FBQ3ZmLFlBQVksQ0FBQ2tmLFlBQVksQ0FBQ29SLGVBQWVHO29CQUNoRDtnQkFDRixPQUFPLElBQUksQ0FBQzF1QixNQUFNd3VCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQ2hSLFVBQVUsRUFBRTtvQkFDekMsSUFBSSxDQUFDdmYsWUFBWSxDQUFDOWtDLFdBQVcsQ0FBQ28xRDtnQkFDaEM7WUFDRjtRQUNGLE9BQU87WUFDTCxJQUFJLENBQUNFLGdCQUFnQixDQUFDRixlQUFlNTJDO1FBQ3ZDO0lBQ0Y7SUFFQTAyQyxtQkFBbUJ4cEUsU0FBUyxDQUFDdzdDLFdBQVcsR0FBRyxTQUFVN3dDLElBQUk7UUFDdkQsSUFBSSxDQUFDLElBQUksQ0FBQ2d1RCxVQUFVLEVBQUU7WUFDcEIsT0FBTyxJQUFJbFAsZ0JBQWdCOStDLE1BQU0sSUFBSSxDQUFDMFAsVUFBVSxFQUFFLElBQUk7UUFDeEQ7UUFFQSxPQUFPLElBQUk2cUQsY0FBY3Y2RCxNQUFNLElBQUksQ0FBQzBQLFVBQVUsRUFBRSxJQUFJO0lBQ3REO0lBRUFtdkQsbUJBQW1CeHBFLFNBQVMsQ0FBQ3k3QyxVQUFVLEdBQUcsU0FBVTl3QyxJQUFJO1FBQ3RELElBQUksQ0FBQyxJQUFJLENBQUNndUQsVUFBVSxFQUFFO1lBQ3BCLE9BQU8sSUFBSWpELHFCQUFxQi9xRCxNQUFNLElBQUksQ0FBQzBQLFVBQVUsRUFBRSxJQUFJO1FBQzdEO1FBRUEsT0FBTyxJQUFJeXNELGFBQWFuOEQsTUFBTSxJQUFJLENBQUMwUCxVQUFVLEVBQUUsSUFBSTtJQUNyRDtJQUVBbXZELG1CQUFtQnhwRSxTQUFTLENBQUMwN0MsWUFBWSxHQUFHLFNBQVUvd0MsSUFBSTtRQUN4RCxJQUFJLENBQUM4K0QsTUFBTSxHQUFHLElBQUl0QixlQUFleDlELE1BQU0sSUFBSSxDQUFDMFAsVUFBVSxFQUFFLElBQUk7UUFDNUQsT0FBTyxJQUFJLENBQUNvdkQsTUFBTTtJQUNwQjtJQUVBRCxtQkFBbUJ4cEUsU0FBUyxDQUFDbzdDLFdBQVcsR0FBRyxTQUFVendDLElBQUk7UUFDdkQsSUFBSSxDQUFDLElBQUksQ0FBQ2d1RCxVQUFVLEVBQUU7WUFDcEIsT0FBTyxJQUFJaFYsY0FBY2g1QyxNQUFNLElBQUksQ0FBQzBQLFVBQVUsRUFBRSxJQUFJO1FBQ3REO1FBRUEsT0FBTyxJQUFJZ3ZELGNBQWMxK0QsTUFBTSxJQUFJLENBQUMwUCxVQUFVLEVBQUUsSUFBSTtJQUN0RDtJQUVBbXZELG1CQUFtQnhwRSxTQUFTLENBQUNzN0MsV0FBVyxHQUFHLFNBQVUzd0MsSUFBSTtRQUN2RCxJQUFJLENBQUMsSUFBSSxDQUFDZ3VELFVBQVUsRUFBRTtZQUNwQixPQUFPLElBQUl0QixjQUFjMXNELE1BQU0sSUFBSSxDQUFDMFAsVUFBVSxFQUFFLElBQUk7UUFDdEQ7UUFFQSxPQUFPLElBQUkycUQsY0FBY3I2RCxNQUFNLElBQUksQ0FBQzBQLFVBQVUsRUFBRSxJQUFJO0lBQ3REO0lBRUFtdkQsbUJBQW1CeHBFLFNBQVMsQ0FBQ3U3QyxVQUFVLEdBQUdxZCxZQUFZNTRELFNBQVMsQ0FBQ3U3QyxVQUFVO0lBRTFFaXVCLG1CQUFtQnhwRSxTQUFTLENBQUNncUUsdUJBQXVCLEdBQUcsU0FBVWwzQyxHQUFHO1FBQ2xFLElBQUlsekIsSUFBSTtRQUNSLElBQUlDLE1BQU0sSUFBSSxDQUFDMG9FLGNBQWMsQ0FBQ3pvRSxNQUFNO1FBRXBDLE1BQU9GLElBQUlDLElBQUs7WUFDZCxJQUFJLElBQUksQ0FBQzBvRSxjQUFjLENBQUMzb0UsRUFBRSxDQUFDcXFFLFFBQVEsSUFBSW4zQyxPQUFPLElBQUksQ0FBQ3kxQyxjQUFjLENBQUMzb0UsRUFBRSxDQUFDc3FFLE1BQU0sSUFBSXAzQyxLQUFLO2dCQUNsRixPQUFPLElBQUksQ0FBQ3kxQyxjQUFjLENBQUMzb0UsRUFBRSxDQUFDNm9FLGVBQWU7WUFDL0M7WUFFQTdvRSxLQUFLO1FBQ1A7UUFFQSxPQUFPO0lBQ1Q7SUFFQTRwRSxtQkFBbUJ4cEUsU0FBUyxDQUFDbXFFLHFCQUFxQixHQUFHLFNBQVVyM0MsR0FBRyxFQUFFeHpCLElBQUk7UUFDdEUsSUFBSW1wRSxrQkFBa0JwcEUsVUFBVTtRQUNoQyxJQUFJd0c7UUFDSixJQUFJKzdEO1FBQ0pqOEQsU0FBUzhpRTtRQUNULElBQUl4dUQsWUFBWTVhLFVBQVU7UUFDMUJzRyxTQUFTc1U7UUFFVCxJQUFJM2EsU0FBUyxNQUFNO1lBQ2pCdUcsUUFBUTRpRSxnQkFBZ0I1aUUsS0FBSztZQUM3QkEsTUFBTXVNLEtBQUssR0FBRyxJQUFJLENBQUNpSSxVQUFVLENBQUNzaUMsUUFBUSxDQUFDeHNCLENBQUMsR0FBRztZQUMzQ3RxQixNQUFNd00sTUFBTSxHQUFHLElBQUksQ0FBQ2dJLFVBQVUsQ0FBQ3NpQyxRQUFRLENBQUM1MEMsQ0FBQyxHQUFHO1lBQzVDLElBQUlvbEMsU0FBUztZQUNidG5DLE1BQU1NLHFCQUFxQixHQUFHZ25DO1lBQzlCdG5DLE1BQU1nOEQsa0JBQWtCLEdBQUcxMEI7WUFDM0J0bkMsTUFBTUssZUFBZSxHQUFHaW5DO1lBQ3hCeTBCLGlCQUFpQjNuRCxVQUFVcFUsS0FBSztZQUNoQyxJQUFJZzJCLFNBQVM7WUFDYitsQyxlQUFlL25DLFNBQVMsR0FBR2dDO1lBQzNCK2xDLGVBQWVrRCxlQUFlLEdBQUdqcEM7UUFDbkM7UUFFQTRzQyxnQkFBZ0JuMEQsV0FBVyxDQUFDMkYsWUFBWSxpREFBaUQ7UUFFekYsSUFBSW13RCxzQkFBc0I7WUFDeEJud0QsV0FBV0E7WUFDWHd1RCxpQkFBaUJBO1lBQ2pCd0IsVUFBVW4zQztZQUNWbzNDLFFBQVFwM0M7WUFDUnh6QixNQUFNQTtRQUNSO1FBQ0EsSUFBSSxDQUFDaXBFLGNBQWMsQ0FBQ3BuRSxJQUFJLENBQUNpcEU7UUFDekIsT0FBT0E7SUFDVDtJQUVBWixtQkFBbUJ4cEUsU0FBUyxDQUFDcXFFLGlCQUFpQixHQUFHO1FBQy9DLElBQUl6cUU7UUFDSixJQUFJQyxNQUFNLElBQUksQ0FBQzZMLE1BQU0sQ0FBQzVMLE1BQU07UUFDNUIsSUFBSXdxRTtRQUNKLElBQUlDLG1CQUFtQjtRQUV2QixJQUFLM3FFLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCLElBQUksSUFBSSxDQUFDOEwsTUFBTSxDQUFDOUwsRUFBRSxDQUFDK3BFLEdBQUcsSUFBSSxJQUFJLENBQUNqK0QsTUFBTSxDQUFDOUwsRUFBRSxDQUFDMk0sRUFBRSxLQUFLLEdBQUc7Z0JBQ2pELElBQUlnK0QscUJBQXFCLE1BQU07b0JBQzdCQSxtQkFBbUI7b0JBQ25CRCwwQkFBMEIsSUFBSSxDQUFDSCxxQkFBcUIsQ0FBQ3ZxRSxHQUFHO2dCQUMxRDtnQkFFQTBxRSx3QkFBd0JKLE1BQU0sR0FBR2htRSxLQUFLTyxHQUFHLENBQUM2bEUsd0JBQXdCSixNQUFNLEVBQUV0cUU7WUFDNUUsT0FBTztnQkFDTCxJQUFJMnFFLHFCQUFxQixNQUFNO29CQUM3QkEsbUJBQW1CO29CQUNuQkQsMEJBQTBCLElBQUksQ0FBQ0gscUJBQXFCLENBQUN2cUUsR0FBRztnQkFDMUQ7Z0JBRUEwcUUsd0JBQXdCSixNQUFNLEdBQUdobUUsS0FBS08sR0FBRyxDQUFDNmxFLHdCQUF3QkosTUFBTSxFQUFFdHFFO1lBQzVFO1FBQ0Y7UUFFQUMsTUFBTSxJQUFJLENBQUMwb0UsY0FBYyxDQUFDem9FLE1BQU07UUFFaEMsSUFBS0YsSUFBSUMsTUFBTSxHQUFHRCxLQUFLLEdBQUdBLEtBQUssRUFBRztZQUNoQyxJQUFJLENBQUM0cUUsV0FBVyxDQUFDbDJELFdBQVcsQ0FBQyxJQUFJLENBQUNpMEQsY0FBYyxDQUFDM29FLEVBQUUsQ0FBQzZvRSxlQUFlO1FBQ3JFO0lBQ0Y7SUFFQWUsbUJBQW1CeHBFLFNBQVMsQ0FBQzRwRSxnQkFBZ0IsR0FBRyxTQUFVanBELElBQUksRUFBRW1TLEdBQUc7UUFDakUsSUFBSWx6QixJQUFJO1FBQ1IsSUFBSUMsTUFBTSxJQUFJLENBQUMwb0UsY0FBYyxDQUFDem9FLE1BQU07UUFFcEMsTUFBT0YsSUFBSUMsSUFBSztZQUNkLElBQUlpekIsT0FBTyxJQUFJLENBQUN5MUMsY0FBYyxDQUFDM29FLEVBQUUsQ0FBQ3NxRSxNQUFNLEVBQUU7Z0JBQ3hDLElBQUlyK0QsSUFBSSxJQUFJLENBQUMwOEQsY0FBYyxDQUFDM29FLEVBQUUsQ0FBQ3FxRSxRQUFRO2dCQUN2QyxJQUFJNVI7Z0JBRUosTUFBT3hzRCxJQUFJaW5CLElBQUs7b0JBQ2QsSUFBSSxJQUFJLENBQUNpUyxRQUFRLENBQUNsNUIsRUFBRSxJQUFJLElBQUksQ0FBQ2s1QixRQUFRLENBQUNsNUIsRUFBRSxDQUFDa3VDLGNBQWMsRUFBRTt3QkFDdkRzZSxjQUFjLElBQUksQ0FBQ3R6QixRQUFRLENBQUNsNUIsRUFBRSxDQUFDa3VDLGNBQWM7b0JBQy9DO29CQUVBbHVDLEtBQUs7Z0JBQ1A7Z0JBRUEsSUFBSXdzRCxhQUFhO29CQUNmLElBQUksQ0FBQ2tRLGNBQWMsQ0FBQzNvRSxFQUFFLENBQUNxYSxTQUFTLENBQUNxK0MsWUFBWSxDQUFDMzNDLE1BQU0wM0M7Z0JBQ3RELE9BQU87b0JBQ0wsSUFBSSxDQUFDa1EsY0FBYyxDQUFDM29FLEVBQUUsQ0FBQ3FhLFNBQVMsQ0FBQzNGLFdBQVcsQ0FBQ3FNO2dCQUMvQztnQkFFQTtZQUNGO1lBRUEvZ0IsS0FBSztRQUNQO0lBQ0Y7SUFFQTRwRSxtQkFBbUJ4cEUsU0FBUyxDQUFDMFosZUFBZSxHQUFHLFNBQVUyQyxRQUFRO1FBQy9ELElBQUltdUQsY0FBY25yRSxVQUFVO1FBQzVCLElBQUkyYSxVQUFVLElBQUksQ0FBQzBpQyxhQUFhLENBQUMxaUMsT0FBTztRQUN4QyxJQUFJblUsUUFBUTJrRSxZQUFZM2tFLEtBQUs7UUFDN0JBLE1BQU11TSxLQUFLLEdBQUdpSyxTQUFTOFQsQ0FBQyxHQUFHO1FBQzNCdHFCLE1BQU13TSxNQUFNLEdBQUdnSyxTQUFTdFUsQ0FBQyxHQUFHO1FBQzVCLElBQUksQ0FBQ3lpRSxXQUFXLEdBQUdBO1FBQ25CN2tFLFNBQVM2a0U7UUFDVDNrRSxNQUFNUyxjQUFjLEdBQUc7UUFDdkJULE1BQU1XLGlCQUFpQixHQUFHO1FBQzFCWCxNQUFNVSxvQkFBb0IsR0FBRztRQUU3QixJQUFJLElBQUksQ0FBQyt2QyxZQUFZLENBQUNzaEIsU0FBUyxFQUFFO1lBQy9CNFMsWUFBWTdvRCxZQUFZLENBQUMsU0FBUyxJQUFJLENBQUMyMEIsWUFBWSxDQUFDc2hCLFNBQVM7UUFDL0Q7UUFFQTU5QyxRQUFRMUYsV0FBVyxDQUFDazJEO1FBQ3BCM2tFLE1BQU00a0UsUUFBUSxHQUFHO1FBQ2pCLElBQUl0USxNQUFNcHdELFNBQVM7UUFDbkJvd0QsSUFBSXg0QyxZQUFZLENBQUMsU0FBUztRQUMxQnc0QyxJQUFJeDRDLFlBQVksQ0FBQyxVQUFVO1FBQzNCaGMsU0FBU3cwRDtRQUNULElBQUksQ0FBQ3FRLFdBQVcsQ0FBQ2wyRCxXQUFXLENBQUM2bEQ7UUFDN0IsSUFBSTcvQyxPQUFPdlEsU0FBUztRQUNwQm93RCxJQUFJN2xELFdBQVcsQ0FBQ2dHO1FBQ2hCLElBQUksQ0FBQzNQLElBQUksR0FBRzBSLFVBQVUsaUJBQWlCO1FBRXZDLElBQUksQ0FBQ21nQyxlQUFlLENBQUNuZ0MsVUFBVTg5QztRQUMvQixJQUFJLENBQUM5L0MsVUFBVSxDQUFDQyxJQUFJLEdBQUdBO1FBQ3ZCLElBQUksQ0FBQzVPLE1BQU0sR0FBRzJRLFNBQVMzUSxNQUFNO1FBQzdCLElBQUksQ0FBQzB0QyxZQUFZLEdBQUcsSUFBSSxDQUFDb3hCLFdBQVc7UUFDcEMsSUFBSSxDQUFDSCxpQkFBaUI7UUFDdEIsSUFBSSxDQUFDbnRELG1CQUFtQjtJQUMxQjtJQUVBc3NELG1CQUFtQnhwRSxTQUFTLENBQUNtVixPQUFPLEdBQUc7UUFDckMsSUFBSSxJQUFJLENBQUN1bkMsYUFBYSxDQUFDMWlDLE9BQU8sRUFBRTtZQUM5QixJQUFJLENBQUMwaUMsYUFBYSxDQUFDMWlDLE9BQU8sQ0FBQzhILFNBQVMsR0FBRztRQUN6QztRQUVBLElBQUksQ0FBQzQ2QixhQUFhLENBQUN6aUMsU0FBUyxHQUFHO1FBQy9CLElBQUksQ0FBQ0ksVUFBVSxDQUFDQyxJQUFJLEdBQUc7UUFDdkIsSUFBSTFhO1FBQ0osSUFBSUMsTUFBTSxJQUFJLENBQUM2TCxNQUFNLEdBQUcsSUFBSSxDQUFDQSxNQUFNLENBQUM1TCxNQUFNLEdBQUc7UUFFN0MsSUFBS0YsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDM0IsSUFBSSxJQUFJLENBQUNtbEMsUUFBUSxDQUFDbmxDLEVBQUUsSUFBSSxJQUFJLENBQUNtbEMsUUFBUSxDQUFDbmxDLEVBQUUsQ0FBQ3VWLE9BQU8sRUFBRTtnQkFDaEQsSUFBSSxDQUFDNHZCLFFBQVEsQ0FBQ25sQyxFQUFFLENBQUN1VixPQUFPO1lBQzFCO1FBQ0Y7UUFFQSxJQUFJLENBQUM0dkIsUUFBUSxDQUFDamxDLE1BQU0sR0FBRztRQUN2QixJQUFJLENBQUNpNEQsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ3JiLGFBQWEsR0FBRztJQUN2QjtJQUVBOHNCLG1CQUFtQnhwRSxTQUFTLENBQUNrZCxtQkFBbUIsR0FBRztRQUNqRCxJQUFJK2tELGVBQWUsSUFBSSxDQUFDdmxCLGFBQWEsQ0FBQzFpQyxPQUFPLENBQUMwMkIsV0FBVztRQUN6RCxJQUFJd3hCLGdCQUFnQixJQUFJLENBQUN4bEIsYUFBYSxDQUFDMWlDLE9BQU8sQ0FBQ21vRCxZQUFZO1FBQzNELElBQUlFLGFBQWFKLGVBQWVDO1FBQ2hDLElBQUlJLGVBQWUsSUFBSSxDQUFDam9ELFVBQVUsQ0FBQ3NpQyxRQUFRLENBQUN4c0IsQ0FBQyxHQUFHLElBQUksQ0FBQzlWLFVBQVUsQ0FBQ3NpQyxRQUFRLENBQUM1MEMsQ0FBQztRQUMxRSxJQUFJbXhCO1FBQ0osSUFBSS9DO1FBQ0osSUFBSXdEO1FBQ0osSUFBSXB0QjtRQUVKLElBQUkrMUQsZUFBZUQsWUFBWTtZQUM3Qm5wQyxLQUFLK29DLGVBQWUsSUFBSSxDQUFDNW5ELFVBQVUsQ0FBQ3NpQyxRQUFRLENBQUN4c0IsQ0FBQztZQUM5Q2dHLEtBQUs4ckMsZUFBZSxJQUFJLENBQUM1bkQsVUFBVSxDQUFDc2lDLFFBQVEsQ0FBQ3hzQixDQUFDO1lBQzlDd0osS0FBSztZQUNMcHRCLEtBQUssQ0FBQzIxRCxnQkFBZ0IsSUFBSSxDQUFDN25ELFVBQVUsQ0FBQ3NpQyxRQUFRLENBQUM1MEMsQ0FBQyxHQUFJazZELENBQUFBLGVBQWUsSUFBSSxDQUFDNW5ELFVBQVUsQ0FBQ3NpQyxRQUFRLENBQUN4c0IsQ0FBQyxLQUFLO1FBQ3BHLE9BQU87WUFDTCtJLEtBQUtncEMsZ0JBQWdCLElBQUksQ0FBQzduRCxVQUFVLENBQUNzaUMsUUFBUSxDQUFDNTBDLENBQUM7WUFDL0NvdUIsS0FBSytyQyxnQkFBZ0IsSUFBSSxDQUFDN25ELFVBQVUsQ0FBQ3NpQyxRQUFRLENBQUM1MEMsQ0FBQztZQUMvQzR4QixLQUFLLENBQUNzb0MsZUFBZSxJQUFJLENBQUM1bkQsVUFBVSxDQUFDc2lDLFFBQVEsQ0FBQ3hzQixDQUFDLEdBQUkreEMsQ0FBQUEsZ0JBQWdCLElBQUksQ0FBQzduRCxVQUFVLENBQUNzaUMsUUFBUSxDQUFDNTBDLENBQUMsS0FBSztZQUNsR3dFLEtBQUs7UUFDUDtRQUVBLElBQUkxRyxRQUFRLElBQUksQ0FBQzJrRSxXQUFXLENBQUMza0UsS0FBSztRQUNsQ0EsTUFBTWkvRCxlQUFlLEdBQUcsY0FBYzVyQyxLQUFLLGNBQWMvQyxLQUFLLGtCQUFrQndELEtBQUssTUFBTXB0QixLQUFLO1FBQ2hHMUcsTUFBTWcwQixTQUFTLEdBQUdoMEIsTUFBTWkvRCxlQUFlO0lBQ3pDO0lBRUEwRSxtQkFBbUJ4cEUsU0FBUyxDQUFDb2QsV0FBVyxHQUFHdzdDLFlBQVk1NEQsU0FBUyxDQUFDb2QsV0FBVztJQUU1RW9zRCxtQkFBbUJ4cEUsU0FBUyxDQUFDMGYsSUFBSSxHQUFHO1FBQ2xDLElBQUksQ0FBQzhxRCxXQUFXLENBQUMza0UsS0FBSyxDQUFDSSxPQUFPLEdBQUc7SUFDbkM7SUFFQXVqRSxtQkFBbUJ4cEUsU0FBUyxDQUFDMmYsSUFBSSxHQUFHO1FBQ2xDLElBQUksQ0FBQzZxRCxXQUFXLENBQUMza0UsS0FBSyxDQUFDSSxPQUFPLEdBQUc7SUFDbkM7SUFFQXVqRSxtQkFBbUJ4cEUsU0FBUyxDQUFDNmMsU0FBUyxHQUFHO1FBQ3ZDLElBQUksQ0FBQysrQixhQUFhO1FBRWxCLElBQUksSUFBSSxDQUFDNnRCLE1BQU0sRUFBRTtZQUNmLElBQUksQ0FBQ0EsTUFBTSxDQUFDbkIsS0FBSztRQUNuQixPQUFPO1lBQ0wsSUFBSW9DLFNBQVMsSUFBSSxDQUFDcndELFVBQVUsQ0FBQ3NpQyxRQUFRLENBQUN4c0IsQ0FBQztZQUN2QyxJQUFJdzZDLFVBQVUsSUFBSSxDQUFDdHdELFVBQVUsQ0FBQ3NpQyxRQUFRLENBQUM1MEMsQ0FBQztZQUN4QyxJQUFJbkk7WUFDSixJQUFJQyxNQUFNLElBQUksQ0FBQzBvRSxjQUFjLENBQUN6b0UsTUFBTTtZQUVwQyxJQUFLRixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztnQkFDM0IsSUFBSWlHLFFBQVEsSUFBSSxDQUFDMGlFLGNBQWMsQ0FBQzNvRSxFQUFFLENBQUM2b0UsZUFBZSxDQUFDNWlFLEtBQUs7Z0JBQ3hEQSxNQUFNOGlFLGlCQUFpQixHQUFHemtFLEtBQUtHLElBQUksQ0FBQ0gsS0FBS0MsR0FBRyxDQUFDdW1FLFFBQVEsS0FBS3htRSxLQUFLQyxHQUFHLENBQUN3bUUsU0FBUyxNQUFNO2dCQUNsRjlrRSxNQUFNNmlFLFdBQVcsR0FBRzdpRSxNQUFNOGlFLGlCQUFpQjtZQUM3QztRQUNGO0lBQ0Y7SUFFQWEsbUJBQW1CeHBFLFNBQVMsQ0FBQ3VjLHVCQUF1QixHQUFHLFNBQVV4UCxNQUFNO1FBQ3JFLElBQUluTjtRQUNKLElBQUlDLE1BQU1rTixPQUFPak4sTUFBTTtRQUN2QixJQUFJOHFFLG9CQUFvQnZyRSxVQUFVO1FBRWxDLElBQUtPLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1lBQzNCLElBQUltTixNQUFNLENBQUNuTixFQUFFLENBQUMrWCxFQUFFLEVBQUU7Z0JBQ2hCLElBQUl6SyxPQUFPLElBQUksQ0FBQ211QyxVQUFVLENBQUN0dUMsTUFBTSxDQUFDbk4sRUFBRSxFQUFFZ3JFLG1CQUFtQixJQUFJLENBQUN2d0QsVUFBVSxDQUFDbk4sSUFBSSxFQUFFO2dCQUMvRUEsS0FBSzBPLGVBQWU7Z0JBQ3BCLElBQUksQ0FBQ3ZCLFVBQVUsQ0FBQ2QsZ0JBQWdCLENBQUNqQyxtQkFBbUIsQ0FBQ3BLO1lBQ3ZEO1FBQ0Y7SUFDRjtJQUVBLFNBQVMyOUQsYUFBYWxnRSxJQUFJLEVBQUUwUCxVQUFVLEVBQUVuTixJQUFJO1FBQzFDLElBQUksQ0FBQ3hCLE1BQU0sR0FBR2YsS0FBS2UsTUFBTTtRQUN6QixJQUFJLENBQUNpdEQsVUFBVSxHQUFHLENBQUNodUQsS0FBS3VCLE9BQU87UUFDL0IsSUFBSSxDQUFDVCxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDNHdDLGVBQWUsR0FBRyxFQUFFO1FBQ3pCLElBQUksQ0FBQ3RYLFFBQVEsR0FBRyxJQUFJLENBQUNyNUIsTUFBTSxHQUFHMUksaUJBQWlCLElBQUksQ0FBQzBJLE1BQU0sQ0FBQzVMLE1BQU0sSUFBSSxFQUFFO1FBQ3ZFLElBQUksQ0FBQ3lqRCxXQUFXLENBQUM1NEMsTUFBTTBQLFlBQVluTjtRQUNuQyxJQUFJLENBQUM0SixFQUFFLEdBQUduTSxLQUFLbU0sRUFBRSxHQUFHaWIsZ0JBQWdCQyxPQUFPLENBQUMsSUFBSSxFQUFFcm5CLEtBQUttTSxFQUFFLEVBQUUsR0FBR3VELFdBQVc5QixTQUFTLEVBQUUsSUFBSSxJQUFJO1lBQzFGaWlDLGNBQWM7UUFDaEI7SUFDRjtJQUVBLzZDLGdCQUFnQjtRQUFDK3BFO1FBQW9CalI7UUFBY2tNO0tBQWEsRUFBRW9HO0lBQ2xFQSxhQUFhN3FFLFNBQVMsQ0FBQzhxRSw0QkFBNEIsR0FBR0QsYUFBYTdxRSxTQUFTLENBQUN1aEQsdUJBQXVCO0lBRXBHc3BCLGFBQWE3cUUsU0FBUyxDQUFDdWhELHVCQUF1QixHQUFHO1FBQy9DLElBQUksQ0FBQ3VwQiw0QkFBNEIsSUFBSSxrRkFBa0Y7UUFHdkgsSUFBSSxJQUFJLENBQUNuZ0UsSUFBSSxDQUFDdUIsT0FBTyxFQUFFO1lBQ3JCLElBQUksQ0FBQ3NyRCxVQUFVLENBQUM3MUMsWUFBWSxDQUFDLFNBQVMsSUFBSSxDQUFDaFgsSUFBSSxDQUFDd2xCLENBQUM7WUFDakQsSUFBSSxDQUFDcW5DLFVBQVUsQ0FBQzcxQyxZQUFZLENBQUMsVUFBVSxJQUFJLENBQUNoWCxJQUFJLENBQUM1QyxDQUFDO1lBQ2xELElBQUksQ0FBQzA1QyxrQkFBa0IsR0FBRyxJQUFJLENBQUN0SSxXQUFXO1FBQzVDLE9BQU87WUFDTCxJQUFJLENBQUNzSSxrQkFBa0IsR0FBRyxJQUFJLENBQUNySSxZQUFZO1FBQzdDO0lBQ0Y7SUFFQXl4QixhQUFhN3FFLFNBQVMsQ0FBQzRwRSxnQkFBZ0IsR0FBRyxTQUFVanBELElBQUksRUFBRW1TLEdBQUc7UUFDM0QsSUFBSWpuQixJQUFJO1FBQ1IsSUFBSXdzRDtRQUVKLE1BQU94c0QsSUFBSWluQixJQUFLO1lBQ2QsSUFBSSxJQUFJLENBQUNpUyxRQUFRLENBQUNsNUIsRUFBRSxJQUFJLElBQUksQ0FBQ2s1QixRQUFRLENBQUNsNUIsRUFBRSxDQUFDa3VDLGNBQWMsRUFBRTtnQkFDdkRzZSxjQUFjLElBQUksQ0FBQ3R6QixRQUFRLENBQUNsNUIsRUFBRSxDQUFDa3VDLGNBQWM7WUFDL0M7WUFFQWx1QyxLQUFLO1FBQ1A7UUFFQSxJQUFJd3NELGFBQWE7WUFDZixJQUFJLENBQUNqZixZQUFZLENBQUNrZixZQUFZLENBQUMzM0MsTUFBTTAzQztRQUN2QyxPQUFPO1lBQ0wsSUFBSSxDQUFDamYsWUFBWSxDQUFDOWtDLFdBQVcsQ0FBQ3FNO1FBQ2hDO0lBQ0Y7SUFFQWtxRCxhQUFhN3FFLFNBQVMsQ0FBQ3E3QyxVQUFVLEdBQUcsU0FBVTF3QyxJQUFJO1FBQ2hELElBQUksQ0FBQyxJQUFJLENBQUNndUQsVUFBVSxFQUFFO1lBQ3BCLE9BQU8sSUFBSTVCLGVBQWVwc0QsTUFBTSxJQUFJLENBQUMwUCxVQUFVLEVBQUUsSUFBSTtRQUN2RDtRQUVBLE9BQU8sSUFBSXd3RCxhQUFhbGdFLE1BQU0sSUFBSSxDQUFDMFAsVUFBVSxFQUFFLElBQUk7SUFDckQ7SUFFQSxTQUFTMHdELGVBQWVydUIsYUFBYSxFQUFFbWMsTUFBTTtRQUMzQyxJQUFJLENBQUNuYyxhQUFhLEdBQUdBO1FBQ3JCLElBQUksQ0FBQ2h4QyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUM0a0IsYUFBYSxHQUFHLENBQUM7UUFDdEIsSUFBSSxDQUFDZ21CLFlBQVksR0FBRztZQUNsQnNoQixXQUFXaUIsVUFBVUEsT0FBT2pCLFNBQVMsSUFBSTtZQUN6QzlULDBCQUEwQitVLFVBQVVBLE9BQU8vVSx3QkFBd0IsSUFBSTtZQUN2RXZOLG1CQUFtQixDQUFFc2lCLENBQUFBLFVBQVVBLE9BQU90aUIsaUJBQWlCLEtBQUssS0FBSTtZQUNoRThpQixZQUFZO2dCQUNWam5ELE9BQU95bUQsVUFBVUEsT0FBT1EsVUFBVSxJQUFJUixPQUFPUSxVQUFVLENBQUNqbkQsS0FBSyxJQUFJO2dCQUNqRUMsUUFBUXdtRCxVQUFVQSxPQUFPUSxVQUFVLElBQUlSLE9BQU9RLFVBQVUsQ0FBQ2huRCxNQUFNLElBQUk7Z0JBQ25FbVMsR0FBR3EwQyxVQUFVQSxPQUFPUSxVQUFVLElBQUlSLE9BQU9RLFVBQVUsQ0FBQzcwQyxDQUFDLElBQUk7Z0JBQ3pEc0ksR0FBRytyQyxVQUFVQSxPQUFPUSxVQUFVLElBQUlSLE9BQU9RLFVBQVUsQ0FBQ3ZzQyxDQUFDLElBQUk7WUFDM0Q7WUFDQXdzQyxnQkFBZ0IsQ0FBQ1QsVUFBVUEsT0FBT1MsY0FBYyxLQUFLOStDLGFBQWFxK0MsT0FBT1MsY0FBYztRQUN6RjtRQUNBLElBQUksQ0FBQ2ovQyxVQUFVLEdBQUc7WUFDaEJ3VyxNQUFNO1lBQ05wRixVQUFVLENBQUM7WUFDWDZxQixjQUFjLElBQUksQ0FBQ0EsWUFBWTtRQUNqQztRQUNBLElBQUksQ0FBQytGLGVBQWUsR0FBRyxFQUFFO1FBQ3pCLElBQUksQ0FBQ3RYLFFBQVEsR0FBRyxFQUFFO1FBQ2xCLElBQUksQ0FBQ3dqQyxjQUFjLEdBQUcsRUFBRTtRQUN4QixJQUFJLENBQUN4USxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDMFIsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDOVEsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQy83QyxZQUFZLEdBQUc7SUFDdEI7SUFFQW5kLGdCQUFnQjtRQUFDK3BFO0tBQW1CLEVBQUV1QjtJQUV0Q0EsZUFBZS9xRSxTQUFTLENBQUNxN0MsVUFBVSxHQUFHLFNBQVUxd0MsSUFBSTtRQUNsRCxJQUFJLENBQUMsSUFBSSxDQUFDZ3VELFVBQVUsRUFBRTtZQUNwQixPQUFPLElBQUk1QixlQUFlcHNELE1BQU0sSUFBSSxDQUFDMFAsVUFBVSxFQUFFLElBQUk7UUFDdkQ7UUFFQSxPQUFPLElBQUl3d0QsYUFBYWxnRSxNQUFNLElBQUksQ0FBQzBQLFVBQVUsRUFBRSxJQUFJO0lBQ3JEO0lBRUEsSUFBSSs5QiwwQkFBMEI7UUFDNUIsT0FBTyxTQUFVbHJDLElBQUk7WUFDbkIsU0FBUzg5RCxtQkFBbUI1ekQsSUFBSTtnQkFDOUIsSUFBSXhYLElBQUk7Z0JBQ1IsSUFBSUMsTUFBTXFOLEtBQUt4QixNQUFNLENBQUM1TCxNQUFNO2dCQUU1QixNQUFPRixJQUFJQyxJQUFLO29CQUNkLElBQUlxTixLQUFLeEIsTUFBTSxDQUFDOUwsRUFBRSxDQUFDNlgsRUFBRSxLQUFLTCxRQUFRbEssS0FBS3hCLE1BQU0sQ0FBQzlMLEVBQUUsQ0FBQ2d0QixHQUFHLEtBQUt4VixNQUFNO3dCQUM3RCxPQUFPbEssS0FBSzYzQixRQUFRLENBQUNubEMsRUFBRSxDQUFDeTRDLGNBQWM7b0JBQ3hDO29CQUVBejRDLEtBQUs7Z0JBQ1A7Z0JBRUEsT0FBTyxNQUFNLHlCQUF5QjtZQUN4QztZQUVBTSxPQUFPK3FFLGNBQWMsQ0FBQ0Qsb0JBQW9CLFNBQVM7Z0JBQ2pEN3JFLE9BQU8rTixLQUFLdkMsSUFBSSxDQUFDOE0sRUFBRTtZQUNyQjtZQUNBdXpELG1CQUFtQjd2QixLQUFLLEdBQUc2dkI7WUFDM0JBLG1CQUFtQkUsV0FBVyxHQUFHO1lBQ2pDRixtQkFBbUIzNEQsTUFBTSxHQUFHbkYsS0FBS3ZDLElBQUksQ0FBQzVDLENBQUMsSUFBSW1GLEtBQUttTixVQUFVLENBQUNzaUMsUUFBUSxDQUFDNTBDLENBQUM7WUFDckVpakUsbUJBQW1CNTRELEtBQUssR0FBR2xGLEtBQUt2QyxJQUFJLENBQUN3bEIsQ0FBQyxJQUFJampCLEtBQUttTixVQUFVLENBQUNzaUMsUUFBUSxDQUFDeHNCLENBQUM7WUFDcEU2NkMsbUJBQW1CRSxXQUFXLEdBQUc7WUFDakNGLG1CQUFtQkcsYUFBYSxHQUFHLElBQUlqK0QsS0FBS21OLFVBQVUsQ0FBQzlCLFNBQVM7WUFDaEV5eUQsbUJBQW1CSSxnQkFBZ0IsR0FBRztZQUN0Q0osbUJBQW1CSyxTQUFTLEdBQUduK0QsS0FBS3hCLE1BQU0sQ0FBQzVMLE1BQU07WUFDakQsT0FBT2tyRTtRQUNUO0lBQ0Y7SUFFQSxTQUFTTSxVQUFVbG9FLEdBQUc7UUFBSTtRQUEyQixJQUFJLE9BQU9DLFdBQVcsY0FBYyxPQUFPQSxPQUFPQyxRQUFRLEtBQUssVUFBVTtZQUFFZ29FLFlBQVksU0FBUy9uRSxRQUFRSCxHQUFHO2dCQUFJLE9BQU8sT0FBT0E7WUFBSztRQUFHLE9BQU87WUFBRWtvRSxZQUFZLFNBQVMvbkUsUUFBUUgsR0FBRztnQkFBSSxPQUFPQSxPQUFPLE9BQU9DLFdBQVcsY0FBY0QsSUFBSUksV0FBVyxLQUFLSCxVQUFVRCxRQUFRQyxPQUFPckQsU0FBUyxHQUFHLFdBQVcsT0FBT29EO1lBQUs7UUFBRztRQUFFLE9BQU9rb0UsVUFBVWxvRTtJQUFNO0lBRWpZLGtCQUFrQixHQUVsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNCQyxHQUNELFNBQVNtb0UsV0FBVzFsRCxJQUFJLEVBQUVXLElBQUk7UUFDNUIsRUFBRTtRQUNGLDBEQUEwRDtRQUMxRCxFQUFFO1FBQ0YsSUFBSXRvQixTQUFTLElBQUksRUFDYmtVLFFBQVEsS0FDUixrQ0FBa0M7UUFDdENvNUQsU0FBUyxHQUNMLDJDQUEyQztRQUMvQ0MsU0FBUyxJQUNMLDhDQUE4QztRQUNsREMsVUFBVSxVQUNOLG9EQUFvRDtRQUN4REMsYUFBYW5sRCxLQUFLcmlCLEdBQUcsQ0FBQ2lPLE9BQU9vNUQsU0FDekJJLGVBQWVwbEQsS0FBS3JpQixHQUFHLENBQUMsR0FBR3NuRSxTQUMzQmhCLFdBQVdtQixlQUFlLEdBQzFCdHNCLE9BQU9sdEMsUUFBUSxHQUNmeTVELFlBQVksb0RBQW9EO1FBQ3BFLEVBQUU7UUFDRixlQUFlO1FBQ2YsbURBQW1EO1FBQ25ELEVBQUU7UUFFRixTQUFTQyxXQUFXQyxJQUFJLEVBQUVDLE9BQU8sRUFBRTE3RCxRQUFRO1lBQ3pDLElBQUkwSCxNQUFNLEVBQUU7WUFDWmcwRCxVQUFVQSxZQUFZLE9BQU87Z0JBQzNCQyxTQUFTO1lBQ1gsSUFBSUQsV0FBVyxDQUFDLEdBQUcscUVBQXFFO1lBRXhGLElBQUlFLFlBQVlDLE9BQU9DLFFBQVFKLFFBQVFDLE9BQU8sR0FBRztnQkFBQ0Y7Z0JBQU1NLFNBQVN4bUQ7YUFBTSxHQUFHa21ELFNBQVMsT0FBT08sYUFBYVAsTUFBTSxJQUFJL3pELE1BQU0sZ0RBQWdEO1lBRXZLLElBQUl1MEQsT0FBTyxJQUFJQyxLQUFLeDBELE1BQU0sZ0VBQWdFO1lBQzFGLGlFQUFpRTtZQUVqRSxJQUFJeTBELE9BQU8sU0FBU0E7Z0JBQ2xCLElBQUkxL0MsSUFBSXcvQyxLQUFLcGtFLENBQUMsQ0FBQ3FqRSxTQUNYLG9DQUFvQztnQkFDeEM5aUUsSUFBSWlqRSxZQUNBLGdDQUFnQztnQkFDcENubkQsSUFBSSxHQUFHLDhCQUE4QjtnQkFFckMsTUFBT3VJLElBQUk2K0MsYUFBYztvQkFDdkIsb0NBQW9DO29CQUNwQzcrQyxJQUFJLENBQUNBLElBQUl2SSxDQUFBQSxJQUFLcFMsT0FBTywyQkFBMkI7b0JBRWhEMUosS0FBSzBKLE9BQU8saUNBQWlDO29CQUU3Q29TLElBQUkrbkQsS0FBS3BrRSxDQUFDLENBQUMsSUFBSSxnQ0FBZ0M7Z0JBQ2pEO2dCQUVBLE1BQU80a0IsS0FBSzA5QyxTQUFVO29CQUNwQixzQ0FBc0M7b0JBQ3RDMTlDLEtBQUssR0FBRyxnQ0FBZ0M7b0JBRXhDcmtCLEtBQUssR0FBRyxtQ0FBbUM7b0JBRTNDOGIsT0FBTyxHQUFHLHNDQUFzQztnQkFDbEQ7Z0JBRUEsT0FBTyxDQUFDdUksSUFBSXZJLENBQUFBLElBQUs5YixHQUFHLGlDQUFpQztZQUN2RDtZQUVBK2pFLEtBQUtDLEtBQUssR0FBRztnQkFDWCxPQUFPSCxLQUFLcGtFLENBQUMsQ0FBQyxLQUFLO1lBQ3JCO1lBRUFza0UsS0FBS0UsS0FBSyxHQUFHO2dCQUNYLE9BQU9KLEtBQUtwa0UsQ0FBQyxDQUFDLEtBQUs7WUFDckI7WUFFQXNrRSxJQUFJLENBQUMsU0FBUyxHQUFHQSxNQUFNLCtDQUErQztZQUV0RU4sT0FBT0UsU0FBU0UsS0FBS0ssQ0FBQyxHQUFHL21ELE9BQU8sMkVBQTJFO1lBRTNHLE9BQU8sQ0FBQ21tRCxRQUFRYSxJQUFJLElBQUl2OEQsWUFBWSxTQUFVbThELElBQUksRUFBRVYsSUFBSSxFQUFFZSxZQUFZLEVBQUVDLEtBQUs7Z0JBQzNFLElBQUlBLE9BQU87b0JBQ1QsaUVBQWlFO29CQUNqRSxJQUFJQSxNQUFNSCxDQUFDLEVBQUU7d0JBQ1hJLEtBQUtELE9BQU9SO29CQUNkLEVBQUUsaUVBQWlFO29CQUduRUUsS0FBS00sS0FBSyxHQUFHO3dCQUNYLE9BQU9DLEtBQUtULE1BQU0sQ0FBQztvQkFDckI7Z0JBQ0YsRUFBRSw0REFBNEQ7Z0JBQzlELHVFQUF1RTtnQkFHdkUsSUFBSU8sY0FBYztvQkFDaEJ0bUQsSUFBSSxDQUFDa2xELFFBQVEsR0FBR2U7b0JBQ2hCLE9BQU9WO2dCQUNULE9BRUssT0FBT1U7WUFDZCxHQUFHQSxNQUFNUCxXQUFXLFlBQVlGLFVBQVVBLFFBQVE5dEUsTUFBTSxHQUFHLElBQUksSUFBSXNvQixNQUFNd2xELFFBQVFlLEtBQUs7UUFDeEY7UUFFQXZtRCxJQUFJLENBQUMsU0FBU2tsRCxRQUFRLEdBQUdJLFlBQVksRUFBRTtRQUN2QyxPQUFPO1FBQ1AsRUFBRTtRQUNGLHNFQUFzRTtRQUN0RSx3RUFBd0U7UUFDeEUsRUFBRTtRQUNGLHVFQUF1RTtRQUN2RSxzRUFBc0U7UUFDdEUsaURBQWlEO1FBQ2pELEVBQUU7UUFFRixTQUFTVSxLQUFLeDBELEdBQUc7WUFDZixJQUFJeFAsR0FDQXlrRSxTQUFTajFELElBQUlsWSxNQUFNLEVBQ25Cb3RFLEtBQUssSUFBSSxFQUNUdHRFLElBQUksR0FDSmlNLElBQUlxaEUsR0FBR3R0RSxDQUFDLEdBQUdzdEUsR0FBR3JoRSxDQUFDLEdBQUcsR0FDbEI3RCxJQUFJa2xFLEdBQUdOLENBQUMsR0FBRyxFQUFFLEVBQUUsc0NBQXNDO1lBRXpELElBQUksQ0FBQ0ssUUFBUTtnQkFDWGoxRCxNQUFNO29CQUFDaTFEO2lCQUFTO1lBQ2xCLEVBQUUsd0RBQXdEO1lBRzFELE1BQU9ydEUsSUFBSXdTLE1BQU87Z0JBQ2hCcEssQ0FBQyxDQUFDcEksRUFBRSxHQUFHQTtZQUNUO1lBRUEsSUFBS0EsSUFBSSxHQUFHQSxJQUFJd1MsT0FBT3hTLElBQUs7Z0JBQzFCb0ksQ0FBQyxDQUFDcEksRUFBRSxHQUFHb0ksQ0FBQyxDQUFDNkQsSUFBSXl6QyxPQUFPenpDLElBQUltTSxHQUFHLENBQUNwWSxJQUFJcXRFLE9BQU8sR0FBSXprRSxDQUFBQSxJQUFJUixDQUFDLENBQUNwSSxFQUFFLEVBQUU7Z0JBQ3JEb0ksQ0FBQyxDQUFDNkQsRUFBRSxHQUFHckQ7WUFDVCxFQUFFLGlFQUFpRTtZQUduRTBrRSxHQUFHL2tFLENBQUMsR0FBRyxTQUFVa2tDLEtBQUs7Z0JBQ3BCLHdFQUF3RTtnQkFDeEUsSUFBSTdqQyxHQUNBTixJQUFJLEdBQ0p0SSxJQUFJc3RFLEdBQUd0dEUsQ0FBQyxFQUNSaU0sSUFBSXFoRSxHQUFHcmhFLENBQUMsRUFDUjdELElBQUlrbEUsR0FBR04sQ0FBQztnQkFFWixNQUFPdmdDLFFBQVM7b0JBQ2Q3akMsSUFBSVIsQ0FBQyxDQUFDcEksSUFBSTAvQyxPQUFPMS9DLElBQUksRUFBRTtvQkFDdkJzSSxJQUFJQSxJQUFJa0ssUUFBUXBLLENBQUMsQ0FBQ3MzQyxPQUFPLENBQUN0M0MsQ0FBQyxDQUFDcEksRUFBRSxHQUFHb0ksQ0FBQyxDQUFDNkQsSUFBSXl6QyxPQUFPenpDLElBQUlyRCxFQUFFLElBQUtSLENBQUFBLENBQUMsQ0FBQzZELEVBQUUsR0FBR3JELENBQUFBLEVBQUc7Z0JBQ3JFO2dCQUVBMGtFLEdBQUd0dEUsQ0FBQyxHQUFHQTtnQkFDUHN0RSxHQUFHcmhFLENBQUMsR0FBR0E7Z0JBQ1AsT0FBTzNELEdBQUcscUVBQXFFO1lBQy9FLHNFQUFzRTtZQUN0RSwyREFBMkQ7WUFDN0Q7UUFDRixFQUFFLEVBQUU7UUFDSixTQUFTO1FBQ1QsMkRBQTJEO1FBQzNELEVBQUU7UUFHRixTQUFTOGtFLEtBQUsza0UsQ0FBQyxFQUFFRyxDQUFDO1lBQ2hCQSxFQUFFNUksQ0FBQyxHQUFHeUksRUFBRXpJLENBQUM7WUFDVDRJLEVBQUVxRCxDQUFDLEdBQUd4RCxFQUFFd0QsQ0FBQztZQUNUckQsRUFBRW9rRSxDQUFDLEdBQUd2a0UsRUFBRXVrRSxDQUFDLENBQUNuckQsS0FBSztZQUNmLE9BQU9qWjtRQUNULEVBQUUsRUFBRTtRQUNKLFlBQVk7UUFDWix1REFBdUQ7UUFDdkQsRUFBRTtRQUdGLFNBQVM0akUsUUFBUWhwRSxHQUFHLEVBQUVvbUMsS0FBSztZQUN6QixJQUFJMmpDLFNBQVMsRUFBRSxFQUNYQyxNQUFNOUIsVUFBVWxvRSxNQUNoQjdDO1lBRUosSUFBSWlwQyxTQUFTNGpDLE9BQU8sVUFBVTtnQkFDNUIsSUFBSzdzRSxRQUFRNkMsSUFBSztvQkFDaEIsSUFBSTt3QkFDRitwRSxPQUFPaHNFLElBQUksQ0FBQ2lyRSxRQUFRaHBFLEdBQUcsQ0FBQzdDLEtBQUssRUFBRWlwQyxRQUFRO29CQUN6QyxFQUFFLE9BQU9qK0IsR0FBRyxDQUFDO2dCQUNmO1lBQ0Y7WUFFQSxPQUFPNGhFLE9BQU9ydEUsTUFBTSxHQUFHcXRFLFNBQVNDLE9BQU8sV0FBV2hxRSxNQUFNQSxNQUFNO1FBQ2hFLEVBQUUsRUFBRTtRQUNKLFdBQVc7UUFDWCxtRUFBbUU7UUFDbkUsd0VBQXdFO1FBQ3hFLEVBQUU7UUFHRixTQUFTK29FLE9BQU9KLElBQUksRUFBRS96RCxHQUFHO1lBQ3ZCLElBQUlxMUQsYUFBYXRCLE9BQU8sSUFDcEJ1QixPQUNBemhFLElBQUk7WUFFUixNQUFPQSxJQUFJd2hFLFdBQVd2dEUsTUFBTSxDQUFFO2dCQUM1QmtZLEdBQUcsQ0FBQ3NuQyxPQUFPenpDLEVBQUUsR0FBR3l6QyxPQUFPLENBQUNndUIsU0FBU3QxRCxHQUFHLENBQUNzbkMsT0FBT3p6QyxFQUFFLEdBQUcsRUFBQyxJQUFLd2hFLFdBQVdoNkIsVUFBVSxDQUFDeG5DO1lBQy9FO1lBRUEsT0FBT3dnRSxTQUFTcjBEO1FBQ2xCLEVBQUUsRUFBRTtRQUNKLGFBQWE7UUFDYix5RUFBeUU7UUFDekUsdUJBQXVCO1FBQ3ZCLEVBQUU7UUFHRixTQUFTczBEO1lBQ1AsSUFBSTtnQkFDRixJQUFJVCxZQUFZO29CQUNkLE9BQU9RLFNBQVNSLFdBQVcwQixXQUFXLENBQUNuN0Q7Z0JBQ3pDO2dCQUVBLElBQUk2YixNQUFNLElBQUl1L0MsV0FBV3A3RDtnQkFDeEJsVSxDQUFBQSxPQUFPdXZFLE1BQU0sSUFBSXZ2RSxPQUFPd3ZFLFFBQVEsRUFBRUMsZUFBZSxDQUFDMS9DO2dCQUNuRCxPQUFPbytDLFNBQVNwK0M7WUFDbEIsRUFBRSxPQUFPMWlCLEdBQUc7Z0JBQ1YsSUFBSXFpRSxVQUFVMXZFLE9BQU9ELFNBQVMsRUFDMUI0dkUsVUFBVUQsV0FBV0EsUUFBUUMsT0FBTztnQkFDeEMsT0FBTztvQkFBQyxDQUFDLElBQUkxOEI7b0JBQVFqekM7b0JBQVEydkU7b0JBQVMzdkUsT0FBTzR2RSxNQUFNO29CQUFFekIsU0FBU3htRDtpQkFBTTtZQUN0RTtRQUNGLEVBQUUsRUFBRTtRQUNKLGFBQWE7UUFDYiw2Q0FBNkM7UUFDN0MsRUFBRTtRQUdGLFNBQVN3bUQsU0FBU3o5RCxDQUFDO1lBQ2pCLE9BQU9zbkQsT0FBT0MsWUFBWSxDQUFDanpELEtBQUssQ0FBQyxHQUFHMEw7UUFDdEMsRUFBRSxFQUFFO1FBQ0osOERBQThEO1FBQzlELDhEQUE4RDtRQUM5RCw2REFBNkQ7UUFDN0QsOERBQThEO1FBQzlELGtCQUFrQjtRQUNsQixFQUFFO1FBR0Z1OUQsT0FBTzNsRCxLQUFLemhCLE1BQU0sSUFBSThnQixPQUFPLEVBQUU7SUFDL0Isc0VBQXNFO0lBQ3RFLHFCQUFxQjtJQUNyQixFQUFFO0lBQ0YsZ0RBQWdEO0lBQ2xEOztJQUlBLFNBQVNrb0QsYUFBYW5wRSxNQUFNO1FBQzFCMm1FLFdBQVcsRUFBRSxFQUFFM21FO0lBQ2pCO0lBRUEsSUFBSW9wRSxZQUFZO1FBQ2RDLE9BQU87SUFDVDtJQUVBLFNBQVNDLFVBQVU5cUUsR0FBRztRQUFJO1FBQTJCLElBQUksT0FBT0MsV0FBVyxjQUFjLE9BQU9BLE9BQU9DLFFBQVEsS0FBSyxVQUFVO1lBQUU0cUUsWUFBWSxTQUFTM3FFLFFBQVFILEdBQUc7Z0JBQUksT0FBTyxPQUFPQTtZQUFLO1FBQUcsT0FBTztZQUFFOHFFLFlBQVksU0FBUzNxRSxRQUFRSCxHQUFHO2dCQUFJLE9BQU9BLE9BQU8sT0FBT0MsV0FBVyxjQUFjRCxJQUFJSSxXQUFXLEtBQUtILFVBQVVELFFBQVFDLE9BQU9yRCxTQUFTLEdBQUcsV0FBVyxPQUFPb0Q7WUFBSztRQUFHO1FBQUUsT0FBTzhxRSxVQUFVOXFFO0lBQU07SUFFalksSUFBSStxRSxvQkFBb0I7UUFDdEI7UUFFQSxJQUFJajZELEtBQUssQ0FBQztRQUNWLElBQUloUSxPQUFPVTtRQUNYLElBQUlsRCxTQUFTO1FBQ2IsSUFBSW5DLFdBQVc7UUFDZixJQUFJaVIsaUJBQWlCO1FBQ3JCLElBQUk0OUQsUUFBUTtRQUNaLElBQUlDLFNBQVM7UUFDYixJQUFJQyxnQkFBZ0IsQ0FBQztRQUNyQlAsYUFBYW5wRTtRQUViLFNBQVN5WTtZQUNQaXhELGdCQUFnQixDQUFDO1FBQ25CO1FBRUEsU0FBU0Msc0JBQXNCNXJFLEdBQUc7WUFDaEMsT0FBT0EsSUFBSWEsV0FBVyxLQUFLUCxTQUFTTixJQUFJYSxXQUFXLEtBQUtYO1FBQzFEO1FBRUEsU0FBUzJyRSxZQUFZQyxJQUFJLEVBQUV4bUUsQ0FBQztZQUMxQixPQUFPd21FLFNBQVMsWUFBWXhtRSxhQUFhK1YsVUFBVXl3RCxTQUFTLGFBQWFBLFNBQVM7UUFDcEY7UUFFQSxTQUFTQyxRQUFROS9ELENBQUM7WUFDaEIsSUFBSSsvRCxPQUFPVCxVQUFVdC9EO1lBRXJCLElBQUkrL0QsU0FBUyxZQUFZLy9ELGFBQWFvUCxVQUFVMndELFNBQVMsV0FBVztnQkFDbEUsT0FBTyxDQUFDLy9EO1lBQ1Y7WUFFQSxJQUFJMi9ELHNCQUFzQjMvRCxJQUFJO2dCQUM1QixJQUFJaFA7Z0JBQ0osSUFBSWd2RSxPQUFPaGdFLEVBQUU5TyxNQUFNO2dCQUNuQixJQUFJK3VFLFNBQVMsRUFBRTtnQkFFZixJQUFLanZFLElBQUksR0FBR0EsSUFBSWd2RSxNQUFNaHZFLEtBQUssRUFBRztvQkFDNUJpdkUsTUFBTSxDQUFDanZFLEVBQUUsR0FBRyxDQUFDZ1AsQ0FBQyxDQUFDaFAsRUFBRTtnQkFDbkI7Z0JBRUEsT0FBT2l2RTtZQUNUO1lBRUEsSUFBSWpnRSxFQUFFaWQsUUFBUSxFQUFFO2dCQUNkLE9BQU9qZCxFQUFFM0csQ0FBQztZQUNaO1lBRUEsT0FBTyxDQUFDMkc7UUFDVjtRQUVBLElBQUlrZ0UsWUFBWTVzRCxjQUFjQyxlQUFlLENBQUMsT0FBTyxHQUFHLE9BQU8sT0FBTyxVQUFVb0MsR0FBRztRQUNuRixJQUFJd3FELGFBQWE3c0QsY0FBY0MsZUFBZSxDQUFDLE9BQU8sT0FBTyxPQUFPLEdBQUcsV0FBV29DLEdBQUc7UUFDckYsSUFBSXlxRCxlQUFlOXNELGNBQWNDLGVBQWUsQ0FBQyxNQUFNLEdBQUcsT0FBTyxHQUFHLGFBQWFvQyxHQUFHO1FBRXBGLFNBQVMrdkIsSUFBSTFsQyxDQUFDLEVBQUV4RyxDQUFDO1lBQ2YsSUFBSXVtRSxPQUFPVCxVQUFVdC9EO1lBRXJCLElBQUlxZ0UsT0FBT2YsVUFBVTlsRTtZQUVyQixJQUFJb21FLFlBQVlHLE1BQU0vL0QsTUFBTTQvRCxZQUFZUyxNQUFNN21FLE1BQU11bUUsU0FBUyxZQUFZTSxTQUFTLFVBQVU7Z0JBQzFGLE9BQU9yZ0UsSUFBSXhHO1lBQ2I7WUFFQSxJQUFJbW1FLHNCQUFzQjMvRCxNQUFNNC9ELFlBQVlTLE1BQU03bUUsSUFBSTtnQkFDcER3RyxJQUFJQSxFQUFFNlMsS0FBSyxDQUFDO2dCQUNaN1MsQ0FBQyxDQUFDLEVBQUUsSUFBSXhHO2dCQUNSLE9BQU93RztZQUNUO1lBRUEsSUFBSTQvRCxZQUFZRyxNQUFNLy9ELE1BQU0yL0Qsc0JBQXNCbm1FLElBQUk7Z0JBQ3BEQSxJQUFJQSxFQUFFcVosS0FBSyxDQUFDO2dCQUNaclosQ0FBQyxDQUFDLEVBQUUsR0FBR3dHLElBQUl4RyxDQUFDLENBQUMsRUFBRTtnQkFDZixPQUFPQTtZQUNUO1lBRUEsSUFBSW1tRSxzQkFBc0IzL0QsTUFBTTIvRCxzQkFBc0JubUUsSUFBSTtnQkFDeEQsSUFBSXhJLElBQUk7Z0JBQ1IsSUFBSWd2RSxPQUFPaGdFLEVBQUU5TyxNQUFNO2dCQUNuQixJQUFJb3ZFLE9BQU85bUUsRUFBRXRJLE1BQU07Z0JBQ25CLElBQUkrdUUsU0FBUyxFQUFFO2dCQUVmLE1BQU9qdkUsSUFBSWd2RSxRQUFRaHZFLElBQUlzdkUsS0FBTTtvQkFDM0IsSUFBSSxDQUFDLE9BQU90Z0UsQ0FBQyxDQUFDaFAsRUFBRSxLQUFLLFlBQVlnUCxDQUFDLENBQUNoUCxFQUFFLFlBQVlvZSxNQUFLLEtBQU8sUUFBTzVWLENBQUMsQ0FBQ3hJLEVBQUUsS0FBSyxZQUFZd0ksQ0FBQyxDQUFDeEksRUFBRSxZQUFZb2UsTUFBSyxHQUFJO3dCQUNoSDZ3RCxNQUFNLENBQUNqdkUsRUFBRSxHQUFHZ1AsQ0FBQyxDQUFDaFAsRUFBRSxHQUFHd0ksQ0FBQyxDQUFDeEksRUFBRTtvQkFDekIsT0FBTzt3QkFDTGl2RSxNQUFNLENBQUNqdkUsRUFBRSxHQUFHd0ksQ0FBQyxDQUFDeEksRUFBRSxLQUFLNGEsWUFBWTVMLENBQUMsQ0FBQ2hQLEVBQUUsR0FBR2dQLENBQUMsQ0FBQ2hQLEVBQUUsSUFBSXdJLENBQUMsQ0FBQ3hJLEVBQUU7b0JBQ3REO29CQUVBQSxLQUFLO2dCQUNQO2dCQUVBLE9BQU9pdkU7WUFDVDtZQUVBLE9BQU87UUFDVDtRQUVBLElBQUk3ZixNQUFNMWE7UUFFVixTQUFTNjZCLElBQUl2Z0UsQ0FBQyxFQUFFeEcsQ0FBQztZQUNmLElBQUl1bUUsT0FBT1QsVUFBVXQvRDtZQUVyQixJQUFJcWdFLE9BQU9mLFVBQVU5bEU7WUFFckIsSUFBSW9tRSxZQUFZRyxNQUFNLy9ELE1BQU00L0QsWUFBWVMsTUFBTTdtRSxJQUFJO2dCQUNoRCxJQUFJdW1FLFNBQVMsVUFBVTtvQkFDckIvL0QsSUFBSTZMLFNBQVM3TCxHQUFHO2dCQUNsQjtnQkFFQSxJQUFJcWdFLFNBQVMsVUFBVTtvQkFDckI3bUUsSUFBSXFTLFNBQVNyUyxHQUFHO2dCQUNsQjtnQkFFQSxPQUFPd0csSUFBSXhHO1lBQ2I7WUFFQSxJQUFJbW1FLHNCQUFzQjMvRCxNQUFNNC9ELFlBQVlTLE1BQU03bUUsSUFBSTtnQkFDcER3RyxJQUFJQSxFQUFFNlMsS0FBSyxDQUFDO2dCQUNaN1MsQ0FBQyxDQUFDLEVBQUUsSUFBSXhHO2dCQUNSLE9BQU93RztZQUNUO1lBRUEsSUFBSTQvRCxZQUFZRyxNQUFNLy9ELE1BQU0yL0Qsc0JBQXNCbm1FLElBQUk7Z0JBQ3BEQSxJQUFJQSxFQUFFcVosS0FBSyxDQUFDO2dCQUNaclosQ0FBQyxDQUFDLEVBQUUsR0FBR3dHLElBQUl4RyxDQUFDLENBQUMsRUFBRTtnQkFDZixPQUFPQTtZQUNUO1lBRUEsSUFBSW1tRSxzQkFBc0IzL0QsTUFBTTIvRCxzQkFBc0JubUUsSUFBSTtnQkFDeEQsSUFBSXhJLElBQUk7Z0JBQ1IsSUFBSWd2RSxPQUFPaGdFLEVBQUU5TyxNQUFNO2dCQUNuQixJQUFJb3ZFLE9BQU85bUUsRUFBRXRJLE1BQU07Z0JBQ25CLElBQUkrdUUsU0FBUyxFQUFFO2dCQUVmLE1BQU9qdkUsSUFBSWd2RSxRQUFRaHZFLElBQUlzdkUsS0FBTTtvQkFDM0IsSUFBSSxDQUFDLE9BQU90Z0UsQ0FBQyxDQUFDaFAsRUFBRSxLQUFLLFlBQVlnUCxDQUFDLENBQUNoUCxFQUFFLFlBQVlvZSxNQUFLLEtBQU8sUUFBTzVWLENBQUMsQ0FBQ3hJLEVBQUUsS0FBSyxZQUFZd0ksQ0FBQyxDQUFDeEksRUFBRSxZQUFZb2UsTUFBSyxHQUFJO3dCQUNoSDZ3RCxNQUFNLENBQUNqdkUsRUFBRSxHQUFHZ1AsQ0FBQyxDQUFDaFAsRUFBRSxHQUFHd0ksQ0FBQyxDQUFDeEksRUFBRTtvQkFDekIsT0FBTzt3QkFDTGl2RSxNQUFNLENBQUNqdkUsRUFBRSxHQUFHd0ksQ0FBQyxDQUFDeEksRUFBRSxLQUFLNGEsWUFBWTVMLENBQUMsQ0FBQ2hQLEVBQUUsR0FBR2dQLENBQUMsQ0FBQ2hQLEVBQUUsSUFBSXdJLENBQUMsQ0FBQ3hJLEVBQUU7b0JBQ3REO29CQUVBQSxLQUFLO2dCQUNQO2dCQUVBLE9BQU9pdkU7WUFDVDtZQUVBLE9BQU87UUFDVDtRQUVBLFNBQVNPLElBQUl4Z0UsQ0FBQyxFQUFFeEcsQ0FBQztZQUNmLElBQUl1bUUsT0FBT1QsVUFBVXQvRDtZQUVyQixJQUFJcWdFLE9BQU9mLFVBQVU5bEU7WUFFckIsSUFBSXpGO1lBRUosSUFBSTZyRSxZQUFZRyxNQUFNLy9ELE1BQU00L0QsWUFBWVMsTUFBTTdtRSxJQUFJO2dCQUNoRCxPQUFPd0csSUFBSXhHO1lBQ2I7WUFFQSxJQUFJeEk7WUFDSixJQUFJQztZQUVKLElBQUkwdUUsc0JBQXNCMy9ELE1BQU00L0QsWUFBWVMsTUFBTTdtRSxJQUFJO2dCQUNwRHZJLE1BQU0rTyxFQUFFOU8sTUFBTTtnQkFDZDZDLE1BQU1GLGlCQUFpQixXQUFXNUM7Z0JBRWxDLElBQUtELElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO29CQUMzQitDLEdBQUcsQ0FBQy9DLEVBQUUsR0FBR2dQLENBQUMsQ0FBQ2hQLEVBQUUsR0FBR3dJO2dCQUNsQjtnQkFFQSxPQUFPekY7WUFDVDtZQUVBLElBQUk2ckUsWUFBWUcsTUFBTS8vRCxNQUFNMi9ELHNCQUFzQm5tRSxJQUFJO2dCQUNwRHZJLE1BQU11SSxFQUFFdEksTUFBTTtnQkFDZDZDLE1BQU1GLGlCQUFpQixXQUFXNUM7Z0JBRWxDLElBQUtELElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO29CQUMzQitDLEdBQUcsQ0FBQy9DLEVBQUUsR0FBR2dQLElBQUl4RyxDQUFDLENBQUN4SSxFQUFFO2dCQUNuQjtnQkFFQSxPQUFPK0M7WUFDVDtZQUVBLE9BQU87UUFDVDtRQUVBLFNBQVNvZixJQUFJblQsQ0FBQyxFQUFFeEcsQ0FBQztZQUNmLElBQUl1bUUsT0FBT1QsVUFBVXQvRDtZQUVyQixJQUFJcWdFLE9BQU9mLFVBQVU5bEU7WUFFckIsSUFBSXpGO1lBRUosSUFBSTZyRSxZQUFZRyxNQUFNLy9ELE1BQU00L0QsWUFBWVMsTUFBTTdtRSxJQUFJO2dCQUNoRCxPQUFPd0csSUFBSXhHO1lBQ2I7WUFFQSxJQUFJeEk7WUFDSixJQUFJQztZQUVKLElBQUkwdUUsc0JBQXNCMy9ELE1BQU00L0QsWUFBWVMsTUFBTTdtRSxJQUFJO2dCQUNwRHZJLE1BQU0rTyxFQUFFOU8sTUFBTTtnQkFDZDZDLE1BQU1GLGlCQUFpQixXQUFXNUM7Z0JBRWxDLElBQUtELElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO29CQUMzQitDLEdBQUcsQ0FBQy9DLEVBQUUsR0FBR2dQLENBQUMsQ0FBQ2hQLEVBQUUsR0FBR3dJO2dCQUNsQjtnQkFFQSxPQUFPekY7WUFDVDtZQUVBLElBQUk2ckUsWUFBWUcsTUFBTS8vRCxNQUFNMi9ELHNCQUFzQm5tRSxJQUFJO2dCQUNwRHZJLE1BQU11SSxFQUFFdEksTUFBTTtnQkFDZDZDLE1BQU1GLGlCQUFpQixXQUFXNUM7Z0JBRWxDLElBQUtELElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO29CQUMzQitDLEdBQUcsQ0FBQy9DLEVBQUUsR0FBR2dQLElBQUl4RyxDQUFDLENBQUN4SSxFQUFFO2dCQUNuQjtnQkFFQSxPQUFPK0M7WUFDVDtZQUVBLE9BQU87UUFDVDtRQUVBLFNBQVMwc0UsSUFBSXpnRSxDQUFDLEVBQUV4RyxDQUFDO1lBQ2YsSUFBSSxPQUFPd0csTUFBTSxVQUFVO2dCQUN6QkEsSUFBSTZMLFNBQVM3TCxHQUFHO1lBQ2xCO1lBRUEsSUFBSSxPQUFPeEcsTUFBTSxVQUFVO2dCQUN6QkEsSUFBSXFTLFNBQVNyUyxHQUFHO1lBQ2xCO1lBRUEsT0FBT3dHLElBQUl4RztRQUNiO1FBRUEsSUFBSWtuRSxVQUFVaDdCO1FBQ2QsSUFBSWk3QixVQUFVSjtRQUNkLElBQUlLLFVBQVVKO1FBQ2QsSUFBSUssVUFBVTF0RDtRQUNkLElBQUkydEQsVUFBVUw7UUFFZCxTQUFTTSxNQUFNMTVCLEdBQUcsRUFBRXR4QyxHQUFHLEVBQUVGLEdBQUc7WUFDMUIsSUFBSUUsTUFBTUYsS0FBSztnQkFDYixJQUFJbXJFLEtBQUtuckU7Z0JBQ1RBLE1BQU1FO2dCQUNOQSxNQUFNaXJFO1lBQ1I7WUFFQSxPQUFPMXJFLEtBQUtTLEdBQUcsQ0FBQ1QsS0FBS08sR0FBRyxDQUFDd3hDLEtBQUt0eEMsTUFBTUY7UUFDdEM7UUFFQSxTQUFTb3JFLGlCQUFpQjVxRSxHQUFHO1lBQzNCLE9BQU9BLE1BQU1JO1FBQ2Y7UUFFQSxJQUFJeXFFLHFCQUFxQkQ7UUFFekIsU0FBU0UsaUJBQWlCOXFFLEdBQUc7WUFDM0IsT0FBT0EsTUFBTUk7UUFDZjtRQUVBLElBQUkycUUscUJBQXFCSDtRQUN6QixJQUFJSSxvQkFBb0I7WUFBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7U0FBRTtRQUUxQyxTQUFTbndFLE9BQU9vd0UsSUFBSSxFQUFFQyxJQUFJO1lBQ3hCLElBQUksT0FBT0QsU0FBUyxZQUFZQSxnQkFBZ0JseUQsUUFBUTtnQkFDdERteUQsT0FBT0EsUUFBUTtnQkFDZixPQUFPanNFLEtBQUtjLEdBQUcsQ0FBQ2tyRSxPQUFPQztZQUN6QjtZQUVBLElBQUksQ0FBQ0EsTUFBTTtnQkFDVEEsT0FBT0Y7WUFDVDtZQUVBLElBQUlyd0U7WUFDSixJQUFJQyxNQUFNcUUsS0FBS1MsR0FBRyxDQUFDdXJFLEtBQUtwd0UsTUFBTSxFQUFFcXdFLEtBQUtyd0UsTUFBTTtZQUMzQyxJQUFJb21CLGNBQWM7WUFFbEIsSUFBS3RtQixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztnQkFDM0JzbUIsZUFBZWhpQixLQUFLQyxHQUFHLENBQUNnc0UsSUFBSSxDQUFDdndFLEVBQUUsR0FBR3N3RSxJQUFJLENBQUN0d0UsRUFBRSxFQUFFO1lBQzdDO1lBRUEsT0FBT3NFLEtBQUtHLElBQUksQ0FBQzZoQjtRQUNuQjtRQUVBLFNBQVNrcUQsVUFBVUMsR0FBRztZQUNwQixPQUFPdHVELElBQUlzdUQsS0FBS3Z3RSxPQUFPdXdFO1FBQ3pCO1FBRUEsU0FBU0MsU0FBU3JyRSxHQUFHO1lBQ25CLElBQUlpRCxJQUFJakQsR0FBRyxDQUFDLEVBQUU7WUFDZCxJQUFJa0QsSUFBSWxELEdBQUcsQ0FBQyxFQUFFO1lBQ2QsSUFBSW1ELElBQUluRCxHQUFHLENBQUMsRUFBRTtZQUNkLElBQUlSLE1BQU1QLEtBQUtPLEdBQUcsQ0FBQ3lELEdBQUdDLEdBQUdDO1lBQ3pCLElBQUl6RCxNQUFNVCxLQUFLUyxHQUFHLENBQUN1RCxHQUFHQyxHQUFHQztZQUN6QixJQUFJTDtZQUNKLElBQUlDO1lBQ0osSUFBSXd4QixJQUFJLENBQUMvMEIsTUFBTUUsR0FBRSxJQUFLO1lBRXRCLElBQUlGLFFBQVFFLEtBQUs7Z0JBQ2ZvRCxJQUFJLEdBQUcsYUFBYTtnQkFFcEJDLElBQUksR0FBRyxhQUFhO1lBQ3RCLE9BQU87Z0JBQ0wsSUFBSVUsSUFBSWpFLE1BQU1FO2dCQUNkcUQsSUFBSXd4QixJQUFJLE1BQU05d0IsSUFBSyxLQUFJakUsTUFBTUUsR0FBRSxJQUFLK0QsSUFBS2pFLENBQUFBLE1BQU1FLEdBQUU7Z0JBRWpELE9BQVFGO29CQUNOLEtBQUt5RDt3QkFDSEgsSUFBSSxDQUFDSSxJQUFJQyxDQUFBQSxJQUFLTSxJQUFLUCxDQUFBQSxJQUFJQyxJQUFJLElBQUk7d0JBQy9CO29CQUVGLEtBQUtEO3dCQUNISixJQUFJLENBQUNLLElBQUlGLENBQUFBLElBQUtRLElBQUk7d0JBQ2xCO29CQUVGLEtBQUtOO3dCQUNITCxJQUFJLENBQUNHLElBQUlDLENBQUFBLElBQUtPLElBQUk7d0JBQ2xCO29CQUVGO3dCQUNFO2dCQUNKO2dCQUVBWCxLQUFLO1lBQ1A7WUFFQSxPQUFPO2dCQUFDQTtnQkFBR0M7Z0JBQUd3eEI7Z0JBQUd2MEIsR0FBRyxDQUFDLEVBQUU7YUFBQztRQUMxQjtRQUVBLFNBQVNzckUsUUFBUWpvRSxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztZQUN0QixJQUFJQSxJQUFJLEdBQUdBLEtBQUs7WUFDaEIsSUFBSUEsSUFBSSxHQUFHQSxLQUFLO1lBQ2hCLElBQUlBLElBQUksSUFBSSxHQUFHLE9BQU9GLElBQUksQ0FBQ0MsSUFBSUQsQ0FBQUEsSUFBSyxJQUFJRTtZQUN4QyxJQUFJQSxJQUFJLElBQUksR0FBRyxPQUFPRDtZQUN0QixJQUFJQyxJQUFJLElBQUksR0FBRyxPQUFPRixJQUFJLENBQUNDLElBQUlELENBQUFBLElBQU0sS0FBSSxJQUFJRSxDQUFBQSxJQUFLO1lBQ2xELE9BQU9GO1FBQ1Q7UUFFQSxTQUFTa29FLFNBQVN2ckUsR0FBRztZQUNuQixJQUFJOEMsSUFBSTlDLEdBQUcsQ0FBQyxFQUFFO1lBQ2QsSUFBSStDLElBQUkvQyxHQUFHLENBQUMsRUFBRTtZQUNkLElBQUl1MEIsSUFBSXYwQixHQUFHLENBQUMsRUFBRTtZQUNkLElBQUlpRDtZQUNKLElBQUlDO1lBQ0osSUFBSUM7WUFFSixJQUFJSixNQUFNLEdBQUc7Z0JBQ1hFLElBQUlzeEIsR0FBRyxhQUFhO2dCQUVwQnB4QixJQUFJb3hCLEdBQUcsYUFBYTtnQkFFcEJyeEIsSUFBSXF4QixHQUFHLGFBQWE7WUFDdEIsT0FBTztnQkFDTCxJQUFJanhCLElBQUlpeEIsSUFBSSxNQUFNQSxJQUFLLEtBQUl4eEIsQ0FBQUEsSUFBS3d4QixJQUFJeHhCLElBQUl3eEIsSUFBSXh4QjtnQkFDNUMsSUFBSU0sSUFBSSxJQUFJa3hCLElBQUlqeEI7Z0JBQ2hCTCxJQUFJcW9FLFFBQVFqb0UsR0FBR0MsR0FBR1IsSUFBSSxJQUFJO2dCQUMxQkksSUFBSW9vRSxRQUFRam9FLEdBQUdDLEdBQUdSO2dCQUNsQkssSUFBSW1vRSxRQUFRam9FLEdBQUdDLEdBQUdSLElBQUksSUFBSTtZQUM1QjtZQUVBLE9BQU87Z0JBQUNHO2dCQUFHQztnQkFBR0M7Z0JBQUduRCxHQUFHLENBQUMsRUFBRTthQUFDO1FBQzFCO1FBRUEsU0FBU3dyRSxPQUFPam9FLENBQUMsRUFBRWtvRSxJQUFJLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFQyxNQUFNO1lBQzNDLElBQUlELFdBQVdwMkQsYUFBYXEyRCxXQUFXcjJELFdBQVc7Z0JBQ2hEbzJELFNBQVNGO2dCQUNURyxTQUFTRjtnQkFDVEQsT0FBTztnQkFDUEMsT0FBTztZQUNUO1lBRUEsSUFBSUEsT0FBT0QsTUFBTTtnQkFDZixJQUFJSSxRQUFRSDtnQkFDWkEsT0FBT0Q7Z0JBQ1BBLE9BQU9JO1lBQ1Q7WUFFQSxJQUFJdG9FLEtBQUtrb0UsTUFBTTtnQkFDYixPQUFPRTtZQUNUO1lBRUEsSUFBSXBvRSxLQUFLbW9FLE1BQU07Z0JBQ2IsT0FBT0U7WUFDVDtZQUVBLElBQUk3b0QsT0FBTzJvRCxTQUFTRCxPQUFPLElBQUksQ0FBQ2xvRSxJQUFJa29FLElBQUcsSUFBTUMsQ0FBQUEsT0FBT0QsSUFBRztZQUV2RCxJQUFJLENBQUNFLE9BQU85d0UsTUFBTSxFQUFFO2dCQUNsQixPQUFPOHdFLFNBQVMsQ0FBQ0MsU0FBU0QsTUFBSyxJQUFLNW9EO1lBQ3RDO1lBRUEsSUFBSXBvQjtZQUNKLElBQUlDLE1BQU0rd0UsT0FBTzl3RSxNQUFNO1lBQ3ZCLElBQUk2QyxNQUFNRixpQkFBaUIsV0FBVzVDO1lBRXRDLElBQUtELElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO2dCQUMzQitDLEdBQUcsQ0FBQy9DLEVBQUUsR0FBR2d4RSxNQUFNLENBQUNoeEUsRUFBRSxHQUFHLENBQUNpeEUsTUFBTSxDQUFDanhFLEVBQUUsR0FBR2d4RSxNQUFNLENBQUNoeEUsRUFBRSxJQUFJb29CO1lBQ2pEO1lBRUEsT0FBT3JsQjtRQUNUO1FBRUEsU0FBU29DLE9BQU9KLEdBQUcsRUFBRUYsR0FBRztZQUN0QixJQUFJQSxRQUFRK1YsV0FBVztnQkFDckIsSUFBSTdWLFFBQVE2VixXQUFXO29CQUNyQjdWLE1BQU07b0JBQ05GLE1BQU07Z0JBQ1IsT0FBTztvQkFDTEEsTUFBTUU7b0JBQ05BLE1BQU02VjtnQkFDUjtZQUNGO1lBRUEsSUFBSS9WLElBQUkzRSxNQUFNLEVBQUU7Z0JBQ2QsSUFBSUY7Z0JBQ0osSUFBSUMsTUFBTTRFLElBQUkzRSxNQUFNO2dCQUVwQixJQUFJLENBQUM2RSxLQUFLO29CQUNSQSxNQUFNbEMsaUJBQWlCLFdBQVc1QztnQkFDcEM7Z0JBRUEsSUFBSThDLE1BQU1GLGlCQUFpQixXQUFXNUM7Z0JBQ3RDLElBQUlreEUsTUFBTW5zRSxPQUFPRyxNQUFNO2dCQUV2QixJQUFLbkYsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7b0JBQzNCK0MsR0FBRyxDQUFDL0MsRUFBRSxHQUFHK0UsR0FBRyxDQUFDL0UsRUFBRSxHQUFHbXhFLE1BQU90c0UsQ0FBQUEsR0FBRyxDQUFDN0UsRUFBRSxHQUFHK0UsR0FBRyxDQUFDL0UsRUFBRTtnQkFDMUM7Z0JBRUEsT0FBTytDO1lBQ1Q7WUFFQSxJQUFJZ0MsUUFBUTZWLFdBQVc7Z0JBQ3JCN1YsTUFBTTtZQUNSO1lBRUEsSUFBSXFzRSxPQUFPcHNFLE9BQU9HLE1BQU07WUFDeEIsT0FBT0osTUFBTXFzRSxPQUFRdnNFLENBQUFBLE1BQU1FLEdBQUU7UUFDL0I7UUFFQSxTQUFTc3NFLFdBQVc5c0QsTUFBTSxFQUFFK3NELFVBQVUsRUFBRUMsV0FBVyxFQUFFN2hFLE1BQU07WUFDekQsSUFBSTFQO1lBQ0osSUFBSUMsTUFBTXNrQixPQUFPcmtCLE1BQU07WUFDdkIsSUFBSTRLLE9BQU9rcEIsVUFBVTlOLFVBQVU7WUFDL0JwYixLQUFLZ29CLFdBQVcsQ0FBQyxDQUFDLENBQUNwakIsUUFBUXpQO1lBQzNCLElBQUl1eEUsaUJBQWlCO2dCQUFDO2dCQUFHO2FBQUU7WUFDM0IsSUFBSUM7WUFDSixJQUFJQztZQUVKLElBQUsxeEUsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7Z0JBQzNCeXhFLGdCQUFnQkgsY0FBY0EsVUFBVSxDQUFDdHhFLEVBQUUsR0FBR3N4RSxVQUFVLENBQUN0eEUsRUFBRSxHQUFHd3hFO2dCQUM5REUsaUJBQWlCSCxlQUFlQSxXQUFXLENBQUN2eEUsRUFBRSxHQUFHdXhFLFdBQVcsQ0FBQ3Z4RSxFQUFFLEdBQUd3eEU7Z0JBQ2xFMW1FLEtBQUtxb0IsV0FBVyxDQUFDNU8sTUFBTSxDQUFDdmtCLEVBQUUsQ0FBQyxFQUFFLEVBQUV1a0IsTUFBTSxDQUFDdmtCLEVBQUUsQ0FBQyxFQUFFLEVBQUUweEUsY0FBYyxDQUFDLEVBQUUsR0FBR250RCxNQUFNLENBQUN2a0IsRUFBRSxDQUFDLEVBQUUsRUFBRTB4RSxjQUFjLENBQUMsRUFBRSxHQUFHbnRELE1BQU0sQ0FBQ3ZrQixFQUFFLENBQUMsRUFBRSxFQUFFeXhFLGFBQWEsQ0FBQyxFQUFFLEdBQUdsdEQsTUFBTSxDQUFDdmtCLEVBQUUsQ0FBQyxFQUFFLEVBQUV5eEUsYUFBYSxDQUFDLEVBQUUsR0FBR2x0RCxNQUFNLENBQUN2a0IsRUFBRSxDQUFDLEVBQUUsRUFBRUEsR0FBRztZQUN4TDtZQUVBLE9BQU84SztRQUNUO1FBRUEsU0FBUzZtRSxtQkFBbUI1d0QsSUFBSSxFQUFFaFcsSUFBSSxFQUFFNm1FLFFBQVE7WUFDOUMsd0NBQXdDO1lBQ3hDLFNBQVNDLEtBQUtDLE1BQU07Z0JBQ2xCLE9BQU9BO1lBQ1Q7WUFFQSxJQUFJLENBQUMvd0QsS0FBS3RHLFVBQVUsQ0FBQ2k4QixZQUFZLENBQUNnakIsY0FBYyxFQUFFO2dCQUNoRCxPQUFPbVk7WUFDVDtZQUVBLElBQUl4c0UsTUFBTTBGLEtBQUs2WixDQUFDO1lBQ2hCLElBQUltdEQsZ0JBQWdCLHFCQUFxQjd0RSxJQUFJLENBQUNtQjtZQUU5QyxJQUFJMnNFLGVBQWUzc0UsSUFBSWdMLE9BQU8sQ0FBQyxjQUFjLENBQUM7WUFFOUMsSUFBSTRoRSxXQUFXbHhELEtBQUtoVyxJQUFJLENBQUM0QixFQUFFO1lBQzNCLElBQUlzdEI7WUFDSixJQUFJaTRDO1lBQ0osSUFBSWg1QjtZQUNKLElBQUlvSTtZQUNKLElBQUk2d0IsZUFBZVA7WUFDbkJPLGFBQWFDLFdBQVcsR0FBR0QsYUFBYXZ1QyxjQUFjO1lBQ3REdGpDLE9BQU8rcUUsY0FBYyxDQUFDOEcsY0FBYyxTQUFTO2dCQUMzQ3h0RCxLQUFLLFNBQVNBO29CQUNaLE9BQU93dEQsYUFBYTlwRSxDQUFDO2dCQUN2QjtZQUNGO1lBQ0EwWSxLQUFLelQsSUFBSSxDQUFDaStELGFBQWEsR0FBRyxJQUFJeHFELEtBQUt6VCxJQUFJLENBQUNtTixVQUFVLENBQUM5QixTQUFTO1lBQzVEb0ksS0FBS3pULElBQUksQ0FBQ2srRCxnQkFBZ0IsR0FBRztZQUM3QixJQUFJNkcsVUFBVXR4RCxLQUFLaFcsSUFBSSxDQUFDNkQsRUFBRSxHQUFHbVMsS0FBS3pULElBQUksQ0FBQ21OLFVBQVUsQ0FBQzlCLFNBQVM7WUFDM0QsSUFBSTI1RCxXQUFXdnhELEtBQUtoVyxJQUFJLENBQUM4RCxFQUFFLEdBQUdrUyxLQUFLelQsSUFBSSxDQUFDbU4sVUFBVSxDQUFDOUIsU0FBUztZQUM1RCxJQUFJbkcsUUFBUXVPLEtBQUtoVyxJQUFJLENBQUM2Z0QsRUFBRSxHQUFHN3FDLEtBQUtoVyxJQUFJLENBQUM2Z0QsRUFBRSxHQUFHO1lBQzFDLElBQUluNUMsU0FBU3NPLEtBQUtoVyxJQUFJLENBQUNnakIsRUFBRSxHQUFHaE4sS0FBS2hXLElBQUksQ0FBQ2dqQixFQUFFLEdBQUc7WUFDM0MsSUFBSXZXLE9BQU91SixLQUFLaFcsSUFBSSxDQUFDOE0sRUFBRTtZQUN2QixJQUFJMDZEO1lBQ0osSUFBSUM7WUFDSixJQUFJQztZQUNKLElBQUlDO1lBQ0osSUFBSUM7WUFDSixJQUFJQztZQUNKLElBQUlDO1lBQ0osSUFBSUM7WUFDSixJQUFJQztZQUNKLElBQUlDO1lBQ0osSUFBSTlzRTtZQUNKLElBQUkrc0U7WUFDSixJQUFJQztZQUNKLElBQUl6NUM7WUFDSixJQUFJMDVDO1lBQ0osSUFBSUM7WUFDSixJQUFJMXpCO1lBQ0osSUFBSTB5QjtZQUNKLElBQUlpQjtZQUNKLElBQUlDLGNBQWMsMEdBQTBHO1lBRTVILElBQUlDLHNCQUFzQkMsS0FBSyxzQ0FBc0NudUUsTUFBTSx5QkFBeUIsQ0FBQyxFQUFFLEVBQUUsOEJBQThCO1lBRXZJLElBQUlvdUUsVUFBVTdCLFNBQVNwZ0QsRUFBRSxHQUFHem1CLEtBQUtvQixDQUFDLENBQUNqTSxNQUFNLEdBQUc7WUFDNUMsSUFBSXd6RSxTQUFTLENBQUMsSUFBSSxDQUFDM29FLElBQUksSUFBSSxJQUFJLENBQUNBLElBQUksQ0FBQ3MzQyxFQUFFLEtBQUs7WUFFNUMsSUFBSXN4QixTQUFTLFVBQVNBLE9BQU9DLElBQUksRUFBRUMsR0FBRztnQkFDcEMsSUFBSUM7Z0JBQ0osSUFBSTduRTtnQkFDSixJQUFJOG5FLFlBQVksSUFBSSxDQUFDN25ELEVBQUUsQ0FBQ2hzQixNQUFNLEdBQUcsSUFBSSxDQUFDZ3NCLEVBQUUsQ0FBQ2hzQixNQUFNLEdBQUc7Z0JBQ2xELElBQUk4ekUsWUFBWW54RSxpQkFBaUIsV0FBV2t4RTtnQkFDNUNILE9BQU87Z0JBQ1AsSUFBSXZxQixhQUFhL2tELEtBQUtLLEtBQUssQ0FBQ3NTLE9BQU8yOEQ7Z0JBQ25DRSxVQUFVO2dCQUNWN25FLElBQUk7Z0JBRUosTUFBTzZuRSxVQUFVenFCLFdBQVk7b0JBQzNCLDZCQUE2QjtvQkFDN0IsSUFBS3A5QyxJQUFJLEdBQUdBLElBQUk4bkUsV0FBVzluRSxLQUFLLEVBQUc7d0JBQ2pDK25FLFNBQVMsQ0FBQy9uRSxFQUFFLElBQUksQ0FBQzRuRSxNQUFNQSxNQUFNLElBQUk3dUUsT0FBT0csTUFBTSxJQUFJLG9DQUFvQztvQkFDeEY7b0JBRUEydUUsV0FBVztnQkFDYixFQUFFLDhCQUE4QjtnQkFHaEMsSUFBSUcsVUFBVWg5RCxPQUFPMjhEO2dCQUNyQixJQUFJeHJELE9BQU82ckQsVUFBVTN2RSxLQUFLSyxLQUFLLENBQUNzdkU7Z0JBQ2hDLElBQUlseEUsTUFBTUYsaUJBQWlCLFdBQVdreEU7Z0JBRXRDLElBQUlBLFlBQVksR0FBRztvQkFDakIsSUFBSzluRSxJQUFJLEdBQUdBLElBQUk4bkUsV0FBVzluRSxLQUFLLEVBQUc7d0JBQ2pDbEosR0FBRyxDQUFDa0osRUFBRSxHQUFHLElBQUksQ0FBQ2lnQixFQUFFLENBQUNqZ0IsRUFBRSxHQUFHK25FLFNBQVMsQ0FBQy9uRSxFQUFFLEdBQUcsQ0FBQyxDQUFDNG5FLE1BQU1BLE1BQU0sSUFBSTd1RSxPQUFPRyxNQUFNLEVBQUMsSUFBS2lqQixNQUFNLGdFQUFnRTtvQkFDaEosOERBQThEO29CQUNoRTtvQkFFQSxPQUFPcmxCO2dCQUNUO2dCQUVBLE9BQU8sSUFBSSxDQUFDbXBCLEVBQUUsR0FBRzhuRCxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQ0gsTUFBTUEsTUFBTSxJQUFJN3VFLE9BQU9HLE1BQU0sRUFBQyxJQUFLaWpCO1lBQ3ZFLEdBQUVqVSxJQUFJLENBQUMsSUFBSTtZQUVYLElBQUlnK0QsYUFBYUksTUFBTSxFQUFFO2dCQUN2QkEsU0FBU0osYUFBYUksTUFBTSxDQUFDcCtELElBQUksQ0FBQ2crRDtnQkFDbENLLFVBQVVEO1lBQ1o7WUFFQSxJQUFJSixhQUFhTSxPQUFPLEVBQUU7Z0JBQ3hCQSxVQUFVTixhQUFhTSxPQUFPLENBQUN0K0QsSUFBSSxDQUFDZytEO2dCQUNwQ08sV0FBV0Q7WUFDYjtZQUVBLElBQUlOLGFBQWFRLE1BQU0sRUFBRTtnQkFDdkJBLFNBQVNSLGFBQWFRLE1BQU0sQ0FBQ3grRCxJQUFJLENBQUNnK0Q7WUFDcEM7WUFFQSxTQUFTK0IsZUFBZXgwRSxJQUFJLEVBQUV5WCxRQUFRO2dCQUNwQyxPQUFPbzdELE9BQU83eUUsTUFBTXlYLFVBQVU7WUFDaEM7WUFFQSxTQUFTZzlELGdCQUFnQnowRSxJQUFJLEVBQUV5WCxRQUFRO2dCQUNyQyxPQUFPczdELFFBQVEveUUsTUFBTXlYLFVBQVU7WUFDakM7WUFFQSxJQUFJLElBQUksQ0FBQ3lzQixjQUFjLEVBQUU7Z0JBQ3ZCd3VDLGNBQWMsSUFBSSxDQUFDeHVDLGNBQWMsQ0FBQ3p2QixJQUFJLENBQUMsSUFBSTtZQUM3QztZQUVBLElBQUksSUFBSSxDQUFDaWdFLGlCQUFpQixFQUFFO2dCQUMxQmYsaUJBQWlCLElBQUksQ0FBQ2UsaUJBQWlCLENBQUNqZ0UsSUFBSSxDQUFDLElBQUk7WUFDbkQ7WUFFQSxJQUFJN0csT0FBT3lULEtBQUt6VCxJQUFJLENBQUNtTixVQUFVLENBQUNkLGdCQUFnQixDQUFDeEYsSUFBSSxDQUFDNE0sS0FBS3pULElBQUksQ0FBQ21OLFVBQVUsQ0FBQ2QsZ0JBQWdCO1lBRTNGLFNBQVMwNkQsT0FBT0MsS0FBSyxFQUFFQyxLQUFLO2dCQUMxQixJQUFJQyxPQUFPO29CQUFDRCxLQUFLLENBQUMsRUFBRSxHQUFHRCxLQUFLLENBQUMsRUFBRTtvQkFBRUMsS0FBSyxDQUFDLEVBQUUsR0FBR0QsS0FBSyxDQUFDLEVBQUU7b0JBQUVDLEtBQUssQ0FBQyxFQUFFLEdBQUdELEtBQUssQ0FBQyxFQUFFO2lCQUFDO2dCQUMxRSxJQUFJRyxRQUFRbndFLEtBQUtxckIsS0FBSyxDQUFDNmtELElBQUksQ0FBQyxFQUFFLEVBQUVsd0UsS0FBS0csSUFBSSxDQUFDK3ZFLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFLEtBQUsvdUU7Z0JBQ3BGLElBQUlpdkUsTUFBTSxDQUFDcHdFLEtBQUtxckIsS0FBSyxDQUFDNmtELElBQUksQ0FBQyxFQUFFLEVBQUVBLElBQUksQ0FBQyxFQUFFLElBQUkvdUU7Z0JBQzFDLE9BQU87b0JBQUNpdkU7b0JBQUtEO29CQUFPO2lCQUFFO1lBQ3hCO1lBRUEsU0FBU0UsUUFBUS9yRSxDQUFDLEVBQUVrb0UsSUFBSSxFQUFFQyxJQUFJLEVBQUU2RCxJQUFJLEVBQUVDLElBQUk7Z0JBQ3hDLE9BQU9DLFVBQVUzRixZQUFZdm1FLEdBQUdrb0UsTUFBTUMsTUFBTTZELE1BQU1DO1lBQ3BEO1lBRUEsU0FBU0UsT0FBT25zRSxDQUFDLEVBQUVrb0UsSUFBSSxFQUFFQyxJQUFJLEVBQUU2RCxJQUFJLEVBQUVDLElBQUk7Z0JBQ3ZDLE9BQU9DLFVBQVU1RixXQUFXdG1FLEdBQUdrb0UsTUFBTUMsTUFBTTZELE1BQU1DO1lBQ25EO1lBRUEsU0FBU0csS0FBS3BzRSxDQUFDLEVBQUVrb0UsSUFBSSxFQUFFQyxJQUFJLEVBQUU2RCxJQUFJLEVBQUVDLElBQUk7Z0JBQ3JDLE9BQU9DLFVBQVUxRixjQUFjeG1FLEdBQUdrb0UsTUFBTUMsTUFBTTZELE1BQU1DO1lBQ3REO1lBRUEsU0FBU0MsVUFBVTVwRSxFQUFFLEVBQUV0QyxDQUFDLEVBQUVrb0UsSUFBSSxFQUFFQyxJQUFJLEVBQUU2RCxJQUFJLEVBQUVDLElBQUk7Z0JBQzlDLElBQUlELFNBQVNoNkQsV0FBVztvQkFDdEJnNkQsT0FBTzlEO29CQUNQK0QsT0FBTzlEO2dCQUNULE9BQU87b0JBQ0xub0UsSUFBSSxDQUFDQSxJQUFJa29FLElBQUcsSUFBTUMsQ0FBQUEsT0FBT0QsSUFBRztnQkFDOUI7Z0JBRUEsSUFBSWxvRSxJQUFJLEdBQUc7b0JBQ1RBLElBQUk7Z0JBQ04sT0FBTyxJQUFJQSxJQUFJLEdBQUc7b0JBQ2hCQSxJQUFJO2dCQUNOO2dCQUVBLElBQUlvb0IsT0FBTzlsQixHQUFHdEM7Z0JBRWQsSUFBSStsRSxzQkFBc0JpRyxPQUFPO29CQUMvQixJQUFJSztvQkFDSixJQUFJQyxTQUFTTixLQUFLMTBFLE1BQU07b0JBQ3hCLElBQUk2QyxNQUFNRixpQkFBaUIsV0FBV3F5RTtvQkFFdEMsSUFBS0QsT0FBTyxHQUFHQSxPQUFPQyxRQUFRRCxRQUFRLEVBQUc7d0JBQ3ZDbHlFLEdBQUcsQ0FBQ2t5RSxLQUFLLEdBQUcsQ0FBQ0osSUFBSSxDQUFDSSxLQUFLLEdBQUdMLElBQUksQ0FBQ0ssS0FBSyxJQUFJamtELE9BQU80akQsSUFBSSxDQUFDSyxLQUFLO29CQUMzRDtvQkFFQSxPQUFPbHlFO2dCQUNUO2dCQUVBLE9BQU8sQ0FBQzh4RSxPQUFPRCxJQUFHLElBQUs1akQsT0FBTzRqRDtZQUNoQztZQUVBLFNBQVNPLFdBQVdsK0QsSUFBSTtnQkFDdEIsSUFBSWcrRDtnQkFDSixJQUFJQyxTQUFTbnFFLEtBQUtvQixDQUFDLENBQUNqTSxNQUFNO2dCQUMxQixJQUFJZ2dCO2dCQUNKLElBQUkwTTtnQkFFSixJQUFJLENBQUM3aEIsS0FBS29CLENBQUMsQ0FBQ2pNLE1BQU0sSUFBSSxPQUFPNkssS0FBS29CLENBQUMsQ0FBQyxFQUFFLEtBQUssVUFBVTtvQkFDbkQrVCxRQUFRO29CQUNSME0sVUFBVTtnQkFDWixPQUFPO29CQUNMMU0sUUFBUSxDQUFDO29CQUNUakosUUFBUThKLEtBQUt6VCxJQUFJLENBQUNtTixVQUFVLENBQUM5QixTQUFTO29CQUV0QyxJQUFJMUIsT0FBT2xNLEtBQUtvQixDQUFDLENBQUMsRUFBRSxDQUFDdkQsQ0FBQyxFQUFFO3dCQUN0QnNYLFFBQVE7d0JBQ1IwTSxVQUFVN2hCLEtBQUtvQixDQUFDLENBQUMsRUFBRSxDQUFDdkQsQ0FBQztvQkFDdkIsT0FBTzt3QkFDTCxJQUFLcXNFLE9BQU8sR0FBR0EsT0FBT0MsU0FBUyxHQUFHRCxRQUFRLEVBQUc7NEJBQzNDLElBQUloK0QsU0FBU2xNLEtBQUtvQixDQUFDLENBQUM4b0UsS0FBSyxDQUFDcnNFLENBQUMsRUFBRTtnQ0FDM0JzWCxRQUFRKzBELE9BQU87Z0NBQ2Zyb0QsVUFBVTdoQixLQUFLb0IsQ0FBQyxDQUFDOG9FLEtBQUssQ0FBQ3JzRSxDQUFDO2dDQUN4Qjs0QkFDRixPQUFPLElBQUlxTyxPQUFPbE0sS0FBS29CLENBQUMsQ0FBQzhvRSxLQUFLLENBQUNyc0UsQ0FBQyxJQUFJcU8sT0FBT2xNLEtBQUtvQixDQUFDLENBQUM4b0UsT0FBTyxFQUFFLENBQUNyc0UsQ0FBQyxFQUFFO2dDQUM3RCxJQUFJcU8sT0FBT2xNLEtBQUtvQixDQUFDLENBQUM4b0UsS0FBSyxDQUFDcnNFLENBQUMsR0FBR21DLEtBQUtvQixDQUFDLENBQUM4b0UsT0FBTyxFQUFFLENBQUNyc0UsQ0FBQyxHQUFHcU8sTUFBTTtvQ0FDckRpSixRQUFRKzBELE9BQU87b0NBQ2Zyb0QsVUFBVTdoQixLQUFLb0IsQ0FBQyxDQUFDOG9FLE9BQU8sRUFBRSxDQUFDcnNFLENBQUM7Z0NBQzlCLE9BQU87b0NBQ0xzWCxRQUFRKzBELE9BQU87b0NBQ2Zyb0QsVUFBVTdoQixLQUFLb0IsQ0FBQyxDQUFDOG9FLEtBQUssQ0FBQ3JzRSxDQUFDO2dDQUMxQjtnQ0FFQTs0QkFDRjt3QkFDRjt3QkFFQSxJQUFJc1gsVUFBVSxDQUFDLEdBQUc7NEJBQ2hCQSxRQUFRKzBELE9BQU87NEJBQ2Zyb0QsVUFBVTdoQixLQUFLb0IsQ0FBQyxDQUFDOG9FLEtBQUssQ0FBQ3JzRSxDQUFDO3dCQUMxQjtvQkFDRjtnQkFDRjtnQkFFQSxJQUFJd3NFLFFBQVEsQ0FBQztnQkFDYkEsTUFBTWwxRCxLQUFLLEdBQUdBO2dCQUNkazFELE1BQU1uK0QsSUFBSSxHQUFHMlYsVUFBVTdMLEtBQUt6VCxJQUFJLENBQUNtTixVQUFVLENBQUM5QixTQUFTO2dCQUNyRCxPQUFPeThEO1lBQ1Q7WUFFQSxTQUFTaDlELElBQUk0VSxHQUFHO2dCQUNkLElBQUlvb0Q7Z0JBQ0osSUFBSUg7Z0JBQ0osSUFBSUM7Z0JBRUosSUFBSSxDQUFDbnFFLEtBQUtvQixDQUFDLENBQUNqTSxNQUFNLElBQUksT0FBTzZLLEtBQUtvQixDQUFDLENBQUMsRUFBRSxLQUFLLFVBQVU7b0JBQ25ELE1BQU0sSUFBSXlLLE1BQU0sMkNBQTJDb1c7Z0JBQzdEO2dCQUVBQSxPQUFPO2dCQUNQb29ELFFBQVE7b0JBQ05uK0QsTUFBTWxNLEtBQUtvQixDQUFDLENBQUM2Z0IsSUFBSSxDQUFDcGtCLENBQUMsR0FBR21ZLEtBQUt6VCxJQUFJLENBQUNtTixVQUFVLENBQUM5QixTQUFTO29CQUNwRHBaLE9BQU8sRUFBRTtnQkFDWDtnQkFDQSxJQUFJd0QsTUFBTXpDLE9BQU9GLFNBQVMsQ0FBQ0csY0FBYyxDQUFDQyxJQUFJLENBQUN1SyxLQUFLb0IsQ0FBQyxDQUFDNmdCLElBQUksRUFBRSxPQUFPamlCLEtBQUtvQixDQUFDLENBQUM2Z0IsSUFBSSxDQUFDNWtCLENBQUMsR0FBRzJDLEtBQUtvQixDQUFDLENBQUM2Z0IsTUFBTSxFQUFFLENBQUNyaEIsQ0FBQztnQkFDcEd1cEUsU0FBU255RSxJQUFJN0MsTUFBTTtnQkFFbkIsSUFBSyswRSxPQUFPLEdBQUdBLE9BQU9DLFFBQVFELFFBQVEsRUFBRztvQkFDdkNHLEtBQUssQ0FBQ0gsS0FBSyxHQUFHbHlFLEdBQUcsQ0FBQ2t5RSxLQUFLO29CQUN2QkcsTUFBTTcxRSxLQUFLLENBQUMwMUUsS0FBSyxHQUFHbHlFLEdBQUcsQ0FBQ2t5RSxLQUFLO2dCQUMvQjtnQkFFQSxPQUFPRztZQUNUO1lBRUEsU0FBU0MsYUFBYTM0RCxFQUFFLEVBQUU0NEQsR0FBRztnQkFDM0IsSUFBSSxDQUFDQSxLQUFLO29CQUNSQSxNQUFNdjBELEtBQUt6VCxJQUFJLENBQUNtTixVQUFVLENBQUM5QixTQUFTO2dCQUN0QztnQkFFQSxPQUFPK0QsS0FBSzQ0RDtZQUNkO1lBRUEsU0FBU0MsYUFBYTNzRSxDQUFDLEVBQUUwc0UsR0FBRztnQkFDMUIsSUFBSSxDQUFDMXNFLEtBQUtBLE1BQU0sR0FBRztvQkFDakJBLElBQUlxTztnQkFDTjtnQkFFQSxJQUFJLENBQUNxK0QsS0FBSztvQkFDUkEsTUFBTXYwRCxLQUFLelQsSUFBSSxDQUFDbU4sVUFBVSxDQUFDOUIsU0FBUztnQkFDdEM7Z0JBRUEsT0FBTy9QLElBQUkwc0U7WUFDYjtZQUVBLFNBQVMzSixXQUFXUSxJQUFJO2dCQUN0Qm5uRSxPQUFPa25FLFVBQVUsQ0FBQ3NKLFdBQVdySjtZQUMvQjtZQUVBLFNBQVN0MUI7Z0JBQ1AsT0FBTzkxQixLQUFLODFCLGdCQUFnQjtZQUM5QjtZQUVBLFNBQVM0K0IsVUFBVXgyRCxJQUFJLEVBQUVDLEdBQUc7Z0JBQzFCLElBQUksT0FBTzNmLFVBQVUsVUFBVTtvQkFDN0IsSUFBSTJmLFFBQVF0RSxXQUFXO3dCQUNyQixPQUFPcmIsTUFBTWsyRSxTQUFTLENBQUN4MkQ7b0JBQ3pCO29CQUVBLE9BQU8xZixNQUFNazJFLFNBQVMsQ0FBQ3gyRCxNQUFNQztnQkFDL0I7Z0JBRUEsT0FBTztZQUNUO1lBRUEsU0FBU2hFLE9BQU8rRCxJQUFJLEVBQUVDLEdBQUc7Z0JBQ3ZCLElBQUksT0FBTzNmLFVBQVUsVUFBVTtvQkFDN0IsSUFBSTJmLFFBQVF0RSxXQUFXO3dCQUNyQixPQUFPcmIsTUFBTTJiLE1BQU0sQ0FBQytEO29CQUN0QjtvQkFFQSxPQUFPMWYsTUFBTTJiLE1BQU0sQ0FBQytELE1BQU1DO2dCQUM1QjtnQkFFQSxPQUFPO1lBQ1Q7WUFFQSxTQUFTdzJELGNBQWNDLGVBQWU7Z0JBQ3BDMStELE9BQU8wK0Qsb0JBQW9CLElBQUksSUFBSXJ4RSxLQUFLSyxLQUFLLENBQUNzUyxPQUFPMCtELG1CQUFtQkE7Z0JBQ3hFcDJFLFFBQVE2eUUsWUFBWW43RDtZQUN0QjtZQUVBLElBQUlBO1lBQ0osSUFBSTIrRDtZQUNKLElBQUlyMkU7WUFDSixJQUFJZ3pDO1lBQ0osSUFBSXNqQztZQUNKLElBQUlDO1lBQ0osSUFBSUM7WUFDSixJQUFJNzFELFFBQVFhLEtBQUtoVyxJQUFJLENBQUNpaUIsR0FBRztZQUN6QixJQUFJZ3BELFlBQVksQ0FBQyxDQUFFajFELENBQUFBLEtBQUtzN0IsU0FBUyxJQUFJdDdCLEtBQUtzN0IsU0FBUyxDQUFDbjhDLE1BQU07WUFDMUQsSUFBSTZ3QztZQUNKLElBQUl5a0MsV0FBV2x4RSxLQUFLSyxLQUFLLENBQUNMLEtBQUthLE1BQU0sS0FBSztZQUMxQyxJQUFJc1YsYUFBYXNHLEtBQUt0RyxVQUFVO1lBRWhDLFNBQVN3N0Qsa0JBQWtCbkUsTUFBTTtnQkFDL0IsK0JBQStCO2dCQUMvQnZ5RSxRQUFRdXlFO2dCQUVSLElBQUksSUFBSSxDQUFDb0UsaUJBQWlCLEtBQUtuMUQsS0FBS3RHLFVBQVUsQ0FBQzBXLE9BQU8sSUFBSSxJQUFJLENBQUNsRixRQUFRLEtBQUssZ0JBQWdCO29CQUMxRixPQUFPMXNCO2dCQUNUO2dCQUVBLElBQUksSUFBSSxDQUFDMHNCLFFBQVEsS0FBSyxnQkFBZ0I7b0JBQ3BDNHBELFlBQVksSUFBSSxDQUFDQSxTQUFTO29CQUMxQkMsWUFBWSxJQUFJLENBQUNBLFNBQVM7b0JBQzFCQyxnQkFBZ0IsSUFBSSxDQUFDQSxhQUFhO2dCQUNwQztnQkFFQSxJQUFJLENBQUM1QyxXQUFXO29CQUNkNWdDLE9BQU94eEIsS0FBSzAzQixjQUFjLENBQUNsRyxJQUFJO29CQUMvQjRnQyxZQUFZcHlELEtBQUswM0IsY0FBYztvQkFDL0IyNkIsV0FBV3J5RCxLQUFLelQsSUFBSSxDQUFDMkssYUFBYTtvQkFDbEMyNkQsVUFBVU8sVUFBVVAsT0FBTyxDQUFDeitELElBQUksQ0FBQ2cvRDtvQkFDakNOLFlBQVlNLFVBQVVOLFNBQVMsQ0FBQzErRCxJQUFJLENBQUNnL0Q7b0JBQ3JDTCxXQUFXSyxVQUFVTCxRQUFRLENBQUMzK0QsSUFBSSxDQUFDZy9EO29CQUNuQ0osU0FBU0ksVUFBVUosTUFBTSxDQUFDNStELElBQUksQ0FBQ2cvRDtvQkFDL0J6ekIsT0FBT3l6QixVQUFVenpCLElBQUksR0FBR3l6QixVQUFVenpCLElBQUksQ0FBQ3ZyQyxJQUFJLENBQUNnL0QsYUFBYTtvQkFDekRILG9CQUFvQkY7Z0JBQ3RCO2dCQUVBLElBQUksQ0FBQzc0QyxXQUFXO29CQUNkQSxZQUFZbFosS0FBSzAzQixjQUFjLENBQUM7b0JBQ2hDeTVCLGdCQUFnQmo0QztvQkFFaEIsSUFBSUEsV0FBVzt3QkFDYmk1QyxjQUFjajVDLFVBQVVpNUMsV0FBVztvQkFDbkM7OytDQUVtQyxHQUNyQztnQkFDRjtnQkFFQSxJQUFJakIsYUFBYSxLQUFLLENBQUMvNEIsU0FBUztvQkFDOUJBLFVBQVVpNkIsVUFBVTtnQkFDdEI7Z0JBRUEsSUFBSSxDQUFDN3hCLFFBQVE7b0JBQ1hBLFNBQVM2eEIsVUFBVTtnQkFDckI7Z0JBRUE2QyxZQUFZLENBQUMsQ0FBRWoxRCxDQUFBQSxLQUFLczdCLFNBQVMsSUFBSXQ3QixLQUFLczdCLFNBQVMsQ0FBQ244QyxNQUFNO2dCQUV0RCxJQUFJODFFLGFBQWEsQ0FBQ2psQyxRQUFRO29CQUN4QkEsU0FBU2h3QixLQUFLczdCLFNBQVMsQ0FBQyxFQUFFLENBQUM1RCxjQUFjO2dCQUMzQztnQkFFQXhoQyxPQUFPLElBQUksQ0FBQzNKLElBQUksQ0FBQ29qQixhQUFhLEdBQUcsSUFBSSxDQUFDcGpCLElBQUksQ0FBQ21OLFVBQVUsQ0FBQzlCLFNBQVM7Z0JBRS9ELElBQUlxNUQsY0FBYztvQkFDaEJyRyxXQUFXNkosV0FBV3YrRDtnQkFDeEI7Z0JBRUEsSUFBSTg2RCxlQUFlO29CQUNqQjZELFdBQVd2QyxlQUFlcDhEO2dCQUM1QjtnQkFFQXM4RDtnQkFDQSxJQUFJLENBQUMyQyxpQkFBaUIsR0FBR24xRCxLQUFLdEcsVUFBVSxDQUFDMFcsT0FBTyxFQUFFLHdFQUF3RTtnQkFDMUgsbUZBQW1GO2dCQUVuRm1pRCxlQUFlQSxhQUFhcm5ELFFBQVEsS0FBS21pRCxVQUFVQyxLQUFLLEdBQUdpRixhQUFhanJFLENBQUMsR0FBR2lyRTtnQkFDNUUsT0FBT0E7WUFDVCxFQUFFLG9FQUFvRTtZQUd0RTJDLGtCQUFrQkUsd0JBQXdCLEdBQUc7Z0JBQUNqRTtnQkFBZWdCO2dCQUFhajhEO2dCQUFNMitEO2dCQUFVdkQ7Z0JBQVNDO2dCQUFVOS9EO2dCQUFPQztnQkFBUStFO2dCQUFNZzdEO2dCQUFTRTtnQkFBVUM7Z0JBQVFJO2dCQUFRQztnQkFBbUJKO2dCQUFTQztnQkFBV256QjtnQkFBTXg1QztnQkFBVStzRTtnQkFBVXg1QztnQkFBTzI1QztnQkFBVUs7Z0JBQVNDO2dCQUFRQztnQkFBUU87Z0JBQWdCQztnQkFBaUI3bUU7Z0JBQU0rbUU7Z0JBQVFNO2dCQUFTSTtnQkFBUUM7Z0JBQU1HO2dCQUFZLzhEO2dCQUFLbTZCO2dCQUFNc2pDO2dCQUFXQztnQkFBV0M7Z0JBQWVWO2dCQUFjRTtnQkFBYzErQjtnQkFBa0I0K0I7Z0JBQVd2NkQ7Z0JBQVF3NkQ7Z0JBQWV4MUQ7Z0JBQU96RjthQUFXO1lBQ3BmLE9BQU93N0Q7UUFDVDtRQUVBM2hFLEdBQUdxOUQsa0JBQWtCLEdBQUdBO1FBQ3hCcjlELEdBQUc2aEUsd0JBQXdCLEdBQUc7WUFBQ3IwRTtZQUFRbkM7WUFBVWlSO1lBQWdCNDlEO1lBQU9DO1lBQVFLO1lBQVMxZjtZQUFLc2dCO1lBQVNDO1lBQVNDO1lBQVNDO1lBQVNDO1lBQVNDO1lBQU9HO1lBQW9CQztZQUFrQkM7WUFBb0JJO1lBQVdFO1lBQVVFO1lBQVVDO1lBQVExckU7WUFBUWtzRTtZQUFZM0M7U0FBYztRQUNyUnA2RCxHQUFHbUosVUFBVSxHQUFHQTtRQUNoQixPQUFPbko7SUFDVDtJQUVBLElBQUk4aEUsY0FBYztRQUNoQixJQUFJOWhFLEtBQUssQ0FBQztRQUNWQSxHQUFHMEgsZUFBZSxHQUFHQTtRQUNyQjFILEdBQUdtSixVQUFVLEdBQUc4d0Qsa0JBQWtCOXdELFVBQVU7UUFFNUMsU0FBU3pCLGdCQUFnQnpLLFNBQVM7WUFDaEMsSUFBSThrRSxhQUFhO1lBQ2pCLElBQUlDLFlBQVksRUFBRTtZQUVsQixTQUFTQztnQkFDUEYsY0FBYztZQUNoQjtZQUVBLFNBQVNHO2dCQUNQSCxjQUFjO2dCQUVkLElBQUlBLGVBQWUsR0FBRztvQkFDcEJJO2dCQUNGO1lBQ0Y7WUFFQSxTQUFTQywyQkFBMkJDLFVBQVU7Z0JBQzVDLElBQUlMLFVBQVVqbUUsT0FBTyxDQUFDc21FLGdCQUFnQixDQUFDLEdBQUc7b0JBQ3hDTCxVQUFVLzBFLElBQUksQ0FBQ28xRTtnQkFDakI7WUFDRjtZQUVBLFNBQVNGO2dCQUNQLElBQUl6MkU7Z0JBQ0osSUFBSUMsTUFBTXEyRSxVQUFVcDJFLE1BQU07Z0JBRTFCLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO29CQUMzQnMyRSxTQUFTLENBQUN0MkUsRUFBRSxDQUFDbW1CLE9BQU87Z0JBQ3RCO2dCQUVBbXdELFVBQVVwMkUsTUFBTSxHQUFHO1lBQ3JCO1lBRUFxUixVQUFVNEgsUUFBUSxDQUFDbEIsYUFBYSxHQUFHdWdDLHdCQUF3QmpuQyxVQUFVNEgsUUFBUTtZQUM3RTVILFVBQVU0SCxRQUFRLENBQUNzQixVQUFVLENBQUNkLGdCQUFnQixDQUFDakMsbUJBQW1CLENBQUNuRyxVQUFVNEgsUUFBUTtZQUNyRjVILFVBQVU0SCxRQUFRLENBQUNzQixVQUFVLENBQUM4N0QsY0FBYyxHQUFHQTtZQUMvQ2hsRSxVQUFVNEgsUUFBUSxDQUFDc0IsVUFBVSxDQUFDKzdELGFBQWEsR0FBR0E7WUFDOUNqbEUsVUFBVTRILFFBQVEsQ0FBQ3NCLFVBQVUsQ0FBQ2k4RCwwQkFBMEIsR0FBR0E7UUFDN0Q7UUFFQSxPQUFPcGlFO0lBQ1Q7SUFFQSxJQUFJc2lFLHVCQUF1QjtRQUN6QixTQUFTQyxjQUFjbjNCLElBQUksRUFBRTMwQyxJQUFJO1lBQy9CLElBQUksQ0FBQytyRSxLQUFLLEdBQUdwM0I7WUFDYixJQUFJLENBQUNxM0IsS0FBSyxHQUFHaHNFO1FBQ2Y7UUFFQXpLLE9BQU8rcUUsY0FBYyxDQUFDd0wsY0FBY3oyRSxTQUFTLEVBQUUsWUFBWTtZQUN6RHVrQixLQUFLLFNBQVNBO2dCQUNaLElBQUksSUFBSSxDQUFDbXlELEtBQUssQ0FBQ24yRSxJQUFJLENBQUN3TCxDQUFDLEVBQUU7b0JBQ3JCLElBQUksQ0FBQzJxRSxLQUFLLENBQUNuMkUsSUFBSSxDQUFDbXhCLFFBQVE7Z0JBQzFCO2dCQUVBLE9BQU8sSUFBSSxDQUFDZ2xELEtBQUssQ0FBQ24yRSxJQUFJO1lBQ3hCO1FBQ0Y7UUFDQUwsT0FBTytxRSxjQUFjLENBQUN3TCxjQUFjejJFLFNBQVMsRUFBRSxlQUFlO1lBQzVEdWtCLEtBQUssU0FBU0E7Z0JBQ1osSUFBSSxJQUFJLENBQUNteUQsS0FBSyxDQUFDam9FLEVBQUUsQ0FBQzFDLENBQUMsRUFBRTtvQkFDbkIsSUFBSSxDQUFDMnFFLEtBQUssQ0FBQ2pvRSxFQUFFLENBQUNpakIsUUFBUTtnQkFDeEI7Z0JBRUEsT0FBTyxJQUFJLENBQUNnbEQsS0FBSyxDQUFDam9FLEVBQUUsQ0FBQ3hHLENBQUMsR0FBRztZQUMzQjtRQUNGO1FBRUEsSUFBSTJ1RSxjQUFjLFNBQVNBLFlBQVl0K0IsV0FBVztZQUNoRCxJQUFJdStCLG1CQUFtQjd6RSxpQkFBaUJzMUMsWUFBWWlHLFFBQVEsQ0FBQ3orQyxNQUFNO1lBRW5FLElBQUlGO1lBQ0osSUFBSUMsTUFBTXk0QyxZQUFZaUcsUUFBUSxDQUFDeitDLE1BQU07WUFFckMsSUFBS0YsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7Z0JBQzNCaTNFLGdCQUFnQixDQUFDajNFLEVBQUUsR0FBRyxJQUFJNjJFLGNBQWNuK0IsWUFBWWlHLFFBQVEsQ0FBQzMrQyxFQUFFLEVBQUUwNEMsWUFBWWxzQyxlQUFlLENBQUN4TSxFQUFFO1lBQ2pHO1lBRUEsSUFBSWszRSxlQUFlLFNBQVNBLGFBQWExL0QsSUFBSTtnQkFDM0N4WCxJQUFJO2dCQUVKLE1BQU9BLElBQUlDLElBQUs7b0JBQ2QsSUFBSXk0QyxZQUFZbHNDLGVBQWUsQ0FBQ3hNLEVBQUUsQ0FBQzZYLEVBQUUsS0FBS0wsTUFBTTt3QkFDOUMsT0FBT3kvRCxnQkFBZ0IsQ0FBQ2ozRSxFQUFFO29CQUM1QjtvQkFFQUEsS0FBSztnQkFDUDtnQkFFQSxPQUFPO1lBQ1Q7WUFFQSxPQUFPazNFO1FBQ1Q7UUFFQSxPQUFPRjtJQUNUO0lBRUEsSUFBSUcsOEJBQThCO1FBQ2hDLElBQUlDLDZCQUE2QjtZQUMvQmxyRCxJQUFJO1lBQ0o3akIsR0FBRztZQUNIMm9CLE1BQU07UUFDUjtRQUNBLElBQUlxbUQsK0JBQStCO1lBQ2pDbnJELElBQUk7Z0JBQUM7Z0JBQUc7Z0JBQUc7YUFBRTtZQUNiN2pCLEdBQUc7Z0JBQUM7Z0JBQUc7Z0JBQUc7YUFBRTtZQUNaMm9CLE1BQU07UUFDUjtRQUVBLFNBQVNzbUQsaUJBQWlCQyxlQUFlLEVBQUUzRixRQUFRLEVBQUVseUUsSUFBSTtZQUN2RFksT0FBTytxRSxjQUFjLENBQUNrTSxpQkFBaUIsWUFBWTtnQkFDakQ1eUQsS0FBSyxTQUFTQTtvQkFDWixPQUFPaXRELFNBQVN3QyxpQkFBaUIsQ0FBQ3hDLFNBQVN0a0UsSUFBSSxDQUFDMEssWUFBWTtnQkFDOUQ7WUFDRjtZQUNBdS9ELGdCQUFnQjlELE9BQU8sR0FBRzdCLFNBQVN2bEQsU0FBUyxHQUFHdWxELFNBQVN2bEQsU0FBUyxDQUFDbnNCLE1BQU0sR0FBRztZQUUzRXEzRSxnQkFBZ0JuL0QsR0FBRyxHQUFHLFNBQVU4YSxHQUFHO2dCQUNqQyxJQUFJLENBQUNxa0QsZ0JBQWdCOUQsT0FBTyxFQUFFO29CQUM1QixPQUFPO2dCQUNUO2dCQUVBLElBQUlsMEUsUUFBUTtnQkFFWixJQUFJLE9BQU9xeUUsU0FBU3ZsRCxTQUFTLENBQUM2RyxNQUFNLEVBQUUsRUFBRTtvQkFDdEMzekIsUUFBUXF5RSxTQUFTdmxELFNBQVMsQ0FBQzZHLE1BQU0sRUFBRSxDQUFDOXFCLENBQUM7Z0JBQ3ZDLE9BQU8sSUFBSSxPQUFPd3BFLFNBQVN2bEQsU0FBUyxDQUFDNkcsTUFBTSxFQUFFLEVBQUU7b0JBQzdDM3pCLFFBQVFxeUUsU0FBU3ZsRCxTQUFTLENBQUM2RyxNQUFNLEVBQUUsQ0FBQ3ZuQixDQUFDO2dCQUN2QyxPQUFPO29CQUNMcE0sUUFBUXF5RSxTQUFTdmxELFNBQVMsQ0FBQzZHLE1BQU0sRUFBRSxDQUFDOXFCLENBQUM7Z0JBQ3ZDO2dCQUVBLElBQUlvdkUsWUFBWTkzRSxTQUFTLG1CQUFtQixJQUFJMGUsT0FBTzdlLFNBQVNlLE9BQU9tMUMsTUFBTSxDQUFDLENBQUMsR0FBR2wyQyxRQUFRLHNDQUFzQztnQkFFaElpNEUsVUFBVXZnRSxJQUFJLEdBQUcyNkQsU0FBU3ZsRCxTQUFTLENBQUM2RyxNQUFNLEVBQUUsQ0FBQ3RxQixDQUFDLEdBQUdncEUsU0FBUzd3RCxJQUFJLENBQUN6VCxJQUFJLENBQUNtTixVQUFVLENBQUM5QixTQUFTO2dCQUN4RjYrRCxVQUFVajRFLEtBQUssR0FBR0csU0FBUyxtQkFBbUJILEtBQUssQ0FBQyxFQUFFLEdBQUdBO2dCQUN6RCxPQUFPaTRFO1lBQ1Q7WUFFQUQsZ0JBQWdCbkYsV0FBVyxHQUFHUixTQUFTaHVDLGNBQWM7WUFDckQyekMsZ0JBQWdCRSxXQUFXLEdBQUc3RixTQUFTOEYsY0FBYztZQUNyREgsZ0JBQWdCbEUsY0FBYyxHQUFHekIsU0FBU3dDLGlCQUFpQjtZQUMzRG1ELGdCQUFnQkksYUFBYSxHQUFHL0YsU0FBUytGLGFBQWE7UUFDeEQ7UUFFQSxTQUFTQyxnQ0FBZ0NoRyxRQUFRO1lBQy9DLElBQUksQ0FBQ0EsWUFBWSxDQUFFLFNBQVFBLFFBQU8sR0FBSTtnQkFDcENBLFdBQVd3RjtZQUNiO1lBRUEsSUFBSXBtRCxPQUFPLElBQUk0Z0QsU0FBUzVnRCxJQUFJO1lBQzVCLElBQUkzckIsTUFBTXVzRSxTQUFTMWxELEVBQUUsR0FBRzhFO1lBQ3hCLElBQUl1bUQsa0JBQWtCLElBQUluNUQsT0FBTy9ZLE1BQU0sc0NBQXNDO1lBRTdFa3lFLGdCQUFnQmg0RSxLQUFLLEdBQUc4RjtZQUN4Qml5RSxpQkFBaUJDLGlCQUFpQjNGLFVBQVU7WUFDNUMsT0FBTztnQkFDTCxJQUFJQSxTQUFTemxFLENBQUMsRUFBRTtvQkFDZHlsRSxTQUFTOS9DLFFBQVE7Z0JBQ25CO2dCQUVBenNCLE1BQU11c0UsU0FBU3ZwRSxDQUFDLEdBQUcyb0I7Z0JBRW5CLElBQUl1bUQsZ0JBQWdCaDRFLEtBQUssS0FBSzhGLEtBQUs7b0JBQ2pDa3lFLGtCQUFrQixJQUFJbjVELE9BQU8vWSxNQUFNLHNDQUFzQztvQkFFekVreUUsZ0JBQWdCaDRFLEtBQUssR0FBRzhGO29CQUN4Qml5RSxpQkFBaUJDLGlCQUFpQjNGLFVBQVU7Z0JBQzlDO2dCQUVBLE9BQU8yRjtZQUNUO1FBQ0Y7UUFFQSxTQUFTTSxrQ0FBa0NqRyxRQUFRO1lBQ2pELElBQUksQ0FBQ0EsWUFBWSxDQUFFLFNBQVFBLFFBQU8sR0FBSTtnQkFDcENBLFdBQVd5RjtZQUNiO1lBRUEsSUFBSXJtRCxPQUFPLElBQUk0Z0QsU0FBUzVnRCxJQUFJO1lBQzVCLElBQUkvd0IsTUFBTTJ4RSxTQUFTN21FLElBQUksSUFBSTZtRSxTQUFTN21FLElBQUksQ0FBQzZ1QixDQUFDLElBQUlnNEMsU0FBUzFsRCxFQUFFLENBQUNoc0IsTUFBTTtZQUNoRSxJQUFJcTNFLGtCQUFrQjEwRSxpQkFBaUIsV0FBVzVDO1lBQ2xELElBQUk2M0UsV0FBV2oxRSxpQkFBaUIsV0FBVzVDO1lBQzNDczNFLGdCQUFnQmg0RSxLQUFLLEdBQUd1NEU7WUFDeEJSLGlCQUFpQkMsaUJBQWlCM0YsVUFBVTtZQUM1QyxPQUFPO2dCQUNMLElBQUlBLFNBQVN6bEUsQ0FBQyxFQUFFO29CQUNkeWxFLFNBQVM5L0MsUUFBUTtnQkFDbkI7Z0JBRUEsSUFBSyxJQUFJOXhCLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO29CQUMvQjgzRSxRQUFRLENBQUM5M0UsRUFBRSxHQUFHNHhFLFNBQVN2cEUsQ0FBQyxDQUFDckksRUFBRSxHQUFHZ3hCO29CQUM5QnVtRCxlQUFlLENBQUN2M0UsRUFBRSxHQUFHODNFLFFBQVEsQ0FBQzkzRSxFQUFFO2dCQUNsQztnQkFFQSxPQUFPdTNFO1lBQ1Q7UUFDRixFQUFFLHVDQUF1QztRQUd6QyxTQUFTUTtZQUNQLE9BQU9YO1FBQ1Q7UUFFQSxPQUFPLFNBQVV4RixRQUFRO1lBQ3ZCLElBQUksQ0FBQ0EsVUFBVTtnQkFDYixPQUFPbUc7WUFDVDtZQUVBLElBQUluRyxTQUFTM2xELFFBQVEsS0FBSyxrQkFBa0I7Z0JBQzFDLE9BQU8yckQsZ0NBQWdDaEc7WUFDekM7WUFFQSxPQUFPaUcsa0NBQWtDakc7UUFDM0M7SUFDRjtJQUVBLElBQUlvRywrQkFBK0I7UUFDakMsT0FBTyxTQUFVLzlDLFNBQVM7WUFDeEIsU0FBU2crQyxjQUFjemdFLElBQUk7Z0JBQ3pCLE9BQVFBO29CQUNOLEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7d0JBQ0gsT0FBT3lnRSxjQUFjeCtDLEtBQUs7b0JBRTVCLEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7b0JBQ0wsS0FBSzt3QkFDSCxPQUFPdytDLGNBQWNoRixRQUFRO29CQUUvQixLQUFLO3dCQUNILE9BQU9nRixjQUFjQyxTQUFTO29CQUVoQyxLQUFLO3dCQUNILE9BQU9ELGNBQWNFLFNBQVM7b0JBRWhDLEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7d0JBQ0gsT0FBT0YsY0FBYy94RSxRQUFRO29CQUUvQixLQUFLO3dCQUNILE9BQU8reEUsY0FBY0csU0FBUztvQkFFaEMsS0FBSzt3QkFDSCxPQUFPSCxjQUFjSSxTQUFTO29CQUVoQyxLQUFLO3dCQUNILE9BQU9KLGNBQWNLLFNBQVM7b0JBRWhDLEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7b0JBQ0wsS0FBSzt3QkFDSCxPQUFPTCxjQUFjL0UsV0FBVztvQkFFbEMsS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7d0JBQ0gsT0FBTytFLGNBQWNqNkIsT0FBTztvQkFFOUI7d0JBQ0UsT0FBTztnQkFDWDtZQUNGO1lBRUExOUMsT0FBTytxRSxjQUFjLENBQUM0TSxlQUFlLFlBQVk7Z0JBQy9DdHpELEtBQUt3eUQsNEJBQTRCbDlDLFVBQVUzeEIsQ0FBQyxJQUFJMnhCLFVBQVU4SSxFQUFFO1lBQzlEO1lBQ0F6aUMsT0FBTytxRSxjQUFjLENBQUM0TSxlQUFlLGFBQWE7Z0JBQ2hEdHpELEtBQUt3eUQsNEJBQTRCbDlDLFVBQVU4SSxFQUFFLElBQUk5SSxVQUFVM3hCLENBQUM7WUFDOUQ7WUFDQWhJLE9BQU8rcUUsY0FBYyxDQUFDNE0sZUFBZSxhQUFhO2dCQUNoRHR6RCxLQUFLd3lELDRCQUE0Qmw5QyxVQUFVZ0osRUFBRTtZQUMvQztZQUNBM2lDLE9BQU8rcUUsY0FBYyxDQUFDNE0sZUFBZSxhQUFhO2dCQUNoRHR6RCxLQUFLd3lELDRCQUE0Qmw5QyxVQUFVK0ksRUFBRTtZQUMvQztZQUNBMWlDLE9BQU8rcUUsY0FBYyxDQUFDNE0sZUFBZSxTQUFTO2dCQUM1Q3R6RCxLQUFLd3lELDRCQUE0Qmw5QyxVQUFVN3hCLENBQUM7WUFDOUM7WUFFQSxJQUFJbXdFO1lBRUosSUFBSUM7WUFFSixJQUFJQztZQUVKLElBQUlDO1lBRUosSUFBSXorQyxVQUFVdnhCLENBQUMsRUFBRTtnQkFDZmd3RSxvQkFBb0J2Qiw0QkFBNEJsOUMsVUFBVXZ4QixDQUFDO1lBQzdELE9BQU87Z0JBQ0w2dkUsTUFBTXBCLDRCQUE0Qmw5QyxVQUFVaUosRUFBRTtnQkFDOUNzMUMsTUFBTXJCLDRCQUE0Qmw5QyxVQUFVa0osRUFBRTtnQkFFOUMsSUFBSWxKLFVBQVVtSixFQUFFLEVBQUU7b0JBQ2hCcTFDLE1BQU10Qiw0QkFBNEJsOUMsVUFBVW1KLEVBQUU7Z0JBQ2hEO1lBQ0Y7WUFFQTlpQyxPQUFPK3FFLGNBQWMsQ0FBQzRNLGVBQWUsWUFBWTtnQkFDL0N0ekQsS0FBSyxTQUFTQTtvQkFDWixJQUFJc1YsVUFBVXZ4QixDQUFDLEVBQUU7d0JBQ2YsT0FBT2d3RTtvQkFDVDtvQkFFQSxPQUFPO3dCQUFDSDt3QkFBT0M7d0JBQU9DLE1BQU1BLFFBQVE7cUJBQUU7Z0JBQ3hDO1lBQ0Y7WUFDQW40RSxPQUFPK3FFLGNBQWMsQ0FBQzRNLGVBQWUsYUFBYTtnQkFDaER0ekQsS0FBS3d5RCw0QkFBNEJsOUMsVUFBVWlKLEVBQUU7WUFDL0M7WUFDQTVpQyxPQUFPK3FFLGNBQWMsQ0FBQzRNLGVBQWUsYUFBYTtnQkFDaER0ekQsS0FBS3d5RCw0QkFBNEJsOUMsVUFBVWtKLEVBQUU7WUFDL0M7WUFDQTdpQyxPQUFPK3FFLGNBQWMsQ0FBQzRNLGVBQWUsYUFBYTtnQkFDaER0ekQsS0FBS3d5RCw0QkFBNEJsOUMsVUFBVW1KLEVBQUU7WUFDL0M7WUFDQTlpQyxPQUFPK3FFLGNBQWMsQ0FBQzRNLGVBQWUsZUFBZTtnQkFDbER0ekQsS0FBS3d5RCw0QkFBNEJsOUMsVUFBVWpyQixDQUFDO1lBQzlDO1lBQ0ExTyxPQUFPK3FFLGNBQWMsQ0FBQzRNLGVBQWUsV0FBVztnQkFDOUN0ekQsS0FBS3d5RCw0QkFBNEJsOUMsVUFBVXBzQixDQUFDO1lBQzlDO1lBQ0F2TixPQUFPK3FFLGNBQWMsQ0FBQzRNLGVBQWUsUUFBUTtnQkFDM0N0ekQsS0FBS3d5RCw0QkFBNEJsOUMsVUFBVWhyQixFQUFFO1lBQy9DO1lBQ0EzTyxPQUFPK3FFLGNBQWMsQ0FBQzRNLGVBQWUsWUFBWTtnQkFDL0N0ekQsS0FBS3d5RCw0QkFBNEJsOUMsVUFBVS9xQixFQUFFO1lBQy9DO1lBQ0E1TyxPQUFPK3FFLGNBQWMsQ0FBQzRNLGVBQWUsZUFBZTtnQkFDbER0ekQsS0FBS3d5RCw0QkFBNEJsOUMsVUFBVXBELEVBQUU7WUFDL0M7WUFDQSxPQUFPb2hEO1FBQ1Q7SUFDRjtJQUVBLElBQUk3L0IsMkJBQTJCO1FBQzdCLFNBQVN1Z0MsVUFBVTFoRSxJQUFJO1lBQ3JCLElBQUkyaEUsYUFBYSxJQUFJcmdEO1lBRXJCLElBQUl0aEIsU0FBUzJELFdBQVc7Z0JBQ3RCLElBQUlpK0QsYUFBYSxJQUFJLENBQUN4bUIsS0FBSyxDQUFDN2IsY0FBYyxDQUFDQyxLQUFLLENBQUM3UyxjQUFjLENBQUMzc0I7Z0JBRWhFNGhFLFdBQVcza0QsS0FBSyxDQUFDMGtEO1lBQ25CLE9BQU87Z0JBQ0wsSUFBSTFWLGVBQWUsSUFBSSxDQUFDN1EsS0FBSyxDQUFDN2IsY0FBYyxDQUFDQyxLQUFLO2dCQUNsRHlzQixhQUFhcmdDLGFBQWEsQ0FBQysxQztZQUM3QjtZQUVBLE9BQU9BO1FBQ1Q7UUFFQSxTQUFTRSxXQUFXLzFFLEdBQUcsRUFBRWtVLElBQUk7WUFDM0IsSUFBSTJoRSxhQUFhLElBQUksQ0FBQ0QsU0FBUyxDQUFDMWhFO1lBQ2hDMmhFLFdBQVcvL0MsS0FBSyxDQUFDLEdBQUcsR0FBRztZQUN2QisvQyxXQUFXLy9DLEtBQUssQ0FBQyxHQUFHLEdBQUc7WUFDdkIrL0MsV0FBVy8vQyxLQUFLLENBQUMsR0FBRyxHQUFHO1lBQ3ZCLE9BQU8sSUFBSSxDQUFDa2dELFVBQVUsQ0FBQ0gsWUFBWTcxRTtRQUNyQztRQUVBLFNBQVM2dkUsUUFBUTd2RSxHQUFHLEVBQUVrVSxJQUFJO1lBQ3hCLElBQUkyaEUsYUFBYSxJQUFJLENBQUNELFNBQVMsQ0FBQzFoRTtZQUNoQyxPQUFPLElBQUksQ0FBQzhoRSxVQUFVLENBQUNILFlBQVk3MUU7UUFDckM7UUFFQSxTQUFTaTJFLGFBQWFqMkUsR0FBRyxFQUFFa1UsSUFBSTtZQUM3QixJQUFJMmhFLGFBQWEsSUFBSSxDQUFDRCxTQUFTLENBQUMxaEU7WUFDaEMyaEUsV0FBVy8vQyxLQUFLLENBQUMsR0FBRyxHQUFHO1lBQ3ZCKy9DLFdBQVcvL0MsS0FBSyxDQUFDLEdBQUcsR0FBRztZQUN2QisvQyxXQUFXLy9DLEtBQUssQ0FBQyxHQUFHLEdBQUc7WUFDdkIsT0FBTyxJQUFJLENBQUNvZ0QsV0FBVyxDQUFDTCxZQUFZNzFFO1FBQ3RDO1FBRUEsU0FBUzh2RSxVQUFVOXZFLEdBQUcsRUFBRWtVLElBQUk7WUFDMUIsSUFBSTJoRSxhQUFhLElBQUksQ0FBQ0QsU0FBUyxDQUFDMWhFO1lBQ2hDLE9BQU8sSUFBSSxDQUFDZ2lFLFdBQVcsQ0FBQ0wsWUFBWTcxRTtRQUN0QztRQUVBLFNBQVNnMkUsV0FBVzk4QyxNQUFNLEVBQUVsNUIsR0FBRztZQUM3QixJQUFJLElBQUksQ0FBQ3N2RCxLQUFLLENBQUNoVyxTQUFTLElBQUksSUFBSSxDQUFDZ1csS0FBSyxDQUFDaFcsU0FBUyxDQUFDbjhDLE1BQU0sRUFBRTtnQkFDdkQsSUFBSUY7Z0JBQ0osSUFBSUMsTUFBTSxJQUFJLENBQUNveUQsS0FBSyxDQUFDaFcsU0FBUyxDQUFDbjhDLE1BQU07Z0JBRXJDLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO29CQUMzQixJQUFJLENBQUNxeUQsS0FBSyxDQUFDaFcsU0FBUyxDQUFDcjhDLEVBQUUsQ0FBQ3cyQyxjQUFjLENBQUNDLEtBQUssQ0FBQzVULGFBQWEsQ0FBQzVHO2dCQUM3RDtZQUNGO1lBRUEsT0FBT0EsT0FBT2UsaUJBQWlCLENBQUNqNkIsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUUsRUFBRUEsR0FBRyxDQUFDLEVBQUUsSUFBSTtRQUM1RDtRQUVBLFNBQVNrMkUsWUFBWWg5QyxNQUFNLEVBQUVsNUIsR0FBRztZQUM5QixJQUFJLElBQUksQ0FBQ3N2RCxLQUFLLENBQUNoVyxTQUFTLElBQUksSUFBSSxDQUFDZ1csS0FBSyxDQUFDaFcsU0FBUyxDQUFDbjhDLE1BQU0sRUFBRTtnQkFDdkQsSUFBSUY7Z0JBQ0osSUFBSUMsTUFBTSxJQUFJLENBQUNveUQsS0FBSyxDQUFDaFcsU0FBUyxDQUFDbjhDLE1BQU07Z0JBRXJDLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO29CQUMzQixJQUFJLENBQUNxeUQsS0FBSyxDQUFDaFcsU0FBUyxDQUFDcjhDLEVBQUUsQ0FBQ3cyQyxjQUFjLENBQUNDLEtBQUssQ0FBQzVULGFBQWEsQ0FBQzVHO2dCQUM3RDtZQUNGO1lBRUEsT0FBT0EsT0FBT2MsWUFBWSxDQUFDaDZCO1FBQzdCO1FBRUEsU0FBUyt2RSxTQUFTL3ZFLEdBQUc7WUFDbkIsSUFBSTYxRSxhQUFhLElBQUlyZ0Q7WUFDckJxZ0QsV0FBV2xqRCxLQUFLO1lBRWhCLElBQUksQ0FBQzI4QixLQUFLLENBQUM3YixjQUFjLENBQUNDLEtBQUssQ0FBQzVULGFBQWEsQ0FBQysxQztZQUU5QyxJQUFJLElBQUksQ0FBQ3ZtQixLQUFLLENBQUNoVyxTQUFTLElBQUksSUFBSSxDQUFDZ1csS0FBSyxDQUFDaFcsU0FBUyxDQUFDbjhDLE1BQU0sRUFBRTtnQkFDdkQsSUFBSUY7Z0JBQ0osSUFBSUMsTUFBTSxJQUFJLENBQUNveUQsS0FBSyxDQUFDaFcsU0FBUyxDQUFDbjhDLE1BQU07Z0JBRXJDLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO29CQUMzQixJQUFJLENBQUNxeUQsS0FBSyxDQUFDaFcsU0FBUyxDQUFDcjhDLEVBQUUsQ0FBQ3cyQyxjQUFjLENBQUNDLEtBQUssQ0FBQzVULGFBQWEsQ0FBQysxQztnQkFDN0Q7Z0JBRUEsT0FBT0EsV0FBVzc3QyxZQUFZLENBQUNoNkI7WUFDakM7WUFFQSxPQUFPNjFFLFdBQVc3N0MsWUFBWSxDQUFDaDZCO1FBQ2pDO1FBRUEsU0FBU20yRTtZQUNQLE9BQU87Z0JBQUM7Z0JBQUc7Z0JBQUc7Z0JBQUc7YUFBRTtRQUNyQjtRQUVBLE9BQU8sU0FBVW40RCxJQUFJO1lBQ25CLElBQUlvNEQ7WUFFSixTQUFTQyx1QkFBdUIxZ0MsV0FBVztnQkFDekMweUIsbUJBQW1CMXJCLElBQUksR0FBRyxJQUFJazNCLHFCQUFxQmwrQixhQUFhMzNCO1lBQ2xFO1lBRUEsU0FBU3M0RCwwQkFBMEJ6aEMsT0FBTztnQkFDeEN3ekIsbUJBQW1COXBCLE1BQU0sR0FBRzFKO1lBQzlCO1lBRUEsU0FBU3d6QixtQkFBbUI1ekQsSUFBSTtnQkFDOUIsT0FBUUE7b0JBQ04sS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7d0JBQ0gsT0FBTzR6RCxtQkFBbUJyeUIsY0FBYztvQkFFMUMsS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxLQUFLO3dCQUNILE9BQU9vZ0M7b0JBRVQsS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7b0JBQ0wsS0FBSzt3QkFDSCxPQUFPL04sbUJBQW1COXBCLE1BQU07b0JBRWxDLEtBQUs7d0JBQ0gsT0FBTzhwQixtQkFBbUJqeUIsYUFBYTtvQkFFekM7d0JBQ0UsT0FBTztnQkFDWDtZQUNGO1lBRUFpeUIsbUJBQW1CdU4sU0FBUyxHQUFHQTtZQUMvQnZOLG1CQUFtQjZOLFdBQVcsR0FBR0E7WUFDakM3TixtQkFBbUIyTixVQUFVLEdBQUdBO1lBQ2hDM04sbUJBQW1Cd0gsT0FBTyxHQUFHQTtZQUM3QnhILG1CQUFtQjBOLFVBQVUsR0FBR0E7WUFDaEMxTixtQkFBbUJ5SCxTQUFTLEdBQUdBO1lBQy9CekgsbUJBQW1CNE4sWUFBWSxHQUFHQTtZQUNsQzVOLG1CQUFtQjJILE1BQU0sR0FBR0g7WUFDNUJ4SCxtQkFBbUIwSCxRQUFRLEdBQUdBO1lBQzlCMUgsbUJBQW1COE4sV0FBVyxHQUFHQTtZQUNqQzlOLG1CQUFtQnYwQixnQkFBZ0IsR0FBRzkxQixLQUFLODFCLGdCQUFnQixDQUFDMWlDLElBQUksQ0FBQzRNO1lBQ2pFcXFELG1CQUFtQi9ZLEtBQUssR0FBR3R4QztZQUMzQm80RCxxQkFBcUJuQiw2QkFBNkJqM0QsS0FBS3kxQixjQUFjLENBQUNDLEtBQUs7WUFDM0UsSUFBSTZpQyx3QkFBd0I3NEUsY0FBYzA0RSxvQkFBb0I7WUFDOUQ3NEUsT0FBT2k1RSxnQkFBZ0IsQ0FBQ25PLG9CQUFvQjtnQkFDMUM0SyxXQUFXO29CQUNUcnhELEtBQUssU0FBU0E7d0JBQ1osT0FBTzVELEtBQUtzN0IsU0FBUyxDQUFDbjhDLE1BQU07b0JBQzlCO2dCQUNGO2dCQUNBNndDLFFBQVE7b0JBQ05wc0IsS0FBSyxTQUFTQTt3QkFDWixPQUFPNUQsS0FBS3M3QixTQUFTLENBQUMsRUFBRSxDQUFDNUQsY0FBYztvQkFDekM7Z0JBQ0Y7Z0JBQ0F3NkIsVUFBVXh5RSxjQUFjMDRFLG9CQUFvQjtnQkFDNUMxL0MsT0FBT2g1QixjQUFjMDRFLG9CQUFvQjtnQkFDekNqekUsVUFBVXpGLGNBQWMwNEUsb0JBQW9CO2dCQUM1Q243QixTQUFTdjlDLGNBQWMwNEUsb0JBQW9CO2dCQUMzQ2pHLGFBQWFvRztnQkFDYkUsY0FBY0Y7Z0JBQ2RyL0MsV0FBVztvQkFDVHRWLEtBQUssU0FBU0E7d0JBQ1osT0FBT3cwRDtvQkFDVDtnQkFDRjtnQkFDQXpGLFFBQVE7b0JBQ04vdUQsS0FBSyxTQUFTQTt3QkFDWixPQUFPNUQsS0FBSzgwQixTQUFTO29CQUN2QjtnQkFDRjtZQUNGO1lBQ0F1MUIsbUJBQW1CcU8sU0FBUyxHQUFHMTRELEtBQUtoVyxJQUFJLENBQUMrRCxFQUFFO1lBQzNDczhELG1CQUFtQmxyRCxLQUFLLEdBQUdhLEtBQUtoVyxJQUFJLENBQUNpaUIsR0FBRztZQUN4Q28rQyxtQkFBbUJscUIsTUFBTSxHQUFHbmdDLEtBQUtoVyxJQUFJLENBQUM4QixLQUFLO1lBQzNDdStELG1CQUFtQjM0RCxNQUFNLEdBQUdzTyxLQUFLaFcsSUFBSSxDQUFDNEIsRUFBRSxLQUFLLElBQUlvVSxLQUFLaFcsSUFBSSxDQUFDNUMsQ0FBQyxHQUFHO1lBQy9EaWpFLG1CQUFtQjU0RCxLQUFLLEdBQUd1TyxLQUFLaFcsSUFBSSxDQUFDNEIsRUFBRSxLQUFLLElBQUlvVSxLQUFLaFcsSUFBSSxDQUFDd2xCLENBQUMsR0FBRztZQUM5RDY2QyxtQkFBbUJpSCxPQUFPLEdBQUd0eEQsS0FBS2hXLElBQUksQ0FBQzZELEVBQUUsR0FBR21TLEtBQUt6VCxJQUFJLENBQUNtTixVQUFVLENBQUM5QixTQUFTO1lBQzFFeXlELG1CQUFtQmtILFFBQVEsR0FBR3Z4RCxLQUFLaFcsSUFBSSxDQUFDOEQsRUFBRSxHQUFHa1MsS0FBS3pULElBQUksQ0FBQ21OLFVBQVUsQ0FBQzlCLFNBQVM7WUFDM0V5eUQsbUJBQW1Cc08sS0FBSyxHQUFHMzRELEtBQUtoVyxJQUFJLENBQUM4TSxFQUFFO1lBQ3ZDdXpELG1CQUFtQnp5QixxQkFBcUIsR0FBR3lnQztZQUMzQ2hPLG1CQUFtQnR5Qix3QkFBd0IsR0FBR3VnQztZQUM5QyxPQUFPak87UUFDVDtJQUNGO0lBRUEsSUFBSXVPLHVCQUF1QjtRQUN6QixPQUFPLFNBQVVDLGlCQUFpQixFQUFFQyxtQkFBbUI7WUFDckQsT0FBTyxTQUFVeDBFLEdBQUc7Z0JBQ2xCQSxNQUFNQSxRQUFRdVYsWUFBWSxJQUFJdlY7Z0JBRTlCLElBQUlBLE9BQU8sR0FBRztvQkFDWixPQUFPdTBFO2dCQUNUO2dCQUVBLE9BQU9DLG9CQUFvQngwRSxNQUFNO1lBQ25DO1FBQ0Y7SUFDRjtJQUVBLElBQUl5MEUsb0JBQW9CO1FBQ3RCLE9BQU8sU0FBVUMsWUFBWSxFQUFFcEMsYUFBYTtZQUMxQyxJQUFJaUMsb0JBQW9CO2dCQUN0QkYsT0FBT0s7WUFDVDtZQUVBLFNBQVNDLGVBQWUzMEUsR0FBRztnQkFDekJBLE1BQU1BLFFBQVF1VixZQUFZLElBQUl2VjtnQkFFOUIsSUFBSUEsT0FBTyxHQUFHO29CQUNaLE9BQU91MEU7Z0JBQ1Q7Z0JBRUEsT0FBT2pDLGNBQWN0eUUsTUFBTTtZQUM3QjtZQUVBLE9BQU8yMEU7UUFDVDtJQUNGO0lBRUEsSUFBSTNoQyw2QkFBNkI7UUFDL0IsSUFBSS9qQyxLQUFLO1lBQ1B1a0Msd0JBQXdCQTtRQUMxQjtRQUVBLFNBQVNBLHVCQUF1QjkzQixJQUFJLEVBQUU0MkQsYUFBYTtZQUNqRCxJQUFJNTJELEtBQUs0NEIsY0FBYyxFQUFFO2dCQUN2QixJQUFJN0IsaUJBQWlCLEVBQUU7Z0JBQ3ZCLElBQUltaUMsY0FBY2w1RCxLQUFLaFcsSUFBSSxDQUFDOHNDLEVBQUU7Z0JBQzlCLElBQUk3M0M7Z0JBQ0osSUFBSUMsTUFBTThnQixLQUFLNDRCLGNBQWMsQ0FBQzdCLGNBQWMsQ0FBQzUzQyxNQUFNO2dCQUVuRCxJQUFLRixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztvQkFDM0I4M0MsZUFBZXYyQyxJQUFJLENBQUMyNEUscUJBQXFCRCxXQUFXLENBQUNqNkUsRUFBRSxFQUFFK2dCLEtBQUs0NEIsY0FBYyxDQUFDN0IsY0FBYyxDQUFDOTNDLEVBQUUsRUFBRTIzRSxlQUFlNTJEO2dCQUNqSDtnQkFFQSxJQUFJNjJCLFVBQVU3MkIsS0FBS2hXLElBQUksQ0FBQzhzQyxFQUFFLElBQUksRUFBRTtnQkFFaEMsSUFBSXNpQyxpQkFBaUIsU0FBU0EsZUFBZTNpRSxJQUFJO29CQUMvQ3hYLElBQUk7b0JBQ0pDLE1BQU0yM0MsUUFBUTEzQyxNQUFNO29CQUVwQixNQUFPRixJQUFJQyxJQUFLO3dCQUNkLElBQUl1WCxTQUFTb2dDLE9BQU8sQ0FBQzUzQyxFQUFFLENBQUM2WCxFQUFFLElBQUlMLFNBQVNvZ0MsT0FBTyxDQUFDNTNDLEVBQUUsQ0FBQ282RSxFQUFFLElBQUk1aUUsU0FBU29nQyxPQUFPLENBQUM1M0MsRUFBRSxDQUFDaW1DLEVBQUUsRUFBRTs0QkFDOUUsT0FBTzZSLGNBQWMsQ0FBQzkzQyxFQUFFO3dCQUMxQjt3QkFFQUEsS0FBSztvQkFDUDtvQkFFQSxPQUFPO2dCQUNUO2dCQUVBTSxPQUFPK3FFLGNBQWMsQ0FBQzhPLGdCQUFnQixpQkFBaUI7b0JBQ3JEeDFELEtBQUssU0FBU0E7d0JBQ1osT0FBT2l6QixRQUFRMTNDLE1BQU07b0JBQ3ZCO2dCQUNGO2dCQUNBLE9BQU9pNkU7WUFDVDtZQUVBLE9BQU87UUFDVDtRQUVBLFNBQVNELHFCQUFxQm52RSxJQUFJLEVBQUVvNkIsUUFBUSxFQUFFd3lDLGFBQWEsRUFBRTUyRCxJQUFJO1lBQy9ELFNBQVNvNUQsZUFBZTNpRSxJQUFJO2dCQUMxQixJQUFJb2dDLFVBQVU3c0MsS0FBSzhzQyxFQUFFO2dCQUNyQixJQUFJNzNDLElBQUk7Z0JBQ1IsSUFBSUMsTUFBTTIzQyxRQUFRMTNDLE1BQU07Z0JBRXhCLE1BQU9GLElBQUlDLElBQUs7b0JBQ2QsSUFBSXVYLFNBQVNvZ0MsT0FBTyxDQUFDNTNDLEVBQUUsQ0FBQzZYLEVBQUUsSUFBSUwsU0FBU29nQyxPQUFPLENBQUM1M0MsRUFBRSxDQUFDbzZFLEVBQUUsSUFBSTVpRSxTQUFTb2dDLE9BQU8sQ0FBQzUzQyxFQUFFLENBQUNpbUMsRUFBRSxFQUFFO3dCQUM5RSxJQUFJMlIsT0FBTyxDQUFDNTNDLEVBQUUsQ0FBQzJNLEVBQUUsS0FBSyxHQUFHOzRCQUN2QixPQUFPbXJDLGNBQWMsQ0FBQzkzQyxFQUFFO3dCQUMxQjt3QkFFQSxPQUFPODNDLGNBQWMsQ0FBQzkzQyxFQUFFO29CQUMxQjtvQkFFQUEsS0FBSztnQkFDUDtnQkFFQSxNQUFNLElBQUk0VztZQUNaO1lBRUEsSUFBSW9qRSxpQkFBaUJMLHFCQUFxQlEsZ0JBQWdCeEM7WUFFMUQsSUFBSTcvQixpQkFBaUIsRUFBRTtZQUN2QixJQUFJOTNDO1lBQ0osSUFBSUMsTUFBTThLLEtBQUs4c0MsRUFBRSxDQUFDMzNDLE1BQU07WUFFeEIsSUFBS0YsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7Z0JBQzNCLElBQUkrSyxLQUFLOHNDLEVBQUUsQ0FBQzczQyxFQUFFLENBQUMyTSxFQUFFLEtBQUssR0FBRztvQkFDdkJtckMsZUFBZXYyQyxJQUFJLENBQUMyNEUscUJBQXFCbnZFLEtBQUs4c0MsRUFBRSxDQUFDNzNDLEVBQUUsRUFBRW1sQyxTQUFTMlMsY0FBYyxDQUFDOTNDLEVBQUUsRUFBRW1sQyxTQUFTMlMsY0FBYyxDQUFDOTNDLEVBQUUsQ0FBQzIzRSxhQUFhLEVBQUU1MkQ7Z0JBQzdILE9BQU87b0JBQ0wrMkIsZUFBZXYyQyxJQUFJLENBQUM4NEUscUJBQXFCbDFDLFNBQVMyUyxjQUFjLENBQUM5M0MsRUFBRSxFQUFFK0ssS0FBSzhzQyxFQUFFLENBQUM3M0MsRUFBRSxDQUFDMk0sRUFBRSxFQUFFb1UsTUFBTWk1RDtnQkFDNUY7WUFDRjtZQUVBLElBQUlqdkUsS0FBS3F2RSxFQUFFLEtBQUssc0JBQXNCO2dCQUNwQzk1RSxPQUFPK3FFLGNBQWMsQ0FBQzhPLGdCQUFnQixTQUFTO29CQUM3Q3gxRCxLQUFLLFNBQVNBO3dCQUNaLE9BQU9tekIsY0FBYyxDQUFDLEVBQUU7b0JBQzFCO2dCQUNGO1lBQ0Y7WUFFQXgzQyxPQUFPaTVFLGdCQUFnQixDQUFDWSxnQkFBZ0I7Z0JBQ3RDRyxlQUFlO29CQUNiMzFELEtBQUssU0FBU0E7d0JBQ1osT0FBTzVaLEtBQUt3dkUsRUFBRTtvQkFDaEI7Z0JBQ0Y7Z0JBQ0FiLE9BQU87b0JBQ0xuNkUsT0FBT3dMLEtBQUs4TSxFQUFFO2dCQUNoQjtnQkFDQTgvRCxlQUFlO29CQUNicDRFLE9BQU95NkU7Z0JBQ1Q7WUFDRjtZQUNBRyxlQUFlSyxPQUFPLEdBQUd6dkUsS0FBSzB2RSxFQUFFLEtBQUs7WUFDckNOLGVBQWV6RyxNQUFNLEdBQUd5RyxlQUFlSyxPQUFPO1lBQzlDLE9BQU9MO1FBQ1Q7UUFFQSxTQUFTRSxxQkFBcUJyMEUsT0FBTyxFQUFFdEcsSUFBSSxFQUFFcWhCLElBQUksRUFBRTQyRCxhQUFhO1lBQzlELElBQUkrQyxxQkFBcUJ2RCw0QkFBNEJueEUsUUFBUTBDLENBQUM7WUFFOUQsU0FBU2t4RTtnQkFDUCxJQUFJbDZFLFNBQVMsSUFBSTtvQkFDZixPQUFPcWhCLEtBQUt6VCxJQUFJLENBQUMySyxhQUFhLENBQUNqUyxRQUFRMEMsQ0FBQyxDQUFDTCxDQUFDO2dCQUM1QztnQkFFQSxPQUFPcXlFO1lBQ1Q7WUFFQSxJQUFJMTBFLFFBQVEwQyxDQUFDLENBQUNpeUUsZ0JBQWdCLEVBQUU7Z0JBQzlCMzBFLFFBQVEwQyxDQUFDLENBQUNpeUUsZ0JBQWdCLENBQUNiLGtCQUFrQixJQUFJbkM7WUFDbkQ7WUFFQSxPQUFPaUM7UUFDVDtRQUVBLE9BQU90bEU7SUFDVDtJQUVBLElBQUlzbUUscUJBQXFCO1FBQ3ZCLE9BQU8sU0FBU0MscUJBQXFCMW1ELEtBQUssRUFBRTJtRCxJQUFJLEVBQUVuRCxhQUFhO1lBQzdELElBQUloM0UsT0FBT202RSxLQUFLL3NELEVBQUU7WUFFbEIsU0FBUzZyRCxrQkFBa0J2MEUsR0FBRztnQkFDNUIsSUFBSUEsUUFBUSxXQUFXQSxRQUFRLFdBQVdBLFFBQVEsVUFBVUEsUUFBUSxVQUFVQSxRQUFRLHVCQUF1QkEsUUFBUSxHQUFHO29CQUN0SCxPQUFPdTBFLGtCQUFrQjl1RSxJQUFJO2dCQUMvQjtnQkFFQSxPQUFPO1lBQ1Q7WUFFQSxJQUFJa3ZFLGlCQUFpQkwscUJBQXFCQyxtQkFBbUJqQztZQUU3RGgzRSxLQUFLZzZFLGdCQUFnQixDQUFDYixrQkFBa0IsUUFBUUU7WUFDaEQxNUUsT0FBT2k1RSxnQkFBZ0IsQ0FBQ0ssbUJBQW1CO2dCQUN6Qzl1RSxNQUFNO29CQUNKNlosS0FBSyxTQUFTQTt3QkFDWixJQUFJaGtCLEtBQUt3TCxDQUFDLEVBQUU7NEJBQ1Z4TCxLQUFLbXhCLFFBQVE7d0JBQ2Y7d0JBRUEsT0FBT254QjtvQkFDVDtnQkFDRjtnQkFDQXd6QixPQUFPO29CQUNMeFAsS0FBSyxTQUFTQTt3QkFDWixJQUFJaGtCLEtBQUt3TCxDQUFDLEVBQUU7NEJBQ1Z4TCxLQUFLbXhCLFFBQVE7d0JBQ2Y7d0JBRUEsT0FBT254QjtvQkFDVDtnQkFDRjtnQkFDQSs0RSxPQUFPO29CQUNMbjZFLE9BQU80MEIsTUFBTXRjLEVBQUU7Z0JBQ2pCO2dCQUNBb3VCLElBQUk7b0JBQ0YxbUMsT0FBTzQwQixNQUFNOFIsRUFBRTtnQkFDakI7Z0JBQ0E4MEMsZUFBZTtvQkFDYng3RSxPQUFPNDBCLE1BQU04UixFQUFFO2dCQUNqQjtnQkFDQW0wQyxJQUFJO29CQUNGNzZFLE9BQU80MEIsTUFBTWltRCxFQUFFO2dCQUNqQjtnQkFDQXpDLGVBQWU7b0JBQ2JwNEUsT0FBT280RTtnQkFDVDtZQUNGO1lBQ0EsT0FBT2lDO1FBQ1Q7SUFDRjtJQUVBLElBQUl0aEMsMkJBQTJCO1FBQzdCLFNBQVMwaUMsZ0JBQWdCanVFLE1BQU0sRUFBRSt0RSxJQUFJLEVBQUVuRCxhQUFhO1lBQ2xELElBQUk1MEUsTUFBTSxFQUFFO1lBQ1osSUFBSS9DO1lBQ0osSUFBSUMsTUFBTThNLFNBQVNBLE9BQU83TSxNQUFNLEdBQUc7WUFFbkMsSUFBS0YsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7Z0JBQzNCLElBQUkrTSxNQUFNLENBQUMvTSxFQUFFLENBQUMyTSxFQUFFLEtBQUssTUFBTTtvQkFDekI1SixJQUFJeEIsSUFBSSxDQUFDMDVFLHNCQUFzQmx1RSxNQUFNLENBQUMvTSxFQUFFLEVBQUU4NkUsSUFBSSxDQUFDOTZFLEVBQUUsRUFBRTIzRTtnQkFDckQsT0FBTyxJQUFJNXFFLE1BQU0sQ0FBQy9NLEVBQUUsQ0FBQzJNLEVBQUUsS0FBSyxNQUFNO29CQUNoQzVKLElBQUl4QixJQUFJLENBQUMyNUUscUJBQXFCbnVFLE1BQU0sQ0FBQy9NLEVBQUUsRUFBRTg2RSxJQUFJLENBQUM5NkUsRUFBRSxFQUFFMjNFO2dCQUNwRCxPQUFPLElBQUk1cUUsTUFBTSxDQUFDL00sRUFBRSxDQUFDMk0sRUFBRSxLQUFLLE1BQU07b0JBQ2hDNUosSUFBSXhCLElBQUksQ0FBQzQ1RSx1QkFBdUJwdUUsTUFBTSxDQUFDL00sRUFBRSxFQUFFODZFLElBQUksQ0FBQzk2RSxFQUFFLEVBQUUyM0U7Z0JBQ3RELE9BQU8sSUFBSTVxRSxNQUFNLENBQUMvTSxFQUFFLENBQUMyTSxFQUFFLEtBQUssTUFBTTtvQkFDaEM1SixJQUFJeEIsSUFBSSxDQUFDNjVFLHFCQUFxQnJ1RSxNQUFNLENBQUMvTSxFQUFFLEVBQUU4NkUsSUFBSSxDQUFDOTZFLEVBQUUsRUFBRTIzRTtnQkFDcEQsT0FBTyxJQUFJNXFFLE1BQU0sQ0FBQy9NLEVBQUUsQ0FBQzJNLEVBQUUsS0FBSyxNQUFNLENBQ2xDLE9BQU8sSUFBSUksTUFBTSxDQUFDL00sRUFBRSxDQUFDMk0sRUFBRSxLQUFLLE1BQU07b0JBQ2hDNUosSUFBSXhCLElBQUksQ0FBQzg1RSx3QkFBd0J0dUUsTUFBTSxDQUFDL00sRUFBRSxFQUFFODZFLElBQUksQ0FBQzk2RSxFQUFFLEVBQUUyM0U7Z0JBQ3ZELE9BQU8sSUFBSTVxRSxNQUFNLENBQUMvTSxFQUFFLENBQUMyTSxFQUFFLEtBQUssTUFBTTtvQkFDaEM1SixJQUFJeEIsSUFBSSxDQUFDKzVFLHFCQUFxQnZ1RSxNQUFNLENBQUMvTSxFQUFFLEVBQUU4NkUsSUFBSSxDQUFDOTZFLEVBQUUsRUFBRTIzRTtnQkFDcEQsT0FBTyxJQUFJNXFFLE1BQU0sQ0FBQy9NLEVBQUUsQ0FBQzJNLEVBQUUsS0FBSyxNQUFNO29CQUNoQzVKLElBQUl4QixJQUFJLENBQUNxNUUsbUJBQW1CN3RFLE1BQU0sQ0FBQy9NLEVBQUUsRUFBRTg2RSxJQUFJLENBQUM5NkUsRUFBRSxFQUFFMjNFO2dCQUNsRCxPQUFPLElBQUk1cUUsTUFBTSxDQUFDL00sRUFBRSxDQUFDMk0sRUFBRSxLQUFLLE1BQU07b0JBQ2hDNUosSUFBSXhCLElBQUksQ0FBQ2c2RSxxQkFBcUJ4dUUsTUFBTSxDQUFDL00sRUFBRSxFQUFFODZFLElBQUksQ0FBQzk2RSxFQUFFLEVBQUUyM0U7Z0JBQ3BELE9BQU8sSUFBSTVxRSxNQUFNLENBQUMvTSxFQUFFLENBQUMyTSxFQUFFLEtBQUssTUFBTTtvQkFDaEM1SixJQUFJeEIsSUFBSSxDQUFDaTZFLHdCQUF3Qnp1RSxNQUFNLENBQUMvTSxFQUFFLEVBQUU4NkUsSUFBSSxDQUFDOTZFLEVBQUUsRUFBRTIzRTtnQkFDdkQsT0FBTyxJQUFJNXFFLE1BQU0sQ0FBQy9NLEVBQUUsQ0FBQzJNLEVBQUUsS0FBSyxNQUFNO29CQUNoQzVKLElBQUl4QixJQUFJLENBQUNrNkUseUJBQXlCMXVFLE1BQU0sQ0FBQy9NLEVBQUUsRUFBRTg2RSxJQUFJLENBQUM5NkUsRUFBRSxFQUFFMjNFO2dCQUN4RCxPQUFPLElBQUk1cUUsTUFBTSxDQUFDL00sRUFBRSxDQUFDMk0sRUFBRSxLQUFLLE1BQU07b0JBQ2hDNUosSUFBSXhCLElBQUksQ0FBQ202RSw2QkFBNkIzdUUsTUFBTSxDQUFDL00sRUFBRSxFQUFFODZFLElBQUksQ0FBQzk2RSxFQUFFLEVBQUUyM0U7Z0JBQzVELE9BQU87b0JBQ0w1MEUsSUFBSXhCLElBQUksQ0FBQ282RSx3QkFBd0I1dUUsTUFBTSxDQUFDL00sRUFBRSxFQUFFODZFLElBQUksQ0FBQzk2RSxFQUFFLEVBQUUyM0U7Z0JBQ3ZEO1lBQ0Y7WUFFQSxPQUFPNTBFO1FBQ1Q7UUFFQSxTQUFTNjRFLHlCQUF5QnpuRCxLQUFLLEVBQUUybUQsSUFBSSxFQUFFbkQsYUFBYTtZQUMxRCxJQUFJa0U7WUFFSixJQUFJakMsb0JBQW9CLFNBQVNrQyxtQkFBbUJ2OEUsS0FBSztnQkFDdkQsSUFBSVMsSUFBSTtnQkFDUixJQUFJQyxNQUFNNDdFLFdBQVczN0UsTUFBTTtnQkFFM0IsTUFBT0YsSUFBSUMsSUFBSztvQkFDZCxJQUFJNDdFLFVBQVUsQ0FBQzc3RSxFQUFFLENBQUMwNUUsS0FBSyxLQUFLbjZFLFNBQVNzOEUsVUFBVSxDQUFDNzdFLEVBQUUsQ0FBQ282RSxFQUFFLEtBQUs3NkUsU0FBU3M4RSxVQUFVLENBQUM3N0UsRUFBRSxDQUFDKzZFLGFBQWEsS0FBS3g3RSxTQUFTczhFLFVBQVUsQ0FBQzc3RSxFQUFFLENBQUNpbUMsRUFBRSxLQUFLMW1DLFNBQVNzOEUsVUFBVSxDQUFDNzdFLEVBQUUsQ0FBQ2d0QixHQUFHLEtBQUt6dEIsT0FBTzt3QkFDckssT0FBT3M4RSxVQUFVLENBQUM3N0UsRUFBRTtvQkFDdEI7b0JBRUFBLEtBQUs7Z0JBQ1A7Z0JBRUEsSUFBSSxPQUFPVCxVQUFVLFVBQVU7b0JBQzdCLE9BQU9zOEUsVUFBVSxDQUFDdDhFLFFBQVEsRUFBRTtnQkFDOUI7Z0JBRUEsT0FBTztZQUNUO1lBRUFxNkUsa0JBQWtCakMsYUFBYSxHQUFHZ0MscUJBQXFCQyxtQkFBbUJqQztZQUMxRWtFLGFBQWFiLGdCQUFnQjdtRCxNQUFNdm1CLEVBQUUsRUFBRWt0RSxLQUFLbHRFLEVBQUUsRUFBRWdzRSxrQkFBa0JqQyxhQUFhO1lBQy9FaUMsa0JBQWtCVSxhQUFhLEdBQUd1QixXQUFXMzdFLE1BQU07WUFDbkQsSUFBSWk1RSxxQkFBcUI0QywwQkFBMEI1bkQsTUFBTXZtQixFQUFFLENBQUN1bUIsTUFBTXZtQixFQUFFLENBQUMxTixNQUFNLEdBQUcsRUFBRSxFQUFFNDZFLEtBQUtsdEUsRUFBRSxDQUFDa3RFLEtBQUtsdEUsRUFBRSxDQUFDMU4sTUFBTSxHQUFHLEVBQUUsRUFBRTA1RSxrQkFBa0JqQyxhQUFhO1lBQzlJaUMsa0JBQWtCMy9DLFNBQVMsR0FBR2svQztZQUM5QlMsa0JBQWtCbUIsYUFBYSxHQUFHNW1ELE1BQU02bkQsR0FBRztZQUMzQ3BDLGtCQUFrQkYsS0FBSyxHQUFHdmxELE1BQU10YyxFQUFFO1lBQ2xDLE9BQU8raEU7UUFDVDtRQUVBLFNBQVNxQixzQkFBc0I5bUQsS0FBSyxFQUFFMm1ELElBQUksRUFBRW5ELGFBQWE7WUFDdkQsSUFBSWlDLG9CQUFvQixTQUFTa0MsbUJBQW1CdjhFLEtBQUs7Z0JBQ3ZELE9BQVFBO29CQUNOLEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxLQUFLO3dCQUNILE9BQU9xNkUsa0JBQWtCMWdDLE9BQU87b0JBQ2xDLHNFQUFzRTtvQkFDdEUsc0NBQXNDO29CQUN0QyxVQUFVO29CQUVWO3dCQUNFLE9BQU8wZ0Msa0JBQWtCMy9DLFNBQVM7Z0JBQ3RDO1lBQ0Y7WUFFQTIvQyxrQkFBa0JqQyxhQUFhLEdBQUdnQyxxQkFBcUJDLG1CQUFtQmpDO1lBQzFFLElBQUl6K0IsVUFBVTBpQyx5QkFBeUJ6bkQsT0FBTzJtRCxNQUFNbEIsa0JBQWtCakMsYUFBYTtZQUNuRixJQUFJd0IscUJBQXFCNEMsMEJBQTBCNW5ELE1BQU12bUIsRUFBRSxDQUFDdW1CLE1BQU12bUIsRUFBRSxDQUFDMU4sTUFBTSxHQUFHLEVBQUUsRUFBRTQ2RSxLQUFLbHRFLEVBQUUsQ0FBQ2t0RSxLQUFLbHRFLEVBQUUsQ0FBQzFOLE1BQU0sR0FBRyxFQUFFLEVBQUUwNUUsa0JBQWtCakMsYUFBYTtZQUM5SWlDLGtCQUFrQjFnQyxPQUFPLEdBQUdBO1lBQzVCMGdDLGtCQUFrQjMvQyxTQUFTLEdBQUdrL0M7WUFDOUI3NEUsT0FBTytxRSxjQUFjLENBQUN1TyxtQkFBbUIsU0FBUztnQkFDaERqMUQsS0FBSyxTQUFTQTtvQkFDWixPQUFPd1AsTUFBTXRjLEVBQUU7Z0JBQ2pCO1lBQ0YsSUFBSSxpREFBaUQ7WUFFckQraEUsa0JBQWtCVSxhQUFhLEdBQUdubUQsTUFBTW9tRCxFQUFFO1lBQzFDWCxrQkFBa0JtQixhQUFhLEdBQUc1bUQsTUFBTThSLEVBQUU7WUFDMUMyekMsa0JBQWtCL2hFLEVBQUUsR0FBR3NjLE1BQU10YyxFQUFFO1lBQy9CK2hFLGtCQUFrQlEsRUFBRSxHQUFHam1ELE1BQU1pbUQsRUFBRTtZQUMvQixPQUFPUjtRQUNUO1FBRUEsU0FBU3NCLHFCQUFxQi9tRCxLQUFLLEVBQUUybUQsSUFBSSxFQUFFbkQsYUFBYTtZQUN0RCxTQUFTaUMsa0JBQWtCdjBFLEdBQUc7Z0JBQzVCLElBQUlBLFFBQVEsV0FBV0EsUUFBUSxTQUFTO29CQUN0QyxPQUFPdTBFLGtCQUFrQjV3RSxLQUFLO2dCQUNoQztnQkFFQSxJQUFJM0QsUUFBUSxhQUFhQSxRQUFRLFdBQVc7b0JBQzFDLE9BQU91MEUsa0JBQWtCNTdCLE9BQU87Z0JBQ2xDO2dCQUVBLE9BQU87WUFDVDtZQUVBMTlDLE9BQU9pNUUsZ0JBQWdCLENBQUNLLG1CQUFtQjtnQkFDekM1d0UsT0FBTztvQkFDTDJiLEtBQUt3eUQsNEJBQTRCMkQsS0FBS3ZyRSxDQUFDO2dCQUN6QztnQkFDQXl1QyxTQUFTO29CQUNQcjVCLEtBQUt3eUQsNEJBQTRCMkQsS0FBS2p0RSxDQUFDO2dCQUN6QztnQkFDQTZyRSxPQUFPO29CQUNMbjZFLE9BQU80MEIsTUFBTXRjLEVBQUU7Z0JBQ2pCO2dCQUNBdWlFLElBQUk7b0JBQ0Y3NkUsT0FBTzQwQixNQUFNaW1ELEVBQUU7Z0JBQ2pCO1lBQ0Y7WUFDQVUsS0FBS3ZyRSxDQUFDLENBQUNvckUsZ0JBQWdCLENBQUNiLGtCQUFrQixTQUFTbkM7WUFDbkRtRCxLQUFLanRFLENBQUMsQ0FBQzhzRSxnQkFBZ0IsQ0FBQ2Isa0JBQWtCLFdBQVduQztZQUNyRCxPQUFPaUM7UUFDVDtRQUVBLFNBQVM4Qiw2QkFBNkJ2bkQsS0FBSyxFQUFFMm1ELElBQUksRUFBRW5ELGFBQWE7WUFDOUQsU0FBU2lDLGtCQUFrQnYwRSxHQUFHO2dCQUM1QixJQUFJQSxRQUFRLGlCQUFpQkEsUUFBUSxlQUFlO29CQUNsRCxPQUFPdTBFLGtCQUFrQnFDLFVBQVU7Z0JBQ3JDO2dCQUVBLElBQUk1MkUsUUFBUSxlQUFlQSxRQUFRLGFBQWE7b0JBQzlDLE9BQU91MEUsa0JBQWtCc0MsUUFBUTtnQkFDbkM7Z0JBRUEsSUFBSTcyRSxRQUFRLGFBQWFBLFFBQVEsV0FBVztvQkFDMUMsT0FBT3UwRSxrQkFBa0I1N0IsT0FBTztnQkFDbEM7Z0JBRUEsT0FBTztZQUNUO1lBRUExOUMsT0FBT2k1RSxnQkFBZ0IsQ0FBQ0ssbUJBQW1CO2dCQUN6Q3FDLFlBQVk7b0JBQ1Z0M0QsS0FBS3d5RCw0QkFBNEIyRCxLQUFLMXlFLENBQUM7Z0JBQ3pDO2dCQUNBOHpFLFVBQVU7b0JBQ1J2M0QsS0FBS3d5RCw0QkFBNEIyRCxLQUFLbnZFLENBQUM7Z0JBQ3pDO2dCQUNBcXlDLFNBQVM7b0JBQ1ByNUIsS0FBS3d5RCw0QkFBNEIyRCxLQUFLanRFLENBQUM7Z0JBQ3pDO2dCQUNBbk8sTUFBTTtvQkFDSmlsQixLQUFLLFNBQVNBO3dCQUNaLE9BQU87b0JBQ1Q7Z0JBQ0Y7Z0JBQ0ErMEQsT0FBTztvQkFDTG42RSxPQUFPNDBCLE1BQU10YyxFQUFFO2dCQUNqQjtnQkFDQXVpRSxJQUFJO29CQUNGNzZFLE9BQU80MEIsTUFBTWltRCxFQUFFO2dCQUNqQjtZQUNGO1lBQ0FVLEtBQUsxeUUsQ0FBQyxDQUFDdXlFLGdCQUFnQixDQUFDYixrQkFBa0IsZUFBZW5DO1lBQ3pEbUQsS0FBS252RSxDQUFDLENBQUNndkUsZ0JBQWdCLENBQUNiLGtCQUFrQixhQUFhbkM7WUFDdkRtRCxLQUFLanRFLENBQUMsQ0FBQzhzRSxnQkFBZ0IsQ0FBQ2Isa0JBQWtCLFdBQVduQztZQUNyRCxPQUFPaUM7UUFDVDtRQUVBLFNBQVMrQjtZQUNQLFNBQVMvQjtnQkFDUCxPQUFPO1lBQ1Q7WUFFQSxPQUFPQTtRQUNUO1FBRUEsU0FBU3VCLHVCQUF1QmhuRCxLQUFLLEVBQUUybUQsSUFBSSxFQUFFbkQsYUFBYTtZQUN4RCxJQUFJcUMsaUJBQWlCTCxxQkFBcUJDLG1CQUFtQmpDO1lBRTdELElBQUl3RSxxQkFBcUJ4QyxxQkFBcUJ5QyxRQUFRcEM7WUFFdEQsU0FBU3FDLG9CQUFvQnI4RSxDQUFDO2dCQUM1Qk0sT0FBTytxRSxjQUFjLENBQUMrUSxRQUFRam9ELE1BQU1yckIsQ0FBQyxDQUFDOUksRUFBRSxDQUFDNlgsRUFBRSxFQUFFO29CQUMzQzhNLEtBQUt3eUQsNEJBQTRCMkQsS0FBS2h5RSxDQUFDLENBQUM0OEMsU0FBUyxDQUFDMWxELEVBQUUsQ0FBQzBJLENBQUM7Z0JBQ3hEO1lBQ0Y7WUFFQSxJQUFJMUk7WUFDSixJQUFJQyxNQUFNazBCLE1BQU1yckIsQ0FBQyxHQUFHcXJCLE1BQU1yckIsQ0FBQyxDQUFDNUksTUFBTSxHQUFHO1lBQ3JDLElBQUlrOEUsU0FBUyxDQUFDO1lBRWQsSUFBS3A4RSxJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztnQkFDM0JxOEUsb0JBQW9CcjhFO2dCQUNwQjg2RSxLQUFLaHlFLENBQUMsQ0FBQzQ4QyxTQUFTLENBQUMxbEQsRUFBRSxDQUFDMEksQ0FBQyxDQUFDaXlFLGdCQUFnQixDQUFDd0I7WUFDekM7WUFFQSxTQUFTdkMsa0JBQWtCdjBFLEdBQUc7Z0JBQzVCLElBQUlBLFFBQVEsV0FBV0EsUUFBUSxTQUFTO29CQUN0QyxPQUFPdTBFLGtCQUFrQjV3RSxLQUFLO2dCQUNoQztnQkFFQSxJQUFJM0QsUUFBUSxhQUFhQSxRQUFRLFdBQVc7b0JBQzFDLE9BQU91MEUsa0JBQWtCNTdCLE9BQU87Z0JBQ2xDO2dCQUVBLElBQUkzNEMsUUFBUSxrQkFBa0JBLFFBQVEsZ0JBQWdCO29CQUNwRCxPQUFPdTBFLGtCQUFrQm5TLFdBQVc7Z0JBQ3RDO2dCQUVBLE9BQU87WUFDVDtZQUVBbm5FLE9BQU9pNUUsZ0JBQWdCLENBQUNLLG1CQUFtQjtnQkFDekM1d0UsT0FBTztvQkFDTDJiLEtBQUt3eUQsNEJBQTRCMkQsS0FBS3ZyRSxDQUFDO2dCQUN6QztnQkFDQXl1QyxTQUFTO29CQUNQcjVCLEtBQUt3eUQsNEJBQTRCMkQsS0FBS2p0RSxDQUFDO2dCQUN6QztnQkFDQTQ1RCxhQUFhO29CQUNYOWlELEtBQUt3eUQsNEJBQTRCMkQsS0FBS3ZxRCxDQUFDO2dCQUN6QztnQkFDQStyRCxNQUFNO29CQUNKMzNELEtBQUssU0FBU0E7d0JBQ1osT0FBT3kzRDtvQkFDVDtnQkFDRjtnQkFDQTFDLE9BQU87b0JBQ0xuNkUsT0FBTzQwQixNQUFNdGMsRUFBRTtnQkFDakI7Z0JBQ0F1aUUsSUFBSTtvQkFDRjc2RSxPQUFPNDBCLE1BQU1pbUQsRUFBRTtnQkFDakI7WUFDRjtZQUNBVSxLQUFLdnJFLENBQUMsQ0FBQ29yRSxnQkFBZ0IsQ0FBQ2Isa0JBQWtCLFNBQVNFO1lBQ25EYyxLQUFLanRFLENBQUMsQ0FBQzhzRSxnQkFBZ0IsQ0FBQ2Isa0JBQWtCLFdBQVdFO1lBQ3JEYyxLQUFLdnFELENBQUMsQ0FBQ29xRCxnQkFBZ0IsQ0FBQ2Isa0JBQWtCLGdCQUFnQkU7WUFDMUQsT0FBT0o7UUFDVDtRQUVBLFNBQVN3QixxQkFBcUJqbkQsS0FBSyxFQUFFMm1ELElBQUksRUFBRW5ELGFBQWE7WUFDdEQsU0FBU2lDLGtCQUFrQnYwRSxHQUFHO2dCQUM1QixJQUFJQSxRQUFROHVCLE1BQU14b0IsQ0FBQyxDQUFDczZCLEVBQUUsSUFBSTVnQyxRQUFRLFNBQVNBLFFBQVEsT0FBTztvQkFDeEQsT0FBT3UwRSxrQkFBa0IxNkQsR0FBRztnQkFDOUI7Z0JBRUEsSUFBSTdaLFFBQVE4dUIsTUFBTS9yQixDQUFDLENBQUM2OUIsRUFBRSxFQUFFO29CQUN0QixPQUFPMnpDLGtCQUFrQjJDLEtBQUs7Z0JBQ2hDO2dCQUVBLElBQUlsM0UsUUFBUTh1QixNQUFNdG1CLENBQUMsQ0FBQ280QixFQUFFLEVBQUU7b0JBQ3RCLE9BQU8yekMsa0JBQWtCM3dFLE1BQU07Z0JBQ2pDO2dCQUVBLE9BQU87WUFDVDtZQUVBLElBQUkrd0UsaUJBQWlCTCxxQkFBcUJDLG1CQUFtQmpDO1lBRTdEaUMsa0JBQWtCbUIsYUFBYSxHQUFHNW1ELE1BQU04UixFQUFFO1lBQzFDNjBDLEtBQUsxeUUsQ0FBQyxDQUFDdXlFLGdCQUFnQixDQUFDYixrQkFBa0IsU0FBU0U7WUFDbkRjLEtBQUtudkUsQ0FBQyxDQUFDZ3ZFLGdCQUFnQixDQUFDYixrQkFBa0IsT0FBT0U7WUFDakRjLEtBQUtqdEUsQ0FBQyxDQUFDOHNFLGdCQUFnQixDQUFDYixrQkFBa0IsVUFBVUU7WUFDcERKLGtCQUFrQm1CLGFBQWEsR0FBRzVtRCxNQUFNOFIsRUFBRTtZQUMxQzJ6QyxrQkFBa0JqQyxhQUFhLEdBQUdBO1lBQ2xDcjNFLE9BQU9pNUUsZ0JBQWdCLENBQUNLLG1CQUFtQjtnQkFDekMyQyxPQUFPO29CQUNMNTNELEtBQUt3eUQsNEJBQTRCMkQsS0FBSzF5RSxDQUFDO2dCQUN6QztnQkFDQThXLEtBQUs7b0JBQ0h5RixLQUFLd3lELDRCQUE0QjJELEtBQUtudkUsQ0FBQztnQkFDekM7Z0JBQ0ExQyxRQUFRO29CQUNOMGIsS0FBS3d5RCw0QkFBNEIyRCxLQUFLanRFLENBQUM7Z0JBQ3pDO2dCQUNBNnJFLE9BQU87b0JBQ0xuNkUsT0FBTzQwQixNQUFNdGMsRUFBRTtnQkFDakI7WUFDRjtZQUNBK2hFLGtCQUFrQlEsRUFBRSxHQUFHam1ELE1BQU1pbUQsRUFBRTtZQUMvQixPQUFPUjtRQUNUO1FBRUEsU0FBU21DLDBCQUEwQjVuRCxLQUFLLEVBQUUybUQsSUFBSSxFQUFFbkQsYUFBYTtZQUMzRCxTQUFTaUMsa0JBQWtCcjZFLEtBQUs7Z0JBQzlCLElBQUk0MEIsTUFBTW5sQixDQUFDLENBQUNpM0IsRUFBRSxLQUFLMW1DLFNBQVNBLFVBQVUsZ0JBQWdCO29CQUNwRCxPQUFPcTZFLGtCQUFrQjFHLFdBQVc7Z0JBQ3RDO2dCQUVBLElBQUkvK0MsTUFBTXRtQixDQUFDLENBQUNvNEIsRUFBRSxLQUFLMW1DLFNBQVNBLFVBQVUsV0FBVztvQkFDL0MsT0FBT3E2RSxrQkFBa0I1N0IsT0FBTztnQkFDbEM7Z0JBRUEsSUFBSTdwQixNQUFNenJCLENBQUMsQ0FBQ3U5QixFQUFFLEtBQUsxbUMsU0FBU0EsVUFBVSxZQUFZO29CQUNoRCxPQUFPcTZFLGtCQUFrQjF6RSxRQUFRO2dCQUNuQztnQkFFQSxJQUFJaXVCLE1BQU03ckIsQ0FBQyxDQUFDMjlCLEVBQUUsS0FBSzFtQyxTQUFTQSxVQUFVLGNBQWNBLFVBQVUsd0JBQXdCO29CQUNwRixPQUFPcTZFLGtCQUFrQjNHLFFBQVE7Z0JBQ25DO2dCQUVBLElBQUk5K0MsTUFBTS9yQixDQUFDLENBQUM2OUIsRUFBRSxLQUFLMW1DLFNBQVNBLFVBQVUsU0FBUztvQkFDN0MsT0FBT3E2RSxrQkFBa0JuZ0QsS0FBSztnQkFDaEM7Z0JBRUEsSUFBSXRGLE1BQU1sbEIsRUFBRSxJQUFJa2xCLE1BQU1sbEIsRUFBRSxDQUFDZzNCLEVBQUUsS0FBSzFtQyxTQUFTQSxVQUFVLFFBQVE7b0JBQ3pELE9BQU9xNkUsa0JBQWtCcmdELElBQUk7Z0JBQy9CO2dCQUVBLElBQUlwRixNQUFNamxCLEVBQUUsSUFBSWlsQixNQUFNamxCLEVBQUUsQ0FBQysyQixFQUFFLEtBQUsxbUMsU0FBU0EsVUFBVSxhQUFhO29CQUM5RCxPQUFPcTZFLGtCQUFrQjRDLFFBQVE7Z0JBQ25DO2dCQUVBLE9BQU87WUFDVDtZQUVBLElBQUl4QyxpQkFBaUJMLHFCQUFxQkMsbUJBQW1CakM7WUFFN0RtRCxLQUFLN2dELFNBQVMsQ0FBQzBNLE1BQU0sQ0FBQzk0QixDQUFDLENBQUM4c0UsZ0JBQWdCLENBQUNiLGtCQUFrQixXQUFXRTtZQUN0RWMsS0FBSzdnRCxTQUFTLENBQUMwTSxNQUFNLENBQUNqK0IsQ0FBQyxDQUFDaXlFLGdCQUFnQixDQUFDYixrQkFBa0IsWUFBWUU7WUFDdkVjLEtBQUs3Z0QsU0FBUyxDQUFDME0sTUFBTSxDQUFDMzNCLENBQUMsQ0FBQzJyRSxnQkFBZ0IsQ0FBQ2Isa0JBQWtCLGdCQUFnQkU7WUFDM0VjLEtBQUs3Z0QsU0FBUyxDQUFDME0sTUFBTSxDQUFDditCLENBQUMsQ0FBQ3V5RSxnQkFBZ0IsQ0FBQ2Isa0JBQWtCLFNBQVNFO1lBQ3BFYyxLQUFLN2dELFNBQVMsQ0FBQzBNLE1BQU0sQ0FBQ3IrQixDQUFDLENBQUNxeUUsZ0JBQWdCLENBQUNiLGtCQUFrQixZQUFZRTtZQUV2RSxJQUFJYyxLQUFLN2dELFNBQVMsQ0FBQzBNLE1BQU0sQ0FBQzEzQixFQUFFLEVBQUU7Z0JBQzVCNnJFLEtBQUs3Z0QsU0FBUyxDQUFDME0sTUFBTSxDQUFDMTNCLEVBQUUsQ0FBQzByRSxnQkFBZ0IsQ0FBQ2Isa0JBQWtCLFFBQVFFO2dCQUNwRWMsS0FBSzdnRCxTQUFTLENBQUMwTSxNQUFNLENBQUN6M0IsRUFBRSxDQUFDeXJFLGdCQUFnQixDQUFDYixrQkFBa0IsY0FBY0U7WUFDNUU7WUFFQWMsS0FBSzdnRCxTQUFTLENBQUNwckIsRUFBRSxDQUFDOHJFLGdCQUFnQixDQUFDYixrQkFBa0IsV0FBV0U7WUFDaEUxNUUsT0FBT2k1RSxnQkFBZ0IsQ0FBQ0ssbUJBQW1CO2dCQUN6QzU3QixTQUFTO29CQUNQcjVCLEtBQUt3eUQsNEJBQTRCMkQsS0FBSzdnRCxTQUFTLENBQUMwTSxNQUFNLENBQUM5NEIsQ0FBQztnQkFDMUQ7Z0JBQ0EzSCxVQUFVO29CQUNSeWUsS0FBS3d5RCw0QkFBNEIyRCxLQUFLN2dELFNBQVMsQ0FBQzBNLE1BQU0sQ0FBQ2orQixDQUFDO2dCQUMxRDtnQkFDQXdxRSxhQUFhO29CQUNYdnVELEtBQUt3eUQsNEJBQTRCMkQsS0FBSzdnRCxTQUFTLENBQUMwTSxNQUFNLENBQUMzM0IsQ0FBQztnQkFDMUQ7Z0JBQ0F5cUIsT0FBTztvQkFDTDlVLEtBQUt3eUQsNEJBQTRCMkQsS0FBSzdnRCxTQUFTLENBQUMwTSxNQUFNLENBQUN2K0IsQ0FBQztnQkFDMUQ7Z0JBQ0E2cUUsVUFBVTtvQkFDUnR1RCxLQUFLd3lELDRCQUE0QjJELEtBQUs3Z0QsU0FBUyxDQUFDME0sTUFBTSxDQUFDcitCLENBQUM7Z0JBQzFEO2dCQUNBaXhCLE1BQU07b0JBQ0o1VSxLQUFLd3lELDRCQUE0QjJELEtBQUs3Z0QsU0FBUyxDQUFDME0sTUFBTSxDQUFDMTNCLEVBQUU7Z0JBQzNEO2dCQUNBdXRFLFVBQVU7b0JBQ1I3M0QsS0FBS3d5RCw0QkFBNEIyRCxLQUFLN2dELFNBQVMsQ0FBQzBNLE1BQU0sQ0FBQ3ozQixFQUFFO2dCQUMzRDtnQkFDQXdxRSxPQUFPO29CQUNMbjZFLE9BQU80MEIsTUFBTXRjLEVBQUU7Z0JBQ2pCO1lBQ0Y7WUFDQStoRSxrQkFBa0JqdEUsRUFBRSxHQUFHO1lBQ3ZCaXRFLGtCQUFrQlEsRUFBRSxHQUFHam1ELE1BQU1pbUQsRUFBRTtZQUMvQlIsa0JBQWtCakMsYUFBYSxHQUFHQTtZQUNsQyxPQUFPaUM7UUFDVDtRQUVBLFNBQVN5Qix3QkFBd0JsbkQsS0FBSyxFQUFFMm1ELElBQUksRUFBRW5ELGFBQWE7WUFDekQsU0FBU2lDLGtCQUFrQnI2RSxLQUFLO2dCQUM5QixJQUFJNDBCLE1BQU16ckIsQ0FBQyxDQUFDdTlCLEVBQUUsS0FBSzFtQyxPQUFPO29CQUN4QixPQUFPcTZFLGtCQUFrQjF6RSxRQUFRO2dCQUNuQztnQkFFQSxJQUFJaXVCLE1BQU0vckIsQ0FBQyxDQUFDNjlCLEVBQUUsS0FBSzFtQyxPQUFPO29CQUN4QixPQUFPcTZFLGtCQUFrQnZxQyxJQUFJO2dCQUMvQjtnQkFFQSxPQUFPO1lBQ1Q7WUFFQSxJQUFJMnFDLGlCQUFpQkwscUJBQXFCQyxtQkFBbUJqQztZQUU3RGlDLGtCQUFrQm1CLGFBQWEsR0FBRzVtRCxNQUFNOFIsRUFBRTtZQUMxQyxJQUFJdGxDLE9BQU9tNkUsS0FBSy9zRCxFQUFFLENBQUNwaEIsRUFBRSxLQUFLLE9BQU9tdUUsS0FBSy9zRCxFQUFFLENBQUNwdEIsSUFBSSxHQUFHbTZFLEtBQUsvc0QsRUFBRTtZQUN2RHB0QixLQUFLeUgsQ0FBQyxDQUFDdXlFLGdCQUFnQixDQUFDYixrQkFBa0IsUUFBUUU7WUFDbERyNUUsS0FBSytILENBQUMsQ0FBQ2l5RSxnQkFBZ0IsQ0FBQ2Isa0JBQWtCLFlBQVlFO1lBQ3REMTVFLE9BQU9pNUUsZ0JBQWdCLENBQUNLLG1CQUFtQjtnQkFDekN2cUMsTUFBTTtvQkFDSjFxQixLQUFLd3lELDRCQUE0QngyRSxLQUFLeUgsQ0FBQztnQkFDekM7Z0JBQ0FsQyxVQUFVO29CQUNSeWUsS0FBS3d5RCw0QkFBNEJ4MkUsS0FBSytILENBQUM7Z0JBQ3pDO2dCQUNBZ3hFLE9BQU87b0JBQ0xuNkUsT0FBTzQwQixNQUFNdGMsRUFBRTtnQkFDakI7WUFDRjtZQUNBK2hFLGtCQUFrQlEsRUFBRSxHQUFHam1ELE1BQU1pbUQsRUFBRTtZQUMvQixPQUFPUjtRQUNUO1FBRUEsU0FBUzBCLHFCQUFxQm5uRCxLQUFLLEVBQUUybUQsSUFBSSxFQUFFbkQsYUFBYTtZQUN0RCxTQUFTaUMsa0JBQWtCcjZFLEtBQUs7Z0JBQzlCLElBQUk0MEIsTUFBTXpyQixDQUFDLENBQUN1OUIsRUFBRSxLQUFLMW1DLE9BQU87b0JBQ3hCLE9BQU9xNkUsa0JBQWtCMXpFLFFBQVE7Z0JBQ25DO2dCQUVBLElBQUlpdUIsTUFBTTdyQixDQUFDLENBQUMyOUIsRUFBRSxLQUFLMW1DLE9BQU87b0JBQ3hCLE9BQU9xNkUsa0JBQWtCM0csUUFBUTtnQkFDbkM7Z0JBRUEsSUFBSTkrQyxNQUFNMW5CLEVBQUUsQ0FBQ3c1QixFQUFFLEtBQUsxbUMsT0FBTztvQkFDekIsT0FBT3E2RSxrQkFBa0JyMUQsTUFBTTtnQkFDakM7Z0JBRUEsSUFBSTRQLE1BQU0wQyxFQUFFLENBQUNvUCxFQUFFLEtBQUsxbUMsU0FBU0EsVUFBVSxpQ0FBaUM7b0JBQ3RFLE9BQU9xNkUsa0JBQWtCNkMsV0FBVztnQkFDdEM7Z0JBRUEsSUFBSXRvRCxNQUFNMkMsRUFBRSxDQUFDbVAsRUFBRSxLQUFLMW1DLE9BQU87b0JBQ3pCLE9BQU9xNkUsa0JBQWtCOEMsY0FBYztnQkFDekM7Z0JBRUEsSUFBSXZvRCxNQUFNcUMsRUFBRSxJQUFLckMsQ0FBQUEsTUFBTXFDLEVBQUUsQ0FBQ3lQLEVBQUUsS0FBSzFtQyxTQUFTQSxVQUFVLCtCQUE4QixHQUFJO29CQUNwRixPQUFPcTZFLGtCQUFrQitDLFdBQVc7Z0JBQ3RDO2dCQUVBLElBQUl4b0QsTUFBTXNDLEVBQUUsSUFBSXRDLE1BQU1zQyxFQUFFLENBQUN3UCxFQUFFLEtBQUsxbUMsT0FBTztvQkFDckMsT0FBT3E2RSxrQkFBa0JnRCxjQUFjO2dCQUN6QztnQkFFQSxPQUFPO1lBQ1Q7WUFFQSxJQUFJNUMsaUJBQWlCTCxxQkFBcUJDLG1CQUFtQmpDO1lBRTdELElBQUloM0UsT0FBT202RSxLQUFLL3NELEVBQUUsQ0FBQ3BoQixFQUFFLEtBQUssT0FBT211RSxLQUFLL3NELEVBQUUsQ0FBQ3B0QixJQUFJLEdBQUdtNkUsS0FBSy9zRCxFQUFFO1lBQ3ZENnJELGtCQUFrQm1CLGFBQWEsR0FBRzVtRCxNQUFNOFIsRUFBRTtZQUMxQ3RsQyxLQUFLazJCLEVBQUUsQ0FBQzhqRCxnQkFBZ0IsQ0FBQ2Isa0JBQWtCLGdCQUFnQkU7WUFDM0RyNUUsS0FBS20yQixFQUFFLENBQUM2akQsZ0JBQWdCLENBQUNiLGtCQUFrQixtQkFBbUJFO1lBQzlEcjVFLEtBQUs4TCxFQUFFLENBQUNrdUUsZ0JBQWdCLENBQUNiLGtCQUFrQixVQUFVRTtZQUNyRHI1RSxLQUFLK0gsQ0FBQyxDQUFDaXlFLGdCQUFnQixDQUFDYixrQkFBa0IsWUFBWUU7WUFDdERyNUUsS0FBSzJILENBQUMsQ0FBQ3F5RSxnQkFBZ0IsQ0FBQ2Isa0JBQWtCLFlBQVlFO1lBRXRELElBQUk3bEQsTUFBTXFDLEVBQUUsRUFBRTtnQkFDWjcxQixLQUFLNjFCLEVBQUUsQ0FBQ21rRCxnQkFBZ0IsQ0FBQ2Isa0JBQWtCLGdCQUFnQkU7Z0JBQzNEcjVFLEtBQUs4MUIsRUFBRSxDQUFDa2tELGdCQUFnQixDQUFDYixrQkFBa0IsbUJBQW1CRTtZQUNoRTtZQUVBMTVFLE9BQU9pNUUsZ0JBQWdCLENBQUNLLG1CQUFtQjtnQkFDekMxekUsVUFBVTtvQkFDUnllLEtBQUt3eUQsNEJBQTRCeDJFLEtBQUsrSCxDQUFDO2dCQUN6QztnQkFDQXVxRSxVQUFVO29CQUNSdHVELEtBQUt3eUQsNEJBQTRCeDJFLEtBQUsySCxDQUFDO2dCQUN6QztnQkFDQWljLFFBQVE7b0JBQ05JLEtBQUt3eUQsNEJBQTRCeDJFLEtBQUs4TCxFQUFFO2dCQUMxQztnQkFDQWd3RSxhQUFhO29CQUNYOTNELEtBQUt3eUQsNEJBQTRCeDJFLEtBQUtrMkIsRUFBRTtnQkFDMUM7Z0JBQ0E2bEQsZ0JBQWdCO29CQUNkLzNELEtBQUt3eUQsNEJBQTRCeDJFLEtBQUttMkIsRUFBRTtnQkFDMUM7Z0JBQ0E2bEQsYUFBYTtvQkFDWGg0RCxLQUFLd3lELDRCQUE0QngyRSxLQUFLNjFCLEVBQUU7Z0JBQzFDO2dCQUNBb21ELGdCQUFnQjtvQkFDZGo0RCxLQUFLd3lELDRCQUE0QngyRSxLQUFLODFCLEVBQUU7Z0JBQzFDO2dCQUNBaWpELE9BQU87b0JBQ0xuNkUsT0FBTzQwQixNQUFNdGMsRUFBRTtnQkFDakI7WUFDRjtZQUNBK2hFLGtCQUFrQlEsRUFBRSxHQUFHam1ELE1BQU1pbUQsRUFBRTtZQUMvQixPQUFPUjtRQUNUO1FBRUEsU0FBUzJCLHFCQUFxQnBuRCxLQUFLLEVBQUUybUQsSUFBSSxFQUFFbkQsYUFBYTtZQUN0RCxTQUFTaUMsa0JBQWtCcjZFLEtBQUs7Z0JBQzlCLElBQUk0MEIsTUFBTXpyQixDQUFDLENBQUN1OUIsRUFBRSxLQUFLMW1DLE9BQU87b0JBQ3hCLE9BQU9xNkUsa0JBQWtCMXpFLFFBQVE7Z0JBQ25DO2dCQUVBLElBQUlpdUIsTUFBTTdyQixDQUFDLENBQUMyOUIsRUFBRSxLQUFLMW1DLE9BQU87b0JBQ3hCLE9BQU9xNkUsa0JBQWtCbmlELFNBQVM7Z0JBQ3BDO2dCQUVBLElBQUl0RCxNQUFNL3JCLENBQUMsQ0FBQzY5QixFQUFFLEtBQUsxbUMsU0FBU0EsVUFBVSxVQUFVQSxVQUFVLHlCQUF5QjtvQkFDakYsT0FBT3E2RSxrQkFBa0J2cUMsSUFBSTtnQkFDL0I7Z0JBRUEsT0FBTztZQUNUO1lBRUEsSUFBSTJxQyxpQkFBaUJMLHFCQUFxQkMsbUJBQW1CakM7WUFFN0QsSUFBSWgzRSxPQUFPbTZFLEtBQUsvc0QsRUFBRSxDQUFDcGhCLEVBQUUsS0FBSyxPQUFPbXVFLEtBQUsvc0QsRUFBRSxDQUFDcHRCLElBQUksR0FBR202RSxLQUFLL3NELEVBQUU7WUFDdkQ2ckQsa0JBQWtCbUIsYUFBYSxHQUFHNW1ELE1BQU04UixFQUFFO1lBQzFDdGxDLEtBQUsrSCxDQUFDLENBQUNpeUUsZ0JBQWdCLENBQUNiLGtCQUFrQixZQUFZRTtZQUN0RHI1RSxLQUFLeUgsQ0FBQyxDQUFDdXlFLGdCQUFnQixDQUFDYixrQkFBa0IsUUFBUUU7WUFDbERyNUUsS0FBSzJILENBQUMsQ0FBQ3F5RSxnQkFBZ0IsQ0FBQ2Isa0JBQWtCLFlBQVlFO1lBQ3REMTVFLE9BQU9pNUUsZ0JBQWdCLENBQUNLLG1CQUFtQjtnQkFDekMxekUsVUFBVTtvQkFDUnllLEtBQUt3eUQsNEJBQTRCeDJFLEtBQUsrSCxDQUFDO2dCQUN6QztnQkFDQSt1QixXQUFXO29CQUNUOVMsS0FBS3d5RCw0QkFBNEJ4MkUsS0FBSzJILENBQUM7Z0JBQ3pDO2dCQUNBK21DLE1BQU07b0JBQ0oxcUIsS0FBS3d5RCw0QkFBNEJ4MkUsS0FBS3lILENBQUM7Z0JBQ3pDO2dCQUNBc3hFLE9BQU87b0JBQ0xuNkUsT0FBTzQwQixNQUFNdGMsRUFBRTtnQkFDakI7WUFDRjtZQUNBK2hFLGtCQUFrQlEsRUFBRSxHQUFHam1ELE1BQU1pbUQsRUFBRTtZQUMvQixPQUFPUjtRQUNUO1FBRUEsU0FBUzRCLHdCQUF3QnJuRCxLQUFLLEVBQUUybUQsSUFBSSxFQUFFbkQsYUFBYTtZQUN6RCxTQUFTaUMsa0JBQWtCcjZFLEtBQUs7Z0JBQzlCLElBQUk0MEIsTUFBTTdyQixDQUFDLENBQUMyOUIsRUFBRSxLQUFLMW1DLFNBQVNBLFVBQVUsbUJBQW1CO29CQUN2RCxPQUFPcTZFLGtCQUFrQnBzQyxNQUFNO2dCQUNqQztnQkFFQSxPQUFPO1lBQ1Q7WUFFQSxJQUFJd3NDLGlCQUFpQkwscUJBQXFCQyxtQkFBbUJqQztZQUU3RCxJQUFJaDNFLE9BQU9tNkU7WUFDWGxCLGtCQUFrQm1CLGFBQWEsR0FBRzVtRCxNQUFNOFIsRUFBRTtZQUMxQ3RsQyxLQUFLa21DLEVBQUUsQ0FBQzh6QyxnQkFBZ0IsQ0FBQ2Isa0JBQWtCLFVBQVVFO1lBQ3JEMTVFLE9BQU9pNUUsZ0JBQWdCLENBQUNLLG1CQUFtQjtnQkFDekNwc0MsUUFBUTtvQkFDTjdvQixLQUFLd3lELDRCQUE0QngyRSxLQUFLa21DLEVBQUU7Z0JBQzFDO2dCQUNBNnlDLE9BQU87b0JBQ0xuNkUsT0FBTzQwQixNQUFNdGMsRUFBRTtnQkFDakI7WUFDRjtZQUNBK2hFLGtCQUFrQlEsRUFBRSxHQUFHam1ELE1BQU1pbUQsRUFBRTtZQUMvQixPQUFPUjtRQUNUO1FBRUEsU0FBUzZCLHlCQUF5QnRuRCxLQUFLLEVBQUUybUQsSUFBSSxFQUFFbkQsYUFBYTtZQUMxRCxTQUFTaUMsa0JBQWtCcjZFLEtBQUs7Z0JBQzlCLElBQUk0MEIsTUFBTTVrQixDQUFDLENBQUMwMkIsRUFBRSxLQUFLMW1DLFNBQVNBLFVBQVUsVUFBVTtvQkFDOUMsT0FBT3E2RSxrQkFBa0I5ekMsTUFBTTtnQkFDakM7Z0JBRUEsSUFBSTNSLE1BQU10bUIsQ0FBQyxDQUFDbzRCLEVBQUUsS0FBSzFtQyxTQUFTQSxVQUFVLFVBQVU7b0JBQzlDLE9BQU9xNkUsa0JBQWtCM3dFLE1BQU07Z0JBQ2pDO2dCQUVBLE9BQU87WUFDVDtZQUVBLElBQUkrd0UsaUJBQWlCTCxxQkFBcUJDLG1CQUFtQmpDO1lBRTdELElBQUloM0UsT0FBT202RTtZQUNYbEIsa0JBQWtCbUIsYUFBYSxHQUFHNW1ELE1BQU04UixFQUFFO1lBQzFDdGxDLEtBQUs0TyxDQUFDLENBQUNvckUsZ0JBQWdCLENBQUNiLGtCQUFrQixVQUFVRTtZQUNwRHI1RSxLQUFLa04sQ0FBQyxDQUFDOHNFLGdCQUFnQixDQUFDYixrQkFBa0IsVUFBVUU7WUFDcEQxNUUsT0FBT2k1RSxnQkFBZ0IsQ0FBQ0ssbUJBQW1CO2dCQUN6Qzl6QyxRQUFRO29CQUNObmhCLEtBQUt3eUQsNEJBQTRCeDJFLEtBQUs0TyxDQUFDO2dCQUN6QztnQkFDQXRHLFFBQVE7b0JBQ04wYixLQUFLd3lELDRCQUE0QngyRSxLQUFLa04sQ0FBQztnQkFDekM7Z0JBQ0E2ckUsT0FBTztvQkFDTG42RSxPQUFPNDBCLE1BQU10YyxFQUFFO2dCQUNqQjtZQUNGO1lBQ0EraEUsa0JBQWtCUSxFQUFFLEdBQUdqbUQsTUFBTWltRCxFQUFFO1lBQy9CLE9BQU9SO1FBQ1Q7UUFFQSxPQUFPLFNBQVU3c0UsTUFBTSxFQUFFK3RFLElBQUksRUFBRW5ELGFBQWE7WUFDMUMsSUFBSWtFO1lBRUosU0FBU0MsbUJBQW1CdjhFLEtBQUs7Z0JBQy9CLElBQUksT0FBT0EsVUFBVSxVQUFVO29CQUM3QkEsUUFBUUEsVUFBVXFiLFlBQVksSUFBSXJiO29CQUVsQyxJQUFJQSxVQUFVLEdBQUc7d0JBQ2YsT0FBT280RTtvQkFDVDtvQkFFQSxPQUFPa0UsVUFBVSxDQUFDdDhFLFFBQVEsRUFBRTtnQkFDOUI7Z0JBRUEsSUFBSVMsSUFBSTtnQkFDUixJQUFJQyxNQUFNNDdFLFdBQVczN0UsTUFBTTtnQkFFM0IsTUFBT0YsSUFBSUMsSUFBSztvQkFDZCxJQUFJNDdFLFVBQVUsQ0FBQzc3RSxFQUFFLENBQUMwNUUsS0FBSyxLQUFLbjZFLE9BQU87d0JBQ2pDLE9BQU9zOEUsVUFBVSxDQUFDNzdFLEVBQUU7b0JBQ3RCO29CQUVBQSxLQUFLO2dCQUNQO2dCQUVBLE9BQU87WUFDVDtZQUVBLFNBQVM2OEU7Z0JBQ1AsT0FBT2xGO1lBQ1Q7WUFFQW1FLG1CQUFtQm5FLGFBQWEsR0FBR2dDLHFCQUFxQm1DLG9CQUFvQmU7WUFDNUVoQixhQUFhYixnQkFBZ0JqdUUsUUFBUSt0RSxNQUFNZ0IsbUJBQW1CbkUsYUFBYTtZQUMzRW1FLG1CQUFtQnhCLGFBQWEsR0FBR3VCLFdBQVczN0UsTUFBTTtZQUNwRDQ3RSxtQkFBbUJwQyxLQUFLLEdBQUc7WUFDM0IsT0FBT29DO1FBQ1Q7SUFDRjtJQUVBLElBQUl2akMsMEJBQTBCO1FBQzVCLE9BQU8sU0FBVXgzQixJQUFJO1lBQ25CLElBQUkrN0Q7WUFFSixTQUFTMVIsbUJBQW1CNXpELElBQUk7Z0JBQzlCLE9BQVFBO29CQUNOLEtBQUs7d0JBQ0gsT0FBTzR6RCxtQkFBbUIyUixVQUFVO29CQUV0Qzt3QkFDRSxPQUFPO2dCQUNYO1lBQ0Y7WUFFQXo4RSxPQUFPK3FFLGNBQWMsQ0FBQ0Qsb0JBQW9CLGNBQWM7Z0JBQ3REem1ELEtBQUssU0FBU0E7b0JBQ1o1RCxLQUFLcXdDLFlBQVksQ0FBQ3QvQixRQUFRO29CQUMxQixJQUFJa3JELGNBQWNqOEQsS0FBS3F3QyxZQUFZLENBQUMvRSxXQUFXLENBQUN6akQsQ0FBQztvQkFFakQsSUFBSSxDQUFDazBFLGVBQWVFLGdCQUFnQkYsWUFBWXY5RSxLQUFLLEVBQUU7d0JBQ3JEdTlFLGNBQWMsSUFBSXhtQixPQUFPMG1CLGNBQWMsc0NBQXNDO3dCQUM3RSw0R0FBNEc7d0JBRTVHRixZQUFZdjlFLEtBQUssR0FBR3k5RSxlQUFlLElBQUkxbUIsT0FBTzBtQixjQUFjLHNDQUFzQzt3QkFFbEcxOEUsT0FBTytxRSxjQUFjLENBQUN5UixhQUFhLFNBQVM7NEJBQzFDbjRELEtBQUssU0FBU0E7Z0NBQ1osT0FBTztvQ0FDTHM0RCxXQUFXbDhELEtBQUtxd0MsWUFBWSxDQUFDL0UsV0FBVyxDQUFDUixFQUFFO2dDQUM3Qzs0QkFDRjt3QkFDRjtvQkFDRjtvQkFFQSxPQUFPaXhCO2dCQUNUO1lBQ0Y7WUFDQSxPQUFPMVI7UUFDVDtJQUNGO0lBRUEsU0FBU3puRSxRQUFRSCxHQUFHO1FBQUk7UUFBMkIsSUFBSSxPQUFPQyxXQUFXLGNBQWMsT0FBT0EsT0FBT0MsUUFBUSxLQUFLLFVBQVU7WUFBRUMsVUFBVSxTQUFTQSxRQUFRSCxHQUFHO2dCQUFJLE9BQU8sT0FBT0E7WUFBSztRQUFHLE9BQU87WUFBRUcsVUFBVSxTQUFTQSxRQUFRSCxHQUFHO2dCQUFJLE9BQU9BLE9BQU8sT0FBT0MsV0FBVyxjQUFjRCxJQUFJSSxXQUFXLEtBQUtILFVBQVVELFFBQVFDLE9BQU9yRCxTQUFTLEdBQUcsV0FBVyxPQUFPb0Q7WUFBSztRQUFHO1FBQUUsT0FBT0csUUFBUUg7SUFBTTtJQUV6WCxJQUFJNDJDLG1CQUFtQjtRQUNyQixJQUFJOGlDLDBCQUEwQixTQUFTQSx3QkFBd0JuOEQsSUFBSTtZQUNqRSxJQUFJbzhELHNCQUFzQjtZQUMxQixJQUFJQyxrQkFBa0JyOEQsS0FBS3M1QixjQUFjO1lBRXpDLFNBQVNwN0I7Z0JBQ1BrK0Qsc0JBQXNCO2dCQUN0QkMsa0JBQWtCcjhELEtBQUtzNUIsY0FBYztnQkFDckMsT0FBT2lUO1lBQ1Q7WUFFQSxTQUFTQSxlQUFlL3RELEtBQUs7Z0JBQzNCLElBQUk2OUUsZUFBZSxDQUFDNzlFLE1BQU0sRUFBRTtvQkFDMUI0OUUsc0JBQXNCNTlFO29CQUN0QjY5RSxrQkFBa0JBLGVBQWUsQ0FBQzc5RSxNQUFNO29CQUV4QyxJQUFJb0UsUUFBUXk1RSxxQkFBcUIsVUFBVTt3QkFDekMsT0FBTzl2QjtvQkFDVDtvQkFFQSxPQUFPOHZCO2dCQUNUO2dCQUVBLElBQUlDLG9CQUFvQjk5RSxNQUFNOFEsT0FBTyxDQUFDOHNFO2dCQUV0QyxJQUFJRSxzQkFBc0IsQ0FBQyxHQUFHO29CQUM1QixJQUFJbjlELFFBQVFyRixTQUFTdGIsTUFBTTJiLE1BQU0sQ0FBQ21pRSxvQkFBb0JGLG9CQUFvQmo5RSxNQUFNLEdBQUc7b0JBQ25GazlFLGtCQUFrQkEsZUFBZSxDQUFDbDlELE1BQU07b0JBRXhDLElBQUl2YyxRQUFReTVFLHFCQUFxQixVQUFVO3dCQUN6QyxPQUFPOXZCO29CQUNUO29CQUVBLE9BQU84dkI7Z0JBQ1Q7Z0JBRUEsT0FBTztZQUNUO1lBRUEsT0FBT24rRDtRQUNUO1FBRUEsSUFBSXErRCx1QkFBdUIsU0FBU0EscUJBQXFCdjhELElBQUk7WUFDM0QsU0FBUzY0RCxrQkFBa0JyNkUsS0FBSztnQkFDOUIsSUFBSUEsVUFBVSxXQUFXO29CQUN2QixPQUFPcTZFLGtCQUFrQjJELGdCQUFnQjtnQkFDM0M7Z0JBRUEsT0FBTztZQUNUO1lBRUEzRCxrQkFBa0JGLEtBQUssR0FBRztZQUMxQkUsa0JBQWtCMkQsZ0JBQWdCLEdBQUdMLHdCQUF3Qm44RDtZQUM3RCxPQUFPNjREO1FBQ1Q7UUFFQSxPQUFPLFNBQVU3NEQsSUFBSTtZQUNuQixTQUFTKzZELG1CQUFtQnY4RSxLQUFLO2dCQUMvQixJQUFJQSxVQUFVLFFBQVE7b0JBQ3BCLE9BQU91OEUsbUJBQW1CMEIsYUFBYTtnQkFDekM7Z0JBRUEsT0FBTztZQUNUO1lBRUExQixtQkFBbUJwQyxLQUFLLEdBQUc7WUFDM0JvQyxtQkFBbUIwQixhQUFhLEdBQUdGLHFCQUFxQnY4RDtZQUN4RCxPQUFPKzZEO1FBQ1Q7SUFDRjtJQUVBLElBQUlELGFBQWE7UUFDZnRnQyxPQUFPbkQ7UUFDUFIsU0FBU1M7UUFDVC9xQyxNQUFNa3JDO1FBQ05ya0IsT0FBT21rQjtRQUNQL0YsTUFBTWdHO1FBQ05rbEMsU0FBU3JqQztJQUNYO0lBRUEsU0FBU3NqQyxhQUFhaCtFLElBQUk7UUFDeEIsT0FBT204RSxVQUFVLENBQUNuOEUsS0FBSyxJQUFJO0lBQzdCO0lBRUEsSUFBSWkrRSxvQkFBb0I7UUFDdEIsU0FBU0Msa0JBQWtCNzhELElBQUksRUFBRWhXLElBQUksRUFBRXBLLElBQUk7WUFDekMsSUFBSW9LLEtBQUs2WixDQUFDLEVBQUU7Z0JBQ1Zqa0IsS0FBS3dMLENBQUMsR0FBRztnQkFDVHhMLEtBQUtpa0IsQ0FBQyxHQUFHO2dCQUNUamtCLEtBQUtneEUsa0JBQWtCLEdBQUdwRCxrQkFBa0JvRCxrQkFBa0I7Z0JBQzlEaHhFLEtBQUt5d0IsZUFBZSxDQUFDN3ZCLElBQUksQ0FBQ1osS0FBS2d4RSxrQkFBa0IsQ0FBQzV3RCxNQUFNaFcsTUFBTXBLLE1BQU13VCxJQUFJLENBQUN4VDtZQUMzRTtRQUNGO1FBRUEsU0FBU2lqQyxlQUFlL1gsUUFBUTtZQUM5QkEsWUFBWSxJQUFJLENBQUM5SyxJQUFJLENBQUN0RyxVQUFVLENBQUM5QixTQUFTO1lBQzFDa1QsWUFBWSxJQUFJLENBQUNFLFVBQVU7WUFFM0IsSUFBSUYsYUFBYSxJQUFJLENBQUNneUQsY0FBYyxDQUFDdndELFNBQVMsRUFBRTtnQkFDOUMsSUFBSSxDQUFDdXdELGNBQWMsQ0FBQ3p4RCxTQUFTLEdBQUcsSUFBSSxDQUFDeXhELGNBQWMsQ0FBQ3Z3RCxTQUFTLEdBQUd6QixXQUFXLElBQUksQ0FBQ2d5RCxjQUFjLENBQUN6eEQsU0FBUyxHQUFHO2dCQUMzRyxJQUFJLENBQUN5eEQsY0FBYyxDQUFDdCtFLEtBQUssR0FBRyxJQUFJLENBQUNxc0IsZ0JBQWdCLENBQUNDLFVBQVUsSUFBSSxDQUFDZ3lELGNBQWM7Z0JBQy9FLElBQUksQ0FBQ0EsY0FBYyxDQUFDdndELFNBQVMsR0FBR3pCO1lBQ2xDO1lBRUEsT0FBTyxJQUFJLENBQUNneUQsY0FBYyxDQUFDdCtFLEtBQUs7UUFDbEM7UUFFQSxTQUFTbTRFLGVBQWU3ckQsUUFBUTtZQUM5QixJQUFJNmIsUUFBUSxDQUFDO1lBQ2IsSUFBSXhQLEtBQUssSUFBSSxDQUFDMEwsY0FBYyxDQUFDL1g7WUFDN0IsSUFBSThYLEtBQUssSUFBSSxDQUFDQyxjQUFjLENBQUMvWCxXQUFXNmI7WUFDeEMsSUFBSW8yQyxRQUFRO1lBRVosSUFBSTVsRCxHQUFHaDRCLE1BQU0sRUFBRTtnQkFDYixJQUFJRjtnQkFFSixJQUFLQSxJQUFJLEdBQUdBLElBQUlrNEIsR0FBR2g0QixNQUFNLEVBQUVGLEtBQUssRUFBRztvQkFDakM4OUUsU0FBU3g1RSxLQUFLQyxHQUFHLENBQUNvL0IsRUFBRSxDQUFDM2pDLEVBQUUsR0FBR2s0QixFQUFFLENBQUNsNEIsRUFBRSxFQUFFO2dCQUNuQztnQkFFQTg5RSxRQUFReDVFLEtBQUtHLElBQUksQ0FBQ3E1RSxTQUFTO1lBQzdCLE9BQU87Z0JBQ0xBLFFBQVE7WUFDVjtZQUVBLE9BQU9BO1FBQ1Q7UUFFQSxTQUFTMUosa0JBQWtCdm9ELFFBQVE7WUFDakMsSUFBSSxJQUFJLENBQUNnRyxHQUFHLEtBQUtqWCxXQUFXO2dCQUMxQixPQUFPLElBQUksQ0FBQ2lYLEdBQUc7WUFDakI7WUFFQSxJQUFJNlYsUUFBUSxDQUFDLE9BQU8saUNBQWlDO1lBRXJELElBQUl4UCxLQUFLLElBQUksQ0FBQzBMLGNBQWMsQ0FBQy9YO1lBQzdCLElBQUk4WCxLQUFLLElBQUksQ0FBQ0MsY0FBYyxDQUFDL1gsV0FBVzZiO1lBQ3hDLElBQUlrdUM7WUFFSixJQUFJMTlDLEdBQUdoNEIsTUFBTSxFQUFFO2dCQUNiMDFFLFdBQVcveUUsaUJBQWlCLFdBQVdxMUIsR0FBR2g0QixNQUFNO2dCQUNoRCxJQUFJRjtnQkFFSixJQUFLQSxJQUFJLEdBQUdBLElBQUlrNEIsR0FBR2g0QixNQUFNLEVBQUVGLEtBQUssRUFBRztvQkFDakMscUJBQXFCO29CQUNyQiwrQkFBK0I7b0JBQy9CLHdFQUF3RTtvQkFDeEU0MUUsUUFBUSxDQUFDNTFFLEVBQUUsR0FBRyxDQUFDMmpDLEVBQUUsQ0FBQzNqQyxFQUFFLEdBQUdrNEIsRUFBRSxDQUFDbDRCLEVBQUUsSUFBSTBuQztnQkFDbEM7WUFDRixPQUFPO2dCQUNMa3VDLFdBQVcsQ0FBQ2p5QyxLQUFLekwsRUFBQyxJQUFLd1A7WUFDekI7WUFFQSxPQUFPa3VDO1FBQ1Q7UUFFQSxTQUFTbUk7WUFDUCxPQUFPLElBQUksQ0FBQzd4RCxFQUFFO1FBQ2hCO1FBRUEsU0FBU3l1RCxpQkFBaUJoRCxhQUFhO1lBQ3JDLElBQUksQ0FBQ0EsYUFBYSxHQUFHQTtRQUN2QjtRQUVBLE9BQU87WUFDTGlHLG1CQUFtQkE7WUFDbkJsRyxnQkFBZ0JBO1lBQ2hCdEQsbUJBQW1CQTtZQUNuQnh3QyxnQkFBZ0JBO1lBQ2hCbTZDLHNCQUFzQkE7WUFDdEJwRCxrQkFBa0JBO1FBQ3BCO0lBQ0Y7SUFFQSxTQUFTcUQ7UUFDUCxTQUFTdkwsUUFBUS95RSxJQUFJLEVBQUV5WCxRQUFRLEVBQUU4bUUsWUFBWTtZQUMzQyxJQUFJLENBQUMsSUFBSSxDQUFDOXhFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQ2tnQixTQUFTLEVBQUU7Z0JBQzlCLE9BQU8sSUFBSSxDQUFDSCxFQUFFO1lBQ2hCO1lBRUF4c0IsT0FBT0EsT0FBT0EsS0FBS3N2QyxXQUFXLEtBQUs7WUFDbkMsSUFBSWgzQixlQUFlLElBQUksQ0FBQzFLLElBQUksQ0FBQ29qQixhQUFhO1lBQzFDLElBQUlyRSxZQUFZLElBQUksQ0FBQ0EsU0FBUztZQUM5QixJQUFJNnhELGVBQWU3eEQsU0FBUyxDQUFDQSxVQUFVbnNCLE1BQU0sR0FBRyxFQUFFLENBQUMwSSxDQUFDO1lBRXBELElBQUlvUCxnQkFBZ0JrbUUsY0FBYztnQkFDaEMsT0FBTyxJQUFJLENBQUNoeUQsRUFBRTtZQUNoQjtZQUVBLElBQUlpeUQ7WUFDSixJQUFJQztZQUVKLElBQUksQ0FBQ0gsY0FBYztnQkFDakIsSUFBSSxDQUFDOW1FLFlBQVlBLFdBQVdrVixVQUFVbnNCLE1BQU0sR0FBRyxHQUFHO29CQUNoRGlYLFdBQVdrVixVQUFVbnNCLE1BQU0sR0FBRztnQkFDaEM7Z0JBRUFrK0UsZ0JBQWdCL3hELFNBQVMsQ0FBQ0EsVUFBVW5zQixNQUFNLEdBQUcsSUFBSWlYLFNBQVMsQ0FBQ3ZPLENBQUM7Z0JBQzVEdTFFLGdCQUFnQkQsZUFBZUU7WUFDakMsT0FBTztnQkFDTCxJQUFJLENBQUNqbkUsVUFBVTtvQkFDYmduRSxnQkFBZ0I3NUUsS0FBS08sR0FBRyxDQUFDLEdBQUdxNUUsZUFBZSxJQUFJLENBQUNuOUQsSUFBSSxDQUFDaFcsSUFBSSxDQUFDNkQsRUFBRTtnQkFDOUQsT0FBTztvQkFDTHV2RSxnQkFBZ0I3NUUsS0FBS2MsR0FBRyxDQUFDODRFLGVBQWUsSUFBSSxDQUFDbjlELElBQUksQ0FBQ3pULElBQUksQ0FBQ21OLFVBQVUsQ0FBQzlCLFNBQVMsR0FBR3hCO2dCQUNoRjtnQkFFQWluRSxnQkFBZ0JGLGVBQWVDO1lBQ2pDO1lBRUEsSUFBSW4rRTtZQUNKLElBQUlDO1lBQ0osSUFBSW8rRTtZQUVKLElBQUkzK0UsU0FBUyxZQUFZO2dCQUN2QixJQUFJMnBELGFBQWEva0QsS0FBS0ssS0FBSyxDQUFDLENBQUNxVCxlQUFlb21FLGFBQVksSUFBS0Q7Z0JBRTdELElBQUk5MEIsYUFBYSxNQUFNLEdBQUc7b0JBQ3hCLE9BQU8sSUFBSSxDQUFDemxCLGNBQWMsQ0FBQyxDQUFDdTZDLGdCQUFnQixDQUFDbm1FLGVBQWVvbUUsYUFBWSxJQUFLRCxnQkFBZ0JDLGFBQVksSUFBSyxJQUFJLENBQUM5d0UsSUFBSSxDQUFDbU4sVUFBVSxDQUFDOUIsU0FBUyxFQUFFLElBQUksc0JBQXNCO2dCQUMxSztZQUNGLE9BQU8sSUFBSWpaLFNBQVMsVUFBVTtnQkFDNUIsSUFBSTQrRSxRQUFRLElBQUksQ0FBQzE2QyxjQUFjLENBQUN3NkMsZ0JBQWdCLElBQUksQ0FBQzl3RSxJQUFJLENBQUNtTixVQUFVLENBQUM5QixTQUFTLEVBQUU7Z0JBQ2hGLElBQUk0bEUsT0FBTyxJQUFJLENBQUMzNkMsY0FBYyxDQUFDczZDLGVBQWUsSUFBSSxDQUFDNXdFLElBQUksQ0FBQ21OLFVBQVUsQ0FBQzlCLFNBQVMsRUFBRTtnQkFDOUUsSUFBSTZsRSxVQUFVLElBQUksQ0FBQzU2QyxjQUFjLENBQUMsQ0FBQyxDQUFDNXJCLGVBQWVvbUUsYUFBWSxJQUFLRCxnQkFBZ0JDLGFBQVksSUFBSyxJQUFJLENBQUM5d0UsSUFBSSxDQUFDbU4sVUFBVSxDQUFDOUIsU0FBUyxFQUFFLElBQUksc0JBQXNCO2dCQUUvSixJQUFJOGxFLFVBQVVuNkUsS0FBS0ssS0FBSyxDQUFDLENBQUNxVCxlQUFlb21FLGFBQVksSUFBS0Q7Z0JBRTFELElBQUksSUFBSSxDQUFDanlELEVBQUUsQ0FBQ2hzQixNQUFNLEVBQUU7b0JBQ2xCbStFLE1BQU0sSUFBSWg3RSxNQUFNaTdFLE1BQU1wK0UsTUFBTTtvQkFDNUJELE1BQU1vK0UsSUFBSW4rRSxNQUFNO29CQUVoQixJQUFLRixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRzt3QkFDM0JxK0UsR0FBRyxDQUFDcitFLEVBQUUsR0FBRyxDQUFDdStFLElBQUksQ0FBQ3YrRSxFQUFFLEdBQUdzK0UsS0FBSyxDQUFDdCtFLEVBQUUsSUFBSXkrRSxVQUFVRCxPQUFPLENBQUN4K0UsRUFBRTtvQkFDdEQ7b0JBRUEsT0FBT3ErRTtnQkFDVDtnQkFFQSxPQUFPLENBQUNFLE9BQU9ELEtBQUksSUFBS0csVUFBVUQ7WUFDcEMsT0FBTyxJQUFJOStFLFNBQVMsWUFBWTtnQkFDOUIsSUFBSWcvRSxZQUFZLElBQUksQ0FBQzk2QyxjQUFjLENBQUNzNkMsZUFBZSxJQUFJLENBQUM1d0UsSUFBSSxDQUFDbU4sVUFBVSxDQUFDOUIsU0FBUyxFQUFFO2dCQUNuRixJQUFJZ21FLGdCQUFnQixJQUFJLENBQUMvNkMsY0FBYyxDQUFDLENBQUNzNkMsZUFBZSxLQUFJLElBQUssSUFBSSxDQUFDNXdFLElBQUksQ0FBQ21OLFVBQVUsQ0FBQzlCLFNBQVMsRUFBRTtnQkFFakcsSUFBSSxJQUFJLENBQUN1VCxFQUFFLENBQUNoc0IsTUFBTSxFQUFFO29CQUNsQm0rRSxNQUFNLElBQUloN0UsTUFBTXE3RSxVQUFVeCtFLE1BQU07b0JBQ2hDRCxNQUFNbytFLElBQUluK0UsTUFBTTtvQkFFaEIsSUFBS0YsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7d0JBQzNCcStFLEdBQUcsQ0FBQ3IrRSxFQUFFLEdBQUcwK0UsU0FBUyxDQUFDMStFLEVBQUUsR0FBRyxDQUFDMCtFLFNBQVMsQ0FBQzErRSxFQUFFLEdBQUcyK0UsYUFBYSxDQUFDMytFLEVBQUUsSUFBSyxFQUFDZ1ksZUFBZWttRSxZQUFXLElBQUssSUFBSSxDQUFDNXdFLElBQUksQ0FBQ21OLFVBQVUsQ0FBQzlCLFNBQVMsSUFBSSxRQUFRLHNCQUFzQjtvQkFDL0o7b0JBRUEsT0FBTzBsRTtnQkFDVDtnQkFFQSxPQUFPSyxZQUFZLENBQUNBLFlBQVlDLGFBQVksSUFBTSxFQUFDM21FLGVBQWVrbUUsWUFBVyxJQUFLLEtBQUk7WUFDeEY7WUFFQSxPQUFPLElBQUksQ0FBQ3Q2QyxjQUFjLENBQUMsQ0FBQyxDQUFDNXJCLGVBQWVvbUUsYUFBWSxJQUFLRCxnQkFBZ0JDLGFBQVksSUFBSyxJQUFJLENBQUM5d0UsSUFBSSxDQUFDbU4sVUFBVSxDQUFDOUIsU0FBUyxFQUFFLElBQUksc0JBQXNCO1FBQzFKO1FBRUEsU0FBUzQ1RCxPQUFPN3lFLElBQUksRUFBRXlYLFFBQVEsRUFBRThtRSxZQUFZO1lBQzFDLElBQUksQ0FBQyxJQUFJLENBQUM5eEUsQ0FBQyxFQUFFO2dCQUNYLE9BQU8sSUFBSSxDQUFDK2YsRUFBRTtZQUNoQjtZQUVBeHNCLE9BQU9BLE9BQU9BLEtBQUtzdkMsV0FBVyxLQUFLO1lBQ25DLElBQUloM0IsZUFBZSxJQUFJLENBQUMxSyxJQUFJLENBQUNvakIsYUFBYTtZQUMxQyxJQUFJckUsWUFBWSxJQUFJLENBQUNBLFNBQVM7WUFDOUIsSUFBSSt4RCxnQkFBZ0IveEQsU0FBUyxDQUFDLEVBQUUsQ0FBQ3pqQixDQUFDO1lBRWxDLElBQUlvUCxnQkFBZ0JvbUUsZUFBZTtnQkFDakMsT0FBTyxJQUFJLENBQUNseUQsRUFBRTtZQUNoQjtZQUVBLElBQUlpeUQ7WUFDSixJQUFJRDtZQUVKLElBQUksQ0FBQ0QsY0FBYztnQkFDakIsSUFBSSxDQUFDOW1FLFlBQVlBLFdBQVdrVixVQUFVbnNCLE1BQU0sR0FBRyxHQUFHO29CQUNoRGlYLFdBQVdrVixVQUFVbnNCLE1BQU0sR0FBRztnQkFDaEM7Z0JBRUFnK0UsZUFBZTd4RCxTQUFTLENBQUNsVixTQUFTLENBQUN2TyxDQUFDO2dCQUNwQ3UxRSxnQkFBZ0JELGVBQWVFO1lBQ2pDLE9BQU87Z0JBQ0wsSUFBSSxDQUFDam5FLFVBQVU7b0JBQ2JnbkUsZ0JBQWdCNzVFLEtBQUtPLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQ2tjLElBQUksQ0FBQ2hXLElBQUksQ0FBQzhELEVBQUUsR0FBR3V2RTtnQkFDbEQsT0FBTztvQkFDTEQsZ0JBQWdCNzVFLEtBQUtjLEdBQUcsQ0FBQyxJQUFJLENBQUMyYixJQUFJLENBQUN6VCxJQUFJLENBQUNtTixVQUFVLENBQUM5QixTQUFTLEdBQUd4QjtnQkFDakU7Z0JBRUErbUUsZUFBZUUsZ0JBQWdCRDtZQUNqQztZQUVBLElBQUluK0U7WUFDSixJQUFJQztZQUNKLElBQUlvK0U7WUFFSixJQUFJMytFLFNBQVMsWUFBWTtnQkFDdkIsSUFBSTJwRCxhQUFhL2tELEtBQUtLLEtBQUssQ0FBQyxDQUFDeTVFLGdCQUFnQnBtRSxZQUFXLElBQUttbUU7Z0JBRTdELElBQUk5MEIsYUFBYSxNQUFNLEdBQUc7b0JBQ3hCLE9BQU8sSUFBSSxDQUFDemxCLGNBQWMsQ0FBQyxDQUFDLENBQUN3NkMsZ0JBQWdCcG1FLFlBQVcsSUFBS21tRSxnQkFBZ0JDLGFBQVksSUFBSyxJQUFJLENBQUM5d0UsSUFBSSxDQUFDbU4sVUFBVSxDQUFDOUIsU0FBUyxFQUFFLElBQUksc0JBQXNCO2dCQUMxSjtZQUNGLE9BQU8sSUFBSWpaLFNBQVMsVUFBVTtnQkFDNUIsSUFBSTQrRSxRQUFRLElBQUksQ0FBQzE2QyxjQUFjLENBQUN3NkMsZ0JBQWdCLElBQUksQ0FBQzl3RSxJQUFJLENBQUNtTixVQUFVLENBQUM5QixTQUFTLEVBQUU7Z0JBQ2hGLElBQUk0bEUsT0FBTyxJQUFJLENBQUMzNkMsY0FBYyxDQUFDczZDLGVBQWUsSUFBSSxDQUFDNXdFLElBQUksQ0FBQ21OLFVBQVUsQ0FBQzlCLFNBQVMsRUFBRTtnQkFDOUUsSUFBSTZsRSxVQUFVLElBQUksQ0FBQzU2QyxjQUFjLENBQUMsQ0FBQ3U2QyxnQkFBZ0IsQ0FBQ0MsZ0JBQWdCcG1FLFlBQVcsSUFBS21tRSxnQkFBZ0JDLGFBQVksSUFBSyxJQUFJLENBQUM5d0UsSUFBSSxDQUFDbU4sVUFBVSxDQUFDOUIsU0FBUyxFQUFFO2dCQUNySixJQUFJOGxFLFVBQVVuNkUsS0FBS0ssS0FBSyxDQUFDLENBQUN5NUUsZ0JBQWdCcG1FLFlBQVcsSUFBS21tRSxpQkFBaUI7Z0JBRTNFLElBQUksSUFBSSxDQUFDanlELEVBQUUsQ0FBQ2hzQixNQUFNLEVBQUU7b0JBQ2xCbStFLE1BQU0sSUFBSWg3RSxNQUFNaTdFLE1BQU1wK0UsTUFBTTtvQkFDNUJELE1BQU1vK0UsSUFBSW4rRSxNQUFNO29CQUVoQixJQUFLRixJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRzt3QkFDM0JxK0UsR0FBRyxDQUFDcitFLEVBQUUsR0FBR3crRSxPQUFPLENBQUN4K0UsRUFBRSxHQUFHLENBQUN1K0UsSUFBSSxDQUFDditFLEVBQUUsR0FBR3MrRSxLQUFLLENBQUN0K0UsRUFBRSxJQUFJeStFO29CQUMvQztvQkFFQSxPQUFPSjtnQkFDVDtnQkFFQSxPQUFPRyxVQUFVLENBQUNELE9BQU9ELEtBQUksSUFBS0c7WUFDcEMsT0FBTyxJQUFJLytFLFNBQVMsWUFBWTtnQkFDOUIsSUFBSWsvRSxhQUFhLElBQUksQ0FBQ2g3QyxjQUFjLENBQUN3NkMsZ0JBQWdCLElBQUksQ0FBQzl3RSxJQUFJLENBQUNtTixVQUFVLENBQUM5QixTQUFTLEVBQUU7Z0JBQ3JGLElBQUlrbUUsaUJBQWlCLElBQUksQ0FBQ2o3QyxjQUFjLENBQUMsQ0FBQ3c2QyxnQkFBZ0IsS0FBSSxJQUFLLElBQUksQ0FBQzl3RSxJQUFJLENBQUNtTixVQUFVLENBQUM5QixTQUFTLEVBQUU7Z0JBRW5HLElBQUksSUFBSSxDQUFDdVQsRUFBRSxDQUFDaHNCLE1BQU0sRUFBRTtvQkFDbEJtK0UsTUFBTSxJQUFJaDdFLE1BQU11N0UsV0FBVzErRSxNQUFNO29CQUNqQ0QsTUFBTW8rRSxJQUFJbitFLE1BQU07b0JBRWhCLElBQUtGLElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO3dCQUMzQnErRSxHQUFHLENBQUNyK0UsRUFBRSxHQUFHNCtFLFVBQVUsQ0FBQzUrRSxFQUFFLEdBQUcsQ0FBQzQrRSxVQUFVLENBQUM1K0UsRUFBRSxHQUFHNitFLGNBQWMsQ0FBQzcrRSxFQUFFLElBQUtvK0UsQ0FBQUEsZ0JBQWdCcG1FLFlBQVcsSUFBSztvQkFDbEc7b0JBRUEsT0FBT3FtRTtnQkFDVDtnQkFFQSxPQUFPTyxhQUFhLENBQUNBLGFBQWFDLGNBQWEsSUFBTVQsQ0FBQUEsZ0JBQWdCcG1FLFlBQVcsSUFBSztZQUN2RjtZQUVBLE9BQU8sSUFBSSxDQUFDNHJCLGNBQWMsQ0FBQyxDQUFDdTZDLGdCQUFpQixFQUFDQyxnQkFBZ0JwbUUsWUFBVyxJQUFLbW1FLGdCQUFnQkMsYUFBWSxDQUFDLElBQUssSUFBSSxDQUFDOXdFLElBQUksQ0FBQ21OLFVBQVUsQ0FBQzlCLFNBQVMsRUFBRSxJQUFJLHNCQUFzQjtRQUM1SztRQUVBLFNBQVNnNkQsT0FBT25nRSxLQUFLLEVBQUVzc0UsT0FBTztZQUM1QixJQUFJLENBQUMsSUFBSSxDQUFDM3lFLENBQUMsRUFBRTtnQkFDWCxPQUFPLElBQUksQ0FBQytmLEVBQUU7WUFDaEI7WUFFQTFaLFFBQVEsQ0FBQ0EsU0FBUyxHQUFFLElBQUs7WUFDekJzc0UsVUFBVXg2RSxLQUFLSyxLQUFLLENBQUNtNkUsV0FBVztZQUVoQyxJQUFJQSxXQUFXLEdBQUc7Z0JBQ2hCLE9BQU8sSUFBSSxDQUFDNXlELEVBQUU7WUFDaEI7WUFFQSxJQUFJcGxCLGNBQWMsSUFBSSxDQUFDd0csSUFBSSxDQUFDb2pCLGFBQWEsR0FBRyxJQUFJLENBQUNwakIsSUFBSSxDQUFDbU4sVUFBVSxDQUFDOUIsU0FBUztZQUMxRSxJQUFJK1MsWUFBWTVrQixjQUFjMEw7WUFDOUIsSUFBSXVzRSxXQUFXajRFLGNBQWMwTDtZQUM3QixJQUFJd3NFLGtCQUFrQkYsVUFBVSxJQUFJLENBQUNDLFdBQVdyekQsU0FBUSxJQUFNb3pELENBQUFBLFVBQVUsS0FBSztZQUM3RSxJQUFJOStFLElBQUk7WUFDUixJQUFJaU0sSUFBSTtZQUNSLElBQUkxTTtZQUVKLElBQUksSUFBSSxDQUFDMnNCLEVBQUUsQ0FBQ2hzQixNQUFNLEVBQUU7Z0JBQ2xCWCxRQUFRc0QsaUJBQWlCLFdBQVcsSUFBSSxDQUFDcXBCLEVBQUUsQ0FBQ2hzQixNQUFNO1lBQ3BELE9BQU87Z0JBQ0xYLFFBQVE7WUFDVjtZQUVBLElBQUkwL0U7WUFFSixNQUFPai9FLElBQUk4K0UsUUFBUztnQkFDbEJHLGNBQWMsSUFBSSxDQUFDcjdDLGNBQWMsQ0FBQ2xZLFlBQVkxckIsSUFBSWcvRTtnQkFFbEQsSUFBSSxJQUFJLENBQUM5eUQsRUFBRSxDQUFDaHNCLE1BQU0sRUFBRTtvQkFDbEIsSUFBSytMLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNpZ0IsRUFBRSxDQUFDaHNCLE1BQU0sRUFBRStMLEtBQUssRUFBRzt3QkFDdEMxTSxLQUFLLENBQUMwTSxFQUFFLElBQUlnekUsV0FBVyxDQUFDaHpFLEVBQUU7b0JBQzVCO2dCQUNGLE9BQU87b0JBQ0wxTSxTQUFTMC9FO2dCQUNYO2dCQUVBai9FLEtBQUs7WUFDUDtZQUVBLElBQUksSUFBSSxDQUFDa3NCLEVBQUUsQ0FBQ2hzQixNQUFNLEVBQUU7Z0JBQ2xCLElBQUsrTCxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDaWdCLEVBQUUsQ0FBQ2hzQixNQUFNLEVBQUUrTCxLQUFLLEVBQUc7b0JBQ3RDMU0sS0FBSyxDQUFDME0sRUFBRSxJQUFJNnlFO2dCQUNkO1lBQ0YsT0FBTztnQkFDTHYvRSxTQUFTdS9FO1lBQ1g7WUFFQSxPQUFPdi9FO1FBQ1Q7UUFFQSxTQUFTMi9FLHdCQUF3QmpvRSxJQUFJO1lBQ25DLElBQUksQ0FBQyxJQUFJLENBQUNrb0UsdUJBQXVCLEVBQUU7Z0JBQ2pDLElBQUksQ0FBQ0EsdUJBQXVCLEdBQUc7b0JBQzdCOTJFLEdBQUcsSUFBSWt3QjtnQkFDVDtZQUNGLEVBQUUsS0FBSztZQUdQLElBQUkwRCxTQUFTLElBQUksQ0FBQ2tqRCx1QkFBdUIsQ0FBQzkyRSxDQUFDO1lBQzNDNHpCLE9BQU9NLGNBQWMsQ0FBQyxJQUFJLENBQUNpSCxHQUFHLENBQUMzSyxLQUFLO1lBRXBDLElBQUksSUFBSSxDQUFDNEssc0JBQXNCLEdBQUcsR0FBRztnQkFDbkMsSUFBSTI3QyxTQUFTLElBQUksQ0FBQ3B3RSxDQUFDLENBQUM0MEIsY0FBYyxDQUFDM3NCO2dCQUNuQ2dsQixPQUFPbkMsU0FBUyxDQUFDLENBQUNzbEQsTUFBTSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUNwd0UsQ0FBQyxDQUFDZ2lCLElBQUksRUFBRSxDQUFDb3VELE1BQU0sQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDcHdFLENBQUMsQ0FBQ2dpQixJQUFJLEVBQUVvdUQsTUFBTSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUNwd0UsQ0FBQyxDQUFDZ2lCLElBQUk7WUFDOUY7WUFFQSxJQUFJLElBQUksQ0FBQ3lTLHNCQUFzQixHQUFHLEdBQUc7Z0JBQ25DLElBQUloSyxRQUFRLElBQUksQ0FBQ3J4QixDQUFDLENBQUN3N0IsY0FBYyxDQUFDM3NCO2dCQUNsQ2dsQixPQUFPeEMsS0FBSyxDQUFDQSxLQUFLLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQ3J4QixDQUFDLENBQUM0b0IsSUFBSSxFQUFFeUksS0FBSyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUNyeEIsQ0FBQyxDQUFDNG9CLElBQUksRUFBRXlJLEtBQUssQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDcnhCLENBQUMsQ0FBQzRvQixJQUFJO1lBQ3JGO1lBRUEsSUFBSSxJQUFJLENBQUMvaEIsRUFBRSxJQUFJLElBQUksQ0FBQ3cwQixzQkFBc0IsR0FBRyxHQUFHO2dCQUM5QyxJQUFJbEssT0FBTyxJQUFJLENBQUN0cUIsRUFBRSxDQUFDMjBCLGNBQWMsQ0FBQzNzQjtnQkFDbEMsSUFBSXVsRSxXQUFXLElBQUksQ0FBQ3R0RSxFQUFFLENBQUMwMEIsY0FBYyxDQUFDM3NCO2dCQUN0Q2dsQixPQUFPekMsWUFBWSxDQUFDLENBQUNELE9BQU8sSUFBSSxDQUFDdHFCLEVBQUUsQ0FBQytoQixJQUFJLEVBQUV3ckQsV0FBVyxJQUFJLENBQUN0dEUsRUFBRSxDQUFDOGhCLElBQUk7WUFDbkU7WUFFQSxJQUFJLElBQUksQ0FBQzFvQixDQUFDLElBQUksSUFBSSxDQUFDbTdCLHNCQUFzQixHQUFHLEdBQUc7Z0JBQzdDLElBQUl3dkMsV0FBVyxJQUFJLENBQUMzcUUsQ0FBQyxDQUFDczdCLGNBQWMsQ0FBQzNzQjtnQkFDckNnbEIsT0FBT25ELE1BQU0sQ0FBQyxDQUFDbTZDLFdBQVcsSUFBSSxDQUFDM3FFLENBQUMsQ0FBQzBvQixJQUFJO1lBQ3ZDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQzFvQixDQUFDLElBQUksSUFBSSxDQUFDbTdCLHNCQUFzQixHQUFHLEdBQUc7Z0JBQ3JELElBQUk0N0MsWUFBWSxJQUFJLENBQUN0OEMsRUFBRSxDQUFDYSxjQUFjLENBQUMzc0I7Z0JBQ3ZDLElBQUlxb0UsWUFBWSxJQUFJLENBQUN0OEMsRUFBRSxDQUFDWSxjQUFjLENBQUMzc0I7Z0JBQ3ZDLElBQUlzb0UsWUFBWSxJQUFJLENBQUN0OEMsRUFBRSxDQUFDVyxjQUFjLENBQUMzc0I7Z0JBQ3ZDLElBQUl1b0UsY0FBYyxJQUFJLENBQUMzb0QsRUFBRSxDQUFDK00sY0FBYyxDQUFDM3NCO2dCQUN6Q2dsQixPQUFPN0MsT0FBTyxDQUFDLENBQUNpbUQsWUFBWSxJQUFJLENBQUN0OEMsRUFBRSxDQUFDL1IsSUFBSSxFQUFFbUksT0FBTyxDQUFDbW1ELFlBQVksSUFBSSxDQUFDdDhDLEVBQUUsQ0FBQ2hTLElBQUksRUFBRWtJLE9BQU8sQ0FBQ3FtRCxZQUFZLElBQUksQ0FBQ3Q4QyxFQUFFLENBQUNqUyxJQUFJLEVBQUVvSSxPQUFPLENBQUMsQ0FBQ29tRCxXQUFXLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQzNvRCxFQUFFLENBQUM3RixJQUFJLEVBQUVtSSxPQUFPLENBQUNxbUQsV0FBVyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMzb0QsRUFBRSxDQUFDN0YsSUFBSSxFQUFFa0ksT0FBTyxDQUFDc21ELFdBQVcsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDM29ELEVBQUUsQ0FBQzdGLElBQUk7WUFDcE87WUFFQSxJQUFJLElBQUksQ0FBQ2ptQixJQUFJLENBQUNyQyxDQUFDLElBQUksSUFBSSxDQUFDcUMsSUFBSSxDQUFDckMsQ0FBQyxDQUFDTixDQUFDLEVBQUU7Z0JBQ2hDLElBQUlxM0UsWUFBWSxJQUFJLENBQUN2OEMsRUFBRSxDQUFDVSxjQUFjLENBQUMzc0I7Z0JBQ3ZDLElBQUl5b0UsWUFBWSxJQUFJLENBQUN2OEMsRUFBRSxDQUFDUyxjQUFjLENBQUMzc0I7Z0JBRXZDLElBQUksSUFBSSxDQUFDbE0sSUFBSSxDQUFDckMsQ0FBQyxDQUFDOG5CLENBQUMsRUFBRTtvQkFDakIsSUFBSW12RCxZQUFZLElBQUksQ0FBQ3Y4QyxFQUFFLENBQUNRLGNBQWMsQ0FBQzNzQjtvQkFDdkNnbEIsT0FBT25DLFNBQVMsQ0FBQzJsRCxZQUFZLElBQUksQ0FBQ3Y4QyxFQUFFLENBQUNsUyxJQUFJLEVBQUUwdUQsWUFBWSxJQUFJLENBQUN2OEMsRUFBRSxDQUFDblMsSUFBSSxFQUFFLENBQUMydUQsWUFBWSxJQUFJLENBQUN2OEMsRUFBRSxDQUFDcFMsSUFBSTtnQkFDaEcsT0FBTztvQkFDTGlMLE9BQU9uQyxTQUFTLENBQUMybEQsWUFBWSxJQUFJLENBQUN2OEMsRUFBRSxDQUFDbFMsSUFBSSxFQUFFMHVELFlBQVksSUFBSSxDQUFDdjhDLEVBQUUsQ0FBQ25TLElBQUksRUFBRTtnQkFDdkU7WUFDRixPQUFPO2dCQUNMLElBQUk5cUIsV0FBVyxJQUFJLENBQUN3QyxDQUFDLENBQUNrN0IsY0FBYyxDQUFDM3NCO2dCQUNyQ2dsQixPQUFPbkMsU0FBUyxDQUFDNXpCLFFBQVEsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDd0MsQ0FBQyxDQUFDc29CLElBQUksRUFBRTlxQixRQUFRLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQ3dDLENBQUMsQ0FBQ3NvQixJQUFJLEVBQUUsQ0FBQzlxQixRQUFRLENBQUMsRUFBRSxHQUFHLElBQUksQ0FBQ3dDLENBQUMsQ0FBQ3NvQixJQUFJO1lBQ25HO1lBRUEsT0FBT2lMLFFBQVEsS0FBSztRQUN0QjtRQUVBLFNBQVMyakQ7WUFDUCxPQUFPLElBQUksQ0FBQ3YzRSxDQUFDLENBQUM2ckIsS0FBSyxDQUFDLElBQUlxRTtRQUMxQjtRQUVBLElBQUl5TCx1QkFBdUJyQix5QkFBeUJxQixvQkFBb0I7UUFFeEVyQix5QkFBeUJxQixvQkFBb0IsR0FBRyxTQUFVampCLElBQUksRUFBRWhXLElBQUksRUFBRXNQLFNBQVM7WUFDN0UsSUFBSTFaLE9BQU9xakMscUJBQXFCampCLE1BQU1oVyxNQUFNc1A7WUFFNUMsSUFBSTFaLEtBQUs2eEIsaUJBQWlCLENBQUN0eUIsTUFBTSxFQUFFO2dCQUNqQ1MsS0FBS2lqQyxjQUFjLEdBQUdzN0Msd0JBQXdCL3FFLElBQUksQ0FBQ3hUO1lBQ3JELE9BQU87Z0JBQ0xBLEtBQUtpakMsY0FBYyxHQUFHZzhDLDhCQUE4QnpyRSxJQUFJLENBQUN4VDtZQUMzRDtZQUVBQSxLQUFLZzZFLGdCQUFnQixHQUFHZ0Qsa0JBQWtCaEQsZ0JBQWdCO1lBQzFELE9BQU9oNkU7UUFDVDtRQUVBLElBQUlrL0Usa0JBQWtCMXRELGdCQUFnQkMsT0FBTztRQUU3Q0QsZ0JBQWdCQyxPQUFPLEdBQUcsU0FBVXJSLElBQUksRUFBRWhXLElBQUksRUFBRXJMLElBQUksRUFBRXN4QixJQUFJLEVBQUUzVyxTQUFTO1lBQ25FLElBQUkxWixPQUFPay9FLGdCQUFnQjkrRCxNQUFNaFcsTUFBTXJMLE1BQU1zeEIsTUFBTTNXLFlBQVksOENBQThDO1lBQzdHLDBCQUEwQjtZQUMxQix3QkFBd0I7WUFFeEIsSUFBSTFaLEtBQUs2d0IsRUFBRSxFQUFFO2dCQUNYN3dCLEtBQUtpakMsY0FBYyxHQUFHKzVDLGtCQUFrQi81QyxjQUFjLENBQUN6dkIsSUFBSSxDQUFDeFQ7WUFDOUQsT0FBTztnQkFDTEEsS0FBS2lqQyxjQUFjLEdBQUcrNUMsa0JBQWtCSSxvQkFBb0IsQ0FBQzVwRSxJQUFJLENBQUN4VDtZQUNwRTtZQUVBQSxLQUFLZzZFLGdCQUFnQixHQUFHZ0Qsa0JBQWtCaEQsZ0JBQWdCO1lBQzFEaDZFLEtBQUs4eEUsT0FBTyxHQUFHQTtZQUNmOXhFLEtBQUs0eEUsTUFBTSxHQUFHQTtZQUNkNXhFLEtBQUtneUUsTUFBTSxHQUFHQTtZQUNkaHlFLEtBQUt5ekUsaUJBQWlCLEdBQUd1SixrQkFBa0J2SixpQkFBaUIsQ0FBQ2pnRSxJQUFJLENBQUN4VDtZQUNsRUEsS0FBSysyRSxjQUFjLEdBQUdpRyxrQkFBa0JqRyxjQUFjLENBQUN2akUsSUFBSSxDQUFDeFQ7WUFDNURBLEtBQUs4eUUsT0FBTyxHQUFHMW9FLEtBQUtpRSxDQUFDLEtBQUssSUFBSWpFLEtBQUtvQixDQUFDLENBQUNqTSxNQUFNLEdBQUc7WUFDOUNTLEtBQUtvNkUsYUFBYSxHQUFHaHdFLEtBQUtrN0IsRUFBRTtZQUM1QixJQUFJMW1DLFFBQVE7WUFFWixJQUFJRyxTQUFTLEdBQUc7Z0JBQ2RILFFBQVFzRCxpQkFBaUIsV0FBV2tJLEtBQUtpRSxDQUFDLEtBQUssSUFBSWpFLEtBQUtvQixDQUFDLENBQUMsRUFBRSxDQUFDL0QsQ0FBQyxDQUFDbEksTUFBTSxHQUFHNkssS0FBS29CLENBQUMsQ0FBQ2pNLE1BQU07WUFDdkY7WUFFQVMsS0FBS2s5RSxjQUFjLEdBQUc7Z0JBQ3BCdndELFdBQVdwdUI7Z0JBQ1hrdEIsV0FBVztnQkFDWDdzQixPQUFPQTtZQUNUO1lBQ0FvK0Usa0JBQWtCQyxpQkFBaUIsQ0FBQzc4RCxNQUFNaFcsTUFBTXBLO1lBRWhELElBQUlBLEtBQUt3TCxDQUFDLEVBQUU7Z0JBQ1ZrTyxVQUFVc1gsa0JBQWtCLENBQUNoeEI7WUFDL0I7WUFFQSxPQUFPQTtRQUNUO1FBRUEsU0FBU20vRSxvQkFBb0JqMEQsUUFBUTtZQUNuQyxnSEFBZ0g7WUFDaEgsSUFBSSxDQUFDLElBQUksQ0FBQ2d5RCxjQUFjLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQ0EsY0FBYyxHQUFHO29CQUNwQmtDLFlBQVkvckQsVUFBVUUsS0FBSyxDQUFDLElBQUksQ0FBQ2hJLEVBQUU7b0JBQ25DRSxXQUFXO29CQUNYNHpELFVBQVU5Z0Y7Z0JBQ1o7WUFDRjtZQUVBMnNCLFlBQVksSUFBSSxDQUFDOUssSUFBSSxDQUFDdEcsVUFBVSxDQUFDOUIsU0FBUztZQUMxQ2tULFlBQVksSUFBSSxDQUFDRSxVQUFVO1lBRTNCLElBQUlGLGFBQWEsSUFBSSxDQUFDZ3lELGNBQWMsQ0FBQ21DLFFBQVEsRUFBRTtnQkFDN0MsSUFBSSxDQUFDbkMsY0FBYyxDQUFDenhELFNBQVMsR0FBRyxJQUFJLENBQUN5eEQsY0FBYyxDQUFDbUMsUUFBUSxHQUFHbjBELFdBQVcsSUFBSSxDQUFDK0UsUUFBUSxDQUFDeEUsU0FBUyxHQUFHO2dCQUNwRyxJQUFJLENBQUN5eEQsY0FBYyxDQUFDbUMsUUFBUSxHQUFHbjBEO2dCQUMvQixJQUFJLENBQUMrSSxnQkFBZ0IsQ0FBQy9JLFVBQVUsSUFBSSxDQUFDZ3lELGNBQWMsQ0FBQ2tDLFVBQVUsRUFBRSxJQUFJLENBQUNsQyxjQUFjO1lBQ3JGO1lBRUEsT0FBTyxJQUFJLENBQUNBLGNBQWMsQ0FBQ2tDLFVBQVU7UUFDdkM7UUFFQSxJQUFJRSxtQ0FBbUN0ckQscUJBQXFCMEQsc0JBQXNCO1FBQ2xGLElBQUk2bkQsNENBQTRDdnJELHFCQUFxQjJELCtCQUErQjtRQUVwRyxTQUFTNm5ELG9CQUFvQjtRQUU3QkEsaUJBQWlCLy9FLFNBQVMsR0FBRztZQUMzQnd6QixVQUFVLFNBQVNBLFNBQVNqekIsSUFBSSxFQUFFc1csSUFBSTtnQkFDcEMsSUFBSSxJQUFJLENBQUM5SyxDQUFDLEVBQUU7b0JBQ1YsSUFBSSxDQUFDMmxCLFFBQVE7Z0JBQ2Y7Z0JBRUEsSUFBSW1DLFlBQVksSUFBSSxDQUFDNXJCLENBQUM7Z0JBRXRCLElBQUk0TyxTQUFTMkQsV0FBVztvQkFDdEJxWixZQUFZLElBQUksQ0FBQzJQLGNBQWMsQ0FBQzNzQixNQUFNO2dCQUN4QztnQkFFQSxJQUFJalg7Z0JBQ0osSUFBSUMsTUFBTWcwQixVQUFVbE8sT0FBTztnQkFDM0IsSUFBSTZOLFdBQVdLLFNBQVMsQ0FBQ3R6QixLQUFLO2dCQUM5QixJQUFJNGpCLFNBQVMwUCxVQUFVNXJCLENBQUM7Z0JBQ3hCLElBQUl0RixNQUFNSyxpQkFBaUJuRDtnQkFFM0IsSUFBS0QsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7b0JBQzNCLElBQUlXLFNBQVMsT0FBT0EsU0FBUyxLQUFLO3dCQUNoQ29DLEdBQUcsQ0FBQy9DLEVBQUUsR0FBRzs0QkFBQzR6QixRQUFRLENBQUM1ekIsRUFBRSxDQUFDLEVBQUUsR0FBR3VrQixNQUFNLENBQUN2a0IsRUFBRSxDQUFDLEVBQUU7NEJBQUU0ekIsUUFBUSxDQUFDNXpCLEVBQUUsQ0FBQyxFQUFFLEdBQUd1a0IsTUFBTSxDQUFDdmtCLEVBQUUsQ0FBQyxFQUFFO3lCQUFDO29CQUN6RSxPQUFPO3dCQUNMK0MsR0FBRyxDQUFDL0MsRUFBRSxHQUFHOzRCQUFDNHpCLFFBQVEsQ0FBQzV6QixFQUFFLENBQUMsRUFBRTs0QkFBRTR6QixRQUFRLENBQUM1ekIsRUFBRSxDQUFDLEVBQUU7eUJBQUM7b0JBQzNDO2dCQUNGO2dCQUVBLE9BQU8rQztZQUNUO1lBQ0F3aEIsUUFBUSxTQUFTQSxPQUFPdE4sSUFBSTtnQkFDMUIsT0FBTyxJQUFJLENBQUMyYyxRQUFRLENBQUMsS0FBSzNjO1lBQzVCO1lBQ0FxNkQsWUFBWSxTQUFTQSxXQUFXcjZELElBQUk7Z0JBQ2xDLE9BQU8sSUFBSSxDQUFDMmMsUUFBUSxDQUFDLEtBQUszYztZQUM1QjtZQUNBczZELGFBQWEsU0FBU0EsWUFBWXQ2RCxJQUFJO2dCQUNwQyxPQUFPLElBQUksQ0FBQzJjLFFBQVEsQ0FBQyxLQUFLM2M7WUFDNUI7WUFDQW1wRSxVQUFVLFNBQVNBO2dCQUNqQixPQUFPLElBQUksQ0FBQy8zRSxDQUFDLENBQUNrSCxDQUFDO1lBQ2pCO1lBQ0E4d0UsYUFBYSxTQUFTQSxZQUFZajRELElBQUksRUFBRW5SLElBQUk7Z0JBQzFDLElBQUlnZCxZQUFZLElBQUksQ0FBQzVyQixDQUFDO2dCQUV0QixJQUFJNE8sU0FBUzJELFdBQVc7b0JBQ3RCcVosWUFBWSxJQUFJLENBQUMyUCxjQUFjLENBQUMzc0IsTUFBTTtnQkFDeEM7Z0JBRUEsSUFBSSxDQUFDLElBQUksQ0FBQ3FwRSxlQUFlLEVBQUU7b0JBQ3pCLElBQUksQ0FBQ0EsZUFBZSxHQUFHNzBELElBQUloRCxpQkFBaUIsQ0FBQ3dMO2dCQUMvQztnQkFFQSxJQUFJdEwsaUJBQWlCLElBQUksQ0FBQzIzRCxlQUFlO2dCQUN6QyxJQUFJOTVELFVBQVVtQyxlQUFlbkMsT0FBTztnQkFDcEMsSUFBSWtELFlBQVlmLGVBQWVqQyxXQUFXLEdBQUcwQjtnQkFDN0MsSUFBSXBvQixJQUFJO2dCQUNSLElBQUlDLE1BQU11bUIsUUFBUXRtQixNQUFNO2dCQUN4QixJQUFJcWdGLG9CQUFvQjtnQkFDeEIsSUFBSTl6RTtnQkFFSixNQUFPek0sSUFBSUMsSUFBSztvQkFDZCxJQUFJc2dGLG9CQUFvQi81RCxPQUFPLENBQUN4bUIsRUFBRSxDQUFDc21CLFdBQVcsR0FBR29ELFdBQVc7d0JBQzFELElBQUk4MkQsWUFBWXhnRjt3QkFDaEIsSUFBSXlnRixXQUFXeHNELFVBQVUxa0IsQ0FBQyxJQUFJdlAsTUFBTUMsTUFBTSxJQUFJLElBQUlELElBQUk7d0JBQ3RELElBQUlxdEIsY0FBYyxDQUFDM0QsWUFBWTYyRCxpQkFBZ0IsSUFBSy81RCxPQUFPLENBQUN4bUIsRUFBRSxDQUFDc21CLFdBQVc7d0JBQzFFN1osS0FBS2dmLElBQUk1QixpQkFBaUIsQ0FBQ29LLFVBQVU1ckIsQ0FBQyxDQUFDbTRFLFVBQVUsRUFBRXZzRCxVQUFVNXJCLENBQUMsQ0FBQ280RSxTQUFTLEVBQUV4c0QsVUFBVXBtQixDQUFDLENBQUMyeUUsVUFBVSxFQUFFdnNELFVBQVVqMEIsQ0FBQyxDQUFDeWdGLFNBQVMsRUFBRXB6RCxhQUFhN0csT0FBTyxDQUFDeG1CLEVBQUU7d0JBQ2hKO29CQUNGLE9BQU87d0JBQ0x1Z0YscUJBQXFCLzVELE9BQU8sQ0FBQ3htQixFQUFFLENBQUNzbUIsV0FBVztvQkFDN0M7b0JBRUF0bUIsS0FBSztnQkFDUDtnQkFFQSxJQUFJLENBQUN5TSxJQUFJO29CQUNQQSxLQUFLd25CLFVBQVUxa0IsQ0FBQyxHQUFHO3dCQUFDMGtCLFVBQVU1ckIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO3dCQUFFNHJCLFVBQVU1ckIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFO3FCQUFDLEdBQUc7d0JBQUM0ckIsVUFBVTVyQixDQUFDLENBQUM0ckIsVUFBVWxPLE9BQU8sR0FBRyxFQUFFLENBQUMsRUFBRTt3QkFBRWtPLFVBQVU1ckIsQ0FBQyxDQUFDNHJCLFVBQVVsTyxPQUFPLEdBQUcsRUFBRSxDQUFDLEVBQUU7cUJBQUM7Z0JBQzVJO2dCQUVBLE9BQU90WjtZQUNUO1lBQ0FpMEUsY0FBYyxTQUFTQSxhQUFhdDRELElBQUksRUFBRW5SLElBQUksRUFBRTBwRSxVQUFVO2dCQUN4RCw2RkFBNkY7Z0JBQzdGLElBQUl2NEQsUUFBUSxHQUFHO29CQUNiLDZCQUE2QjtvQkFDN0JBLE9BQU8sSUFBSSxDQUFDL2YsQ0FBQyxDQUFDa0gsQ0FBQztnQkFDakIsT0FBTyxJQUFJNlksUUFBUSxHQUFHO29CQUNwQiw2QkFBNkI7b0JBQzdCQSxPQUFPO2dCQUNUO2dCQUVBLElBQUlOLE1BQU0sSUFBSSxDQUFDdTRELFdBQVcsQ0FBQ2o0RCxNQUFNblI7Z0JBQ2pDLElBQUk4USxNQUFNLElBQUksQ0FBQ3M0RCxXQUFXLENBQUNqNEQsT0FBTyxPQUFPblI7Z0JBQ3pDLElBQUkycEUsVUFBVTc0RCxHQUFHLENBQUMsRUFBRSxHQUFHRCxHQUFHLENBQUMsRUFBRTtnQkFDN0IsSUFBSSs0RCxVQUFVOTRELEdBQUcsQ0FBQyxFQUFFLEdBQUdELEdBQUcsQ0FBQyxFQUFFO2dCQUM3QixJQUFJZzVELFlBQVl4OEUsS0FBS0csSUFBSSxDQUFDSCxLQUFLQyxHQUFHLENBQUNxOEUsU0FBUyxLQUFLdDhFLEtBQUtDLEdBQUcsQ0FBQ3M4RSxTQUFTO2dCQUVuRSxJQUFJQyxjQUFjLEdBQUc7b0JBQ25CLE9BQU87d0JBQUM7d0JBQUc7cUJBQUU7Z0JBQ2Y7Z0JBRUEsSUFBSUMsYUFBYUosZUFBZSxZQUFZO29CQUFDQyxVQUFVRTtvQkFBV0QsVUFBVUM7aUJBQVUsR0FBRztvQkFBQyxDQUFDRCxVQUFVQztvQkFBV0YsVUFBVUU7aUJBQVU7Z0JBQ3BJLE9BQU9DO1lBQ1Q7WUFDQUMsZUFBZSxTQUFTQSxjQUFjNTRELElBQUksRUFBRW5SLElBQUk7Z0JBQzlDLE9BQU8sSUFBSSxDQUFDeXBFLFlBQVksQ0FBQ3Q0RCxNQUFNblIsTUFBTTtZQUN2QztZQUNBZ3FFLGNBQWMsU0FBU0EsYUFBYTc0RCxJQUFJLEVBQUVuUixJQUFJO2dCQUM1QyxPQUFPLElBQUksQ0FBQ3lwRSxZQUFZLENBQUN0NEQsTUFBTW5SLE1BQU07WUFDdkM7WUFDQTBqRSxrQkFBa0JnRCxrQkFBa0JoRCxnQkFBZ0I7WUFDcEQvMkMsZ0JBQWdCKzVDLGtCQUFrQkksb0JBQW9CO1FBQ3hEO1FBQ0FsK0UsZ0JBQWdCO1lBQUNzZ0Y7U0FBaUIsRUFBRUY7UUFDcENwZ0YsZ0JBQWdCO1lBQUNzZ0Y7U0FBaUIsRUFBRUQ7UUFDcENBLDBDQUEwQzkvRSxTQUFTLENBQUN3akMsY0FBYyxHQUFHazhDO1FBQ3JFSSwwQ0FBMEM5L0UsU0FBUyxDQUFDdXhFLGtCQUFrQixHQUFHcEQsa0JBQWtCb0Qsa0JBQWtCO1FBQzdHLElBQUl1UCx1QkFBdUJ2c0QscUJBQXFCd0QsWUFBWTtRQUU1RHhELHFCQUFxQndELFlBQVksR0FBRyxTQUFVcFgsSUFBSSxFQUFFaFcsSUFBSSxFQUFFckwsSUFBSSxFQUFFcUQsR0FBRyxFQUFFbytFLEtBQUs7WUFDeEUsSUFBSXhnRixPQUFPdWdGLHFCQUFxQm5nRSxNQUFNaFcsTUFBTXJMLE1BQU1xRCxLQUFLbytFO1lBQ3ZEeGdGLEtBQUtvNkUsYUFBYSxHQUFHaHdFLEtBQUtrN0IsRUFBRTtZQUM1QnRsQyxLQUFLMHdCLElBQUksR0FBRztZQUVaLElBQUkzeEIsU0FBUyxHQUFHO2dCQUNkaStFLGtCQUFrQkMsaUJBQWlCLENBQUM3OEQsTUFBTWhXLEtBQUswQixFQUFFLEVBQUU5TDtZQUNyRCxPQUFPLElBQUlqQixTQUFTLEdBQUc7Z0JBQ3JCaStFLGtCQUFrQkMsaUJBQWlCLENBQUM3OEQsTUFBTWhXLEtBQUs0QyxFQUFFLEVBQUVoTjtZQUNyRDtZQUVBLElBQUlBLEtBQUt3TCxDQUFDLEVBQUU7Z0JBQ1Y0VSxLQUFLNFEsa0JBQWtCLENBQUNoeEI7WUFDMUI7WUFFQSxPQUFPQTtRQUNUO0lBQ0Y7SUFFQSxTQUFTeWdGO1FBQ1BwRDtJQUNGO0lBRUEsU0FBU3FEO1FBQ1AsU0FBU3pEO1lBQ1AsSUFBSSxJQUFJLENBQUM3eUUsSUFBSSxDQUFDakMsQ0FBQyxDQUFDOGIsQ0FBQyxFQUFFO2dCQUNqQixJQUFJLENBQUMwOEQsbUJBQW1CLEdBQUcvUyxrQkFBa0JvRCxrQkFBa0IsQ0FBQ3g5RCxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQzRNLElBQUksRUFBRSxJQUFJLENBQUNoVyxJQUFJLENBQUNqQyxDQUFDLEVBQUUsSUFBSTtnQkFDdkcsSUFBSSxDQUFDMm9CLFNBQVMsQ0FBQyxJQUFJLENBQUM4dkQsa0JBQWtCLENBQUNwdEUsSUFBSSxDQUFDLElBQUk7Z0JBQ2hELE9BQU87WUFDVDtZQUVBLE9BQU87UUFDVDtRQUVBNjNDLGFBQWE1ckQsU0FBUyxDQUFDbWhGLGtCQUFrQixHQUFHLFNBQVUzekIsWUFBWSxFQUFFcmIsSUFBSTtZQUN0RSxJQUFJdm1CLFdBQVcsSUFBSSxDQUFDczFELG1CQUFtQixDQUFDL3VDO1lBRXhDLElBQUlxYixhQUFhaGxELENBQUMsS0FBS29qQixVQUFVO2dCQUMvQixJQUFJb2tDLFVBQVUsQ0FBQztnQkFDZixJQUFJLENBQUMvQyxRQUFRLENBQUMrQyxTQUFTeEM7Z0JBQ3ZCd0MsUUFBUXhuRCxDQUFDLEdBQUdvakIsU0FBU3hpQixRQUFRO2dCQUM3QjRtRCxRQUFRdmdELFVBQVUsR0FBRztnQkFDckIsT0FBT3VnRDtZQUNUO1lBRUEsT0FBT3hDO1FBQ1Q7UUFFQTVCLGFBQWE1ckQsU0FBUyxDQUFDa3RELGNBQWMsR0FBRztZQUN0QyxJQUFJazBCLGNBQWMsSUFBSSxDQUFDL3pCLGVBQWU7WUFDdEMsSUFBSWcwQixpQkFBaUIsSUFBSSxDQUFDN0QsaUJBQWlCO1lBQzNDLElBQUksQ0FBQ3BzRCxFQUFFLEdBQUdnd0QsZUFBZUM7WUFDekIsT0FBTyxJQUFJLENBQUNqd0QsRUFBRTtRQUNoQjtRQUVBdzZCLGFBQWE1ckQsU0FBUyxDQUFDdzlFLGlCQUFpQixHQUFHQTtJQUM3QztJQUVBLFNBQVM4RDtRQUNQTDtJQUNGO0lBRUEsU0FBU00sdUJBQXVCO0lBRWhDQSxvQkFBb0J2aEYsU0FBUyxHQUFHO1FBQzlCd2hGLGlCQUFpQixTQUFTQSxnQkFBZ0JDLFFBQVEsRUFBRUMsR0FBRztZQUNyRCxJQUFJQyxVQUFVNTNFLFNBQVM7WUFDdkI0M0UsUUFBUWhnRSxZQUFZLENBQUMsVUFBVTgvRDtZQUMvQixJQUFJRztZQUNKLElBQUloaUY7WUFFSixJQUFLQSxJQUFJLEdBQUdBLElBQUk4aEYsSUFBSTVoRixNQUFNLEVBQUVGLEtBQUssRUFBRztnQkFDbENnaUYsY0FBYzczRSxTQUFTO2dCQUN2QjYzRSxZQUFZamdFLFlBQVksQ0FBQyxNQUFNKy9ELEdBQUcsQ0FBQzloRixFQUFFO2dCQUNyQytoRixRQUFRcnRFLFdBQVcsQ0FBQ3N0RTtnQkFDcEJELFFBQVFydEUsV0FBVyxDQUFDc3RFO1lBQ3RCO1lBRUEsT0FBT0Q7UUFDVDtJQUNGO0lBRUEsSUFBSUUsb0JBQW9CO0lBRXhCLFNBQVNDLGNBQWN2NUMsTUFBTSxFQUFFeVksYUFBYSxFQUFFcmdDLElBQUksRUFBRTFULEVBQUUsRUFBRTZ6QyxNQUFNO1FBQzVELElBQUksQ0FBQ0UsYUFBYSxHQUFHQTtRQUNyQixJQUFJVCxnQkFBZ0J4MkMsU0FBUztRQUM3QncyQyxjQUFjNStCLFlBQVksQ0FBQyxRQUFRO1FBQ25DNCtCLGNBQWM1K0IsWUFBWSxDQUFDLCtCQUErQjtRQUMxRDQrQixjQUFjNStCLFlBQVksQ0FBQyxVQUFVa2dFLG9CQUFvQjtRQUN6RCxJQUFJLENBQUNFLFlBQVksR0FBR3hoQztRQUNwQkEsY0FBYzUrQixZQUFZLENBQUMsVUFBVTFVLEtBQUs7UUFDMUNzN0IsT0FBT2owQixXQUFXLENBQUNpc0M7UUFDbkJBLGdCQUFnQngyQyxTQUFTO1FBQ3pCdzJDLGNBQWM1K0IsWUFBWSxDQUFDLFFBQVE7UUFDbkM0K0IsY0FBYzUrQixZQUFZLENBQUMsK0JBQStCO1FBQzFENCtCLGNBQWM1K0IsWUFBWSxDQUFDLFVBQVU7UUFDckM0K0IsY0FBYzUrQixZQUFZLENBQUMsVUFBVTFVLEtBQUs7UUFDMUNzN0IsT0FBT2owQixXQUFXLENBQUNpc0M7UUFDbkIsSUFBSSxDQUFDeWhDLFlBQVksR0FBR3poQztRQUNwQixJQUFJb2hDLFVBQVUsSUFBSSxDQUFDSCxlQUFlLENBQUN2MEUsSUFBSTtZQUFDNnpDO1lBQVE3ekMsS0FBSztZQUFXQSxLQUFLO1NBQVU7UUFDL0VzN0IsT0FBT2owQixXQUFXLENBQUNxdEU7SUFDckI7SUFFQWxpRixnQkFBZ0I7UUFBQzhoRjtLQUFvQixFQUFFTztJQUV2Q0EsY0FBYzloRixTQUFTLENBQUNvZCxXQUFXLEdBQUcsU0FBVTZsQixXQUFXO1FBQ3pELElBQUlBLGVBQWUsSUFBSSxDQUFDK2QsYUFBYSxDQUFDbndCLElBQUksRUFBRTtZQUMxQyxJQUFJb3hELGFBQWEsSUFBSSxDQUFDamhDLGFBQWEsQ0FBQ3RKLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDO1lBQ3pELElBQUlpNkUsYUFBYSxJQUFJLENBQUNsaEMsYUFBYSxDQUFDdEosY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUM7WUFDekQsSUFBSTIxQyxVQUFVLElBQUksQ0FBQ29ELGFBQWEsQ0FBQ3RKLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEdBQUc7WUFDekQsSUFBSSxDQUFDODVFLFlBQVksQ0FBQ3BnRSxZQUFZLENBQUMsVUFBVWtnRSxvQkFBb0IsTUFBTWprQyxVQUFVO1lBQzdFLElBQUksQ0FBQ29rQyxZQUFZLENBQUNyZ0UsWUFBWSxDQUFDLFVBQVV1Z0UsVUFBVSxDQUFDLEVBQUUsR0FBR0QsVUFBVSxDQUFDLEVBQUUsR0FBRyxZQUFZQSxVQUFVLENBQUMsRUFBRSxHQUFHLE1BQU9DLENBQUFBLFVBQVUsQ0FBQyxFQUFFLEdBQUdELFVBQVUsQ0FBQyxFQUFFLElBQUksWUFBWUEsVUFBVSxDQUFDLEVBQUUsR0FBRyxNQUFPQyxDQUFBQSxVQUFVLENBQUMsRUFBRSxHQUFHRCxVQUFVLENBQUMsRUFBRSxJQUFJLFlBQVlBLFVBQVUsQ0FBQyxFQUFFLEdBQUc7UUFDL087SUFDRjtJQUVBLFNBQVNFLGNBQWM1NUMsTUFBTSxFQUFFeVksYUFBYSxFQUFFcmdDLElBQUksRUFBRTFULEVBQUU7UUFDcEQsSUFBSSxDQUFDK3pDLGFBQWEsR0FBR0E7UUFDckIsSUFBSVQsZ0JBQWdCeDJDLFNBQVM7UUFDN0J3MkMsY0FBYzUrQixZQUFZLENBQUMsUUFBUTtRQUNuQzQrQixjQUFjNStCLFlBQVksQ0FBQywrQkFBK0I7UUFDMUQ0K0IsY0FBYzUrQixZQUFZLENBQUMsVUFBVTtRQUNyQzQrQixjQUFjNStCLFlBQVksQ0FBQyxVQUFVMVU7UUFDckNzN0IsT0FBT2owQixXQUFXLENBQUNpc0M7UUFDbkIsSUFBSSxDQUFDeWhDLFlBQVksR0FBR3poQztJQUN0QjtJQUVBNGhDLGNBQWNuaUYsU0FBUyxDQUFDb2QsV0FBVyxHQUFHLFNBQVU2bEIsV0FBVztRQUN6RCxJQUFJQSxlQUFlLElBQUksQ0FBQytkLGFBQWEsQ0FBQ253QixJQUFJLEVBQUU7WUFDMUMsSUFBSWpvQixRQUFRLElBQUksQ0FBQ280QyxhQUFhLENBQUN0SixjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQztZQUNwRCxJQUFJMjFDLFVBQVUsSUFBSSxDQUFDb0QsYUFBYSxDQUFDdEosY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUM7WUFDdEQsSUFBSSxDQUFDKzVFLFlBQVksQ0FBQ3JnRSxZQUFZLENBQUMsVUFBVSxhQUFhL1ksS0FBSyxDQUFDLEVBQUUsR0FBRyxjQUFjQSxLQUFLLENBQUMsRUFBRSxHQUFHLGNBQWNBLEtBQUssQ0FBQyxFQUFFLEdBQUcsWUFBWWcxQyxVQUFVO1FBQzNJO0lBQ0Y7SUFFQSxTQUFTd2tDLGdCQUFnQjloQyxHQUFHLEVBQUVVLGFBQWEsRUFBRXJnQyxJQUFJO1FBQy9DLElBQUksQ0FBQzBoRSxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDcmhDLGFBQWEsR0FBR0E7UUFDckIsSUFBSSxDQUFDcmdDLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNxVSxLQUFLLEdBQUcsRUFBRTtJQUNqQjtJQUVBb3RELGdCQUFnQnBpRixTQUFTLENBQUNzaEYsVUFBVSxHQUFHO1FBQ3JDLElBQUlnQixlQUFlLElBQUksQ0FBQzNoRSxJQUFJLENBQUN5NEIsWUFBWSxDQUFDcXVCLFFBQVEsSUFBSSxJQUFJLENBQUM5bUQsSUFBSSxDQUFDeTRCLFlBQVksQ0FBQ21wQyxVQUFVO1FBQ3ZGLElBQUk3M0U7UUFDSixJQUFJODNFO1FBQ0osSUFBSTVpRjtRQUNKLElBQUlDO1FBRUosSUFBSSxJQUFJLENBQUNtaEQsYUFBYSxDQUFDdEosY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsS0FBSyxHQUFHO1lBQ2xEcEksTUFBTSxJQUFJLENBQUM4Z0IsSUFBSSxDQUFDMjNCLFdBQVcsQ0FBQ2xzQyxlQUFlLENBQUN0TSxNQUFNO1lBQ2xERixJQUFJO1FBQ04sT0FBTztZQUNMQSxJQUFJLElBQUksQ0FBQ29oRCxhQUFhLENBQUN0SixjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQyxHQUFHO1lBQy9DcEksTUFBTUQsSUFBSTtRQUNaO1FBRUE0aUYsWUFBWXo0RSxTQUFTO1FBQ3JCeTRFLFVBQVU3Z0UsWUFBWSxDQUFDLFFBQVE7UUFDL0I2Z0UsVUFBVTdnRSxZQUFZLENBQUMsa0JBQWtCO1FBQ3pDNmdFLFVBQVU3Z0UsWUFBWSxDQUFDLHFCQUFxQjtRQUU1QyxJQUFLL2hCLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUN2QjhLLE9BQU9YLFNBQVM7WUFDaEJ5NEUsVUFBVWx1RSxXQUFXLENBQUM1SjtZQUN0QixJQUFJLENBQUNzcUIsS0FBSyxDQUFDN3pCLElBQUksQ0FBQztnQkFDZG1ILEdBQUdvQztnQkFDSCt1QixHQUFHNzVCO1lBQ0w7UUFDRjtRQUVBLElBQUksSUFBSSxDQUFDb2hELGFBQWEsQ0FBQ3RKLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEtBQUssR0FBRztZQUNuRCxJQUFJcTNDLE9BQU92MUMsU0FBUztZQUNwQixJQUFJa0QsS0FBS3RGO1lBQ1QyM0MsS0FBSzM5QixZQUFZLENBQUMsTUFBTTFVO1lBQ3hCcXlDLEtBQUszOUIsWUFBWSxDQUFDLGFBQWE7WUFDL0IyOUIsS0FBS2hyQyxXQUFXLENBQUNrdUU7WUFDakIsSUFBSSxDQUFDN2hFLElBQUksQ0FBQ3RHLFVBQVUsQ0FBQ0MsSUFBSSxDQUFDaEcsV0FBVyxDQUFDZ3JDO1lBQ3RDLElBQUluM0MsSUFBSTRCLFNBQVM7WUFDakI1QixFQUFFd1osWUFBWSxDQUFDLFFBQVEsU0FBU3ZpQixvQkFBb0IsTUFBTTZOLEtBQUs7WUFFL0QsTUFBT3ExRSxZQUFZLENBQUMsRUFBRSxDQUFFO2dCQUN0Qm42RSxFQUFFbU0sV0FBVyxDQUFDZ3VFLFlBQVksQ0FBQyxFQUFFO1lBQy9CO1lBRUEsSUFBSSxDQUFDM2hFLElBQUksQ0FBQ3k0QixZQUFZLENBQUM5a0MsV0FBVyxDQUFDbk07WUFDbkMsSUFBSSxDQUFDdzZDLE1BQU0sR0FBR3JEO1lBQ2RrakMsVUFBVTdnRSxZQUFZLENBQUMsVUFBVTtRQUNuQyxPQUFPLElBQUksSUFBSSxDQUFDcS9CLGFBQWEsQ0FBQ3RKLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEtBQUssS0FBSyxJQUFJLENBQUMrNEMsYUFBYSxDQUFDdEosY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsS0FBSyxHQUFHO1lBQzdHLElBQUksSUFBSSxDQUFDKzRDLGFBQWEsQ0FBQ3RKLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEtBQUssR0FBRztnQkFDbkRxNkUsZUFBZSxJQUFJLENBQUMzaEUsSUFBSSxDQUFDeTRCLFlBQVksQ0FBQ3F1QixRQUFRLElBQUksSUFBSSxDQUFDOW1ELElBQUksQ0FBQ3k0QixZQUFZLENBQUNtcEMsVUFBVTtnQkFFbkYsTUFBT0QsYUFBYXhpRixNQUFNLENBQUU7b0JBQzFCLElBQUksQ0FBQzZnQixJQUFJLENBQUN5NEIsWUFBWSxDQUFDbEksV0FBVyxDQUFDb3hDLFlBQVksQ0FBQyxFQUFFO2dCQUNwRDtZQUNGO1lBRUEsSUFBSSxDQUFDM2hFLElBQUksQ0FBQ3k0QixZQUFZLENBQUM5a0MsV0FBVyxDQUFDa3VFO1lBQ25DLElBQUksQ0FBQzdoRSxJQUFJLENBQUN5NEIsWUFBWSxDQUFDcXBDLGVBQWUsQ0FBQztZQUN2Q0QsVUFBVTdnRSxZQUFZLENBQUMsVUFBVTtRQUNuQztRQUVBLElBQUksQ0FBQzBnRSxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDSyxVQUFVLEdBQUdGO0lBQ3BCO0lBRUFKLGdCQUFnQnBpRixTQUFTLENBQUNvZCxXQUFXLEdBQUcsU0FBVTZsQixXQUFXO1FBQzNELElBQUksQ0FBQyxJQUFJLENBQUNvL0MsV0FBVyxFQUFFO1lBQ3JCLElBQUksQ0FBQ2YsVUFBVTtRQUNqQjtRQUVBLElBQUkxaEY7UUFDSixJQUFJQyxNQUFNLElBQUksQ0FBQ20xQixLQUFLLENBQUNsMUIsTUFBTTtRQUMzQixJQUFJdy9DO1FBQ0osSUFBSTUwQztRQUVKLElBQUs5SyxJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQixJQUFJLElBQUksQ0FBQ28xQixLQUFLLENBQUNwMUIsRUFBRSxDQUFDNjVCLENBQUMsS0FBSyxDQUFDLEdBQUc7Z0JBQzFCNmxCLE9BQU8sSUFBSSxDQUFDMytCLElBQUksQ0FBQzIzQixXQUFXLENBQUNpRyxRQUFRLENBQUMsSUFBSSxDQUFDdnBCLEtBQUssQ0FBQ3AxQixFQUFFLENBQUM2NUIsQ0FBQyxDQUFDO2dCQUN0RC91QixPQUFPLElBQUksQ0FBQ3NxQixLQUFLLENBQUNwMUIsRUFBRSxDQUFDMEksQ0FBQztnQkFFdEIsSUFBSTI2QixlQUFlLElBQUksQ0FBQytkLGFBQWEsQ0FBQ253QixJQUFJLElBQUl5dUIsS0FBSy8rQyxJQUFJLENBQUNzd0IsSUFBSSxFQUFFO29CQUM1RG5tQixLQUFLaVgsWUFBWSxDQUFDLEtBQUsyOUIsS0FBS04sUUFBUTtnQkFDdEM7Z0JBRUEsSUFBSS9iLGVBQWUsSUFBSSxDQUFDK2QsYUFBYSxDQUFDdEosY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUN1b0IsSUFBSSxJQUFJLElBQUksQ0FBQ213QixhQUFhLENBQUN0SixjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ3VvQixJQUFJLElBQUksSUFBSSxDQUFDbXdCLGFBQWEsQ0FBQ3RKLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDdW9CLElBQUksSUFBSSxJQUFJLENBQUNtd0IsYUFBYSxDQUFDdEosY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUN1b0IsSUFBSSxJQUFJeXVCLEtBQUsvK0MsSUFBSSxDQUFDc3dCLElBQUksRUFBRTtvQkFDN04sSUFBSTh4RDtvQkFFSixJQUFJLElBQUksQ0FBQzNoQyxhQUFhLENBQUN0SixjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQyxLQUFLLEtBQUssSUFBSSxDQUFDKzRDLGFBQWEsQ0FBQ3RKLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEtBQUssS0FBSzt3QkFDdEcsSUFBSUQsSUFBSTlELEtBQUtTLEdBQUcsQ0FBQyxJQUFJLENBQUNxOEMsYUFBYSxDQUFDdEosY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsRUFBRSxJQUFJLENBQUMrNEMsYUFBYSxDQUFDdEosY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsSUFBSTt3QkFDdkcsSUFBSXNELElBQUlySCxLQUFLTyxHQUFHLENBQUMsSUFBSSxDQUFDdThDLGFBQWEsQ0FBQ3RKLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEVBQUUsSUFBSSxDQUFDKzRDLGFBQWEsQ0FBQ3RKLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLElBQUk7d0JBQ3ZHLElBQUl1eEIsSUFBSTl1QixLQUFLazRFLGNBQWM7d0JBQzNCRCxpQkFBaUIsV0FBV25wRCxJQUFJeHhCLElBQUk7d0JBQ3BDLElBQUk2NkUsYUFBYXJwRCxJQUFLanVCLENBQUFBLElBQUl2RCxDQUFBQTt3QkFDMUIsSUFBSThULFVBQVUsSUFBSSxJQUFJLENBQUNrbEMsYUFBYSxDQUFDdEosY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQys0QyxhQUFhLENBQUN0SixjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQyxHQUFHO3dCQUM1RyxJQUFJNjZFLFFBQVE1K0UsS0FBS0ssS0FBSyxDQUFDcytFLGFBQWEvbUU7d0JBQ3BDLElBQUlqUTt3QkFFSixJQUFLQSxJQUFJLEdBQUdBLElBQUlpM0UsT0FBT2ozRSxLQUFLLEVBQUc7NEJBQzdCODJFLGtCQUFrQixPQUFPLElBQUksQ0FBQzNoQyxhQUFhLENBQUN0SixjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQyxHQUFHLElBQUksSUFBSSxDQUFDKzRDLGFBQWEsQ0FBQ3RKLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEdBQUcsT0FBTzt3QkFDNUg7d0JBRUEwNkUsa0JBQWtCLE9BQU9ucEQsSUFBSSxLQUFLO29CQUNwQyxPQUFPO3dCQUNMbXBELGlCQUFpQixPQUFPLElBQUksQ0FBQzNoQyxhQUFhLENBQUN0SixjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQyxHQUFHLElBQUksSUFBSSxDQUFDKzRDLGFBQWEsQ0FBQ3RKLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEdBQUc7b0JBQ3BIO29CQUVBeUMsS0FBS2lYLFlBQVksQ0FBQyxvQkFBb0JnaEU7Z0JBQ3hDO1lBQ0Y7UUFDRjtRQUVBLElBQUkxL0MsZUFBZSxJQUFJLENBQUMrZCxhQUFhLENBQUN0SixjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ3VvQixJQUFJLEVBQUU7WUFDOUQsSUFBSSxDQUFDNnhELFVBQVUsQ0FBQy9nRSxZQUFZLENBQUMsZ0JBQWdCLElBQUksQ0FBQ3EvQixhQUFhLENBQUN0SixjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQyxHQUFHO1FBQzFGO1FBRUEsSUFBSWc3QixlQUFlLElBQUksQ0FBQytkLGFBQWEsQ0FBQ3RKLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDdW9CLElBQUksRUFBRTtZQUM5RCxJQUFJLENBQUM2eEQsVUFBVSxDQUFDL2dFLFlBQVksQ0FBQyxXQUFXLElBQUksQ0FBQ3EvQixhQUFhLENBQUN0SixjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQztRQUNsRjtRQUVBLElBQUksSUFBSSxDQUFDKzRDLGFBQWEsQ0FBQ3RKLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEtBQUssS0FBSyxJQUFJLENBQUMrNEMsYUFBYSxDQUFDdEosY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsS0FBSyxHQUFHO1lBQ3RHLElBQUlnN0IsZUFBZSxJQUFJLENBQUMrZCxhQUFhLENBQUN0SixjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ3VvQixJQUFJLEVBQUU7Z0JBQzlELElBQUlqb0IsUUFBUSxJQUFJLENBQUNvNEMsYUFBYSxDQUFDdEosY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUM7Z0JBQ3BELElBQUksQ0FBQ3k2RSxVQUFVLENBQUMvZ0UsWUFBWSxDQUFDLFVBQVUsU0FBU3JkLFFBQVFzRSxLQUFLLENBQUMsRUFBRSxHQUFHLE9BQU8sTUFBTXRFLFFBQVFzRSxLQUFLLENBQUMsRUFBRSxHQUFHLE9BQU8sTUFBTXRFLFFBQVFzRSxLQUFLLENBQUMsRUFBRSxHQUFHLE9BQU87WUFDNUk7UUFDRjtJQUNGO0lBRUEsU0FBU202RSxpQkFBaUJ4NkMsTUFBTSxFQUFFeVksYUFBYSxFQUFFcmdDLElBQUksRUFBRTFULEVBQUU7UUFDdkQsSUFBSSxDQUFDK3pDLGFBQWEsR0FBR0E7UUFDckIsSUFBSVQsZ0JBQWdCeDJDLFNBQVM7UUFDN0J3MkMsY0FBYzUrQixZQUFZLENBQUMsUUFBUTtRQUNuQzQrQixjQUFjNStCLFlBQVksQ0FBQywrQkFBK0I7UUFDMUQ0K0IsY0FBYzUrQixZQUFZLENBQUMsVUFBVTtRQUNyQzRtQixPQUFPajBCLFdBQVcsQ0FBQ2lzQztRQUNuQixJQUFJeWlDLHNCQUFzQmo1RSxTQUFTO1FBQ25DaTVFLG9CQUFvQnJoRSxZQUFZLENBQUMsK0JBQStCO1FBQ2hFcWhFLG9CQUFvQnJoRSxZQUFZLENBQUMsVUFBVTFVO1FBQzNDLElBQUksQ0FBQyswRSxZQUFZLEdBQUdnQjtRQUNwQixJQUFJQyxVQUFVbDVFLFNBQVM7UUFDdkJrNUUsUUFBUXRoRSxZQUFZLENBQUMsUUFBUTtRQUM3QnFoRSxvQkFBb0IxdUUsV0FBVyxDQUFDMnVFO1FBQ2hDLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtRQUNmLElBQUlDLFVBQVVuNUUsU0FBUztRQUN2Qm01RSxRQUFRdmhFLFlBQVksQ0FBQyxRQUFRO1FBQzdCcWhFLG9CQUFvQjF1RSxXQUFXLENBQUM0dUU7UUFDaEMsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1FBQ2YsSUFBSUMsVUFBVXA1RSxTQUFTO1FBQ3ZCbzVFLFFBQVF4aEUsWUFBWSxDQUFDLFFBQVE7UUFDN0JxaEUsb0JBQW9CMXVFLFdBQVcsQ0FBQzZ1RTtRQUNoQyxJQUFJLENBQUNBLE9BQU8sR0FBR0E7UUFDZjU2QyxPQUFPajBCLFdBQVcsQ0FBQzB1RTtJQUNyQjtJQUVBRCxpQkFBaUIvaUYsU0FBUyxDQUFDb2QsV0FBVyxHQUFHLFNBQVU2bEIsV0FBVztRQUM1RCxJQUFJQSxlQUFlLElBQUksQ0FBQytkLGFBQWEsQ0FBQ253QixJQUFJLEVBQUU7WUFDMUMsSUFBSXV5RCxTQUFTLElBQUksQ0FBQ3BpQyxhQUFhLENBQUN0SixjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQztZQUNyRCxJQUFJbzdFLFNBQVMsSUFBSSxDQUFDcmlDLGFBQWEsQ0FBQ3RKLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDO1lBQ3JELElBQUlxN0UsU0FBUyxJQUFJLENBQUN0aUMsYUFBYSxDQUFDdEosY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUM7WUFDckQsSUFBSXM3RSxTQUFTRCxNQUFNLENBQUMsRUFBRSxHQUFHLE1BQU1ELE1BQU0sQ0FBQyxFQUFFLEdBQUcsTUFBTUQsTUFBTSxDQUFDLEVBQUU7WUFDMUQsSUFBSUksU0FBU0YsTUFBTSxDQUFDLEVBQUUsR0FBRyxNQUFNRCxNQUFNLENBQUMsRUFBRSxHQUFHLE1BQU1ELE1BQU0sQ0FBQyxFQUFFO1lBQzFELElBQUlLLFNBQVNILE1BQU0sQ0FBQyxFQUFFLEdBQUcsTUFBTUQsTUFBTSxDQUFDLEVBQUUsR0FBRyxNQUFNRCxNQUFNLENBQUMsRUFBRTtZQUMxRCxJQUFJLENBQUNILE9BQU8sQ0FBQ3RoRSxZQUFZLENBQUMsZUFBZTRoRTtZQUN6QyxJQUFJLENBQUNMLE9BQU8sQ0FBQ3ZoRSxZQUFZLENBQUMsZUFBZTZoRTtZQUN6QyxJQUFJLENBQUNMLE9BQU8sQ0FBQ3hoRSxZQUFZLENBQUMsZUFBZThoRTtRQUMzQztJQUNGO0lBRUEsU0FBU0MsbUJBQW1CbjdDLE1BQU0sRUFBRXlZLGFBQWEsRUFBRXJnQyxJQUFJLEVBQUUxVCxFQUFFO1FBQ3pELElBQUksQ0FBQyt6QyxhQUFhLEdBQUdBO1FBQ3JCLElBQUl0SixpQkFBaUIsSUFBSSxDQUFDc0osYUFBYSxDQUFDdEosY0FBYztRQUN0RCxJQUFJc3JDLHNCQUFzQmo1RSxTQUFTLHdCQUF3QixNQUFNO1FBRWpFLElBQUkydEMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUN5RCxDQUFDLElBQUkyckMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsS0FBSyxLQUFLeXZDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDeUQsQ0FBQyxJQUFJMnJDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEtBQUssS0FBS3l2QyxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ3lELENBQUMsSUFBSTJyQyxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQyxLQUFLLEtBQUt5dkMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUN5RCxDQUFDLElBQUkyckMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsS0FBSyxLQUFLeXZDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDeUQsQ0FBQyxJQUFJMnJDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEtBQUssR0FBRztZQUNsUyxJQUFJLENBQUNnN0UsT0FBTyxHQUFHLElBQUksQ0FBQ1UsWUFBWSxDQUFDLFdBQVdYO1FBQzlDLEVBQUUsUUFBUTtRQUdWLElBQUl0ckMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUN5RCxDQUFDLElBQUkyckMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsS0FBSyxLQUFLeXZDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDeUQsQ0FBQyxJQUFJMnJDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEtBQUssS0FBS3l2QyxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ3lELENBQUMsSUFBSTJyQyxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQyxLQUFLLEtBQUt5dkMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUN5RCxDQUFDLElBQUkyckMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsS0FBSyxLQUFLeXZDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDeUQsQ0FBQyxJQUFJMnJDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEtBQUssR0FBRztZQUNsUyxJQUFJLENBQUNpN0UsT0FBTyxHQUFHLElBQUksQ0FBQ1MsWUFBWSxDQUFDLFdBQVdYO1FBQzlDLEVBQUUsT0FBTztRQUdULElBQUl0ckMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUN5RCxDQUFDLElBQUkyckMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsS0FBSyxLQUFLeXZDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDeUQsQ0FBQyxJQUFJMnJDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEtBQUssS0FBS3l2QyxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ3lELENBQUMsSUFBSTJyQyxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQyxLQUFLLEtBQUt5dkMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUN5RCxDQUFDLElBQUkyckMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsS0FBSyxLQUFLeXZDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDeUQsQ0FBQyxJQUFJMnJDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEtBQUssR0FBRztZQUNsUyxJQUFJLENBQUNrN0UsT0FBTyxHQUFHLElBQUksQ0FBQ1EsWUFBWSxDQUFDLFdBQVdYO1FBQzlDLEVBQUUsUUFBUTtRQUdWLElBQUl0ckMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUN5RCxDQUFDLElBQUkyckMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsS0FBSyxLQUFLeXZDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDeUQsQ0FBQyxJQUFJMnJDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEtBQUssS0FBS3l2QyxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ3lELENBQUMsSUFBSTJyQyxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQyxLQUFLLEtBQUt5dkMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUN5RCxDQUFDLElBQUkyckMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsS0FBSyxLQUFLeXZDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDeUQsQ0FBQyxJQUFJMnJDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEtBQUssR0FBRztZQUNsUyxJQUFJLENBQUMyN0UsT0FBTyxHQUFHLElBQUksQ0FBQ0QsWUFBWSxDQUFDLFdBQVdYO1FBQzlDLEVBQUUsTUFBTTtRQUdSLElBQUksSUFBSSxDQUFDQyxPQUFPLElBQUksSUFBSSxDQUFDQyxPQUFPLElBQUksSUFBSSxDQUFDQyxPQUFPLElBQUksSUFBSSxDQUFDUyxPQUFPLEVBQUU7WUFDaEVaLG9CQUFvQnJoRSxZQUFZLENBQUMsK0JBQStCO1lBQ2hFNG1CLE9BQU9qMEIsV0FBVyxDQUFDMHVFO1FBQ3JCO1FBRUEsSUFBSXRyQyxjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ3lELENBQUMsSUFBSTJyQyxjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQyxLQUFLLEtBQUt5dkMsY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUN5RCxDQUFDLElBQUkyckMsY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsS0FBSyxLQUFLeXZDLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDeUQsQ0FBQyxJQUFJMnJDLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEtBQUssS0FBS3l2QyxjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ3lELENBQUMsSUFBSTJyQyxjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQyxLQUFLLEtBQUt5dkMsY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUN5RCxDQUFDLElBQUkyckMsY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsS0FBSyxHQUFHO1lBQ3hSKzZFLHNCQUFzQmo1RSxTQUFTO1lBQy9CaTVFLG9CQUFvQnJoRSxZQUFZLENBQUMsK0JBQStCO1lBQ2hFcWhFLG9CQUFvQnJoRSxZQUFZLENBQUMsVUFBVTFVO1lBQzNDczdCLE9BQU9qMEIsV0FBVyxDQUFDMHVFO1lBQ25CLElBQUksQ0FBQ2EsZUFBZSxHQUFHLElBQUksQ0FBQ0YsWUFBWSxDQUFDLFdBQVdYO1lBQ3BELElBQUksQ0FBQ2MsZUFBZSxHQUFHLElBQUksQ0FBQ0gsWUFBWSxDQUFDLFdBQVdYO1lBQ3BELElBQUksQ0FBQ2UsZUFBZSxHQUFHLElBQUksQ0FBQ0osWUFBWSxDQUFDLFdBQVdYO1FBQ3REO0lBQ0Y7SUFFQVUsbUJBQW1CMWpGLFNBQVMsQ0FBQzJqRixZQUFZLEdBQUcsU0FBVXJrRixJQUFJLEVBQUUwakYsbUJBQW1CO1FBQzdFLElBQUlqZ0MsU0FBU2g1QyxTQUFTeks7UUFDdEJ5akQsT0FBT3BoQyxZQUFZLENBQUMsUUFBUTtRQUM1QnFoRSxvQkFBb0IxdUUsV0FBVyxDQUFDeXVDO1FBQ2hDLE9BQU9BO0lBQ1Q7SUFFQTJnQyxtQkFBbUIxakYsU0FBUyxDQUFDZ2tGLGFBQWEsR0FBRyxTQUFVQyxVQUFVLEVBQUVDLFVBQVUsRUFBRUMsS0FBSyxFQUFFQyxXQUFXLEVBQUVDLFdBQVc7UUFDNUcsSUFBSTF3RCxNQUFNO1FBQ1YsSUFBSXZhLFdBQVc7UUFDZixJQUFJNE87UUFDSixJQUFJcmpCLE1BQU1ULEtBQUtTLEdBQUcsQ0FBQ3MvRSxZQUFZQztRQUMvQixJQUFJei9FLE1BQU1QLEtBQUtPLEdBQUcsQ0FBQ3cvRSxZQUFZQztRQUMvQixJQUFJSSxRQUFRcmhGLE1BQU03QyxJQUFJLENBQUMsTUFBTTtZQUMzQk4sUUFBUXNaO1FBQ1Y7UUFDQSxJQUFJbXJFO1FBQ0osSUFBSXp4RCxNQUFNO1FBQ1YsSUFBSTB4RCxjQUFjSCxjQUFjRDtRQUNoQyxJQUFJSyxhQUFhUCxhQUFhRDtRQUU5QixNQUFPdHdELE9BQU8sSUFBSztZQUNqQjNMLE9BQU8yTCxNQUFNO1lBRWIsSUFBSTNMLFFBQVFyakIsS0FBSztnQkFDZjQvRSxhQUFhRSxhQUFhLElBQUlKLGNBQWNEO1lBQzlDLE9BQU8sSUFBSXA4RCxRQUFRdmpCLEtBQUs7Z0JBQ3RCOC9FLGFBQWFFLGFBQWEsSUFBSUwsY0FBY0M7WUFDOUMsT0FBTztnQkFDTEUsYUFBYUgsY0FBY0ksY0FBY3RnRixLQUFLQyxHQUFHLENBQUMsQ0FBQzZqQixPQUFPaThELFVBQVMsSUFBS1EsWUFBWSxJQUFJTjtZQUMxRjtZQUVBRyxLQUFLLENBQUN4eEQsSUFBSSxHQUFHeXhEO1lBQ2J6eEQsT0FBTztZQUNQYSxPQUFPLE1BQU92YSxDQUFBQSxXQUFXO1FBQzNCO1FBRUEsT0FBT2tyRSxNQUFNeHpFLElBQUksQ0FBQztJQUNwQjtJQUVBNHlFLG1CQUFtQjFqRixTQUFTLENBQUNvZCxXQUFXLEdBQUcsU0FBVTZsQixXQUFXO1FBQzlELElBQUlBLGVBQWUsSUFBSSxDQUFDK2QsYUFBYSxDQUFDbndCLElBQUksRUFBRTtZQUMxQyxJQUFJNXJCO1lBQ0osSUFBSXl5QyxpQkFBaUIsSUFBSSxDQUFDc0osYUFBYSxDQUFDdEosY0FBYztZQUV0RCxJQUFJLElBQUksQ0FBQ21zQyxlQUFlLElBQUs1Z0QsQ0FBQUEsZUFBZXlVLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDdW9CLElBQUksSUFBSTZtQixjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ3VvQixJQUFJLElBQUk2bUIsY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUN1b0IsSUFBSSxJQUFJNm1CLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDdW9CLElBQUksSUFBSTZtQixjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ3VvQixJQUFJLEdBQUc7Z0JBQ3JMNXJCLE1BQU0sSUFBSSxDQUFDKytFLGFBQWEsQ0FBQ3RzQyxjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQyxFQUFFeXZDLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEVBQUV5dkMsY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsRUFBRXl2QyxjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQyxFQUFFeXZDLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDO2dCQUMxSSxJQUFJLENBQUM0N0UsZUFBZSxDQUFDbGlFLFlBQVksQ0FBQyxlQUFlMWM7Z0JBQ2pELElBQUksQ0FBQzYrRSxlQUFlLENBQUNuaUUsWUFBWSxDQUFDLGVBQWUxYztnQkFDakQsSUFBSSxDQUFDOCtFLGVBQWUsQ0FBQ3BpRSxZQUFZLENBQUMsZUFBZTFjO1lBQ25EO1lBRUEsSUFBSSxJQUFJLENBQUNnK0UsT0FBTyxJQUFLaGdELENBQUFBLGVBQWV5VSxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ3VvQixJQUFJLElBQUk2bUIsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUN1b0IsSUFBSSxJQUFJNm1CLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDdW9CLElBQUksSUFBSTZtQixjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ3VvQixJQUFJLElBQUk2bUIsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUN1b0IsSUFBSSxHQUFHO2dCQUNsTDVyQixNQUFNLElBQUksQ0FBQysrRSxhQUFhLENBQUN0c0MsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsRUFBRXl2QyxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQyxFQUFFeXZDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEVBQUV5dkMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsRUFBRXl2QyxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQztnQkFDL0ksSUFBSSxDQUFDZzdFLE9BQU8sQ0FBQ3RoRSxZQUFZLENBQUMsZUFBZTFjO1lBQzNDO1lBRUEsSUFBSSxJQUFJLENBQUNpK0UsT0FBTyxJQUFLamdELENBQUFBLGVBQWV5VSxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ3VvQixJQUFJLElBQUk2bUIsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUN1b0IsSUFBSSxJQUFJNm1CLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDdW9CLElBQUksSUFBSTZtQixjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ3VvQixJQUFJLElBQUk2bUIsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUN1b0IsSUFBSSxHQUFHO2dCQUNsTDVyQixNQUFNLElBQUksQ0FBQysrRSxhQUFhLENBQUN0c0MsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsRUFBRXl2QyxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQyxFQUFFeXZDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEVBQUV5dkMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsRUFBRXl2QyxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQztnQkFDL0ksSUFBSSxDQUFDaTdFLE9BQU8sQ0FBQ3ZoRSxZQUFZLENBQUMsZUFBZTFjO1lBQzNDO1lBRUEsSUFBSSxJQUFJLENBQUNrK0UsT0FBTyxJQUFLbGdELENBQUFBLGVBQWV5VSxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ3VvQixJQUFJLElBQUk2bUIsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUN1b0IsSUFBSSxJQUFJNm1CLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDdW9CLElBQUksSUFBSTZtQixjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ3VvQixJQUFJLElBQUk2bUIsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUN1b0IsSUFBSSxHQUFHO2dCQUNsTDVyQixNQUFNLElBQUksQ0FBQysrRSxhQUFhLENBQUN0c0MsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsRUFBRXl2QyxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQyxFQUFFeXZDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEVBQUV5dkMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsRUFBRXl2QyxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQztnQkFDL0ksSUFBSSxDQUFDazdFLE9BQU8sQ0FBQ3hoRSxZQUFZLENBQUMsZUFBZTFjO1lBQzNDO1lBRUEsSUFBSSxJQUFJLENBQUMyK0UsT0FBTyxJQUFLM2dELENBQUFBLGVBQWV5VSxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ3VvQixJQUFJLElBQUk2bUIsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUN1b0IsSUFBSSxJQUFJNm1CLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDdW9CLElBQUksSUFBSTZtQixjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ3VvQixJQUFJLElBQUk2bUIsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUN1b0IsSUFBSSxHQUFHO2dCQUNsTDVyQixNQUFNLElBQUksQ0FBQysrRSxhQUFhLENBQUN0c0MsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsRUFBRXl2QyxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQyxFQUFFeXZDLGNBQWMsQ0FBQyxHQUFHLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEVBQUV5dkMsY0FBYyxDQUFDLEdBQUcsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsRUFBRXl2QyxjQUFjLENBQUMsR0FBRyxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQztnQkFDL0ksSUFBSSxDQUFDMjdFLE9BQU8sQ0FBQ2ppRSxZQUFZLENBQUMsZUFBZTFjO1lBQzNDO1FBQ0Y7SUFDRjtJQUVBLFNBQVN5L0Usb0JBQW9CbjhDLE1BQU0sRUFBRXlZLGFBQWEsRUFBRXJnQyxJQUFJLEVBQUUxVCxFQUFFLEVBQUU2ekMsTUFBTTtRQUNsRSxJQUFJNmpDLG1CQUFtQjNqQyxjQUFjL21DLFNBQVMsQ0FBQ0ksVUFBVSxDQUFDaThCLFlBQVksQ0FBQytpQixVQUFVO1FBQ2pGLElBQUlBLGFBQWFyWSxjQUFjcjJDLElBQUksQ0FBQytrRCxFQUFFLElBQUlpMUI7UUFDMUNwOEMsT0FBTzVtQixZQUFZLENBQUMsS0FBSzAzQyxXQUFXNzBDLENBQUMsSUFBSW1nRSxpQkFBaUJuZ0UsQ0FBQztRQUMzRCtqQixPQUFPNW1CLFlBQVksQ0FBQyxLQUFLMDNDLFdBQVd2c0MsQ0FBQyxJQUFJNjNELGlCQUFpQjczRCxDQUFDO1FBQzNEeWIsT0FBTzVtQixZQUFZLENBQUMsU0FBUzAzQyxXQUFXam5ELEtBQUssSUFBSXV5RSxpQkFBaUJ2eUUsS0FBSztRQUN2RW0yQixPQUFPNW1CLFlBQVksQ0FBQyxVQUFVMDNDLFdBQVdobkQsTUFBTSxJQUFJc3lFLGlCQUFpQnR5RSxNQUFNO1FBQzFFLElBQUksQ0FBQzJ1QyxhQUFhLEdBQUdBO1FBQ3JCLElBQUk0akMsaUJBQWlCNzZFLFNBQVM7UUFDOUI2NkUsZUFBZWpqRSxZQUFZLENBQUMsTUFBTTtRQUNsQ2lqRSxlQUFlampFLFlBQVksQ0FBQyxVQUFVMVUsS0FBSztRQUMzQzIzRSxlQUFlampFLFlBQVksQ0FBQyxnQkFBZ0I7UUFDNUMsSUFBSSxDQUFDaWpFLGNBQWMsR0FBR0E7UUFDdEJyOEMsT0FBT2owQixXQUFXLENBQUNzd0U7UUFDbkIsSUFBSUMsV0FBVzk2RSxTQUFTO1FBQ3hCODZFLFNBQVNsakUsWUFBWSxDQUFDLE1BQU07UUFDNUJrakUsU0FBU2xqRSxZQUFZLENBQUMsTUFBTTtRQUM1QmtqRSxTQUFTbGpFLFlBQVksQ0FBQyxNQUFNMVUsS0FBSztRQUNqQzQzRSxTQUFTbGpFLFlBQVksQ0FBQyxVQUFVMVUsS0FBSztRQUNyQyxJQUFJLENBQUM0M0UsUUFBUSxHQUFHQTtRQUNoQnQ4QyxPQUFPajBCLFdBQVcsQ0FBQ3V3RTtRQUNuQixJQUFJQyxVQUFVLzZFLFNBQVM7UUFDdkIrNkUsUUFBUW5qRSxZQUFZLENBQUMsZUFBZTtRQUNwQ21qRSxRQUFRbmpFLFlBQVksQ0FBQyxpQkFBaUI7UUFDdENtakUsUUFBUW5qRSxZQUFZLENBQUMsVUFBVTFVLEtBQUs7UUFDcEMsSUFBSSxDQUFDNjNFLE9BQU8sR0FBR0E7UUFDZnY4QyxPQUFPajBCLFdBQVcsQ0FBQ3d3RTtRQUNuQixJQUFJQyxjQUFjaDdFLFNBQVM7UUFDM0JnN0UsWUFBWXBqRSxZQUFZLENBQUMsTUFBTTFVLEtBQUs7UUFDcEM4M0UsWUFBWXBqRSxZQUFZLENBQUMsT0FBTzFVLEtBQUs7UUFDckM4M0UsWUFBWXBqRSxZQUFZLENBQUMsWUFBWTtRQUNyQ29qRSxZQUFZcGpFLFlBQVksQ0FBQyxVQUFVMVUsS0FBSztRQUN4Q3M3QixPQUFPajBCLFdBQVcsQ0FBQ3l3RTtRQUNuQixJQUFJcEQsVUFBVSxJQUFJLENBQUNILGVBQWUsQ0FBQ3YwRSxJQUFJO1lBQUNBLEtBQUs7WUFBa0I2ekM7U0FBTztRQUN0RXZZLE9BQU9qMEIsV0FBVyxDQUFDcXRFLFVBQVUsRUFBRTtJQUNqQztJQUVBbGlGLGdCQUFnQjtRQUFDOGhGO0tBQW9CLEVBQUVtRDtJQUV2Q0Esb0JBQW9CMWtGLFNBQVMsQ0FBQ29kLFdBQVcsR0FBRyxTQUFVNmxCLFdBQVc7UUFDL0QsSUFBSUEsZUFBZSxJQUFJLENBQUMrZCxhQUFhLENBQUNud0IsSUFBSSxFQUFFO1lBQzFDLElBQUlvUyxlQUFlLElBQUksQ0FBQytkLGFBQWEsQ0FBQ3RKLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDdW9CLElBQUksRUFBRTtnQkFDOUQsSUFBSSxDQUFDK3pELGNBQWMsQ0FBQ2pqRSxZQUFZLENBQUMsZ0JBQWdCLElBQUksQ0FBQ3EvQixhQUFhLENBQUN0SixjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQyxHQUFHO1lBQzlGO1lBRUEsSUFBSWc3QixlQUFlLElBQUksQ0FBQytkLGFBQWEsQ0FBQ3RKLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDdW9CLElBQUksRUFBRTtnQkFDOUQsSUFBSW0wRCxNQUFNLElBQUksQ0FBQ2hrQyxhQUFhLENBQUN0SixjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQztnQkFDbEQsSUFBSSxDQUFDNjhFLE9BQU8sQ0FBQ25qRSxZQUFZLENBQUMsZUFBZTFZLFNBQVMvRSxLQUFLd0IsS0FBSyxDQUFDcy9FLEdBQUcsQ0FBQyxFQUFFLEdBQUcsTUFBTTlnRixLQUFLd0IsS0FBSyxDQUFDcy9FLEdBQUcsQ0FBQyxFQUFFLEdBQUcsTUFBTTlnRixLQUFLd0IsS0FBSyxDQUFDcy9FLEdBQUcsQ0FBQyxFQUFFLEdBQUc7WUFDNUg7WUFFQSxJQUFJL2hELGVBQWUsSUFBSSxDQUFDK2QsYUFBYSxDQUFDdEosY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUN1b0IsSUFBSSxFQUFFO2dCQUM5RCxJQUFJLENBQUNpMEQsT0FBTyxDQUFDbmpFLFlBQVksQ0FBQyxpQkFBaUIsSUFBSSxDQUFDcS9CLGFBQWEsQ0FBQ3RKLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEdBQUc7WUFDeEY7WUFFQSxJQUFJZzdCLGVBQWUsSUFBSSxDQUFDK2QsYUFBYSxDQUFDdEosY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUN1b0IsSUFBSSxJQUFJLElBQUksQ0FBQ213QixhQUFhLENBQUN0SixjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ3VvQixJQUFJLEVBQUU7Z0JBQzdHLElBQUlpVyxXQUFXLElBQUksQ0FBQ2thLGFBQWEsQ0FBQ3RKLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDO2dCQUN2RCxJQUFJMnVCLFFBQVEsQ0FBQyxJQUFJLENBQUNvcUIsYUFBYSxDQUFDdEosY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsR0FBRyxFQUFDLElBQUs1QztnQkFDOUQsSUFBSW1mLElBQUlzaUIsV0FBVzVpQyxLQUFLMnJCLEdBQUcsQ0FBQytHO2dCQUM1QixJQUFJOUosSUFBSWdhLFdBQVc1aUMsS0FBSzhxQixHQUFHLENBQUM0SDtnQkFDNUIsSUFBSSxDQUFDaXVELFFBQVEsQ0FBQ2xqRSxZQUFZLENBQUMsTUFBTTZDO2dCQUNqQyxJQUFJLENBQUNxZ0UsUUFBUSxDQUFDbGpFLFlBQVksQ0FBQyxNQUFNbUw7WUFDbkM7UUFDRjtJQUNGO0lBRUEsSUFBSW00RCxtQkFBbUIsRUFBRTtJQUV6QixTQUFTQyxnQkFBZ0JDLFVBQVUsRUFBRW5rQyxhQUFhLEVBQUVyZ0MsSUFBSTtRQUN0RCxJQUFJLENBQUMwaEUsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ3JoQyxhQUFhLEdBQUdBO1FBQ3JCLElBQUksQ0FBQ21rQyxVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ3hrRSxJQUFJLEdBQUdBO1FBQ1pBLEtBQUs2Z0MsWUFBWSxHQUFHejNDLFNBQVM7UUFDN0I0VyxLQUFLNmdDLFlBQVksQ0FBQ2x0QyxXQUFXLENBQUNxTSxLQUFLeTRCLFlBQVk7UUFDL0N6NEIsS0FBSzZnQyxZQUFZLENBQUNsdEMsV0FBVyxDQUFDcU0sS0FBSzhnQyxrQkFBa0I7UUFDckQ5Z0MsS0FBS3c0QixXQUFXLEdBQUd4NEIsS0FBSzZnQyxZQUFZO0lBQ3RDO0lBRUEwakMsZ0JBQWdCbGxGLFNBQVMsQ0FBQ29sRixVQUFVLEdBQUcsU0FBVTlsQyxJQUFJO1FBQ25ELElBQUkxL0MsSUFBSTtRQUNSLElBQUlDLE1BQU1vbEYsaUJBQWlCbmxGLE1BQU07UUFFakMsTUFBT0YsSUFBSUMsSUFBSztZQUNkLElBQUlvbEYsZ0JBQWdCLENBQUNybEYsRUFBRSxLQUFLMC9DLE1BQU07Z0JBQ2hDLE9BQU8ybEMsZ0JBQWdCLENBQUNybEYsRUFBRTtZQUM1QjtZQUVBQSxLQUFLO1FBQ1A7UUFFQSxPQUFPO0lBQ1Q7SUFFQXNsRixnQkFBZ0JsbEYsU0FBUyxDQUFDcWxGLGVBQWUsR0FBRyxTQUFVL2xDLElBQUksRUFBRWdtQyxRQUFRO1FBQ2xFLElBQUlwMUMsYUFBYW9QLEtBQUtsRyxZQUFZLENBQUNsSixVQUFVO1FBRTdDLElBQUksQ0FBQ0EsWUFBWTtZQUNmO1FBQ0Y7UUFFQSxJQUFJdTNCLFdBQVd2M0IsV0FBV3UzQixRQUFRO1FBQ2xDLElBQUk3bkUsSUFBSTtRQUNSLElBQUlDLE1BQU00bkUsU0FBUzNuRSxNQUFNO1FBRXpCLE1BQU9GLElBQUlDLElBQUs7WUFDZCxJQUFJNG5FLFFBQVEsQ0FBQzduRSxFQUFFLEtBQUswL0MsS0FBS2xHLFlBQVksRUFBRTtnQkFDckM7WUFDRjtZQUVBeDVDLEtBQUs7UUFDUDtRQUVBLElBQUkybEY7UUFFSixJQUFJM2xGLEtBQUtDLE1BQU0sR0FBRztZQUNoQjBsRixZQUFZOWQsUUFBUSxDQUFDN25FLElBQUksRUFBRTtRQUM3QjtRQUVBLElBQUk0bEYsVUFBVXo3RSxTQUFTO1FBQ3ZCeTdFLFFBQVE3akUsWUFBWSxDQUFDLFFBQVEsTUFBTTJqRTtRQUVuQyxJQUFJQyxXQUFXO1lBQ2JyMUMsV0FBV29vQixZQUFZLENBQUNrdEIsU0FBU0Q7UUFDbkMsT0FBTztZQUNMcjFDLFdBQVc1N0IsV0FBVyxDQUFDa3hFO1FBQ3pCO0lBQ0Y7SUFFQU4sZ0JBQWdCbGxGLFNBQVMsQ0FBQ3lsRixnQkFBZ0IsR0FBRyxTQUFVOWtFLElBQUksRUFBRTIrQixJQUFJO1FBQy9ELElBQUksQ0FBQyxJQUFJLENBQUM4bEMsVUFBVSxDQUFDOWxDLE9BQU87WUFDMUIsSUFBSWdtQyxXQUFXMzlFO1lBQ2YsSUFBSWc3QyxTQUFTNTRDLFNBQVM7WUFDdEI0NEMsT0FBT2hoQyxZQUFZLENBQUMsTUFBTTI5QixLQUFLaEcsT0FBTztZQUN0Q3FKLE9BQU9oaEMsWUFBWSxDQUFDLGFBQWE7WUFFakNzakUsaUJBQWlCOWpGLElBQUksQ0FBQ20rQztZQUV0QixJQUFJaGxDLE9BQU9xRyxLQUFLdEcsVUFBVSxDQUFDQyxJQUFJO1lBQy9CQSxLQUFLaEcsV0FBVyxDQUFDcXVDO1lBQ2pCLElBQUkraUMsU0FBUzM3RSxTQUFTO1lBQ3RCMjdFLE9BQU8vakUsWUFBWSxDQUFDLE1BQU0yakU7WUFDMUIsSUFBSSxDQUFDRCxlQUFlLENBQUMvbEMsTUFBTWdtQztZQUMzQkksT0FBT3B4RSxXQUFXLENBQUNnckMsS0FBS2xHLFlBQVk7WUFDcEM5K0IsS0FBS2hHLFdBQVcsQ0FBQ294RTtZQUNqQixJQUFJRixVQUFVejdFLFNBQVM7WUFDdkJ5N0UsUUFBUTdqRSxZQUFZLENBQUMsUUFBUSxNQUFNMmpFO1lBQ25DM2lDLE9BQU9ydUMsV0FBVyxDQUFDa3hFO1lBQ25CbG1DLEtBQUszMEMsSUFBSSxDQUFDczNDLEVBQUUsR0FBRztZQUNmM0MsS0FBSzMvQixJQUFJO1FBQ1g7UUFFQWdCLEtBQUtzaUMsUUFBUSxDQUFDM0QsS0FBS2hHLE9BQU87SUFDNUI7SUFFQTRyQyxnQkFBZ0JsbEYsU0FBUyxDQUFDc2hGLFVBQVUsR0FBRztRQUNyQyxJQUFJMTBELE1BQU0sSUFBSSxDQUFDbzBCLGFBQWEsQ0FBQ3RKLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDO1FBQ2xELElBQUk4OEIsV0FBVyxJQUFJLENBQUNwa0IsSUFBSSxDQUFDelQsSUFBSSxDQUFDNjNCLFFBQVE7UUFDdEMsSUFBSW5sQyxJQUFJO1FBQ1IsSUFBSUMsTUFBTWtsQyxTQUFTamxDLE1BQU07UUFFekIsTUFBT0YsSUFBSUMsSUFBSztZQUNkLElBQUlrbEMsUUFBUSxDQUFDbmxDLEVBQUUsSUFBSW1sQyxRQUFRLENBQUNubEMsRUFBRSxDQUFDK0ssSUFBSSxDQUFDaWlCLEdBQUcsS0FBS0EsS0FBSztnQkFDL0MsSUFBSSxDQUFDNjRELGdCQUFnQixDQUFDLElBQUksQ0FBQzlrRSxJQUFJLEVBQUVva0IsUUFBUSxDQUFDbmxDLEVBQUU7WUFDOUM7WUFFQUEsS0FBSztRQUNQO1FBRUEsSUFBSSxDQUFDeWlGLFdBQVcsR0FBRztJQUNyQjtJQUVBNkMsZ0JBQWdCbGxGLFNBQVMsQ0FBQ29kLFdBQVcsR0FBRztRQUN0QyxJQUFJLENBQUMsSUFBSSxDQUFDaWxFLFdBQVcsRUFBRTtZQUNyQixJQUFJLENBQUNmLFVBQVU7UUFDakI7SUFDRjtJQUVBLFNBQVNxRSxzQkFBc0JwOUMsTUFBTSxFQUFFeVksYUFBYSxFQUFFcmdDLElBQUksRUFBRTFULEVBQUU7UUFDNUQsK0VBQStFO1FBQy9FczdCLE9BQU81bUIsWUFBWSxDQUFDLEtBQUs7UUFDekI0bUIsT0FBTzVtQixZQUFZLENBQUMsS0FBSztRQUN6QjRtQixPQUFPNW1CLFlBQVksQ0FBQyxTQUFTO1FBQzdCNG1CLE9BQU81bUIsWUFBWSxDQUFDLFVBQVU7UUFDOUIsSUFBSSxDQUFDcS9CLGFBQWEsR0FBR0E7UUFDckIsSUFBSTRqQyxpQkFBaUI3NkUsU0FBUztRQUM5QjY2RSxlQUFlampFLFlBQVksQ0FBQyxVQUFVMVU7UUFDdENzN0IsT0FBT2owQixXQUFXLENBQUNzd0U7UUFDbkIsSUFBSSxDQUFDQSxjQUFjLEdBQUdBO0lBQ3hCO0lBRUFlLHNCQUFzQjNsRixTQUFTLENBQUNvZCxXQUFXLEdBQUcsU0FBVTZsQixXQUFXO1FBQ2pFLElBQUlBLGVBQWUsSUFBSSxDQUFDK2QsYUFBYSxDQUFDbndCLElBQUksRUFBRTtZQUMxQyxrREFBa0Q7WUFDbEQsSUFBSSswRCxxQkFBcUI7WUFDekIsSUFBSUMsUUFBUSxJQUFJLENBQUM3a0MsYUFBYSxDQUFDdEosY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsR0FBRzI5RSxvQkFBb0Isc0JBQXNCO1lBQ2pHLEVBQUU7WUFDRiwrQkFBK0I7WUFDL0IseUJBQXlCO1lBQ3pCLHVCQUF1QjtZQUN2QixFQUFFO1lBRUYsSUFBSUUsYUFBYSxJQUFJLENBQUM5a0MsYUFBYSxDQUFDdEosY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUM7WUFDekQsSUFBSTg5RSxTQUFTRCxjQUFjLElBQUksSUFBSUQsT0FBTyw2QkFBNkI7WUFFdkUsSUFBSUcsU0FBU0YsY0FBYyxJQUFJLElBQUlELE9BQU8sNkJBQTZCO1lBRXZFLElBQUksQ0FBQ2pCLGNBQWMsQ0FBQ2pqRSxZQUFZLENBQUMsZ0JBQWdCb2tFLFNBQVMsTUFBTUMsU0FBUyx3QkFBd0I7WUFDakcsRUFBRTtZQUNGLDBCQUEwQjtZQUMxQixxQkFBcUI7WUFFckIsSUFBSUMsV0FBVyxJQUFJLENBQUNqbEMsYUFBYSxDQUFDdEosY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsSUFBSSxJQUFJLFNBQVMsYUFBYSw2QkFBNkI7WUFFbEgsSUFBSSxDQUFDMjhFLGNBQWMsQ0FBQ2pqRSxZQUFZLENBQUMsWUFBWXNrRTtRQUMvQztJQUNGO0lBRUEsU0FBU0MsbUJBQW1CO0lBRTVCQSxnQkFBZ0JsbUYsU0FBUyxDQUFDNmUsSUFBSSxHQUFHLFNBQVUwNkIsY0FBYztRQUN2RCxJQUFJLENBQUNBLGNBQWMsR0FBR0E7UUFDdEIsSUFBSSxDQUFDajZDLElBQUksR0FBR3M5QyxZQUFZQyxnQkFBZ0I7UUFDeEMsSUFBSSxDQUFDaGhCLE1BQU0sR0FBRyxJQUFJMUQ7UUFDbEIsSUFBSSxDQUFDeWxCLE9BQU8sR0FBRyxDQUFDO1FBQ2hCLElBQUksQ0FBQy9zQixJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNxc0IsTUFBTSxHQUFHO0lBQ2hCO0lBRUFncEMsZ0JBQWdCbG1GLFNBQVMsQ0FBQ29kLFdBQVcsR0FBRyxTQUFVK29FLFVBQVU7UUFDMUQsSUFBSSxDQUFDanBDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ3JzQixJQUFJLEdBQUc7UUFFWixJQUFJczFELGNBQWMsSUFBSSxDQUFDNXNDLGNBQWMsQ0FBQzFvQixJQUFJLEVBQUU7WUFDMUMsSUFBSTZtQixpQkFBaUIsSUFBSSxDQUFDNkIsY0FBYyxDQUFDN0IsY0FBYztZQUN2RCxJQUFJc25DLFNBQVN0bkMsY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUM7WUFDbEMsSUFBSW5DLFdBQVc0eEMsY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUM7WUFDcEMsSUFBSW0rRSxpQkFBaUIxdUMsY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUMsS0FBSztZQUMvQyxJQUFJbytFLGNBQWMzdUMsY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUM7WUFDdkMsSUFBSXErRSxhQUFhRixpQkFBaUJDLGNBQWMzdUMsY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUM7WUFDckUsSUFBSWt4QixPQUFPdWUsY0FBYyxDQUFDLEVBQUUsQ0FBQ3B2QyxDQUFDLENBQUNMLENBQUM7WUFDaEMsSUFBSW0wRSxXQUFXMWtDLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDO1lBQ3BDLElBQUk0cUUsV0FBV243QixjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQztZQUNwQyxJQUFJLENBQUM0ekIsTUFBTSxDQUFDdkcsS0FBSztZQUNqQixJQUFJLENBQUN1RyxNQUFNLENBQUNuQyxTQUFTLENBQUMsQ0FBQ3NsRCxNQUFNLENBQUMsRUFBRSxFQUFFLENBQUNBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFO1lBQ3ZELElBQUksQ0FBQ25qRCxNQUFNLENBQUN4QyxLQUFLLENBQUNpdEQsYUFBYSxNQUFNRCxjQUFjLE1BQU07WUFDekQsSUFBSSxDQUFDeHFELE1BQU0sQ0FBQ25ELE1BQU0sQ0FBQyxDQUFDbTZDLFdBQVd4dEU7WUFDL0IsSUFBSSxDQUFDdzJCLE1BQU0sQ0FBQ3pDLFlBQVksQ0FBQyxDQUFDRCxPQUFPOXpCLFdBQVcsQ0FBQysyRSxXQUFXLEVBQUMsSUFBSy8yRTtZQUM5RCxJQUFJLENBQUN3MkIsTUFBTSxDQUFDbkMsU0FBUyxDQUFDNXpCLFFBQVEsQ0FBQyxFQUFFLEVBQUVBLFFBQVEsQ0FBQyxFQUFFLEVBQUU7WUFDaEQsSUFBSSxDQUFDK3FCLElBQUksR0FBRztZQUVaLElBQUksSUFBSSxDQUFDK3NCLE9BQU8sS0FBS2xHLGNBQWMsQ0FBQyxFQUFFLENBQUNwdkMsQ0FBQyxDQUFDTCxDQUFDLEVBQUU7Z0JBQzFDLElBQUksQ0FBQzIxQyxPQUFPLEdBQUdsRyxjQUFjLENBQUMsRUFBRSxDQUFDcHZDLENBQUMsQ0FBQ0wsQ0FBQztnQkFDcEMsSUFBSSxDQUFDaTFDLE1BQU0sR0FBRztZQUNoQjtRQUNGO0lBQ0Y7SUFFQSxTQUFTcXBDLG1CQUFtQnJ2RSxDQUFDLEVBQUU4cEMsYUFBYTtRQUMxQyxJQUFJLENBQUNuaUMsSUFBSSxDQUFDbWlDO0lBQ1o7SUFFQXZoRCxnQkFBZ0I7UUFBQ3ltRjtLQUFnQixFQUFFSztJQUVuQyxTQUFTQyxrQkFBa0JqdEMsY0FBYztRQUN2QyxJQUFJLENBQUMxNkIsSUFBSSxDQUFDMDZCO0lBQ1o7SUFFQTk1QyxnQkFBZ0I7UUFBQ3ltRjtLQUFnQixFQUFFTTtJQUVuQ3p1RSxpQkFBaUIsVUFBVXdzRDtJQUMzQnhzRCxpQkFBaUIsUUFBUWd6RDtJQUN6Qmh6RCxpQkFBaUIsT0FBTzZnRCxjQUFjLDhCQUE4QjtJQUVwRWw1QixlQUFlRSxnQkFBZ0IsQ0FBQyxNQUFNTztJQUN0Q1QsZUFBZUUsZ0JBQWdCLENBQUMsTUFBTXFDO0lBQ3RDdkMsZUFBZUUsZ0JBQWdCLENBQUMsTUFBTWlFO0lBQ3RDbkUsZUFBZUUsZ0JBQWdCLENBQUMsTUFBTTRHO0lBQ3RDOUcsZUFBZUUsZ0JBQWdCLENBQUMsTUFBTWdMO0lBQ3RDbEwsZUFBZUUsZ0JBQWdCLENBQUMsTUFBTW1PLHFCQUFxQixnQ0FBZ0M7SUFFM0Z4a0MscUJBQXFCeXNFO0lBQ3JCdnNFLHdCQUF3QjZ6RTtJQUN4QjBEO0lBQ0FNLGNBQWMsMEJBQTBCO0lBRXhDbGdDLGlCQUFpQixJQUFJMGdDLGVBQWU7SUFDcEMxZ0MsaUJBQWlCLElBQUkrZ0MsZUFBZTtJQUNwQy9nQyxpQkFBaUIsSUFBSWdoQyxpQkFBaUI7SUFDdENoaEMsaUJBQWlCLElBQUkyaEMsa0JBQWtCO0lBQ3ZDM2hDLGlCQUFpQixJQUFJc2lDLG9CQUFvQjtJQUN6Q3RpQyxpQkFBaUIsSUFBSXNqQyxxQkFBcUI7SUFDMUN0akMsaUJBQWlCLElBQUk4akMsaUJBQWlCO0lBQ3RDOWpDLGlCQUFpQixJQUFJdWtDLHVCQUF1QjtJQUM1Q3ZrQyxpQkFBaUIsSUFBSW1sQyxvQkFBb0I7SUFDekMxckIsZUFBZSxJQUFJMnJCO0lBRW5CLE9BQU85bkY7QUFFVCIsInNvdXJjZXMiOlsid2VicGFjazovL3Rlc3QvLi9ub2RlX21vZHVsZXMvbG90dGllLXdlYi9idWlsZC9wbGF5ZXIvbG90dGllLmpzP2M3MjYiXSwic291cmNlc0NvbnRlbnQiOlsiKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIpICYmIChmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLmxvdHRpZSA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHN2Z05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgdmFyIGxvY2F0aW9uSHJlZiA9ICcnO1xuICB2YXIgX3VzZVdlYldvcmtlciA9IGZhbHNlO1xuICB2YXIgaW5pdGlhbERlZmF1bHRGcmFtZSA9IC05OTk5OTk7XG5cbiAgdmFyIHNldFdlYldvcmtlciA9IGZ1bmN0aW9uIHNldFdlYldvcmtlcihmbGFnKSB7XG4gICAgX3VzZVdlYldvcmtlciA9ICEhZmxhZztcbiAgfTtcblxuICB2YXIgZ2V0V2ViV29ya2VyID0gZnVuY3Rpb24gZ2V0V2ViV29ya2VyKCkge1xuICAgIHJldHVybiBfdXNlV2ViV29ya2VyO1xuICB9O1xuXG4gIHZhciBzZXRMb2NhdGlvbkhyZWYgPSBmdW5jdGlvbiBzZXRMb2NhdGlvbkhyZWYodmFsdWUpIHtcbiAgICBsb2NhdGlvbkhyZWYgPSB2YWx1ZTtcbiAgfTtcblxuICB2YXIgZ2V0TG9jYXRpb25IcmVmID0gZnVuY3Rpb24gZ2V0TG9jYXRpb25IcmVmKCkge1xuICAgIHJldHVybiBsb2NhdGlvbkhyZWY7XG4gIH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlVGFnKHR5cGUpIHtcbiAgICAvLyByZXR1cm4ge2FwcGVuZENoaWxkOmZ1bmN0aW9uKCl7fSxzZXRBdHRyaWJ1dGU6ZnVuY3Rpb24oKXt9LHN0eWxlOnt9fVxuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kUHJvdG90eXBlKHNvdXJjZXMsIGRlc3RpbmF0aW9uKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHNvdXJjZXMubGVuZ3RoO1xuICAgIHZhciBzb3VyY2VQcm90b3R5cGU7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHNvdXJjZVByb3RvdHlwZSA9IHNvdXJjZXNbaV0ucHJvdG90eXBlO1xuXG4gICAgICBmb3IgKHZhciBhdHRyIGluIHNvdXJjZVByb3RvdHlwZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZVByb3RvdHlwZSwgYXR0cikpIGRlc3RpbmF0aW9uLnByb3RvdHlwZVthdHRyXSA9IHNvdXJjZVByb3RvdHlwZVthdHRyXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXREZXNjcmlwdG9yKG9iamVjdCwgcHJvcCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcm94eUZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgIGZ1bmN0aW9uIFByb3h5RnVuY3Rpb24oKSB7fVxuXG4gICAgUHJveHlGdW5jdGlvbi5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgcmV0dXJuIFByb3h5RnVuY3Rpb247XG4gIH1cblxuICAvLyBpbXBvcnQgSG93bCBmcm9tICcuLi8uLi8zcmRfcGFydHkvaG93bGVyJztcbiAgdmFyIGF1ZGlvQ29udHJvbGxlckZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXVkaW9Db250cm9sbGVyKGF1ZGlvRmFjdG9yeSkge1xuICAgICAgdGhpcy5hdWRpb3MgPSBbXTtcbiAgICAgIHRoaXMuYXVkaW9GYWN0b3J5ID0gYXVkaW9GYWN0b3J5O1xuICAgICAgdGhpcy5fdm9sdW1lID0gMTtcbiAgICAgIHRoaXMuX2lzTXV0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBBdWRpb0NvbnRyb2xsZXIucHJvdG90eXBlID0ge1xuICAgICAgYWRkQXVkaW86IGZ1bmN0aW9uIGFkZEF1ZGlvKGF1ZGlvKSB7XG4gICAgICAgIHRoaXMuYXVkaW9zLnB1c2goYXVkaW8pO1xuICAgICAgfSxcbiAgICAgIHBhdXNlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmF1ZGlvcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgdGhpcy5hdWRpb3NbaV0ucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlc3VtZTogZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuYXVkaW9zLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICB0aGlzLmF1ZGlvc1tpXS5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldFJhdGU6IGZ1bmN0aW9uIHNldFJhdGUocmF0ZVZhbHVlKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5hdWRpb3MubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHRoaXMuYXVkaW9zW2ldLnNldFJhdGUocmF0ZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNyZWF0ZUF1ZGlvOiBmdW5jdGlvbiBjcmVhdGVBdWRpbyhhc3NldFBhdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9GYWN0b3J5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXVkaW9GYWN0b3J5KGFzc2V0UGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2luZG93Lkhvd2wpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5Ib3dsKHtcbiAgICAgICAgICAgIHNyYzogW2Fzc2V0UGF0aF1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNQbGF5aW5nOiBmYWxzZSxcbiAgICAgICAgICBwbGF5OiBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2VlazogZnVuY3Rpb24gc2VlaygpIHtcbiAgICAgICAgICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwbGF5aW5nOiBmdW5jdGlvbiBwbGF5aW5nKCkge30sXG4gICAgICAgICAgcmF0ZTogZnVuY3Rpb24gcmF0ZSgpIHt9LFxuICAgICAgICAgIHNldFZvbHVtZTogZnVuY3Rpb24gc2V0Vm9sdW1lKCkge31cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBzZXRBdWRpb0ZhY3Rvcnk6IGZ1bmN0aW9uIHNldEF1ZGlvRmFjdG9yeShhdWRpb0ZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5hdWRpb0ZhY3RvcnkgPSBhdWRpb0ZhY3Rvcnk7XG4gICAgICB9LFxuICAgICAgc2V0Vm9sdW1lOiBmdW5jdGlvbiBzZXRWb2x1bWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdm9sdW1lID0gdmFsdWU7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlVm9sdW1lKCk7XG4gICAgICB9LFxuICAgICAgbXV0ZTogZnVuY3Rpb24gbXV0ZSgpIHtcbiAgICAgICAgdGhpcy5faXNNdXRlZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlVm9sdW1lKCk7XG4gICAgICB9LFxuICAgICAgdW5tdXRlOiBmdW5jdGlvbiB1bm11dGUoKSB7XG4gICAgICAgIHRoaXMuX2lzTXV0ZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl91cGRhdGVWb2x1bWUoKTtcbiAgICAgIH0sXG4gICAgICBnZXRWb2x1bWU6IGZ1bmN0aW9uIGdldFZvbHVtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZvbHVtZTtcbiAgICAgIH0sXG4gICAgICBfdXBkYXRlVm9sdW1lOiBmdW5jdGlvbiBfdXBkYXRlVm9sdW1lKCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuYXVkaW9zLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICB0aGlzLmF1ZGlvc1tpXS52b2x1bWUodGhpcy5fdm9sdW1lICogKHRoaXMuX2lzTXV0ZWQgPyAwIDogMSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBBdWRpb0NvbnRyb2xsZXIoKTtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIGNyZWF0ZVR5cGVkQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVndWxhckFycmF5KHR5cGUsIGxlbikge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgICBjYXNlICd1aW50OGMnOlxuICAgICAgICAgIHZhbHVlID0gMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZhbHVlID0gMS4xO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYXJyLnB1c2godmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVR5cGVkQXJyYXlGYWN0b3J5KHR5cGUsIGxlbikge1xuICAgICAgaWYgKHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShsZW4pO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSA9PT0gJ2ludDE2Jykge1xuICAgICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkobGVuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICd1aW50OGMnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhDbGFtcGVkQXJyYXkobGVuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyZWF0ZVJlZ3VsYXJBcnJheSh0eXBlLCBsZW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVR5cGVkQXJyYXlGYWN0b3J5O1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVSZWd1bGFyQXJyYXk7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBjcmVhdGVTaXplZEFycmF5KGxlbikge1xuICAgIHJldHVybiBBcnJheS5hcHBseShudWxsLCB7XG4gICAgICBsZW5ndGg6IGxlblxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gX3R5cGVvZiQ2KG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mJDYgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiQ2ID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2YkNihvYmopOyB9XG4gIHZhciBzdWJmcmFtZUVuYWJsZWQgPSB0cnVlO1xuICB2YXIgZXhwcmVzc2lvbnNQbHVnaW4gPSBudWxsO1xuICB2YXIgZXhwcmVzc2lvbnNJbnRlcmZhY2VzID0gbnVsbDtcbiAgdmFyIGlkUHJlZml4JDEgPSAnJztcbiAgdmFyIGlzU2FmYXJpID0gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIF9zaG91bGRSb3VuZFZhbHVlcyA9IGZhbHNlO1xuICB2YXIgYm1Qb3cgPSBNYXRoLnBvdztcbiAgdmFyIGJtU3FydCA9IE1hdGguc3FydDtcbiAgdmFyIGJtRmxvb3IgPSBNYXRoLmZsb29yO1xuICB2YXIgYm1NYXggPSBNYXRoLm1heDtcbiAgdmFyIGJtTWluID0gTWF0aC5taW47XG4gIHZhciBCTU1hdGggPSB7fTtcblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wZXJ0eU5hbWVzID0gWydhYnMnLCAnYWNvcycsICdhY29zaCcsICdhc2luJywgJ2FzaW5oJywgJ2F0YW4nLCAnYXRhbmgnLCAnYXRhbjInLCAnY2VpbCcsICdjYnJ0JywgJ2V4cG0xJywgJ2NsejMyJywgJ2NvcycsICdjb3NoJywgJ2V4cCcsICdmbG9vcicsICdmcm91bmQnLCAnaHlwb3QnLCAnaW11bCcsICdsb2cnLCAnbG9nMXAnLCAnbG9nMicsICdsb2cxMCcsICdtYXgnLCAnbWluJywgJ3BvdycsICdyYW5kb20nLCAncm91bmQnLCAnc2lnbicsICdzaW4nLCAnc2luaCcsICdzcXJ0JywgJ3RhbicsICd0YW5oJywgJ3RydW5jJywgJ0UnLCAnTE4xMCcsICdMTjInLCAnTE9HMTBFJywgJ0xPRzJFJywgJ1BJJywgJ1NRUlQxXzInLCAnU1FSVDInXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gcHJvcGVydHlOYW1lcy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIEJNTWF0aFtwcm9wZXJ0eU5hbWVzW2ldXSA9IE1hdGhbcHJvcGVydHlOYW1lc1tpXV07XG4gICAgfVxuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIFByb2plY3RJbnRlcmZhY2UkMSgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBCTU1hdGgucmFuZG9tID0gTWF0aC5yYW5kb207XG5cbiAgQk1NYXRoLmFicyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YXIgdE9mVmFsID0gX3R5cGVvZiQ2KHZhbCk7XG5cbiAgICBpZiAodE9mVmFsID09PSAnb2JqZWN0JyAmJiB2YWwubGVuZ3RoKSB7XG4gICAgICB2YXIgYWJzQXJyID0gY3JlYXRlU2l6ZWRBcnJheSh2YWwubGVuZ3RoKTtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHZhbC5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBhYnNBcnJbaV0gPSBNYXRoLmFicyh2YWxbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWJzQXJyO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLmFicyh2YWwpO1xuICB9O1xuXG4gIHZhciBkZWZhdWx0Q3VydmVTZWdtZW50cyA9IDE1MDtcbiAgdmFyIGRlZ1RvUmFkcyA9IE1hdGguUEkgLyAxODA7XG4gIHZhciByb3VuZENvcm5lciA9IDAuNTUxOTtcblxuICBmdW5jdGlvbiByb3VuZFZhbHVlcyhmbGFnKSB7XG4gICAgX3Nob3VsZFJvdW5kVmFsdWVzID0gISFmbGFnO1xuICB9XG5cbiAgZnVuY3Rpb24gYm1SbmQodmFsdWUpIHtcbiAgICBpZiAoX3Nob3VsZFJvdW5kVmFsdWVzKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gc3R5bGVEaXYoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGVsZW1lbnQuc3R5bGUudG9wID0gMDtcbiAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSAwO1xuICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAwJztcbiAgICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9ICcwIDAnO1xuICAgIGVsZW1lbnQuc3R5bGUuYmFja2ZhY2VWaXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgIGVsZW1lbnQuc3R5bGUud2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtU3R5bGUgPSAncHJlc2VydmUtM2QnO1xuICAgIGVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtU3R5bGUgPSAncHJlc2VydmUtM2QnO1xuICAgIGVsZW1lbnQuc3R5bGUubW96VHJhbnNmb3JtU3R5bGUgPSAncHJlc2VydmUtM2QnO1xuICB9XG5cbiAgZnVuY3Rpb24gQk1FbnRlckZyYW1lRXZlbnQodHlwZSwgY3VycmVudFRpbWUsIHRvdGFsVGltZSwgZnJhbWVNdWx0aXBsaWVyKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy50b3RhbFRpbWUgPSB0b3RhbFRpbWU7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSBmcmFtZU11bHRpcGxpZXIgPCAwID8gLTEgOiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gQk1Db21wbGV0ZUV2ZW50KHR5cGUsIGZyYW1lTXVsdGlwbGllcikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSBmcmFtZU11bHRpcGxpZXIgPCAwID8gLTEgOiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gQk1Db21wbGV0ZUxvb3BFdmVudCh0eXBlLCB0b3RhbExvb3BzLCBjdXJyZW50TG9vcCwgZnJhbWVNdWx0aXBsaWVyKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmN1cnJlbnRMb29wID0gY3VycmVudExvb3A7XG4gICAgdGhpcy50b3RhbExvb3BzID0gdG90YWxMb29wcztcbiAgICB0aGlzLmRpcmVjdGlvbiA9IGZyYW1lTXVsdGlwbGllciA8IDAgPyAtMSA6IDE7XG4gIH1cblxuICBmdW5jdGlvbiBCTVNlZ21lbnRTdGFydEV2ZW50KHR5cGUsIGZpcnN0RnJhbWUsIHRvdGFsRnJhbWVzKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmZpcnN0RnJhbWUgPSBmaXJzdEZyYW1lO1xuICAgIHRoaXMudG90YWxGcmFtZXMgPSB0b3RhbEZyYW1lcztcbiAgfVxuXG4gIGZ1bmN0aW9uIEJNRGVzdHJveUV2ZW50KHR5cGUsIHRhcmdldCkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBCTVJlbmRlckZyYW1lRXJyb3JFdmVudChuYXRpdmVFcnJvciwgY3VycmVudFRpbWUpIHtcbiAgICB0aGlzLnR5cGUgPSAncmVuZGVyRnJhbWVFcnJvcic7XG4gICAgdGhpcy5uYXRpdmVFcnJvciA9IG5hdGl2ZUVycm9yO1xuICAgIHRoaXMuY3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEJNQ29uZmlnRXJyb3JFdmVudChuYXRpdmVFcnJvcikge1xuICAgIHRoaXMudHlwZSA9ICdjb25maWdFcnJvcic7XG4gICAgdGhpcy5uYXRpdmVFcnJvciA9IG5hdGl2ZUVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gQk1BbmltYXRpb25Db25maWdFcnJvckV2ZW50KHR5cGUsIG5hdGl2ZUVycm9yKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLm5hdGl2ZUVycm9yID0gbmF0aXZlRXJyb3I7XG4gIH1cblxuICB2YXIgY3JlYXRlRWxlbWVudElEID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfY291bnQgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVJRCgpIHtcbiAgICAgIF9jb3VudCArPSAxO1xuICAgICAgcmV0dXJuIGlkUHJlZml4JDEgKyAnX19sb3R0aWVfZWxlbWVudF8nICsgX2NvdW50O1xuICAgIH07XG4gIH0oKTtcblxuICBmdW5jdGlvbiBIU1Z0b1JHQihoLCBzLCB2KSB7XG4gICAgdmFyIHI7XG4gICAgdmFyIGc7XG4gICAgdmFyIGI7XG4gICAgdmFyIGk7XG4gICAgdmFyIGY7XG4gICAgdmFyIHA7XG4gICAgdmFyIHE7XG4gICAgdmFyIHQ7XG4gICAgaSA9IE1hdGguZmxvb3IoaCAqIDYpO1xuICAgIGYgPSBoICogNiAtIGk7XG4gICAgcCA9IHYgKiAoMSAtIHMpO1xuICAgIHEgPSB2ICogKDEgLSBmICogcyk7XG4gICAgdCA9IHYgKiAoMSAtICgxIC0gZikgKiBzKTtcblxuICAgIHN3aXRjaCAoaSAlIDYpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgciA9IHY7XG4gICAgICAgIGcgPSB0O1xuICAgICAgICBiID0gcDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgciA9IHE7XG4gICAgICAgIGcgPSB2O1xuICAgICAgICBiID0gcDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgciA9IHA7XG4gICAgICAgIGcgPSB2O1xuICAgICAgICBiID0gdDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzpcbiAgICAgICAgciA9IHA7XG4gICAgICAgIGcgPSBxO1xuICAgICAgICBiID0gdjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNDpcbiAgICAgICAgciA9IHQ7XG4gICAgICAgIGcgPSBwO1xuICAgICAgICBiID0gdjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNTpcbiAgICAgICAgciA9IHY7XG4gICAgICAgIGcgPSBwO1xuICAgICAgICBiID0gcTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBbciwgZywgYl07XG4gIH1cblxuICBmdW5jdGlvbiBSR0J0b0hTVihyLCBnLCBiKSB7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICB2YXIgZCA9IG1heCAtIG1pbjtcbiAgICB2YXIgaDtcbiAgICB2YXIgcyA9IG1heCA9PT0gMCA/IDAgOiBkIC8gbWF4O1xuICAgIHZhciB2ID0gbWF4IC8gMjU1O1xuXG4gICAgc3dpdGNoIChtYXgpIHtcbiAgICAgIGNhc2UgbWluOlxuICAgICAgICBoID0gMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgcjpcbiAgICAgICAgaCA9IGcgLSBiICsgZCAqIChnIDwgYiA/IDYgOiAwKTtcbiAgICAgICAgaCAvPSA2ICogZDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgZzpcbiAgICAgICAgaCA9IGIgLSByICsgZCAqIDI7XG4gICAgICAgIGggLz0gNiAqIGQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGI6XG4gICAgICAgIGggPSByIC0gZyArIGQgKiA0O1xuICAgICAgICBoIC89IDYgKiBkO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtoLCBzLCB2XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFNhdHVyYXRpb25Ub1JHQihjb2xvciwgb2Zmc2V0KSB7XG4gICAgdmFyIGhzdiA9IFJHQnRvSFNWKGNvbG9yWzBdICogMjU1LCBjb2xvclsxXSAqIDI1NSwgY29sb3JbMl0gKiAyNTUpO1xuICAgIGhzdlsxXSArPSBvZmZzZXQ7XG5cbiAgICBpZiAoaHN2WzFdID4gMSkge1xuICAgICAgaHN2WzFdID0gMTtcbiAgICB9IGVsc2UgaWYgKGhzdlsxXSA8PSAwKSB7XG4gICAgICBoc3ZbMV0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBIU1Z0b1JHQihoc3ZbMF0sIGhzdlsxXSwgaHN2WzJdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEJyaWdodG5lc3NUb1JHQihjb2xvciwgb2Zmc2V0KSB7XG4gICAgdmFyIGhzdiA9IFJHQnRvSFNWKGNvbG9yWzBdICogMjU1LCBjb2xvclsxXSAqIDI1NSwgY29sb3JbMl0gKiAyNTUpO1xuICAgIGhzdlsyXSArPSBvZmZzZXQ7XG5cbiAgICBpZiAoaHN2WzJdID4gMSkge1xuICAgICAgaHN2WzJdID0gMTtcbiAgICB9IGVsc2UgaWYgKGhzdlsyXSA8IDApIHtcbiAgICAgIGhzdlsyXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIEhTVnRvUkdCKGhzdlswXSwgaHN2WzFdLCBoc3ZbMl0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkSHVlVG9SR0IoY29sb3IsIG9mZnNldCkge1xuICAgIHZhciBoc3YgPSBSR0J0b0hTVihjb2xvclswXSAqIDI1NSwgY29sb3JbMV0gKiAyNTUsIGNvbG9yWzJdICogMjU1KTtcbiAgICBoc3ZbMF0gKz0gb2Zmc2V0IC8gMzYwO1xuXG4gICAgaWYgKGhzdlswXSA+IDEpIHtcbiAgICAgIGhzdlswXSAtPSAxO1xuICAgIH0gZWxzZSBpZiAoaHN2WzBdIDwgMCkge1xuICAgICAgaHN2WzBdICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIEhTVnRvUkdCKGhzdlswXSwgaHN2WzFdLCBoc3ZbMl0pO1xuICB9XG5cbiAgdmFyIHJnYlRvSGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb2xvck1hcCA9IFtdO1xuICAgIHZhciBpO1xuICAgIHZhciBoZXg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpICs9IDEpIHtcbiAgICAgIGhleCA9IGkudG9TdHJpbmcoMTYpO1xuICAgICAgY29sb3JNYXBbaV0gPSBoZXgubGVuZ3RoID09PSAxID8gJzAnICsgaGV4IDogaGV4O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAociwgZywgYikge1xuICAgICAgaWYgKHIgPCAwKSB7XG4gICAgICAgIHIgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoZyA8IDApIHtcbiAgICAgICAgZyA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChiIDwgMCkge1xuICAgICAgICBiID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcjJyArIGNvbG9yTWFwW3JdICsgY29sb3JNYXBbZ10gKyBjb2xvck1hcFtiXTtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIHNldFN1YmZyYW1lRW5hYmxlZCA9IGZ1bmN0aW9uIHNldFN1YmZyYW1lRW5hYmxlZChmbGFnKSB7XG4gICAgc3ViZnJhbWVFbmFibGVkID0gISFmbGFnO1xuICB9O1xuXG4gIHZhciBnZXRTdWJmcmFtZUVuYWJsZWQgPSBmdW5jdGlvbiBnZXRTdWJmcmFtZUVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHN1YmZyYW1lRW5hYmxlZDtcbiAgfTtcblxuICB2YXIgc2V0RXhwcmVzc2lvbnNQbHVnaW4gPSBmdW5jdGlvbiBzZXRFeHByZXNzaW9uc1BsdWdpbih2YWx1ZSkge1xuICAgIGV4cHJlc3Npb25zUGx1Z2luID0gdmFsdWU7XG4gIH07XG5cbiAgdmFyIGdldEV4cHJlc3Npb25zUGx1Z2luID0gZnVuY3Rpb24gZ2V0RXhwcmVzc2lvbnNQbHVnaW4oKSB7XG4gICAgcmV0dXJuIGV4cHJlc3Npb25zUGx1Z2luO1xuICB9O1xuXG4gIHZhciBzZXRFeHByZXNzaW9uSW50ZXJmYWNlcyA9IGZ1bmN0aW9uIHNldEV4cHJlc3Npb25JbnRlcmZhY2VzKHZhbHVlKSB7XG4gICAgZXhwcmVzc2lvbnNJbnRlcmZhY2VzID0gdmFsdWU7XG4gIH07XG5cbiAgdmFyIGdldEV4cHJlc3Npb25JbnRlcmZhY2VzID0gZnVuY3Rpb24gZ2V0RXhwcmVzc2lvbkludGVyZmFjZXMoKSB7XG4gICAgcmV0dXJuIGV4cHJlc3Npb25zSW50ZXJmYWNlcztcbiAgfTtcblxuICB2YXIgc2V0RGVmYXVsdEN1cnZlU2VnbWVudHMgPSBmdW5jdGlvbiBzZXREZWZhdWx0Q3VydmVTZWdtZW50cyh2YWx1ZSkge1xuICAgIGRlZmF1bHRDdXJ2ZVNlZ21lbnRzID0gdmFsdWU7XG4gIH07XG5cbiAgdmFyIGdldERlZmF1bHRDdXJ2ZVNlZ21lbnRzID0gZnVuY3Rpb24gZ2V0RGVmYXVsdEN1cnZlU2VnbWVudHMoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRDdXJ2ZVNlZ21lbnRzO1xuICB9O1xuXG4gIHZhciBzZXRJZFByZWZpeCA9IGZ1bmN0aW9uIHNldElkUHJlZml4KHZhbHVlKSB7XG4gICAgaWRQcmVmaXgkMSA9IHZhbHVlO1xuICB9O1xuXG4gIHZhciBnZXRJZFByZWZpeCA9IGZ1bmN0aW9uIGdldElkUHJlZml4KCkge1xuICAgIHJldHVybiBpZFByZWZpeCQxO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5TKHR5cGUpIHtcbiAgICAvLyByZXR1cm4ge2FwcGVuZENoaWxkOmZ1bmN0aW9uKCl7fSxzZXRBdHRyaWJ1dGU6ZnVuY3Rpb24oKXt9LHN0eWxlOnt9fVxuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIHR5cGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3R5cGVvZiQ1KG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mJDUgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiQ1ID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2YkNShvYmopOyB9XG5cbiAgdmFyIGRhdGFNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfY291bnRlcklkID0gMTtcbiAgICB2YXIgcHJvY2Vzc2VzID0gW107XG4gICAgdmFyIHdvcmtlckZuO1xuICAgIHZhciB3b3JrZXJJbnN0YW5jZTtcbiAgICB2YXIgd29ya2VyUHJveHkgPSB7XG4gICAgICBvbm1lc3NhZ2U6IGZ1bmN0aW9uIG9ubWVzc2FnZSgpIHt9LFxuICAgICAgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKHBhdGgpIHtcbiAgICAgICAgd29ya2VyRm4oe1xuICAgICAgICAgIGRhdGE6IHBhdGhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgX3dvcmtlclNlbGYgPSB7XG4gICAgICBwb3N0TWVzc2FnZTogZnVuY3Rpb24gcG9zdE1lc3NhZ2UoZGF0YSkge1xuICAgICAgICB3b3JrZXJQcm94eS5vbm1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVdvcmtlcihmbikge1xuICAgICAgaWYgKHdpbmRvdy5Xb3JrZXIgJiYgd2luZG93LkJsb2IgJiYgZ2V0V2ViV29ya2VyKCkpIHtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbJ3ZhciBfd29ya2VyU2VsZiA9IHNlbGY7IHNlbGYub25tZXNzYWdlID0gJywgZm4udG9TdHJpbmcoKV0sIHtcbiAgICAgICAgICB0eXBlOiAndGV4dC9qYXZhc2NyaXB0J1xuICAgICAgICB9KTsgLy8gdmFyIGJsb2IgPSBuZXcgQmxvYihbJ3NlbGYub25tZXNzYWdlID0gJywgZm4udG9TdHJpbmcoKV0sIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSk7XG5cbiAgICAgICAgdmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIHJldHVybiBuZXcgV29ya2VyKHVybCk7XG4gICAgICB9XG5cbiAgICAgIHdvcmtlckZuID0gZm47XG4gICAgICByZXR1cm4gd29ya2VyUHJveHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dXBXb3JrZXIoKSB7XG4gICAgICBpZiAoIXdvcmtlckluc3RhbmNlKSB7XG4gICAgICAgIHdvcmtlckluc3RhbmNlID0gY3JlYXRlV29ya2VyKGZ1bmN0aW9uIHdvcmtlclN0YXJ0KGUpIHtcbiAgICAgICAgICBmdW5jdGlvbiBkYXRhRnVuY3Rpb25NYW5hZ2VyKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gY29tcGxldGVMYXllcnMobGF5ZXJzLCBjb21wcykge1xuICAgICAgICAgICAgICB2YXIgbGF5ZXJEYXRhO1xuICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgdmFyIGxlbiA9IGxheWVycy5sZW5ndGg7XG4gICAgICAgICAgICAgIHZhciBqO1xuICAgICAgICAgICAgICB2YXIgakxlbjtcbiAgICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICAgIHZhciBrTGVuO1xuXG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGxheWVyRGF0YSA9IGxheWVyc1tpXTtcblxuICAgICAgICAgICAgICAgIGlmICgna3MnIGluIGxheWVyRGF0YSAmJiAhbGF5ZXJEYXRhLmNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgbGF5ZXJEYXRhLmNvbXBsZXRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChsYXllckRhdGEuaGFzTWFzaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFza1Byb3BzID0gbGF5ZXJEYXRhLm1hc2tzUHJvcGVydGllcztcbiAgICAgICAgICAgICAgICAgICAgakxlbiA9IG1hc2tQcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrUHJvcHNbal0ucHQuay5pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0UGF0aHNUb0Fic29sdXRlVmFsdWVzKG1hc2tQcm9wc1tqXS5wdC5rKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAga0xlbiA9IG1hc2tQcm9wc1tqXS5wdC5rLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGtMZW47IGsgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1Byb3BzW2pdLnB0Lmtba10ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMobWFza1Byb3BzW2pdLnB0Lmtba10uc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1Byb3BzW2pdLnB0Lmtba10uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMobWFza1Byb3BzW2pdLnB0Lmtba10uZVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKGxheWVyRGF0YS50eSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsYXllckRhdGEubGF5ZXJzID0gZmluZENvbXBMYXllcnMobGF5ZXJEYXRhLnJlZklkLCBjb21wcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlTGF5ZXJzKGxheWVyRGF0YS5sYXllcnMsIGNvbXBzKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5ZXJEYXRhLnR5ID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlU2hhcGVzKGxheWVyRGF0YS5zaGFwZXMpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXllckRhdGEudHkgPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVUZXh0KGxheWVyRGF0YSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlQ2hhcnMoY2hhcnMsIGFzc2V0cykge1xuICAgICAgICAgICAgICBpZiAoY2hhcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGNoYXJzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJzW2ldLnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGNvbXBEYXRhID0gZmluZENvbXAoY2hhcnNbaV0uZGF0YS5yZWZJZCwgYXNzZXRzKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNbaV0uZGF0YS5sYXllcnMgPSBmaW5kQ29tcExheWVycyhjaGFyc1tpXS5kYXRhLnJlZklkLCBhc3NldHMpOyAvLyBjaGFyc1tpXS5kYXRhLmlwID0gMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhcnNbaV0uZGF0YS5vcCA9IDk5OTk5O1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGFyc1tpXS5kYXRhLnN0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhcnNbaV0uZGF0YS5zciA9IDE7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYXJzW2ldLncgPSBjb21wRGF0YS53O1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGFyc1tpXS5kYXRhLmtzID0ge1xuICAgICAgICAgICAgICAgICAgICAvLyAgIGE6IHsgazogWzAsIDAsIDBdLCBhOiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vICAgcDogeyBrOiBbMCwgLWNvbXBEYXRhLmgsIDBdLCBhOiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vICAgcjogeyBrOiAwLCBhOiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vICAgczogeyBrOiBbMTAwLCAxMDBdLCBhOiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vICAgbzogeyBrOiAxMDAsIGE6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gfTtcblxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUxheWVycyhjaGFyc1tpXS5kYXRhLmxheWVycywgYXNzZXRzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZmluZENvbXAoaWQsIGNvbXBzKSB7XG4gICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgdmFyIGxlbiA9IGNvbXBzLmxlbmd0aDtcblxuICAgICAgICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgICAgIGlmIChjb21wc1tpXS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wc1tpXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZmluZENvbXBMYXllcnMoaWQsIGNvbXBzKSB7XG4gICAgICAgICAgICAgIHZhciBjb21wID0gZmluZENvbXAoaWQsIGNvbXBzKTtcblxuICAgICAgICAgICAgICBpZiAoY29tcCkge1xuICAgICAgICAgICAgICAgIGlmICghY29tcC5sYXllcnMuX191c2VkKSB7XG4gICAgICAgICAgICAgICAgICBjb21wLmxheWVycy5fX3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAubGF5ZXJzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbXAubGF5ZXJzKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY29tcGxldGVTaGFwZXMoYXJyKSB7XG4gICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgICAgdmFyIGo7XG4gICAgICAgICAgICAgIHZhciBqTGVuO1xuXG4gICAgICAgICAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycltpXS50eSA9PT0gJ3NoJykge1xuICAgICAgICAgICAgICAgICAgaWYgKGFycltpXS5rcy5rLmkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyhhcnJbaV0ua3Muayk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBqTGVuID0gYXJyW2ldLmtzLmsubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyW2ldLmtzLmtbal0ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyhhcnJbaV0ua3Mua1tqXS5zWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyW2ldLmtzLmtbal0uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyhhcnJbaV0ua3Mua1tqXS5lWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ2dyJykge1xuICAgICAgICAgICAgICAgICAgY29tcGxldGVTaGFwZXMoYXJyW2ldLml0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyhwYXRoKSB7XG4gICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5pLmxlbmd0aDtcblxuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBwYXRoLmlbaV1bMF0gKz0gcGF0aC52W2ldWzBdO1xuICAgICAgICAgICAgICAgIHBhdGguaVtpXVsxXSArPSBwYXRoLnZbaV1bMV07XG4gICAgICAgICAgICAgICAgcGF0aC5vW2ldWzBdICs9IHBhdGgudltpXVswXTtcbiAgICAgICAgICAgICAgICBwYXRoLm9baV1bMV0gKz0gcGF0aC52W2ldWzFdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrVmVyc2lvbihtaW5pbXVtLCBhbmltVmVyc2lvblN0cmluZykge1xuICAgICAgICAgICAgICB2YXIgYW5pbVZlcnNpb24gPSBhbmltVmVyc2lvblN0cmluZyA/IGFuaW1WZXJzaW9uU3RyaW5nLnNwbGl0KCcuJykgOiBbMTAwLCAxMDAsIDEwMF07XG5cbiAgICAgICAgICAgICAgaWYgKG1pbmltdW1bMF0gPiBhbmltVmVyc2lvblswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGFuaW1WZXJzaW9uWzBdID4gbWluaW11bVswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChtaW5pbXVtWzFdID4gYW5pbVZlcnNpb25bMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChhbmltVmVyc2lvblsxXSA+IG1pbmltdW1bMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobWluaW11bVsyXSA+IGFuaW1WZXJzaW9uWzJdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYW5pbVZlcnNpb25bMl0gPiBtaW5pbXVtWzJdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjaGVja1RleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBtaW5pbXVtVmVyc2lvbiA9IFs0LCA0LCAxNF07XG5cbiAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlVGV4dExheWVyKHRleHRMYXllcikge1xuICAgICAgICAgICAgICAgIHZhciBkb2N1bWVudERhdGEgPSB0ZXh0TGF5ZXIudC5kO1xuICAgICAgICAgICAgICAgIHRleHRMYXllci50LmQgPSB7XG4gICAgICAgICAgICAgICAgICBrOiBbe1xuICAgICAgICAgICAgICAgICAgICBzOiBkb2N1bWVudERhdGEsXG4gICAgICAgICAgICAgICAgICAgIHQ6IDBcbiAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGVMYXllcnMobGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGxheWVycy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsYXllcnNbaV0udHkgPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGV4dExheWVyKGxheWVyc1tpXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbmltYXRpb25EYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrVmVyc2lvbihtaW5pbXVtVmVyc2lvbiwgYW5pbWF0aW9uRGF0YS52KSkge1xuICAgICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmxheWVycyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25EYXRhLmFzc2V0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGFuaW1hdGlvbkRhdGEuYXNzZXRzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5hc3NldHNbaV0ubGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRlTGF5ZXJzKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgICB2YXIgY2hlY2tDaGFycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIG1pbmltdW1WZXJzaW9uID0gWzQsIDcsIDk5XTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbmltYXRpb25EYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuY2hhcnMgJiYgIWNoZWNrVmVyc2lvbihtaW5pbXVtVmVyc2lvbiwgYW5pbWF0aW9uRGF0YS52KSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgICB2YXIgbGVuID0gYW5pbWF0aW9uRGF0YS5jaGFycy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhckRhdGEgPSBhbmltYXRpb25EYXRhLmNoYXJzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyRGF0YS5kYXRhICYmIGNoYXJEYXRhLmRhdGEuc2hhcGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVTaGFwZXMoY2hhckRhdGEuZGF0YS5zaGFwZXMpO1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJEYXRhLmRhdGEuaXAgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJEYXRhLmRhdGEub3AgPSA5OTk5OTtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyRGF0YS5kYXRhLnN0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyRGF0YS5kYXRhLnNyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyRGF0YS5kYXRhLmtzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBrOiBbMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGs6IFsxMDAsIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGs6IFswLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgazogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgazogMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmICghYW5pbWF0aW9uRGF0YS5jaGFyc1tpXS50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyRGF0YS5kYXRhLnNoYXBlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHk6ICdubydcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhckRhdGEuZGF0YS5zaGFwZXNbMF0uaXQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrOiBbMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgazogWzEwMCwgMTAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrOiBbMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICByOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgazogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrOiAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGs6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGs6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0eTogJ3RyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgICB2YXIgY2hlY2tQYXRoUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIG1pbmltdW1WZXJzaW9uID0gWzUsIDcsIDE1XTtcblxuICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVUZXh0TGF5ZXIodGV4dExheWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gdGV4dExheWVyLnQucDtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0aERhdGEuYSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgIHBhdGhEYXRhLmEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGE6IDAsXG4gICAgICAgICAgICAgICAgICAgIGs6IHBhdGhEYXRhLmFcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXRoRGF0YS5wID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgcGF0aERhdGEucCA9IHtcbiAgICAgICAgICAgICAgICAgICAgYTogMCxcbiAgICAgICAgICAgICAgICAgICAgazogcGF0aERhdGEucFxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhdGhEYXRhLnIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICBwYXRoRGF0YS5yID0ge1xuICAgICAgICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICAgICAgICBrOiBwYXRoRGF0YS5yXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGVMYXllcnMobGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGxheWVycy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsYXllcnNbaV0udHkgPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGV4dExheWVyKGxheWVyc1tpXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbmltYXRpb25EYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrVmVyc2lvbihtaW5pbXVtVmVyc2lvbiwgYW5pbWF0aW9uRGF0YS52KSkge1xuICAgICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmxheWVycyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25EYXRhLmFzc2V0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGFuaW1hdGlvbkRhdGEuYXNzZXRzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5hc3NldHNbaV0ubGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRlTGF5ZXJzKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgICB2YXIgY2hlY2tDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBtaW5pbXVtVmVyc2lvbiA9IFs0LCAxLCA5XTtcblxuICAgICAgICAgICAgICBmdW5jdGlvbiBpdGVyYXRlU2hhcGVzKHNoYXBlcykge1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBzaGFwZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBqO1xuICAgICAgICAgICAgICAgIHZhciBqTGVuO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoc2hhcGVzW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVTaGFwZXMoc2hhcGVzW2ldLml0KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAnZmwnIHx8IHNoYXBlc1tpXS50eSA9PT0gJ3N0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcGVzW2ldLmMuayAmJiBzaGFwZXNbaV0uYy5rWzBdLmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBqTGVuID0gc2hhcGVzW2ldLmMuay5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcGVzW2ldLmMua1tqXS5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uc1swXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uc1sxXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uc1syXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uc1szXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGFwZXNbaV0uYy5rW2pdLmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGVzW2ldLmMua1tqXS5lWzBdIC89IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGVzW2ldLmMua1tqXS5lWzFdIC89IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGVzW2ldLmMua1tqXS5lWzJdIC89IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGVzW2ldLmMua1tqXS5lWzNdIC89IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2hhcGVzW2ldLmMua1swXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgc2hhcGVzW2ldLmMua1sxXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgc2hhcGVzW2ldLmMua1syXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgc2hhcGVzW2ldLmMua1szXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmdW5jdGlvbiBpdGVyYXRlTGF5ZXJzKGxheWVycykge1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBsYXllcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobGF5ZXJzW2ldLnR5ID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVTaGFwZXMobGF5ZXJzW2ldLnNoYXBlcyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbmltYXRpb25EYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrVmVyc2lvbihtaW5pbXVtVmVyc2lvbiwgYW5pbWF0aW9uRGF0YS52KSkge1xuICAgICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmxheWVycyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25EYXRhLmFzc2V0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGFuaW1hdGlvbkRhdGEuYXNzZXRzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5hc3NldHNbaV0ubGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRlTGF5ZXJzKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSgpO1xuXG4gICAgICAgICAgICB2YXIgY2hlY2tTaGFwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBtaW5pbXVtVmVyc2lvbiA9IFs0LCA0LCAxOF07XG5cbiAgICAgICAgICAgICAgZnVuY3Rpb24gY29tcGxldGVDbG9zaW5nU2hhcGVzKGFycikge1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBqO1xuICAgICAgICAgICAgICAgIHZhciBqTGVuO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV0udHkgPT09ICdzaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycltpXS5rcy5rLmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhcnJbaV0ua3Muay5jID0gYXJyW2ldLmNsb3NlZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBqTGVuID0gYXJyW2ldLmtzLmsubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFycltpXS5rcy5rW2pdLnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyW2ldLmtzLmtbal0uc1swXS5jID0gYXJyW2ldLmNsb3NlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFycltpXS5rcy5rW2pdLmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyW2ldLmtzLmtbal0uZVswXS5jID0gYXJyW2ldLmNsb3NlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlQ2xvc2luZ1NoYXBlcyhhcnJbaV0uaXQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGVMYXllcnMobGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxheWVyRGF0YTtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gbGF5ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgICAgICB2YXIgakxlbjtcbiAgICAgICAgICAgICAgICB2YXIgaztcbiAgICAgICAgICAgICAgICB2YXIga0xlbjtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgbGF5ZXJEYXRhID0gbGF5ZXJzW2ldO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobGF5ZXJEYXRhLmhhc01hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hc2tQcm9wcyA9IGxheWVyRGF0YS5tYXNrc1Byb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgICAgIGpMZW4gPSBtYXNrUHJvcHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1Byb3BzW2pdLnB0LmsuaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFza1Byb3BzW2pdLnB0LmsuYyA9IG1hc2tQcm9wc1tqXS5jbDtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAga0xlbiA9IG1hc2tQcm9wc1tqXS5wdC5rLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGtMZW47IGsgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1Byb3BzW2pdLnB0Lmtba10ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tQcm9wc1tqXS5wdC5rW2tdLnNbMF0uYyA9IG1hc2tQcm9wc1tqXS5jbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrUHJvcHNbal0ucHQua1trXS5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza1Byb3BzW2pdLnB0Lmtba10uZVswXS5jID0gbWFza1Byb3BzW2pdLmNsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChsYXllckRhdGEudHkgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVDbG9zaW5nU2hhcGVzKGxheWVyRGF0YS5zaGFwZXMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1ZlcnNpb24obWluaW11bVZlcnNpb24sIGFuaW1hdGlvbkRhdGEudikpIHtcbiAgICAgICAgICAgICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5sYXllcnMpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5hc3NldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRpb25EYXRhLmFzc2V0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gY29tcGxldGVEYXRhKGFuaW1hdGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuX19jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNoZWNrQ29sb3JzKGFuaW1hdGlvbkRhdGEpO1xuICAgICAgICAgICAgICBjaGVja1RleHQoYW5pbWF0aW9uRGF0YSk7XG4gICAgICAgICAgICAgIGNoZWNrQ2hhcnMoYW5pbWF0aW9uRGF0YSk7XG4gICAgICAgICAgICAgIGNoZWNrUGF0aFByb3BlcnRpZXMoYW5pbWF0aW9uRGF0YSk7XG4gICAgICAgICAgICAgIGNoZWNrU2hhcGVzKGFuaW1hdGlvbkRhdGEpO1xuICAgICAgICAgICAgICBjb21wbGV0ZUxheWVycyhhbmltYXRpb25EYXRhLmxheWVycywgYW5pbWF0aW9uRGF0YS5hc3NldHMpO1xuICAgICAgICAgICAgICBjb21wbGV0ZUNoYXJzKGFuaW1hdGlvbkRhdGEuY2hhcnMsIGFuaW1hdGlvbkRhdGEuYXNzZXRzKTtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uRGF0YS5fX2NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY29tcGxldGVUZXh0KGRhdGEpIHtcbiAgICAgICAgICAgICAgaWYgKGRhdGEudC5hLmxlbmd0aCA9PT0gMCAmJiAhKCdtJyBpbiBkYXRhLnQucCkpIHsvLyBkYXRhLnNpbmdsZVNoYXBlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbW9kdWxlT2IgPSB7fTtcbiAgICAgICAgICAgIG1vZHVsZU9iLmNvbXBsZXRlRGF0YSA9IGNvbXBsZXRlRGF0YTtcbiAgICAgICAgICAgIG1vZHVsZU9iLmNoZWNrQ29sb3JzID0gY2hlY2tDb2xvcnM7XG4gICAgICAgICAgICBtb2R1bGVPYi5jaGVja0NoYXJzID0gY2hlY2tDaGFycztcbiAgICAgICAgICAgIG1vZHVsZU9iLmNoZWNrUGF0aFByb3BlcnRpZXMgPSBjaGVja1BhdGhQcm9wZXJ0aWVzO1xuICAgICAgICAgICAgbW9kdWxlT2IuY2hlY2tTaGFwZXMgPSBjaGVja1NoYXBlcztcbiAgICAgICAgICAgIG1vZHVsZU9iLmNvbXBsZXRlTGF5ZXJzID0gY29tcGxldGVMYXllcnM7XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlT2I7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFfd29ya2VyU2VsZi5kYXRhTWFuYWdlcikge1xuICAgICAgICAgICAgX3dvcmtlclNlbGYuZGF0YU1hbmFnZXIgPSBkYXRhRnVuY3Rpb25NYW5hZ2VyKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFfd29ya2VyU2VsZi5hc3NldExvYWRlcikge1xuICAgICAgICAgICAgX3dvcmtlclNlbGYuYXNzZXRMb2FkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIGZvcm1hdFJlc3BvbnNlKHhocikge1xuICAgICAgICAgICAgICAgIC8vIHVzaW5nIHR5cGVvZiBkb3VibGVzIHRoZSB0aW1lIG9mIGV4ZWN1dGlvbiBvZiB0aGlzIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAvLyBzbyBpZiBhdmFpbGFibGUsIGl0J3MgYmV0dGVyIHRvIHVzZSB0aGUgaGVhZGVyIHRvIHZhbGlkYXRlIHRoZSB0eXBlXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlSGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcblxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZUhlYWRlciAmJiB4aHIucmVzcG9uc2VUeXBlID09PSAnanNvbicgJiYgY29udGVudFR5cGVIZWFkZXIuaW5kZXhPZignanNvbicpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoeGhyLnJlc3BvbnNlICYmIF90eXBlb2YkNSh4aHIucmVzcG9uc2UpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoeGhyLnJlc3BvbnNlICYmIHR5cGVvZiB4aHIucmVzcG9uc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh4aHIucmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIGxvYWRBc3NldChwYXRoLCBmdWxsUGF0aCwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpOyAvLyBzZXQgcmVzcG9uc2VUeXBlIGFmdGVyIGNhbGxpbmcgb3BlbiBvciBJRSB3aWxsIGJyZWFrLlxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY3Jhc2hlcyBvbiBBbmRyb2lkIFdlYlZpZXcgcHJpb3IgdG8gS2l0S2F0XG4gICAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuXG5cbiAgICAgICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGZvcm1hdFJlc3BvbnNlKHhocik7XG4gICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGZvcm1hdFJlc3BvbnNlKHhocik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAvLyBIYWNrIHRvIHdvcmthcm91bmQgYmFubmVyIHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICAgIHhoci5vcGVuKFsnRycsICdFJywgJ1QnXS5qb2luKCcnKSwgcGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEhhY2sgdG8gd29ya2Fyb3VuZCBiYW5uZXIgdmFsaWRhdGlvblxuICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oWydHJywgJ0UnLCAnVCddLmpvaW4oJycpLCBmdWxsUGF0aCArICcvJyArIHBhdGgsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHhoci5zZW5kKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxvYWQ6IGxvYWRBc3NldFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlLmRhdGEudHlwZSA9PT0gJ2xvYWRBbmltYXRpb24nKSB7XG4gICAgICAgICAgICBfd29ya2VyU2VsZi5hc3NldExvYWRlci5sb2FkKGUuZGF0YS5wYXRoLCBlLmRhdGEuZnVsbFBhdGgsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgIF93b3JrZXJTZWxmLmRhdGFNYW5hZ2VyLmNvbXBsZXRlRGF0YShkYXRhKTtcblxuICAgICAgICAgICAgICBfd29ya2VyU2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgaWQ6IGUuZGF0YS5pZCxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBkYXRhLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3N1Y2Nlc3MnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfd29ya2VyU2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgaWQ6IGUuZGF0YS5pZCxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdlcnJvcidcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS50eXBlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gZS5kYXRhLmFuaW1hdGlvbjtcblxuICAgICAgICAgICAgX3dvcmtlclNlbGYuZGF0YU1hbmFnZXIuY29tcGxldGVEYXRhKGFuaW1hdGlvbik7XG5cbiAgICAgICAgICAgIF93b3JrZXJTZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgaWQ6IGUuZGF0YS5pZCxcbiAgICAgICAgICAgICAgcGF5bG9hZDogYW5pbWF0aW9uLFxuICAgICAgICAgICAgICBzdGF0dXM6ICdzdWNjZXNzJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEudHlwZSA9PT0gJ2xvYWREYXRhJykge1xuICAgICAgICAgICAgX3dvcmtlclNlbGYuYXNzZXRMb2FkZXIubG9hZChlLmRhdGEucGF0aCwgZS5kYXRhLmZ1bGxQYXRoLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICBfd29ya2VyU2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgaWQ6IGUuZGF0YS5pZCxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBkYXRhLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ3N1Y2Nlc3MnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfd29ya2VyU2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgaWQ6IGUuZGF0YS5pZCxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdlcnJvcidcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdvcmtlckluc3RhbmNlLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICB2YXIgaWQgPSBkYXRhLmlkO1xuICAgICAgICAgIHZhciBwcm9jZXNzID0gcHJvY2Vzc2VzW2lkXTtcbiAgICAgICAgICBwcm9jZXNzZXNbaWRdID0gbnVsbDtcblxuICAgICAgICAgIGlmIChkYXRhLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm9uQ29tcGxldGUoZGF0YS5wYXlsb2FkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3Mub25FcnJvcikge1xuICAgICAgICAgICAgcHJvY2Vzcy5vbkVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVByb2Nlc3Mob25Db21wbGV0ZSwgb25FcnJvcikge1xuICAgICAgX2NvdW50ZXJJZCArPSAxO1xuICAgICAgdmFyIGlkID0gJ3Byb2Nlc3NJZF8nICsgX2NvdW50ZXJJZDtcbiAgICAgIHByb2Nlc3Nlc1tpZF0gPSB7XG4gICAgICAgIG9uQ29tcGxldGU6IG9uQ29tcGxldGUsXG4gICAgICAgIG9uRXJyb3I6IG9uRXJyb3JcbiAgICAgIH07XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZEFuaW1hdGlvbihwYXRoLCBvbkNvbXBsZXRlLCBvbkVycm9yKSB7XG4gICAgICBzZXR1cFdvcmtlcigpO1xuICAgICAgdmFyIHByb2Nlc3NJZCA9IGNyZWF0ZVByb2Nlc3Mob25Db21wbGV0ZSwgb25FcnJvcik7XG4gICAgICB3b3JrZXJJbnN0YW5jZS5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICdsb2FkQW5pbWF0aW9uJyxcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgZnVsbFBhdGg6IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIGlkOiBwcm9jZXNzSWRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWREYXRhKHBhdGgsIG9uQ29tcGxldGUsIG9uRXJyb3IpIHtcbiAgICAgIHNldHVwV29ya2VyKCk7XG4gICAgICB2YXIgcHJvY2Vzc0lkID0gY3JlYXRlUHJvY2VzcyhvbkNvbXBsZXRlLCBvbkVycm9yKTtcbiAgICAgIHdvcmtlckluc3RhbmNlLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogJ2xvYWREYXRhJyxcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgZnVsbFBhdGg6IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIGlkOiBwcm9jZXNzSWRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlQW5pbWF0aW9uKGFuaW0sIG9uQ29tcGxldGUsIG9uRXJyb3IpIHtcbiAgICAgIHNldHVwV29ya2VyKCk7XG4gICAgICB2YXIgcHJvY2Vzc0lkID0gY3JlYXRlUHJvY2VzcyhvbkNvbXBsZXRlLCBvbkVycm9yKTtcbiAgICAgIHdvcmtlckluc3RhbmNlLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogJ2NvbXBsZXRlJyxcbiAgICAgICAgYW5pbWF0aW9uOiBhbmltLFxuICAgICAgICBpZDogcHJvY2Vzc0lkXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbG9hZEFuaW1hdGlvbjogbG9hZEFuaW1hdGlvbixcbiAgICAgIGxvYWREYXRhOiBsb2FkRGF0YSxcbiAgICAgIGNvbXBsZXRlQW5pbWF0aW9uOiBjb21wbGV0ZUFuaW1hdGlvblxuICAgIH07XG4gIH0oKTtcblxuICB2YXIgSW1hZ2VQcmVsb2FkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3h5SW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY2FudmFzID0gY3JlYXRlVGFnKCdjYW52YXMnKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gMTtcbiAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgICByZXR1cm4gY2FudmFzO1xuICAgIH0oKTtcblxuICAgIGZ1bmN0aW9uIGltYWdlTG9hZGVkKCkge1xuICAgICAgdGhpcy5sb2FkZWRBc3NldHMgKz0gMTtcblxuICAgICAgaWYgKHRoaXMubG9hZGVkQXNzZXRzID09PSB0aGlzLnRvdGFsSW1hZ2VzICYmIHRoaXMubG9hZGVkRm9vdGFnZXNDb3VudCA9PT0gdGhpcy50b3RhbEZvb3RhZ2VzKSB7XG4gICAgICAgIGlmICh0aGlzLmltYWdlc0xvYWRlZENiKSB7XG4gICAgICAgICAgdGhpcy5pbWFnZXNMb2FkZWRDYihudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvb3RhZ2VMb2FkZWQoKSB7XG4gICAgICB0aGlzLmxvYWRlZEZvb3RhZ2VzQ291bnQgKz0gMTtcblxuICAgICAgaWYgKHRoaXMubG9hZGVkQXNzZXRzID09PSB0aGlzLnRvdGFsSW1hZ2VzICYmIHRoaXMubG9hZGVkRm9vdGFnZXNDb3VudCA9PT0gdGhpcy50b3RhbEZvb3RhZ2VzKSB7XG4gICAgICAgIGlmICh0aGlzLmltYWdlc0xvYWRlZENiKSB7XG4gICAgICAgICAgdGhpcy5pbWFnZXNMb2FkZWRDYihudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEFzc2V0c1BhdGgoYXNzZXREYXRhLCBhc3NldHNQYXRoLCBvcmlnaW5hbFBhdGgpIHtcbiAgICAgIHZhciBwYXRoID0gJyc7XG5cbiAgICAgIGlmIChhc3NldERhdGEuZSkge1xuICAgICAgICBwYXRoID0gYXNzZXREYXRhLnA7XG4gICAgICB9IGVsc2UgaWYgKGFzc2V0c1BhdGgpIHtcbiAgICAgICAgdmFyIGltYWdlUGF0aCA9IGFzc2V0RGF0YS5wO1xuXG4gICAgICAgIGlmIChpbWFnZVBhdGguaW5kZXhPZignaW1hZ2VzLycpICE9PSAtMSkge1xuICAgICAgICAgIGltYWdlUGF0aCA9IGltYWdlUGF0aC5zcGxpdCgnLycpWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aCA9IGFzc2V0c1BhdGggKyBpbWFnZVBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoID0gb3JpZ2luYWxQYXRoO1xuICAgICAgICBwYXRoICs9IGFzc2V0RGF0YS51ID8gYXNzZXREYXRhLnUgOiAnJztcbiAgICAgICAgcGF0aCArPSBhc3NldERhdGEucDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGVzdEltYWdlTG9hZGVkKGltZykge1xuICAgICAgdmFyIF9jb3VudCA9IDA7XG4gICAgICB2YXIgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJveCA9IGltZy5nZXRCQm94KCk7XG5cbiAgICAgICAgaWYgKGJveC53aWR0aCB8fCBfY291bnQgPiA1MDApIHtcbiAgICAgICAgICB0aGlzLl9pbWFnZUxvYWRlZCgpO1xuXG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9jb3VudCArPSAxO1xuICAgICAgfS5iaW5kKHRoaXMpLCA1MCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW1hZ2VEYXRhKGFzc2V0RGF0YSkge1xuICAgICAgdmFyIHBhdGggPSBnZXRBc3NldHNQYXRoKGFzc2V0RGF0YSwgdGhpcy5hc3NldHNQYXRoLCB0aGlzLnBhdGgpO1xuICAgICAgdmFyIGltZyA9IGNyZWF0ZU5TKCdpbWFnZScpO1xuXG4gICAgICBpZiAoaXNTYWZhcmkpIHtcbiAgICAgICAgdGhpcy50ZXN0SW1hZ2VMb2FkZWQoaW1nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5faW1hZ2VMb2FkZWQsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBvYi5pbWcgPSBwcm94eUltYWdlO1xuXG4gICAgICAgIHRoaXMuX2ltYWdlTG9hZGVkKCk7XG4gICAgICB9LmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICAgIGltZy5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsICdocmVmJywgcGF0aCk7XG5cbiAgICAgIGlmICh0aGlzLl9lbGVtZW50SGVscGVyLmFwcGVuZCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50SGVscGVyLmFwcGVuZChpbWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudEhlbHBlci5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2IgPSB7XG4gICAgICAgIGltZzogaW1nLFxuICAgICAgICBhc3NldERhdGE6IGFzc2V0RGF0YVxuICAgICAgfTtcbiAgICAgIHJldHVybiBvYjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbWdEYXRhKGFzc2V0RGF0YSkge1xuICAgICAgdmFyIHBhdGggPSBnZXRBc3NldHNQYXRoKGFzc2V0RGF0YSwgdGhpcy5hc3NldHNQYXRoLCB0aGlzLnBhdGgpO1xuICAgICAgdmFyIGltZyA9IGNyZWF0ZVRhZygnaW1nJyk7XG4gICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcbiAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5faW1hZ2VMb2FkZWQsIGZhbHNlKTtcbiAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2IuaW1nID0gcHJveHlJbWFnZTtcblxuICAgICAgICB0aGlzLl9pbWFnZUxvYWRlZCgpO1xuICAgICAgfS5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgICBpbWcuc3JjID0gcGF0aDtcbiAgICAgIHZhciBvYiA9IHtcbiAgICAgICAgaW1nOiBpbWcsXG4gICAgICAgIGFzc2V0RGF0YTogYXNzZXREYXRhXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG9iO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvb3RhZ2VEYXRhKGRhdGEpIHtcbiAgICAgIHZhciBvYiA9IHtcbiAgICAgICAgYXNzZXREYXRhOiBkYXRhXG4gICAgICB9O1xuICAgICAgdmFyIHBhdGggPSBnZXRBc3NldHNQYXRoKGRhdGEsIHRoaXMuYXNzZXRzUGF0aCwgdGhpcy5wYXRoKTtcbiAgICAgIGRhdGFNYW5hZ2VyLmxvYWREYXRhKHBhdGgsIGZ1bmN0aW9uIChmb290YWdlRGF0YSkge1xuICAgICAgICBvYi5pbWcgPSBmb290YWdlRGF0YTtcblxuICAgICAgICB0aGlzLl9mb290YWdlTG9hZGVkKCk7XG4gICAgICB9LmJpbmQodGhpcyksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2IuaW1nID0ge307XG5cbiAgICAgICAgdGhpcy5fZm9vdGFnZUxvYWRlZCgpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIHJldHVybiBvYjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkQXNzZXRzKGFzc2V0cywgY2IpIHtcbiAgICAgIHRoaXMuaW1hZ2VzTG9hZGVkQ2IgPSBjYjtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IGFzc2V0cy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoIWFzc2V0c1tpXS5sYXllcnMpIHtcbiAgICAgICAgICBpZiAoIWFzc2V0c1tpXS50IHx8IGFzc2V0c1tpXS50ID09PSAnc2VxJykge1xuICAgICAgICAgICAgdGhpcy50b3RhbEltYWdlcyArPSAxO1xuICAgICAgICAgICAgdGhpcy5pbWFnZXMucHVzaCh0aGlzLl9jcmVhdGVJbWFnZURhdGEoYXNzZXRzW2ldKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChhc3NldHNbaV0udCA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy50b3RhbEZvb3RhZ2VzICs9IDE7XG4gICAgICAgICAgICB0aGlzLmltYWdlcy5wdXNoKHRoaXMuY3JlYXRlRm9vdGFnZURhdGEoYXNzZXRzW2ldKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0UGF0aChwYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSBwYXRoIHx8ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEFzc2V0c1BhdGgocGF0aCkge1xuICAgICAgdGhpcy5hc3NldHNQYXRoID0gcGF0aCB8fCAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBc3NldChhc3NldERhdGEpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmltYWdlcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGlmICh0aGlzLmltYWdlc1tpXS5hc3NldERhdGEgPT09IGFzc2V0RGF0YSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmltYWdlc1tpXS5pbWc7XG4gICAgICAgIH1cblxuICAgICAgICBpICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmltYWdlc0xvYWRlZENiID0gbnVsbDtcbiAgICAgIHRoaXMuaW1hZ2VzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZGVkSW1hZ2VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG90YWxJbWFnZXMgPT09IHRoaXMubG9hZGVkQXNzZXRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRlZEZvb3RhZ2VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG90YWxGb290YWdlcyA9PT0gdGhpcy5sb2FkZWRGb290YWdlc0NvdW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldENhY2hlVHlwZSh0eXBlLCBlbGVtZW50SGVscGVyKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudEhlbHBlciA9IGVsZW1lbnRIZWxwZXI7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUltYWdlRGF0YSA9IHRoaXMuY3JlYXRlSW1hZ2VEYXRhLmJpbmQodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jcmVhdGVJbWFnZURhdGEgPSB0aGlzLmNyZWF0ZUltZ0RhdGEuYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJbWFnZVByZWxvYWRlckZhY3RvcnkoKSB7XG4gICAgICB0aGlzLl9pbWFnZUxvYWRlZCA9IGltYWdlTG9hZGVkLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9mb290YWdlTG9hZGVkID0gZm9vdGFnZUxvYWRlZC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy50ZXN0SW1hZ2VMb2FkZWQgPSB0ZXN0SW1hZ2VMb2FkZWQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuY3JlYXRlRm9vdGFnZURhdGEgPSBjcmVhdGVGb290YWdlRGF0YS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5hc3NldHNQYXRoID0gJyc7XG4gICAgICB0aGlzLnBhdGggPSAnJztcbiAgICAgIHRoaXMudG90YWxJbWFnZXMgPSAwO1xuICAgICAgdGhpcy50b3RhbEZvb3RhZ2VzID0gMDtcbiAgICAgIHRoaXMubG9hZGVkQXNzZXRzID0gMDtcbiAgICAgIHRoaXMubG9hZGVkRm9vdGFnZXNDb3VudCA9IDA7XG4gICAgICB0aGlzLmltYWdlc0xvYWRlZENiID0gbnVsbDtcbiAgICAgIHRoaXMuaW1hZ2VzID0gW107XG4gICAgfVxuXG4gICAgSW1hZ2VQcmVsb2FkZXJGYWN0b3J5LnByb3RvdHlwZSA9IHtcbiAgICAgIGxvYWRBc3NldHM6IGxvYWRBc3NldHMsXG4gICAgICBzZXRBc3NldHNQYXRoOiBzZXRBc3NldHNQYXRoLFxuICAgICAgc2V0UGF0aDogc2V0UGF0aCxcbiAgICAgIGxvYWRlZEltYWdlczogbG9hZGVkSW1hZ2VzLFxuICAgICAgbG9hZGVkRm9vdGFnZXM6IGxvYWRlZEZvb3RhZ2VzLFxuICAgICAgZGVzdHJveTogZGVzdHJveSxcbiAgICAgIGdldEFzc2V0OiBnZXRBc3NldCxcbiAgICAgIGNyZWF0ZUltZ0RhdGE6IGNyZWF0ZUltZ0RhdGEsXG4gICAgICBjcmVhdGVJbWFnZURhdGE6IGNyZWF0ZUltYWdlRGF0YSxcbiAgICAgIGltYWdlTG9hZGVkOiBpbWFnZUxvYWRlZCxcbiAgICAgIGZvb3RhZ2VMb2FkZWQ6IGZvb3RhZ2VMb2FkZWQsXG4gICAgICBzZXRDYWNoZVR5cGU6IHNldENhY2hlVHlwZVxuICAgIH07XG4gICAgcmV0dXJuIEltYWdlUHJlbG9hZGVyRmFjdG9yeTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIEJhc2VFdmVudCgpIHt9XG5cbiAgQmFzZUV2ZW50LnByb3RvdHlwZSA9IHtcbiAgICB0cmlnZ2VyRXZlbnQ6IGZ1bmN0aW9uIHRyaWdnZXJFdmVudChldmVudE5hbWUsIGFyZ3MpIHtcbiAgICAgIGlmICh0aGlzLl9jYnNbZXZlbnROYW1lXSkge1xuICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2JzW2V2ZW50TmFtZV07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBjYWxsYmFja3NbaV0oYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCF0aGlzLl9jYnNbZXZlbnROYW1lXSkge1xuICAgICAgICB0aGlzLl9jYnNbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jYnNbZXZlbnROYW1lXS5wdXNoKGNhbGxiYWNrKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgfS5iaW5kKHRoaXMpO1xuICAgIH0sXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2Nic1tldmVudE5hbWVdID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fY2JzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5fY2JzW2V2ZW50TmFtZV0ubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2Nic1tldmVudE5hbWVdW2ldID09PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fY2JzW2V2ZW50TmFtZV0uc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICBsZW4gLT0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2Nic1tldmVudE5hbWVdLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX2Nic1tldmVudE5hbWVdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgbWFya2VyUGFyc2VyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHBhcnNlUGF5bG9hZExpbmVzKHBheWxvYWQpIHtcbiAgICAgIHZhciBsaW5lcyA9IHBheWxvYWQuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgdmFyIGtleXMgPSB7fTtcbiAgICAgIHZhciBsaW5lO1xuICAgICAgdmFyIGtleXNDb3VudCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGluZSA9IGxpbmVzW2ldLnNwbGl0KCc6Jyk7XG5cbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAga2V5c1tsaW5lWzBdXSA9IGxpbmVbMV0udHJpbSgpO1xuICAgICAgICAgIGtleXNDb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXlzQ291bnQgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoX21hcmtlcnMpIHtcbiAgICAgIHZhciBtYXJrZXJzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX21hcmtlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIF9tYXJrZXIgPSBfbWFya2Vyc1tpXTtcbiAgICAgICAgdmFyIG1hcmtlckRhdGEgPSB7XG4gICAgICAgICAgdGltZTogX21hcmtlci50bSxcbiAgICAgICAgICBkdXJhdGlvbjogX21hcmtlci5kclxuICAgICAgICB9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbWFya2VyRGF0YS5wYXlsb2FkID0gSlNPTi5wYXJzZShfbWFya2Vyc1tpXS5jbSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWFya2VyRGF0YS5wYXlsb2FkID0gcGFyc2VQYXlsb2FkTGluZXMoX21hcmtlcnNbaV0uY20pO1xuICAgICAgICAgIH0gY2F0Y2ggKF9fKSB7XG4gICAgICAgICAgICBtYXJrZXJEYXRhLnBheWxvYWQgPSB7XG4gICAgICAgICAgICAgIG5hbWU6IF9tYXJrZXJzW2ldLmNtXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtlcnMucHVzaChtYXJrZXJEYXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBQcm9qZWN0SW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG9zaXRpb24oY29tcCkge1xuICAgICAgdGhpcy5jb21wb3NpdGlvbnMucHVzaChjb21wKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gX3RoaXNQcm9qZWN0RnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmNvbXBvc2l0aW9ucy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICBpZiAodGhpcy5jb21wb3NpdGlvbnNbaV0uZGF0YSAmJiB0aGlzLmNvbXBvc2l0aW9uc1tpXS5kYXRhLm5tID09PSBuYW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb21wb3NpdGlvbnNbaV0ucHJlcGFyZUZyYW1lICYmIHRoaXMuY29tcG9zaXRpb25zW2ldLmRhdGEueHQpIHtcbiAgICAgICAgICAgICAgdGhpcy5jb21wb3NpdGlvbnNbaV0ucHJlcGFyZUZyYW1lKHRoaXMuY3VycmVudEZyYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9zaXRpb25zW2ldLmNvbXBJbnRlcmZhY2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIF90aGlzUHJvamVjdEZ1bmN0aW9uLmNvbXBvc2l0aW9ucyA9IFtdO1xuICAgICAgX3RoaXNQcm9qZWN0RnVuY3Rpb24uY3VycmVudEZyYW1lID0gMDtcbiAgICAgIF90aGlzUHJvamVjdEZ1bmN0aW9uLnJlZ2lzdGVyQ29tcG9zaXRpb24gPSByZWdpc3RlckNvbXBvc2l0aW9uO1xuICAgICAgcmV0dXJuIF90aGlzUHJvamVjdEZ1bmN0aW9uO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgcmVuZGVyZXJzID0ge307XG5cbiAgdmFyIHJlZ2lzdGVyUmVuZGVyZXIgPSBmdW5jdGlvbiByZWdpc3RlclJlbmRlcmVyKGtleSwgdmFsdWUpIHtcbiAgICByZW5kZXJlcnNba2V5XSA9IHZhbHVlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFJlbmRlcmVyKGtleSkge1xuICAgIHJldHVybiByZW5kZXJlcnNba2V5XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJlZ2lzdGVyZWRSZW5kZXJlcigpIHtcbiAgICAvLyBSZXR1cm5zIGNhbnZhcyBieSBkZWZhdWx0IGZvciBjb21wYXRpYmlsaXR5XG4gICAgaWYgKHJlbmRlcmVycy5jYW52YXMpIHtcbiAgICAgIHJldHVybiAnY2FudmFzJztcbiAgICB9IC8vIFJldHVybnMgYW55IHJlbmRlcmVyIHRoYXQgaXMgcmVnaXN0ZXJlZFxuXG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcmVuZGVyZXJzKSB7XG4gICAgICBpZiAocmVuZGVyZXJzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBmdW5jdGlvbiBfdHlwZW9mJDQob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YkNCA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mJDQgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZiQ0KG9iaik7IH1cblxuICB2YXIgQW5pbWF0aW9uSXRlbSA9IGZ1bmN0aW9uIEFuaW1hdGlvbkl0ZW0oKSB7XG4gICAgdGhpcy5fY2JzID0gW107XG4gICAgdGhpcy5uYW1lID0gJyc7XG4gICAgdGhpcy5wYXRoID0gJyc7XG4gICAgdGhpcy5pc0xvYWRlZCA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcbiAgICB0aGlzLmN1cnJlbnRSYXdGcmFtZSA9IDA7XG4gICAgdGhpcy5maXJzdEZyYW1lID0gMDtcbiAgICB0aGlzLnRvdGFsRnJhbWVzID0gMDtcbiAgICB0aGlzLmZyYW1lUmF0ZSA9IDA7XG4gICAgdGhpcy5mcmFtZU11bHQgPSAwO1xuICAgIHRoaXMucGxheVNwZWVkID0gMTtcbiAgICB0aGlzLnBsYXlEaXJlY3Rpb24gPSAxO1xuICAgIHRoaXMucGxheUNvdW50ID0gMDtcbiAgICB0aGlzLmFuaW1hdGlvbkRhdGEgPSB7fTtcbiAgICB0aGlzLmFzc2V0cyA9IFtdO1xuICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMuYXV0b3BsYXkgPSBmYWxzZTtcbiAgICB0aGlzLmxvb3AgPSB0cnVlO1xuICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuYW5pbWF0aW9uSUQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICB0aGlzLmFzc2V0c1BhdGggPSAnJztcbiAgICB0aGlzLnRpbWVDb21wbGV0ZWQgPSAwO1xuICAgIHRoaXMuc2VnbWVudFBvcyA9IDA7XG4gICAgdGhpcy5pc1N1YmZyYW1lRW5hYmxlZCA9IGdldFN1YmZyYW1lRW5hYmxlZCgpO1xuICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcbiAgICB0aGlzLl9pZGxlID0gdHJ1ZTtcbiAgICB0aGlzLl9jb21wbGV0ZWRMb29wID0gZmFsc2U7XG4gICAgdGhpcy5wcm9qZWN0SW50ZXJmYWNlID0gUHJvamVjdEludGVyZmFjZSgpO1xuICAgIHRoaXMuaW1hZ2VQcmVsb2FkZXIgPSBuZXcgSW1hZ2VQcmVsb2FkZXIoKTtcbiAgICB0aGlzLmF1ZGlvQ29udHJvbGxlciA9IGF1ZGlvQ29udHJvbGxlckZhY3RvcnkoKTtcbiAgICB0aGlzLm1hcmtlcnMgPSBbXTtcbiAgICB0aGlzLmNvbmZpZ0FuaW1hdGlvbiA9IHRoaXMuY29uZmlnQW5pbWF0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblNldHVwRXJyb3IgPSB0aGlzLm9uU2V0dXBFcnJvci5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25TZWdtZW50Q29tcGxldGUgPSB0aGlzLm9uU2VnbWVudENvbXBsZXRlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5kcmF3bkZyYW1lRXZlbnQgPSBuZXcgQk1FbnRlckZyYW1lRXZlbnQoJ2RyYXduRnJhbWUnLCAwLCAwLCAwKTtcbiAgICB0aGlzLmV4cHJlc3Npb25zUGx1Z2luID0gZ2V0RXhwcmVzc2lvbnNQbHVnaW4oKTtcbiAgfTtcblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFdmVudF0sIEFuaW1hdGlvbkl0ZW0pO1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldFBhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zLndyYXBwZXIgfHwgcGFyYW1zLmNvbnRhaW5lcikge1xuICAgICAgdGhpcy53cmFwcGVyID0gcGFyYW1zLndyYXBwZXIgfHwgcGFyYW1zLmNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICB2YXIgYW5pbVR5cGUgPSAnc3ZnJztcblxuICAgIGlmIChwYXJhbXMuYW5pbVR5cGUpIHtcbiAgICAgIGFuaW1UeXBlID0gcGFyYW1zLmFuaW1UeXBlO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zLnJlbmRlcmVyKSB7XG4gICAgICBhbmltVHlwZSA9IHBhcmFtcy5yZW5kZXJlcjtcbiAgICB9XG5cbiAgICB2YXIgUmVuZGVyZXJDbGFzcyA9IGdldFJlbmRlcmVyKGFuaW1UeXBlKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyQ2xhc3ModGhpcywgcGFyYW1zLnJlbmRlcmVyU2V0dGluZ3MpO1xuICAgIHRoaXMuaW1hZ2VQcmVsb2FkZXIuc2V0Q2FjaGVUeXBlKGFuaW1UeXBlLCB0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZGVmcyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRQcm9qZWN0SW50ZXJmYWNlKHRoaXMucHJvamVjdEludGVyZmFjZSk7XG4gICAgdGhpcy5hbmltVHlwZSA9IGFuaW1UeXBlO1xuXG4gICAgaWYgKHBhcmFtcy5sb29wID09PSAnJyB8fCBwYXJhbXMubG9vcCA9PT0gbnVsbCB8fCBwYXJhbXMubG9vcCA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcy5sb29wID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmxvb3AgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zLmxvb3AgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmxvb3AgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb29wID0gcGFyc2VJbnQocGFyYW1zLmxvb3AsIDEwKTtcbiAgICB9XG5cbiAgICB0aGlzLmF1dG9wbGF5ID0gJ2F1dG9wbGF5JyBpbiBwYXJhbXMgPyBwYXJhbXMuYXV0b3BsYXkgOiB0cnVlO1xuICAgIHRoaXMubmFtZSA9IHBhcmFtcy5uYW1lID8gcGFyYW1zLm5hbWUgOiAnJztcbiAgICB0aGlzLmF1dG9sb2FkU2VnbWVudHMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyYW1zLCAnYXV0b2xvYWRTZWdtZW50cycpID8gcGFyYW1zLmF1dG9sb2FkU2VnbWVudHMgOiB0cnVlO1xuICAgIHRoaXMuYXNzZXRzUGF0aCA9IHBhcmFtcy5hc3NldHNQYXRoO1xuICAgIHRoaXMuaW5pdGlhbFNlZ21lbnQgPSBwYXJhbXMuaW5pdGlhbFNlZ21lbnQ7XG5cbiAgICBpZiAocGFyYW1zLmF1ZGlvRmFjdG9yeSkge1xuICAgICAgdGhpcy5hdWRpb0NvbnRyb2xsZXIuc2V0QXVkaW9GYWN0b3J5KHBhcmFtcy5hdWRpb0ZhY3RvcnkpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuYW5pbWF0aW9uRGF0YSkge1xuICAgICAgdGhpcy5zZXR1cEFuaW1hdGlvbihwYXJhbXMuYW5pbWF0aW9uRGF0YSk7XG4gICAgfSBlbHNlIGlmIChwYXJhbXMucGF0aCkge1xuICAgICAgaWYgKHBhcmFtcy5wYXRoLmxhc3RJbmRleE9mKCdcXFxcJykgIT09IC0xKSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhcmFtcy5wYXRoLnN1YnN0cigwLCBwYXJhbXMucGF0aC5sYXN0SW5kZXhPZignXFxcXCcpICsgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhdGggPSBwYXJhbXMucGF0aC5zdWJzdHIoMCwgcGFyYW1zLnBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpbGVOYW1lID0gcGFyYW1zLnBhdGguc3Vic3RyKHBhcmFtcy5wYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICAgIHRoaXMuZmlsZU5hbWUgPSB0aGlzLmZpbGVOYW1lLnN1YnN0cigwLCB0aGlzLmZpbGVOYW1lLmxhc3RJbmRleE9mKCcuanNvbicpKTtcbiAgICAgIGRhdGFNYW5hZ2VyLmxvYWRBbmltYXRpb24ocGFyYW1zLnBhdGgsIHRoaXMuY29uZmlnQW5pbWF0aW9uLCB0aGlzLm9uU2V0dXBFcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLm9uU2V0dXBFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2RhdGFfZmFpbGVkJyk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0dXBBbmltYXRpb24gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRhdGFNYW5hZ2VyLmNvbXBsZXRlQW5pbWF0aW9uKGRhdGEsIHRoaXMuY29uZmlnQW5pbWF0aW9uKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gKHdyYXBwZXIsIGFuaW1hdGlvbkRhdGEpIHtcbiAgICBpZiAoYW5pbWF0aW9uRGF0YSkge1xuICAgICAgaWYgKF90eXBlb2YkNChhbmltYXRpb25EYXRhKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgYW5pbWF0aW9uRGF0YSA9IEpTT04ucGFyc2UoYW5pbWF0aW9uRGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgIHdyYXBwZXI6IHdyYXBwZXIsXG4gICAgICBhbmltYXRpb25EYXRhOiBhbmltYXRpb25EYXRhXG4gICAgfTtcbiAgICB2YXIgd3JhcHBlckF0dHJpYnV0ZXMgPSB3cmFwcGVyLmF0dHJpYnV0ZXM7XG4gICAgcGFyYW1zLnBhdGggPSB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbWF0aW9uLXBhdGgnKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbWF0aW9uLXBhdGgnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1wYXRoJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXBhdGgnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcGF0aCcpID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1wYXRoJykudmFsdWUgOiAnJztcbiAgICBwYXJhbXMuYW5pbVR5cGUgPSB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbS10eXBlJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tdHlwZScpLnZhbHVlIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXR5cGUnKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tdHlwZScpLnZhbHVlIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS10eXBlJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS10eXBlJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcmVuZGVyZXInKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcmVuZGVyZXInKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcmVuZGVyZXInKSA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcmVuZGVyZXInKS52YWx1ZSA6IGdldFJlZ2lzdGVyZWRSZW5kZXJlcigpIHx8ICdjYW52YXMnO1xuICAgIHZhciBsb29wID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tbG9vcCcpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLWxvb3AnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1sb29wJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLWxvb3AnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tbG9vcCcpID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1sb29wJykudmFsdWUgOiAnJztcblxuICAgIGlmIChsb29wID09PSAnZmFsc2UnKSB7XG4gICAgICBwYXJhbXMubG9vcCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAobG9vcCA9PT0gJ3RydWUnKSB7XG4gICAgICBwYXJhbXMubG9vcCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChsb29wICE9PSAnJykge1xuICAgICAgcGFyYW1zLmxvb3AgPSBwYXJzZUludChsb29wLCAxMCk7XG4gICAgfVxuXG4gICAgdmFyIGF1dG9wbGF5ID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tYXV0b3BsYXknKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbS1hdXRvcGxheScpLnZhbHVlIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLWF1dG9wbGF5JykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLWF1dG9wbGF5JykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLWF1dG9wbGF5JykgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLWF1dG9wbGF5JykudmFsdWUgOiB0cnVlO1xuICAgIHBhcmFtcy5hdXRvcGxheSA9IGF1dG9wbGF5ICE9PSAnZmFsc2UnO1xuICAgIHBhcmFtcy5uYW1lID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLW5hbWUnKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtbmFtZScpLnZhbHVlIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLW5hbWUnKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tbmFtZScpLnZhbHVlIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1uYW1lJykgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLW5hbWUnKS52YWx1ZSA6ICcnO1xuICAgIHZhciBwcmVyZW5kZXIgPSB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbS1wcmVyZW5kZXInKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbS1wcmVyZW5kZXInKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1wcmVyZW5kZXInKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcHJlcmVuZGVyJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLXByZXJlbmRlcicpID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1wcmVyZW5kZXInKS52YWx1ZSA6ICcnO1xuXG4gICAgaWYgKHByZXJlbmRlciA9PT0gJ2ZhbHNlJykge1xuICAgICAgcGFyYW1zLnByZXJlbmRlciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghcGFyYW1zLnBhdGgpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignZGVzdHJveScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFBhcmFtcyhwYXJhbXMpO1xuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5pbmNsdWRlTGF5ZXJzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5vcCA+IHRoaXMuYW5pbWF0aW9uRGF0YS5vcCkge1xuICAgICAgdGhpcy5hbmltYXRpb25EYXRhLm9wID0gZGF0YS5vcDtcbiAgICAgIHRoaXMudG90YWxGcmFtZXMgPSBNYXRoLmZsb29yKGRhdGEub3AgLSB0aGlzLmFuaW1hdGlvbkRhdGEuaXApO1xuICAgIH1cblxuICAgIHZhciBsYXllcnMgPSB0aGlzLmFuaW1hdGlvbkRhdGEubGF5ZXJzO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBsYXllcnMubGVuZ3RoO1xuICAgIHZhciBuZXdMYXllcnMgPSBkYXRhLmxheWVycztcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbiA9IG5ld0xheWVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgaWYgKGxheWVyc1tpXS5pZCA9PT0gbmV3TGF5ZXJzW2pdLmlkKSB7XG4gICAgICAgICAgbGF5ZXJzW2ldID0gbmV3TGF5ZXJzW2pdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkYXRhLmNoYXJzIHx8IGRhdGEuZm9udHMpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5hZGRDaGFycyhkYXRhLmNoYXJzKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5hZGRGb250cyhkYXRhLmZvbnRzLCB0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZGVmcyk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuYXNzZXRzKSB7XG4gICAgICBsZW4gPSBkYXRhLmFzc2V0cy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkRhdGEuYXNzZXRzLnB1c2goZGF0YS5hc3NldHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYW5pbWF0aW9uRGF0YS5fX2NvbXBsZXRlID0gZmFsc2U7XG4gICAgZGF0YU1hbmFnZXIuY29tcGxldGVBbmltYXRpb24odGhpcy5hbmltYXRpb25EYXRhLCB0aGlzLm9uU2VnbWVudENvbXBsZXRlKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5vblNlZ21lbnRDb21wbGV0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdGhpcy5hbmltYXRpb25EYXRhID0gZGF0YTtcbiAgICB2YXIgZXhwcmVzc2lvbnNQbHVnaW4gPSBnZXRFeHByZXNzaW9uc1BsdWdpbigpO1xuXG4gICAgaWYgKGV4cHJlc3Npb25zUGx1Z2luKSB7XG4gICAgICBleHByZXNzaW9uc1BsdWdpbi5pbml0RXhwcmVzc2lvbnModGhpcyk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkTmV4dFNlZ21lbnQoKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5sb2FkTmV4dFNlZ21lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlZ21lbnRzID0gdGhpcy5hbmltYXRpb25EYXRhLnNlZ21lbnRzO1xuXG4gICAgaWYgKCFzZWdtZW50cyB8fCBzZWdtZW50cy5sZW5ndGggPT09IDAgfHwgIXRoaXMuYXV0b2xvYWRTZWdtZW50cykge1xuICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhX3JlYWR5Jyk7XG4gICAgICB0aGlzLnRpbWVDb21wbGV0ZWQgPSB0aGlzLnRvdGFsRnJhbWVzO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHMuc2hpZnQoKTtcbiAgICB0aGlzLnRpbWVDb21wbGV0ZWQgPSBzZWdtZW50LnRpbWUgKiB0aGlzLmZyYW1lUmF0ZTtcbiAgICB2YXIgc2VnbWVudFBhdGggPSB0aGlzLnBhdGggKyB0aGlzLmZpbGVOYW1lICsgJ18nICsgdGhpcy5zZWdtZW50UG9zICsgJy5qc29uJztcbiAgICB0aGlzLnNlZ21lbnRQb3MgKz0gMTtcbiAgICBkYXRhTWFuYWdlci5sb2FkRGF0YShzZWdtZW50UGF0aCwgdGhpcy5pbmNsdWRlTGF5ZXJzLmJpbmQodGhpcyksIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignZGF0YV9mYWlsZWQnKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmxvYWRTZWdtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VnbWVudHMgPSB0aGlzLmFuaW1hdGlvbkRhdGEuc2VnbWVudHM7XG5cbiAgICBpZiAoIXNlZ21lbnRzKSB7XG4gICAgICB0aGlzLnRpbWVDb21wbGV0ZWQgPSB0aGlzLnRvdGFsRnJhbWVzO1xuICAgIH1cblxuICAgIHRoaXMubG9hZE5leHRTZWdtZW50KCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuaW1hZ2VzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHJpZ2dlcignbG9hZGVkX2ltYWdlcycpO1xuICAgIHRoaXMuY2hlY2tMb2FkZWQoKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5wcmVsb2FkSW1hZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaW1hZ2VQcmVsb2FkZXIuc2V0QXNzZXRzUGF0aCh0aGlzLmFzc2V0c1BhdGgpO1xuICAgIHRoaXMuaW1hZ2VQcmVsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgIHRoaXMuaW1hZ2VQcmVsb2FkZXIubG9hZEFzc2V0cyh0aGlzLmFuaW1hdGlvbkRhdGEuYXNzZXRzLCB0aGlzLmltYWdlc0xvYWRlZC5iaW5kKHRoaXMpKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5jb25maWdBbmltYXRpb24gPSBmdW5jdGlvbiAoYW5pbURhdGEpIHtcbiAgICBpZiAoIXRoaXMucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5hbmltYXRpb25EYXRhID0gYW5pbURhdGE7XG5cbiAgICAgIGlmICh0aGlzLmluaXRpYWxTZWdtZW50KSB7XG4gICAgICAgIHRoaXMudG90YWxGcmFtZXMgPSBNYXRoLmZsb29yKHRoaXMuaW5pdGlhbFNlZ21lbnRbMV0gLSB0aGlzLmluaXRpYWxTZWdtZW50WzBdKTtcbiAgICAgICAgdGhpcy5maXJzdEZyYW1lID0gTWF0aC5yb3VuZCh0aGlzLmluaXRpYWxTZWdtZW50WzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudG90YWxGcmFtZXMgPSBNYXRoLmZsb29yKHRoaXMuYW5pbWF0aW9uRGF0YS5vcCAtIHRoaXMuYW5pbWF0aW9uRGF0YS5pcCk7XG4gICAgICAgIHRoaXMuZmlyc3RGcmFtZSA9IE1hdGgucm91bmQodGhpcy5hbmltYXRpb25EYXRhLmlwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJlci5jb25maWdBbmltYXRpb24oYW5pbURhdGEpO1xuXG4gICAgICBpZiAoIWFuaW1EYXRhLmFzc2V0cykge1xuICAgICAgICBhbmltRGF0YS5hc3NldHMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hc3NldHMgPSB0aGlzLmFuaW1hdGlvbkRhdGEuYXNzZXRzO1xuICAgICAgdGhpcy5mcmFtZVJhdGUgPSB0aGlzLmFuaW1hdGlvbkRhdGEuZnI7XG4gICAgICB0aGlzLmZyYW1lTXVsdCA9IHRoaXMuYW5pbWF0aW9uRGF0YS5mciAvIDEwMDA7XG4gICAgICB0aGlzLnJlbmRlcmVyLnNlYXJjaEV4dHJhQ29tcG9zaXRpb25zKGFuaW1EYXRhLmFzc2V0cyk7XG4gICAgICB0aGlzLm1hcmtlcnMgPSBtYXJrZXJQYXJzZXIoYW5pbURhdGEubWFya2VycyB8fCBbXSk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NvbmZpZ19yZWFkeScpO1xuICAgICAgdGhpcy5wcmVsb2FkSW1hZ2VzKCk7XG4gICAgICB0aGlzLmxvYWRTZWdtZW50cygpO1xuICAgICAgdGhpcy51cGRhRnJhbWVNb2RpZmllcigpO1xuICAgICAgdGhpcy53YWl0Rm9yRm9udHNMb2FkZWQoKTtcblxuICAgICAgaWYgKHRoaXMuaXNQYXVzZWQpIHtcbiAgICAgICAgdGhpcy5hdWRpb0NvbnRyb2xsZXIucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy50cmlnZ2VyQ29uZmlnRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS53YWl0Rm9yRm9udHNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVuZGVyZXIuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5pc0xvYWRlZCkge1xuICAgICAgdGhpcy5jaGVja0xvYWRlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMud2FpdEZvckZvbnRzTG9hZGVkLmJpbmQodGhpcyksIDIwKTtcbiAgICB9XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuY2hlY2tMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzTG9hZGVkICYmIHRoaXMucmVuZGVyZXIuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5pc0xvYWRlZCAmJiAodGhpcy5pbWFnZVByZWxvYWRlci5sb2FkZWRJbWFnZXMoKSB8fCB0aGlzLnJlbmRlcmVyLnJlbmRlcmVyVHlwZSAhPT0gJ2NhbnZhcycpICYmIHRoaXMuaW1hZ2VQcmVsb2FkZXIubG9hZGVkRm9vdGFnZXMoKSkge1xuICAgICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XG4gICAgICB2YXIgZXhwcmVzc2lvbnNQbHVnaW4gPSBnZXRFeHByZXNzaW9uc1BsdWdpbigpO1xuXG4gICAgICBpZiAoZXhwcmVzc2lvbnNQbHVnaW4pIHtcbiAgICAgICAgZXhwcmVzc2lvbnNQbHVnaW4uaW5pdEV4cHJlc3Npb25zKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlcmVyLmluaXRJdGVtcygpO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignRE9NTG9hZGVkJyk7XG4gICAgICB9LmJpbmQodGhpcyksIDApO1xuICAgICAgdGhpcy5nb3RvRnJhbWUoKTtcblxuICAgICAgaWYgKHRoaXMuYXV0b3BsYXkpIHtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgLy8gQWRkaW5nIHRoaXMgdmFsaWRhdGlvbiBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgaW4gY2FzZSBhbiBldmVudCBvYmplY3Qgd2FzIGJlaW5nIHBhc3NlZCBkb3duXG4gICAgdmFyIF93aWR0aCA9IHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgPyB3aWR0aCA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBfaGVpZ2h0ID0gdHlwZW9mIGhlaWdodCA9PT0gJ251bWJlcicgPyBoZWlnaHQgOiB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lclNpemUoX3dpZHRoLCBfaGVpZ2h0KTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXRTdWJmcmFtZSA9IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgdGhpcy5pc1N1YmZyYW1lRW5hYmxlZCA9ICEhZmxhZztcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5nb3RvRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSB0aGlzLmlzU3ViZnJhbWVFbmFibGVkID8gdGhpcy5jdXJyZW50UmF3RnJhbWUgOiB+fnRoaXMuY3VycmVudFJhd0ZyYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWJpdHdpc2VcblxuICAgIGlmICh0aGlzLnRpbWVDb21wbGV0ZWQgIT09IHRoaXMudG90YWxGcmFtZXMgJiYgdGhpcy5jdXJyZW50RnJhbWUgPiB0aGlzLnRpbWVDb21wbGV0ZWQpIHtcbiAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gdGhpcy50aW1lQ29tcGxldGVkO1xuICAgIH1cblxuICAgIHRoaXMudHJpZ2dlcignZW50ZXJGcmFtZScpO1xuICAgIHRoaXMucmVuZGVyRnJhbWUoKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2RyYXduRnJhbWUnKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc0xvYWRlZCA9PT0gZmFsc2UgfHwgIXRoaXMucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuZXhwcmVzc2lvbnNQbHVnaW4pIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uc1BsdWdpbi5yZXNldEZyYW1lKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyRnJhbWUodGhpcy5jdXJyZW50RnJhbWUgKyB0aGlzLmZpcnN0RnJhbWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLnRyaWdnZXJSZW5kZXJGcmFtZUVycm9yKGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNQYXVzZWQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMudHJpZ2dlcignX3BsYXknKTtcbiAgICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLnJlc3VtZSgpO1xuXG4gICAgICBpZiAodGhpcy5faWRsZSkge1xuICAgICAgICB0aGlzLl9pZGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHJpZ2dlcignX2FjdGl2ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNQYXVzZWQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMudHJpZ2dlcignX3BhdXNlJyk7XG4gICAgICB0aGlzLl9pZGxlID0gdHJ1ZTtcbiAgICAgIHRoaXMudHJpZ2dlcignX2lkbGUnKTtcbiAgICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLnBhdXNlKCk7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnRvZ2dsZVBhdXNlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSAmJiB0aGlzLm5hbWUgIT09IG5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1BhdXNlZCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wYXVzZSgpO1xuICAgIHRoaXMucGxheUNvdW50ID0gMDtcbiAgICB0aGlzLl9jb21wbGV0ZWRMb29wID0gZmFsc2U7XG4gICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZSgwKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5nZXRNYXJrZXJEYXRhID0gZnVuY3Rpb24gKG1hcmtlck5hbWUpIHtcbiAgICB2YXIgbWFya2VyO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hcmtlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIG1hcmtlciA9IHRoaXMubWFya2Vyc1tpXTtcblxuICAgICAgaWYgKG1hcmtlci5wYXlsb2FkICYmIG1hcmtlci5wYXlsb2FkLm5hbWUgPT09IG1hcmtlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5nb1RvQW5kU3RvcCA9IGZ1bmN0aW9uICh2YWx1ZSwgaXNGcmFtZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBudW1WYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG5cbiAgICBpZiAoaXNOYU4obnVtVmFsdWUpKSB7XG4gICAgICB2YXIgbWFya2VyID0gdGhpcy5nZXRNYXJrZXJEYXRhKHZhbHVlKTtcblxuICAgICAgaWYgKG1hcmtlcikge1xuICAgICAgICB0aGlzLmdvVG9BbmRTdG9wKG1hcmtlci50aW1lLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRnJhbWUpIHtcbiAgICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKHZhbHVlICogdGhpcy5mcmFtZU1vZGlmaWVyKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhdXNlKCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ29Ub0FuZFBsYXkgPSBmdW5jdGlvbiAodmFsdWUsIGlzRnJhbWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAmJiB0aGlzLm5hbWUgIT09IG5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbnVtVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXG4gICAgaWYgKGlzTmFOKG51bVZhbHVlKSkge1xuICAgICAgdmFyIG1hcmtlciA9IHRoaXMuZ2V0TWFya2VyRGF0YSh2YWx1ZSk7XG5cbiAgICAgIGlmIChtYXJrZXIpIHtcbiAgICAgICAgaWYgKCFtYXJrZXIuZHVyYXRpb24pIHtcbiAgICAgICAgICB0aGlzLmdvVG9BbmRTdG9wKG1hcmtlci50aW1lLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBsYXlTZWdtZW50cyhbbWFya2VyLnRpbWUsIG1hcmtlci50aW1lICsgbWFya2VyLmR1cmF0aW9uXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nb1RvQW5kU3RvcChudW1WYWx1ZSwgaXNGcmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgdGhpcy5wbGF5KCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuYWR2YW5jZVRpbWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pc1BhdXNlZCA9PT0gdHJ1ZSB8fCB0aGlzLmlzTG9hZGVkID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0VmFsdWUgPSB0aGlzLmN1cnJlbnRSYXdGcmFtZSArIHZhbHVlICogdGhpcy5mcmFtZU1vZGlmaWVyO1xuICAgIHZhciBfaXNDb21wbGV0ZSA9IGZhbHNlOyAvLyBDaGVja2luZyBpZiBuZXh0VmFsdWUgPiB0b3RhbEZyYW1lcyAtIDEgZm9yIGFkZHJlc3Npbmcgbm9uIGxvb3BpbmcgYW5kIGxvb3BpbmcgYW5pbWF0aW9ucy5cbiAgICAvLyBJZiBhbmltYXRpb24gd29uJ3QgbG9vcCwgaXQgc2hvdWxkIHN0b3AgYXQgdG90YWxGcmFtZXMgLSAxLiBJZiBpdCB3aWxsIGxvb3AgaXQgc2hvdWxkIGNvbXBsZXRlIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGVuIGxvb3AuXG5cbiAgICBpZiAobmV4dFZhbHVlID49IHRoaXMudG90YWxGcmFtZXMgLSAxICYmIHRoaXMuZnJhbWVNb2RpZmllciA+IDApIHtcbiAgICAgIGlmICghdGhpcy5sb29wIHx8IHRoaXMucGxheUNvdW50ID09PSB0aGlzLmxvb3ApIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrU2VnbWVudHMobmV4dFZhbHVlID4gdGhpcy50b3RhbEZyYW1lcyA/IG5leHRWYWx1ZSAlIHRoaXMudG90YWxGcmFtZXMgOiAwKSkge1xuICAgICAgICAgIF9pc0NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICBuZXh0VmFsdWUgPSB0aGlzLnRvdGFsRnJhbWVzIC0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuZXh0VmFsdWUgPj0gdGhpcy50b3RhbEZyYW1lcykge1xuICAgICAgICB0aGlzLnBsYXlDb3VudCArPSAxO1xuXG4gICAgICAgIGlmICghdGhpcy5jaGVja1NlZ21lbnRzKG5leHRWYWx1ZSAlIHRoaXMudG90YWxGcmFtZXMpKSB7XG4gICAgICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZShuZXh0VmFsdWUgJSB0aGlzLnRvdGFsRnJhbWVzKTtcbiAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRMb29wID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2xvb3BDb21wbGV0ZScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKG5leHRWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0VmFsdWUgPCAwKSB7XG4gICAgICBpZiAoIXRoaXMuY2hlY2tTZWdtZW50cyhuZXh0VmFsdWUgJSB0aGlzLnRvdGFsRnJhbWVzKSkge1xuICAgICAgICBpZiAodGhpcy5sb29wICYmICEodGhpcy5wbGF5Q291bnQtLSA8PSAwICYmIHRoaXMubG9vcCAhPT0gdHJ1ZSkpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBsdXNwbHVzXG4gICAgICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZSh0aGlzLnRvdGFsRnJhbWVzICsgbmV4dFZhbHVlICUgdGhpcy50b3RhbEZyYW1lcyk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuX2NvbXBsZXRlZExvb3ApIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlZExvb3AgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2xvb3BDb21wbGV0ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfaXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgbmV4dFZhbHVlID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKG5leHRWYWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKF9pc0NvbXBsZXRlKSB7XG4gICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKG5leHRWYWx1ZSk7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NvbXBsZXRlJyk7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmFkanVzdFNlZ21lbnQgPSBmdW5jdGlvbiAoYXJyLCBvZmZzZXQpIHtcbiAgICB0aGlzLnBsYXlDb3VudCA9IDA7XG5cbiAgICBpZiAoYXJyWzFdIDwgYXJyWzBdKSB7XG4gICAgICBpZiAodGhpcy5mcmFtZU1vZGlmaWVyID4gMCkge1xuICAgICAgICBpZiAodGhpcy5wbGF5U3BlZWQgPCAwKSB7XG4gICAgICAgICAgdGhpcy5zZXRTcGVlZCgtdGhpcy5wbGF5U3BlZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2V0RGlyZWN0aW9uKC0xKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRvdGFsRnJhbWVzID0gYXJyWzBdIC0gYXJyWzFdO1xuICAgICAgdGhpcy50aW1lQ29tcGxldGVkID0gdGhpcy50b3RhbEZyYW1lcztcbiAgICAgIHRoaXMuZmlyc3RGcmFtZSA9IGFyclsxXTtcbiAgICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUodGhpcy50b3RhbEZyYW1lcyAtIDAuMDAxIC0gb2Zmc2V0KTtcbiAgICB9IGVsc2UgaWYgKGFyclsxXSA+IGFyclswXSkge1xuICAgICAgaWYgKHRoaXMuZnJhbWVNb2RpZmllciA8IDApIHtcbiAgICAgICAgaWYgKHRoaXMucGxheVNwZWVkIDwgMCkge1xuICAgICAgICAgIHRoaXMuc2V0U3BlZWQoLXRoaXMucGxheVNwZWVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNldERpcmVjdGlvbigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRvdGFsRnJhbWVzID0gYXJyWzFdIC0gYXJyWzBdO1xuICAgICAgdGhpcy50aW1lQ29tcGxldGVkID0gdGhpcy50b3RhbEZyYW1lcztcbiAgICAgIHRoaXMuZmlyc3RGcmFtZSA9IGFyclswXTtcbiAgICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUoMC4wMDEgKyBvZmZzZXQpO1xuICAgIH1cblxuICAgIHRoaXMudHJpZ2dlcignc2VnbWVudFN0YXJ0Jyk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0U2VnbWVudCA9IGZ1bmN0aW9uIChpbml0LCBlbmQpIHtcbiAgICB2YXIgcGVuZGluZ0ZyYW1lID0gLTE7XG5cbiAgICBpZiAodGhpcy5pc1BhdXNlZCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFJhd0ZyYW1lICsgdGhpcy5maXJzdEZyYW1lIDwgaW5pdCkge1xuICAgICAgICBwZW5kaW5nRnJhbWUgPSBpbml0O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRSYXdGcmFtZSArIHRoaXMuZmlyc3RGcmFtZSA+IGVuZCkge1xuICAgICAgICBwZW5kaW5nRnJhbWUgPSBlbmQgLSBpbml0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZmlyc3RGcmFtZSA9IGluaXQ7XG4gICAgdGhpcy50b3RhbEZyYW1lcyA9IGVuZCAtIGluaXQ7XG4gICAgdGhpcy50aW1lQ29tcGxldGVkID0gdGhpcy50b3RhbEZyYW1lcztcblxuICAgIGlmIChwZW5kaW5nRnJhbWUgIT09IC0xKSB7XG4gICAgICB0aGlzLmdvVG9BbmRTdG9wKHBlbmRpbmdGcmFtZSwgdHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnBsYXlTZWdtZW50cyA9IGZ1bmN0aW9uIChhcnIsIGZvcmNlRmxhZykge1xuICAgIGlmIChmb3JjZUZsYWcpIHtcbiAgICAgIHRoaXMuc2VnbWVudHMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZiQ0KGFyclswXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5zZWdtZW50cy5wdXNoKGFycltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VnbWVudHMucHVzaChhcnIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNlZ21lbnRzLmxlbmd0aCAmJiBmb3JjZUZsYWcpIHtcbiAgICAgIHRoaXMuYWRqdXN0U2VnbWVudCh0aGlzLnNlZ21lbnRzLnNoaWZ0KCksIDApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzUGF1c2VkKSB7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucmVzZXRTZWdtZW50cyA9IGZ1bmN0aW9uIChmb3JjZUZsYWcpIHtcbiAgICB0aGlzLnNlZ21lbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5zZWdtZW50cy5wdXNoKFt0aGlzLmFuaW1hdGlvbkRhdGEuaXAsIHRoaXMuYW5pbWF0aW9uRGF0YS5vcF0pO1xuXG4gICAgaWYgKGZvcmNlRmxhZykge1xuICAgICAgdGhpcy5jaGVja1NlZ21lbnRzKDApO1xuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5jaGVja1NlZ21lbnRzID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICAgIGlmICh0aGlzLnNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5hZGp1c3RTZWdtZW50KHRoaXMuc2VnbWVudHMuc2hpZnQoKSwgb2Zmc2V0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSAmJiB0aGlzLm5hbWUgIT09IG5hbWUgfHwgIXRoaXMucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2Rlc3Ryb3knKTtcbiAgICB0aGlzLl9jYnMgPSBudWxsO1xuICAgIHRoaXMub25FbnRlckZyYW1lID0gbnVsbDtcbiAgICB0aGlzLm9uTG9vcENvbXBsZXRlID0gbnVsbDtcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBudWxsO1xuICAgIHRoaXMub25TZWdtZW50U3RhcnQgPSBudWxsO1xuICAgIHRoaXMub25EZXN0cm95ID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLmV4cHJlc3Npb25zUGx1Z2luID0gbnVsbDtcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLnByb2plY3RJbnRlcmZhY2UgPSBudWxsO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5jdXJyZW50UmF3RnJhbWUgPSB2YWx1ZTtcbiAgICB0aGlzLmdvdG9GcmFtZSgpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldFNwZWVkID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMucGxheVNwZWVkID0gdmFsO1xuICAgIHRoaXMudXBkYUZyYW1lTW9kaWZpZXIoKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXREaXJlY3Rpb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdGhpcy5wbGF5RGlyZWN0aW9uID0gdmFsIDwgMCA/IC0xIDogMTtcbiAgICB0aGlzLnVwZGFGcmFtZU1vZGlmaWVyKCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0TG9vcCA9IGZ1bmN0aW9uIChpc0xvb3BpbmcpIHtcbiAgICB0aGlzLmxvb3AgPSBpc0xvb3Bpbmc7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0Vm9sdW1lID0gZnVuY3Rpb24gKHZhbCwgbmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLnNldFZvbHVtZSh2YWwpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmdldFZvbHVtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5hdWRpb0NvbnRyb2xsZXIuZ2V0Vm9sdW1lKCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUubXV0ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5hdWRpb0NvbnRyb2xsZXIubXV0ZSgpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnVubXV0ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5hdWRpb0NvbnRyb2xsZXIudW5tdXRlKCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUudXBkYUZyYW1lTW9kaWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mcmFtZU1vZGlmaWVyID0gdGhpcy5mcmFtZU11bHQgKiB0aGlzLnBsYXlTcGVlZCAqIHRoaXMucGxheURpcmVjdGlvbjtcbiAgICB0aGlzLmF1ZGlvQ29udHJvbGxlci5zZXRSYXRlKHRoaXMucGxheVNwZWVkICogdGhpcy5wbGF5RGlyZWN0aW9uKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhdGg7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ2V0QXNzZXRzUGF0aCA9IGZ1bmN0aW9uIChhc3NldERhdGEpIHtcbiAgICB2YXIgcGF0aCA9ICcnO1xuXG4gICAgaWYgKGFzc2V0RGF0YS5lKSB7XG4gICAgICBwYXRoID0gYXNzZXREYXRhLnA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFzc2V0c1BhdGgpIHtcbiAgICAgIHZhciBpbWFnZVBhdGggPSBhc3NldERhdGEucDtcblxuICAgICAgaWYgKGltYWdlUGF0aC5pbmRleE9mKCdpbWFnZXMvJykgIT09IC0xKSB7XG4gICAgICAgIGltYWdlUGF0aCA9IGltYWdlUGF0aC5zcGxpdCgnLycpWzFdO1xuICAgICAgfVxuXG4gICAgICBwYXRoID0gdGhpcy5hc3NldHNQYXRoICsgaW1hZ2VQYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgcGF0aCArPSBhc3NldERhdGEudSA/IGFzc2V0RGF0YS51IDogJyc7XG4gICAgICBwYXRoICs9IGFzc2V0RGF0YS5wO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmdldEFzc2V0RGF0YSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGhpcy5hc3NldHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGlmIChpZCA9PT0gdGhpcy5hc3NldHNbaV0uaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzZXRzW2ldO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLmhpZGUoKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVuZGVyZXIuc2hvdygpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmdldER1cmF0aW9uID0gZnVuY3Rpb24gKGlzRnJhbWUpIHtcbiAgICByZXR1cm4gaXNGcmFtZSA/IHRoaXMudG90YWxGcmFtZXMgOiB0aGlzLnRvdGFsRnJhbWVzIC8gdGhpcy5mcmFtZVJhdGU7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUudXBkYXRlRG9jdW1lbnREYXRhID0gZnVuY3Rpb24gKHBhdGgsIGRvY3VtZW50RGF0YSwgaW5kZXgpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnJlbmRlcmVyLmdldEVsZW1lbnRCeVBhdGgocGF0aCk7XG4gICAgICBlbGVtZW50LnVwZGF0ZURvY3VtZW50RGF0YShkb2N1bWVudERhdGEsIGluZGV4KTtcbiAgICB9IGNhdGNoIChlcnJvcikgey8vIFRPRE86IGRlY2lkZSBob3cgdG8gaGFuZGxlIGNhdGNoIGNhc2VcbiAgICB9XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHRoaXMuX2NicyAmJiB0aGlzLl9jYnNbbmFtZV0pIHtcbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlICdlbnRlckZyYW1lJzpcbiAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuYW1lLCBuZXcgQk1FbnRlckZyYW1lRXZlbnQobmFtZSwgdGhpcy5jdXJyZW50RnJhbWUsIHRoaXMudG90YWxGcmFtZXMsIHRoaXMuZnJhbWVNb2RpZmllcikpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RyYXduRnJhbWUnOlxuICAgICAgICAgIHRoaXMuZHJhd25GcmFtZUV2ZW50LmN1cnJlbnRUaW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG4gICAgICAgICAgdGhpcy5kcmF3bkZyYW1lRXZlbnQudG90YWxUaW1lID0gdGhpcy50b3RhbEZyYW1lcztcbiAgICAgICAgICB0aGlzLmRyYXduRnJhbWVFdmVudC5kaXJlY3Rpb24gPSB0aGlzLmZyYW1lTW9kaWZpZXI7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmFtZSwgdGhpcy5kcmF3bkZyYW1lRXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2xvb3BDb21wbGV0ZSc6XG4gICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmFtZSwgbmV3IEJNQ29tcGxldGVMb29wRXZlbnQobmFtZSwgdGhpcy5sb29wLCB0aGlzLnBsYXlDb3VudCwgdGhpcy5mcmFtZU11bHQpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjb21wbGV0ZSc6XG4gICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmFtZSwgbmV3IEJNQ29tcGxldGVFdmVudChuYW1lLCB0aGlzLmZyYW1lTXVsdCkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NlZ21lbnRTdGFydCc6XG4gICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmFtZSwgbmV3IEJNU2VnbWVudFN0YXJ0RXZlbnQobmFtZSwgdGhpcy5maXJzdEZyYW1lLCB0aGlzLnRvdGFsRnJhbWVzKSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGVzdHJveSc6XG4gICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmFtZSwgbmV3IEJNRGVzdHJveUV2ZW50KG5hbWUsIHRoaXMpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAnZW50ZXJGcmFtZScgJiYgdGhpcy5vbkVudGVyRnJhbWUpIHtcbiAgICAgIHRoaXMub25FbnRlckZyYW1lLmNhbGwodGhpcywgbmV3IEJNRW50ZXJGcmFtZUV2ZW50KG5hbWUsIHRoaXMuY3VycmVudEZyYW1lLCB0aGlzLnRvdGFsRnJhbWVzLCB0aGlzLmZyYW1lTXVsdCkpO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAnbG9vcENvbXBsZXRlJyAmJiB0aGlzLm9uTG9vcENvbXBsZXRlKSB7XG4gICAgICB0aGlzLm9uTG9vcENvbXBsZXRlLmNhbGwodGhpcywgbmV3IEJNQ29tcGxldGVMb29wRXZlbnQobmFtZSwgdGhpcy5sb29wLCB0aGlzLnBsYXlDb3VudCwgdGhpcy5mcmFtZU11bHQpKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ2NvbXBsZXRlJyAmJiB0aGlzLm9uQ29tcGxldGUpIHtcbiAgICAgIHRoaXMub25Db21wbGV0ZS5jYWxsKHRoaXMsIG5ldyBCTUNvbXBsZXRlRXZlbnQobmFtZSwgdGhpcy5mcmFtZU11bHQpKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ3NlZ21lbnRTdGFydCcgJiYgdGhpcy5vblNlZ21lbnRTdGFydCkge1xuICAgICAgdGhpcy5vblNlZ21lbnRTdGFydC5jYWxsKHRoaXMsIG5ldyBCTVNlZ21lbnRTdGFydEV2ZW50KG5hbWUsIHRoaXMuZmlyc3RGcmFtZSwgdGhpcy50b3RhbEZyYW1lcykpO1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAnZGVzdHJveScgJiYgdGhpcy5vbkRlc3Ryb3kpIHtcbiAgICAgIHRoaXMub25EZXN0cm95LmNhbGwodGhpcywgbmV3IEJNRGVzdHJveUV2ZW50KG5hbWUsIHRoaXMpKTtcbiAgICB9XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUudHJpZ2dlclJlbmRlckZyYW1lRXJyb3IgPSBmdW5jdGlvbiAobmF0aXZlRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgQk1SZW5kZXJGcmFtZUVycm9yRXZlbnQobmF0aXZlRXJyb3IsIHRoaXMuY3VycmVudEZyYW1lKTtcbiAgICB0aGlzLnRyaWdnZXJFdmVudCgnZXJyb3InLCBlcnJvcik7XG5cbiAgICBpZiAodGhpcy5vbkVycm9yKSB7XG4gICAgICB0aGlzLm9uRXJyb3IuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnRyaWdnZXJDb25maWdFcnJvciA9IGZ1bmN0aW9uIChuYXRpdmVFcnJvcikge1xuICAgIHZhciBlcnJvciA9IG5ldyBCTUNvbmZpZ0Vycm9yRXZlbnQobmF0aXZlRXJyb3IsIHRoaXMuY3VycmVudEZyYW1lKTtcbiAgICB0aGlzLnRyaWdnZXJFdmVudCgnZXJyb3InLCBlcnJvcik7XG5cbiAgICBpZiAodGhpcy5vbkVycm9yKSB7XG4gICAgICB0aGlzLm9uRXJyb3IuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBhbmltYXRpb25NYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2R1bGVPYiA9IHt9O1xuICAgIHZhciByZWdpc3RlcmVkQW5pbWF0aW9ucyA9IFtdO1xuICAgIHZhciBpbml0VGltZSA9IDA7XG4gICAgdmFyIGxlbiA9IDA7XG4gICAgdmFyIHBsYXlpbmdBbmltYXRpb25zTnVtID0gMDtcbiAgICB2YXIgX3N0b3BwZWQgPSB0cnVlO1xuICAgIHZhciBfaXNGcm96ZW4gPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZXYpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBhbmltSXRlbSA9IGV2LnRhcmdldDtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbiA9PT0gYW5pbUl0ZW0pIHtcbiAgICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgIGxlbiAtPSAxO1xuXG4gICAgICAgICAgaWYgKCFhbmltSXRlbS5pc1BhdXNlZCkge1xuICAgICAgICAgICAgc3VidHJhY3RQbGF5aW5nQ291bnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpICs9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJBbmltYXRpb24oZWxlbWVudCwgYW5pbWF0aW9uRGF0YSkge1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGlmIChyZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5lbGVtID09PSBlbGVtZW50ICYmIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmVsZW0gIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgYW5pbUl0ZW0gPSBuZXcgQW5pbWF0aW9uSXRlbSgpO1xuICAgICAgc2V0dXBBbmltYXRpb24oYW5pbUl0ZW0sIGVsZW1lbnQpO1xuICAgICAgYW5pbUl0ZW0uc2V0RGF0YShlbGVtZW50LCBhbmltYXRpb25EYXRhKTtcbiAgICAgIHJldHVybiBhbmltSXRlbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRSZWdpc3RlcmVkQW5pbWF0aW9ucygpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbkFuaW1zID0gcmVnaXN0ZXJlZEFuaW1hdGlvbnMubGVuZ3RoO1xuICAgICAgdmFyIGFuaW1hdGlvbnMgPSBbXTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbkFuaW1zOyBpICs9IDEpIHtcbiAgICAgICAgYW5pbWF0aW9ucy5wdXNoKHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbmltYXRpb25zO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFBsYXlpbmdDb3VudCgpIHtcbiAgICAgIHBsYXlpbmdBbmltYXRpb25zTnVtICs9IDE7XG4gICAgICBhY3RpdmF0ZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0UGxheWluZ0NvdW50KCkge1xuICAgICAgcGxheWluZ0FuaW1hdGlvbnNOdW0gLT0gMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXR1cEFuaW1hdGlvbihhbmltSXRlbSwgZWxlbWVudCkge1xuICAgICAgYW5pbUl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignZGVzdHJveScsIHJlbW92ZUVsZW1lbnQpO1xuICAgICAgYW5pbUl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignX2FjdGl2ZScsIGFkZFBsYXlpbmdDb3VudCk7XG4gICAgICBhbmltSXRlbS5hZGRFdmVudExpc3RlbmVyKCdfaWRsZScsIHN1YnRyYWN0UGxheWluZ0NvdW50KTtcbiAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zLnB1c2goe1xuICAgICAgICBlbGVtOiBlbGVtZW50LFxuICAgICAgICBhbmltYXRpb246IGFuaW1JdGVtXG4gICAgICB9KTtcbiAgICAgIGxlbiArPSAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRBbmltYXRpb24ocGFyYW1zKSB7XG4gICAgICB2YXIgYW5pbUl0ZW0gPSBuZXcgQW5pbWF0aW9uSXRlbSgpO1xuICAgICAgc2V0dXBBbmltYXRpb24oYW5pbUl0ZW0sIG51bGwpO1xuICAgICAgYW5pbUl0ZW0uc2V0UGFyYW1zKHBhcmFtcyk7XG4gICAgICByZXR1cm4gYW5pbUl0ZW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0U3BlZWQodmFsLCBhbmltYXRpb24pIHtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnNldFNwZWVkKHZhbCwgYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXREaXJlY3Rpb24odmFsLCBhbmltYXRpb24pIHtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnNldERpcmVjdGlvbih2YWwsIGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGxheShhbmltYXRpb24pIHtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnBsYXkoYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXN1bWUobm93VGltZSkge1xuICAgICAgdmFyIGVsYXBzZWRUaW1lID0gbm93VGltZSAtIGluaXRUaW1lO1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24uYWR2YW5jZVRpbWUoZWxhcHNlZFRpbWUpO1xuICAgICAgfVxuXG4gICAgICBpbml0VGltZSA9IG5vd1RpbWU7XG5cbiAgICAgIGlmIChwbGF5aW5nQW5pbWF0aW9uc051bSAmJiAhX2lzRnJvemVuKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVzdW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaXJzdChub3dUaW1lKSB7XG4gICAgICBpbml0VGltZSA9IG5vd1RpbWU7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc3VtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGF1c2UoYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5wYXVzZShhbmltYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdvVG9BbmRTdG9wKHZhbHVlLCBpc0ZyYW1lLCBhbmltYXRpb24pIHtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLmdvVG9BbmRTdG9wKHZhbHVlLCBpc0ZyYW1lLCBhbmltYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0b3AoYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5zdG9wKGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9nZ2xlUGF1c2UoYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi50b2dnbGVQYXVzZShhbmltYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLmRlc3Ryb3koYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZWFyY2hBbmltYXRpb25zKGFuaW1hdGlvbkRhdGEsIHN0YW5kYWxvbmUsIHJlbmRlcmVyKSB7XG4gICAgICB2YXIgYW5pbUVsZW1lbnRzID0gW10uY29uY2F0KFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbG90dGllJykpLCBbXS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2JvZHltb3ZpbicpKSk7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW5BbmltcyA9IGFuaW1FbGVtZW50cy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5BbmltczsgaSArPSAxKSB7XG4gICAgICAgIGlmIChyZW5kZXJlcikge1xuICAgICAgICAgIGFuaW1FbGVtZW50c1tpXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtYm0tdHlwZScsIHJlbmRlcmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVyQW5pbWF0aW9uKGFuaW1FbGVtZW50c1tpXSwgYW5pbWF0aW9uRGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFuZGFsb25lICYmIGxlbkFuaW1zID09PSAwKSB7XG4gICAgICAgIGlmICghcmVuZGVyZXIpIHtcbiAgICAgICAgICByZW5kZXJlciA9ICdzdmcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdO1xuICAgICAgICBib2R5LmlubmVyVGV4dCA9ICcnO1xuICAgICAgICB2YXIgZGl2ID0gY3JlYXRlVGFnKCdkaXYnKTtcbiAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdkYXRhLWJtLXR5cGUnLCByZW5kZXJlcik7XG4gICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgcmVnaXN0ZXJBbmltYXRpb24oZGl2LCBhbmltYXRpb25EYXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5yZXNpemUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhY3RpdmF0ZSgpIHtcbiAgICAgIGlmICghX2lzRnJvemVuICYmIHBsYXlpbmdBbmltYXRpb25zTnVtKSB7XG4gICAgICAgIGlmIChfc3RvcHBlZCkge1xuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZmlyc3QpO1xuICAgICAgICAgIF9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcmVlemUoKSB7XG4gICAgICBfaXNGcm96ZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuZnJlZXplKCkge1xuICAgICAgX2lzRnJvemVuID0gZmFsc2U7XG4gICAgICBhY3RpdmF0ZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFZvbHVtZSh2YWwsIGFuaW1hdGlvbikge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24uc2V0Vm9sdW1lKHZhbCwgYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtdXRlKGFuaW1hdGlvbikge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24ubXV0ZShhbmltYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVubXV0ZShhbmltYXRpb24pIHtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnVubXV0ZShhbmltYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZU9iLnJlZ2lzdGVyQW5pbWF0aW9uID0gcmVnaXN0ZXJBbmltYXRpb247XG4gICAgbW9kdWxlT2IubG9hZEFuaW1hdGlvbiA9IGxvYWRBbmltYXRpb247XG4gICAgbW9kdWxlT2Iuc2V0U3BlZWQgPSBzZXRTcGVlZDtcbiAgICBtb2R1bGVPYi5zZXREaXJlY3Rpb24gPSBzZXREaXJlY3Rpb247XG4gICAgbW9kdWxlT2IucGxheSA9IHBsYXk7XG4gICAgbW9kdWxlT2IucGF1c2UgPSBwYXVzZTtcbiAgICBtb2R1bGVPYi5zdG9wID0gc3RvcDtcbiAgICBtb2R1bGVPYi50b2dnbGVQYXVzZSA9IHRvZ2dsZVBhdXNlO1xuICAgIG1vZHVsZU9iLnNlYXJjaEFuaW1hdGlvbnMgPSBzZWFyY2hBbmltYXRpb25zO1xuICAgIG1vZHVsZU9iLnJlc2l6ZSA9IHJlc2l6ZTsgLy8gbW9kdWxlT2Iuc3RhcnQgPSBzdGFydDtcblxuICAgIG1vZHVsZU9iLmdvVG9BbmRTdG9wID0gZ29Ub0FuZFN0b3A7XG4gICAgbW9kdWxlT2IuZGVzdHJveSA9IGRlc3Ryb3k7XG4gICAgbW9kdWxlT2IuZnJlZXplID0gZnJlZXplO1xuICAgIG1vZHVsZU9iLnVuZnJlZXplID0gdW5mcmVlemU7XG4gICAgbW9kdWxlT2Iuc2V0Vm9sdW1lID0gc2V0Vm9sdW1lO1xuICAgIG1vZHVsZU9iLm11dGUgPSBtdXRlO1xuICAgIG1vZHVsZU9iLnVubXV0ZSA9IHVubXV0ZTtcbiAgICBtb2R1bGVPYi5nZXRSZWdpc3RlcmVkQW5pbWF0aW9ucyA9IGdldFJlZ2lzdGVyZWRBbmltYXRpb25zO1xuICAgIHJldHVybiBtb2R1bGVPYjtcbiAgfSgpO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlICovXG4gIHZhciBCZXppZXJGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxyXG4gICAgICAgKiBCZXppZXJFYXNpbmcgLSB1c2UgYmV6aWVyIGN1cnZlIGZvciB0cmFuc2l0aW9uIGVhc2luZyBmdW5jdGlvblxyXG4gICAgICAgKiBieSBHYcOrdGFuIFJlbmF1ZGVhdSAyMDE0IC0gMjAxNSDigJMgTUlUIExpY2Vuc2VcclxuICAgICAgICpcclxuICAgICAgICogQ3JlZGl0czogaXMgYmFzZWQgb24gRmlyZWZveCdzIG5zU01JTEtleVNwbGluZS5jcHBcclxuICAgICAgICogVXNhZ2U6XHJcbiAgICAgICAqIHZhciBzcGxpbmUgPSBCZXppZXJFYXNpbmcoWyAwLjI1LCAwLjEsIDAuMjUsIDEuMCBdKVxyXG4gICAgICAgKiBzcGxpbmUuZ2V0KHgpID0+IHJldHVybnMgdGhlIGVhc2luZyB2YWx1ZSB8IHggbXVzdCBiZSBpbiBbMCwgMV0gcmFuZ2VcclxuICAgICAgICpcclxuICAgICAgICovXG4gICAgdmFyIG9iID0ge307XG4gICAgb2IuZ2V0QmV6aWVyRWFzaW5nID0gZ2V0QmV6aWVyRWFzaW5nO1xuICAgIHZhciBiZXppZXJzID0ge307XG5cbiAgICBmdW5jdGlvbiBnZXRCZXppZXJFYXNpbmcoYSwgYiwgYywgZCwgbm0pIHtcbiAgICAgIHZhciBzdHIgPSBubSB8fCAoJ2Jlel8nICsgYSArICdfJyArIGIgKyAnXycgKyBjICsgJ18nICsgZCkucmVwbGFjZSgvXFwuL2csICdwJyk7XG5cbiAgICAgIGlmIChiZXppZXJzW3N0cl0pIHtcbiAgICAgICAgcmV0dXJuIGJlemllcnNbc3RyXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJlekVhc2luZyA9IG5ldyBCZXppZXJFYXNpbmcoW2EsIGIsIGMsIGRdKTtcbiAgICAgIGJlemllcnNbc3RyXSA9IGJlekVhc2luZztcbiAgICAgIHJldHVybiBiZXpFYXNpbmc7XG4gICAgfSAvLyBUaGVzZSB2YWx1ZXMgYXJlIGVzdGFibGlzaGVkIGJ5IGVtcGlyaWNpc20gd2l0aCB0ZXN0cyAodHJhZGVvZmY6IHBlcmZvcm1hbmNlIFZTIHByZWNpc2lvbilcblxuXG4gICAgdmFyIE5FV1RPTl9JVEVSQVRJT05TID0gNDtcbiAgICB2YXIgTkVXVE9OX01JTl9TTE9QRSA9IDAuMDAxO1xuICAgIHZhciBTVUJESVZJU0lPTl9QUkVDSVNJT04gPSAwLjAwMDAwMDE7XG4gICAgdmFyIFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TID0gMTA7XG4gICAgdmFyIGtTcGxpbmVUYWJsZVNpemUgPSAxMTtcbiAgICB2YXIga1NhbXBsZVN0ZXBTaXplID0gMS4wIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxLjApO1xuICAgIHZhciBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAnZnVuY3Rpb24nO1xuXG4gICAgZnVuY3Rpb24gQShhQTEsIGFBMikge1xuICAgICAgcmV0dXJuIDEuMCAtIDMuMCAqIGFBMiArIDMuMCAqIGFBMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBCKGFBMSwgYUEyKSB7XG4gICAgICByZXR1cm4gMy4wICogYUEyIC0gNi4wICogYUExO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEMoYUExKSB7XG4gICAgICByZXR1cm4gMy4wICogYUExO1xuICAgIH0gLy8gUmV0dXJucyB4KHQpIGdpdmVuIHQsIHgxLCBhbmQgeDIsIG9yIHkodCkgZ2l2ZW4gdCwgeTEsIGFuZCB5Mi5cblxuXG4gICAgZnVuY3Rpb24gY2FsY0JlemllcihhVCwgYUExLCBhQTIpIHtcbiAgICAgIHJldHVybiAoKEEoYUExLCBhQTIpICogYVQgKyBCKGFBMSwgYUEyKSkgKiBhVCArIEMoYUExKSkgKiBhVDtcbiAgICB9IC8vIFJldHVybnMgZHgvZHQgZ2l2ZW4gdCwgeDEsIGFuZCB4Miwgb3IgZHkvZHQgZ2l2ZW4gdCwgeTEsIGFuZCB5Mi5cblxuXG4gICAgZnVuY3Rpb24gZ2V0U2xvcGUoYVQsIGFBMSwgYUEyKSB7XG4gICAgICByZXR1cm4gMy4wICogQShhQTEsIGFBMikgKiBhVCAqIGFUICsgMi4wICogQihhQTEsIGFBMikgKiBhVCArIEMoYUExKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUoYVgsIGFBLCBhQiwgbVgxLCBtWDIpIHtcbiAgICAgIHZhciBjdXJyZW50WCxcbiAgICAgICAgICBjdXJyZW50VCxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgZG8ge1xuICAgICAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMi4wO1xuICAgICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuXG4gICAgICAgIGlmIChjdXJyZW50WCA+IDAuMCkge1xuICAgICAgICAgIGFCID0gY3VycmVudFQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoTWF0aC5hYnMoY3VycmVudFgpID4gU1VCRElWSVNJT05fUFJFQ0lTSU9OICYmICsraSA8IFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TKTtcblxuICAgICAgcmV0dXJuIGN1cnJlbnRUO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NULCBtWDEsIG1YMikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBORVdUT05fSVRFUkFUSU9OUzsgKytpKSB7XG4gICAgICAgIHZhciBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG4gICAgICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDAuMCkgcmV0dXJuIGFHdWVzc1Q7XG4gICAgICAgIHZhciBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhR3Vlc3NUO1xuICAgIH1cbiAgICAvKipcclxuICAgICAgICogcG9pbnRzIGlzIGFuIGFycmF5IG9mIFsgbVgxLCBtWTEsIG1YMiwgbVkyIF1cclxuICAgICAgICovXG5cblxuICAgIGZ1bmN0aW9uIEJlemllckVhc2luZyhwb2ludHMpIHtcbiAgICAgIHRoaXMuX3AgPSBwb2ludHM7XG4gICAgICB0aGlzLl9tU2FtcGxlVmFsdWVzID0gZmxvYXQzMkFycmF5U3VwcG9ydGVkID8gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKSA6IG5ldyBBcnJheShrU3BsaW5lVGFibGVTaXplKTtcbiAgICAgIHRoaXMuX3ByZWNvbXB1dGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmdldCA9IHRoaXMuZ2V0LmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgQmV6aWVyRWFzaW5nLnByb3RvdHlwZSA9IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KHgpIHtcbiAgICAgICAgdmFyIG1YMSA9IHRoaXMuX3BbMF0sXG4gICAgICAgICAgICBtWTEgPSB0aGlzLl9wWzFdLFxuICAgICAgICAgICAgbVgyID0gdGhpcy5fcFsyXSxcbiAgICAgICAgICAgIG1ZMiA9IHRoaXMuX3BbM107XG4gICAgICAgIGlmICghdGhpcy5fcHJlY29tcHV0ZWQpIHRoaXMuX3ByZWNvbXB1dGUoKTtcbiAgICAgICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSByZXR1cm4geDsgLy8gbGluZWFyXG4gICAgICAgIC8vIEJlY2F1c2UgSmF2YVNjcmlwdCBudW1iZXIgYXJlIGltcHJlY2lzZSwgd2Ugc2hvdWxkIGd1YXJhbnRlZSB0aGUgZXh0cmVtZXMgYXJlIHJpZ2h0LlxuXG4gICAgICAgIGlmICh4ID09PSAwKSByZXR1cm4gMDtcbiAgICAgICAgaWYgKHggPT09IDEpIHJldHVybiAxO1xuICAgICAgICByZXR1cm4gY2FsY0Jlemllcih0aGlzLl9nZXRURm9yWCh4KSwgbVkxLCBtWTIpO1xuICAgICAgfSxcbiAgICAgIC8vIFByaXZhdGUgcGFydFxuICAgICAgX3ByZWNvbXB1dGU6IGZ1bmN0aW9uIF9wcmVjb21wdXRlKCkge1xuICAgICAgICB2YXIgbVgxID0gdGhpcy5fcFswXSxcbiAgICAgICAgICAgIG1ZMSA9IHRoaXMuX3BbMV0sXG4gICAgICAgICAgICBtWDIgPSB0aGlzLl9wWzJdLFxuICAgICAgICAgICAgbVkyID0gdGhpcy5fcFszXTtcbiAgICAgICAgdGhpcy5fcHJlY29tcHV0ZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuICAgICAgICAgIHRoaXMuX2NhbGNTYW1wbGVWYWx1ZXMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jYWxjU2FtcGxlVmFsdWVzOiBmdW5jdGlvbiBfY2FsY1NhbXBsZVZhbHVlcygpIHtcbiAgICAgICAgdmFyIG1YMSA9IHRoaXMuX3BbMF0sXG4gICAgICAgICAgICBtWDIgPSB0aGlzLl9wWzJdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga1NwbGluZVRhYmxlU2l6ZTsgKytpKSB7XG4gICAgICAgICAgdGhpcy5fbVNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcclxuICAgICAgICAgICAqIGdldFRGb3JYIGNob3NlIHRoZSBmYXN0ZXN0IGhldXJpc3RpYyB0byBkZXRlcm1pbmUgdGhlIHBlcmNlbnRhZ2UgdmFsdWUgcHJlY2lzZWx5IGZyb20gYSBnaXZlbiBYIHByb2plY3Rpb24uXHJcbiAgICAgICAgICAgKi9cbiAgICAgIF9nZXRURm9yWDogZnVuY3Rpb24gX2dldFRGb3JYKGFYKSB7XG4gICAgICAgIHZhciBtWDEgPSB0aGlzLl9wWzBdLFxuICAgICAgICAgICAgbVgyID0gdGhpcy5fcFsyXSxcbiAgICAgICAgICAgIG1TYW1wbGVWYWx1ZXMgPSB0aGlzLl9tU2FtcGxlVmFsdWVzO1xuICAgICAgICB2YXIgaW50ZXJ2YWxTdGFydCA9IDAuMDtcbiAgICAgICAgdmFyIGN1cnJlbnRTYW1wbGUgPSAxO1xuICAgICAgICB2YXIgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuXG4gICAgICAgIGZvciAoOyBjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgICAgIGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgLS1jdXJyZW50U2FtcGxlOyAvLyBJbnRlcnBvbGF0ZSB0byBwcm92aWRlIGFuIGluaXRpYWwgZ3Vlc3MgZm9yIHRcblxuICAgICAgICB2YXIgZGlzdCA9IChhWCAtIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pIC8gKG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XG4gICAgICAgIHZhciBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZTtcbiAgICAgICAgdmFyIGluaXRpYWxTbG9wZSA9IGdldFNsb3BlKGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuXG4gICAgICAgIGlmIChpbml0aWFsU2xvcGUgPj0gTkVXVE9OX01JTl9TTE9QRSkge1xuICAgICAgICAgIHJldHVybiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5pdGlhbFNsb3BlID09PSAwLjApIHtcbiAgICAgICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG9iO1xuICB9KCk7XG5cbiAgdmFyIHBvb2xpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX2RvdWJsZShhcnIpIHtcbiAgICAgIHJldHVybiBhcnIuY29uY2F0KGNyZWF0ZVNpemVkQXJyYXkoYXJyLmxlbmd0aCkpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBcImRvdWJsZVwiOiBfZG91YmxlXG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBwb29sRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluaXRpYWxMZW5ndGgsIF9jcmVhdGUsIF9yZWxlYXNlKSB7XG4gICAgICB2YXIgX2xlbmd0aCA9IDA7XG4gICAgICB2YXIgX21heExlbmd0aCA9IGluaXRpYWxMZW5ndGg7XG4gICAgICB2YXIgcG9vbCA9IGNyZWF0ZVNpemVkQXJyYXkoX21heExlbmd0aCk7XG4gICAgICB2YXIgb2IgPSB7XG4gICAgICAgIG5ld0VsZW1lbnQ6IG5ld0VsZW1lbnQsXG4gICAgICAgIHJlbGVhc2U6IHJlbGVhc2VcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIG5ld0VsZW1lbnQoKSB7XG4gICAgICAgIHZhciBlbGVtZW50O1xuXG4gICAgICAgIGlmIChfbGVuZ3RoKSB7XG4gICAgICAgICAgX2xlbmd0aCAtPSAxO1xuICAgICAgICAgIGVsZW1lbnQgPSBwb29sW19sZW5ndGhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnQgPSBfY3JlYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVsZWFzZShlbGVtZW50KSB7XG4gICAgICAgIGlmIChfbGVuZ3RoID09PSBfbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgcG9vbCA9IHBvb2xpbmdbXCJkb3VibGVcIl0ocG9vbCk7XG4gICAgICAgICAgX21heExlbmd0aCAqPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9yZWxlYXNlKSB7XG4gICAgICAgICAgX3JlbGVhc2UoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBwb29sW19sZW5ndGhdID0gZWxlbWVudDtcbiAgICAgICAgX2xlbmd0aCArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2I7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBiZXppZXJMZW5ndGhQb29sID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZGVkTGVuZ3RoOiAwLFxuICAgICAgICBwZXJjZW50czogY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGdldERlZmF1bHRDdXJ2ZVNlZ21lbnRzKCkpLFxuICAgICAgICBsZW5ndGhzOiBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgZ2V0RGVmYXVsdEN1cnZlU2VnbWVudHMoKSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvb2xGYWN0b3J5KDgsIGNyZWF0ZSk7XG4gIH0oKTtcblxuICB2YXIgc2VnbWVudHNMZW5ndGhQb29sID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlbmd0aHM6IFtdLFxuICAgICAgICB0b3RhbExlbmd0aDogMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxlYXNlKGVsZW1lbnQpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IGVsZW1lbnQubGVuZ3Rocy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBiZXppZXJMZW5ndGhQb29sLnJlbGVhc2UoZWxlbWVudC5sZW5ndGhzW2ldKTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5sZW5ndGhzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvb2xGYWN0b3J5KDgsIGNyZWF0ZSwgcmVsZWFzZSk7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBiZXpGdW5jdGlvbigpIHtcbiAgICB2YXIgbWF0aCA9IE1hdGg7XG5cbiAgICBmdW5jdGlvbiBwb2ludE9uTGluZTJEKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgIHZhciBkZXQxID0geDEgKiB5MiArIHkxICogeDMgKyB4MiAqIHkzIC0geDMgKiB5MiAtIHkzICogeDEgLSB4MiAqIHkxO1xuICAgICAgcmV0dXJuIGRldDEgPiAtMC4wMDEgJiYgZGV0MSA8IDAuMDAxO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvaW50T25MaW5lM0QoeDEsIHkxLCB6MSwgeDIsIHkyLCB6MiwgeDMsIHkzLCB6Mykge1xuICAgICAgaWYgKHoxID09PSAwICYmIHoyID09PSAwICYmIHozID09PSAwKSB7XG4gICAgICAgIHJldHVybiBwb2ludE9uTGluZTJEKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGlzdDEgPSBtYXRoLnNxcnQobWF0aC5wb3coeDIgLSB4MSwgMikgKyBtYXRoLnBvdyh5MiAtIHkxLCAyKSArIG1hdGgucG93KHoyIC0gejEsIDIpKTtcbiAgICAgIHZhciBkaXN0MiA9IG1hdGguc3FydChtYXRoLnBvdyh4MyAtIHgxLCAyKSArIG1hdGgucG93KHkzIC0geTEsIDIpICsgbWF0aC5wb3coejMgLSB6MSwgMikpO1xuICAgICAgdmFyIGRpc3QzID0gbWF0aC5zcXJ0KG1hdGgucG93KHgzIC0geDIsIDIpICsgbWF0aC5wb3coeTMgLSB5MiwgMikgKyBtYXRoLnBvdyh6MyAtIHoyLCAyKSk7XG4gICAgICB2YXIgZGlmZkRpc3Q7XG5cbiAgICAgIGlmIChkaXN0MSA+IGRpc3QyKSB7XG4gICAgICAgIGlmIChkaXN0MSA+IGRpc3QzKSB7XG4gICAgICAgICAgZGlmZkRpc3QgPSBkaXN0MSAtIGRpc3QyIC0gZGlzdDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlmZkRpc3QgPSBkaXN0MyAtIGRpc3QyIC0gZGlzdDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGlzdDMgPiBkaXN0Mikge1xuICAgICAgICBkaWZmRGlzdCA9IGRpc3QzIC0gZGlzdDIgLSBkaXN0MTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpZmZEaXN0ID0gZGlzdDIgLSBkaXN0MSAtIGRpc3QzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlmZkRpc3QgPiAtMC4wMDAxICYmIGRpZmZEaXN0IDwgMC4wMDAxO1xuICAgIH1cblxuICAgIHZhciBnZXRCZXppZXJMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHB0MSwgcHQyLCBwdDMsIHB0NCkge1xuICAgICAgICB2YXIgY3VydmVTZWdtZW50cyA9IGdldERlZmF1bHRDdXJ2ZVNlZ21lbnRzKCk7XG4gICAgICAgIHZhciBrO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxlbjtcbiAgICAgICAgdmFyIHB0Q29vcmQ7XG4gICAgICAgIHZhciBwZXJjO1xuICAgICAgICB2YXIgYWRkZWRMZW5ndGggPSAwO1xuICAgICAgICB2YXIgcHREaXN0YW5jZTtcbiAgICAgICAgdmFyIHBvaW50ID0gW107XG4gICAgICAgIHZhciBsYXN0UG9pbnQgPSBbXTtcbiAgICAgICAgdmFyIGxlbmd0aERhdGEgPSBiZXppZXJMZW5ndGhQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgICAgbGVuID0gcHQzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgY3VydmVTZWdtZW50czsgayArPSAxKSB7XG4gICAgICAgICAgcGVyYyA9IGsgLyAoY3VydmVTZWdtZW50cyAtIDEpO1xuICAgICAgICAgIHB0RGlzdGFuY2UgPSAwO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBwdENvb3JkID0gYm1Qb3coMSAtIHBlcmMsIDMpICogcHQxW2ldICsgMyAqIGJtUG93KDEgLSBwZXJjLCAyKSAqIHBlcmMgKiBwdDNbaV0gKyAzICogKDEgLSBwZXJjKSAqIGJtUG93KHBlcmMsIDIpICogcHQ0W2ldICsgYm1Qb3cocGVyYywgMykgKiBwdDJbaV07XG4gICAgICAgICAgICBwb2ludFtpXSA9IHB0Q29vcmQ7XG5cbiAgICAgICAgICAgIGlmIChsYXN0UG9pbnRbaV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcHREaXN0YW5jZSArPSBibVBvdyhwb2ludFtpXSAtIGxhc3RQb2ludFtpXSwgMik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RQb2ludFtpXSA9IHBvaW50W2ldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwdERpc3RhbmNlKSB7XG4gICAgICAgICAgICBwdERpc3RhbmNlID0gYm1TcXJ0KHB0RGlzdGFuY2UpO1xuICAgICAgICAgICAgYWRkZWRMZW5ndGggKz0gcHREaXN0YW5jZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZW5ndGhEYXRhLnBlcmNlbnRzW2tdID0gcGVyYztcbiAgICAgICAgICBsZW5ndGhEYXRhLmxlbmd0aHNba10gPSBhZGRlZExlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aERhdGEuYWRkZWRMZW5ndGggPSBhZGRlZExlbmd0aDtcbiAgICAgICAgcmV0dXJuIGxlbmd0aERhdGE7XG4gICAgICB9O1xuICAgIH0oKTtcblxuICAgIGZ1bmN0aW9uIGdldFNlZ21lbnRzTGVuZ3RoKHNoYXBlRGF0YSkge1xuICAgICAgdmFyIHNlZ21lbnRzTGVuZ3RoID0gc2VnbWVudHNMZW5ndGhQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgIHZhciBjbG9zZWQgPSBzaGFwZURhdGEuYztcbiAgICAgIHZhciBwYXRoViA9IHNoYXBlRGF0YS52O1xuICAgICAgdmFyIHBhdGhPID0gc2hhcGVEYXRhLm87XG4gICAgICB2YXIgcGF0aEkgPSBzaGFwZURhdGEuaTtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHNoYXBlRGF0YS5fbGVuZ3RoO1xuICAgICAgdmFyIGxlbmd0aHMgPSBzZWdtZW50c0xlbmd0aC5sZW5ndGhzO1xuICAgICAgdmFyIHRvdGFsTGVuZ3RoID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbiAtIDE7IGkgKz0gMSkge1xuICAgICAgICBsZW5ndGhzW2ldID0gZ2V0QmV6aWVyTGVuZ3RoKHBhdGhWW2ldLCBwYXRoVltpICsgMV0sIHBhdGhPW2ldLCBwYXRoSVtpICsgMV0pO1xuICAgICAgICB0b3RhbExlbmd0aCArPSBsZW5ndGhzW2ldLmFkZGVkTGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2xvc2VkICYmIGxlbikge1xuICAgICAgICBsZW5ndGhzW2ldID0gZ2V0QmV6aWVyTGVuZ3RoKHBhdGhWW2ldLCBwYXRoVlswXSwgcGF0aE9baV0sIHBhdGhJWzBdKTtcbiAgICAgICAgdG90YWxMZW5ndGggKz0gbGVuZ3Roc1tpXS5hZGRlZExlbmd0aDtcbiAgICAgIH1cblxuICAgICAgc2VnbWVudHNMZW5ndGgudG90YWxMZW5ndGggPSB0b3RhbExlbmd0aDtcbiAgICAgIHJldHVybiBzZWdtZW50c0xlbmd0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBCZXppZXJEYXRhKGxlbmd0aCkge1xuICAgICAgdGhpcy5zZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgIHRoaXMucG9pbnRzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUG9pbnREYXRhKHBhcnRpYWwsIHBvaW50KSB7XG4gICAgICB0aGlzLnBhcnRpYWxMZW5ndGggPSBwYXJ0aWFsO1xuICAgICAgdGhpcy5wb2ludCA9IHBvaW50O1xuICAgIH1cblxuICAgIHZhciBidWlsZEJlemllckRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RvcmVkRGF0YSA9IHt9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwdDEsIHB0MiwgcHQzLCBwdDQpIHtcbiAgICAgICAgdmFyIGJlemllck5hbWUgPSAocHQxWzBdICsgJ18nICsgcHQxWzFdICsgJ18nICsgcHQyWzBdICsgJ18nICsgcHQyWzFdICsgJ18nICsgcHQzWzBdICsgJ18nICsgcHQzWzFdICsgJ18nICsgcHQ0WzBdICsgJ18nICsgcHQ0WzFdKS5yZXBsYWNlKC9cXC4vZywgJ3AnKTtcblxuICAgICAgICBpZiAoIXN0b3JlZERhdGFbYmV6aWVyTmFtZV0pIHtcbiAgICAgICAgICB2YXIgY3VydmVTZWdtZW50cyA9IGdldERlZmF1bHRDdXJ2ZVNlZ21lbnRzKCk7XG4gICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgdmFyIGxlbjtcbiAgICAgICAgICB2YXIgcHRDb29yZDtcbiAgICAgICAgICB2YXIgcGVyYztcbiAgICAgICAgICB2YXIgYWRkZWRMZW5ndGggPSAwO1xuICAgICAgICAgIHZhciBwdERpc3RhbmNlO1xuICAgICAgICAgIHZhciBwb2ludDtcbiAgICAgICAgICB2YXIgbGFzdFBvaW50ID0gbnVsbDtcblxuICAgICAgICAgIGlmIChwdDEubGVuZ3RoID09PSAyICYmIChwdDFbMF0gIT09IHB0MlswXSB8fCBwdDFbMV0gIT09IHB0MlsxXSkgJiYgcG9pbnRPbkxpbmUyRChwdDFbMF0sIHB0MVsxXSwgcHQyWzBdLCBwdDJbMV0sIHB0MVswXSArIHB0M1swXSwgcHQxWzFdICsgcHQzWzFdKSAmJiBwb2ludE9uTGluZTJEKHB0MVswXSwgcHQxWzFdLCBwdDJbMF0sIHB0MlsxXSwgcHQyWzBdICsgcHQ0WzBdLCBwdDJbMV0gKyBwdDRbMV0pKSB7XG4gICAgICAgICAgICBjdXJ2ZVNlZ21lbnRzID0gMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgYmV6aWVyRGF0YSA9IG5ldyBCZXppZXJEYXRhKGN1cnZlU2VnbWVudHMpO1xuICAgICAgICAgIGxlbiA9IHB0My5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgY3VydmVTZWdtZW50czsgayArPSAxKSB7XG4gICAgICAgICAgICBwb2ludCA9IGNyZWF0ZVNpemVkQXJyYXkobGVuKTtcbiAgICAgICAgICAgIHBlcmMgPSBrIC8gKGN1cnZlU2VnbWVudHMgLSAxKTtcbiAgICAgICAgICAgIHB0RGlzdGFuY2UgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgcHRDb29yZCA9IGJtUG93KDEgLSBwZXJjLCAzKSAqIHB0MVtpXSArIDMgKiBibVBvdygxIC0gcGVyYywgMikgKiBwZXJjICogKHB0MVtpXSArIHB0M1tpXSkgKyAzICogKDEgLSBwZXJjKSAqIGJtUG93KHBlcmMsIDIpICogKHB0MltpXSArIHB0NFtpXSkgKyBibVBvdyhwZXJjLCAzKSAqIHB0MltpXTtcbiAgICAgICAgICAgICAgcG9pbnRbaV0gPSBwdENvb3JkO1xuXG4gICAgICAgICAgICAgIGlmIChsYXN0UG9pbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwdERpc3RhbmNlICs9IGJtUG93KHBvaW50W2ldIC0gbGFzdFBvaW50W2ldLCAyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwdERpc3RhbmNlID0gYm1TcXJ0KHB0RGlzdGFuY2UpO1xuICAgICAgICAgICAgYWRkZWRMZW5ndGggKz0gcHREaXN0YW5jZTtcbiAgICAgICAgICAgIGJlemllckRhdGEucG9pbnRzW2tdID0gbmV3IFBvaW50RGF0YShwdERpc3RhbmNlLCBwb2ludCk7XG4gICAgICAgICAgICBsYXN0UG9pbnQgPSBwb2ludDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGggPSBhZGRlZExlbmd0aDtcbiAgICAgICAgICBzdG9yZWREYXRhW2Jlemllck5hbWVdID0gYmV6aWVyRGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdG9yZWREYXRhW2Jlemllck5hbWVdO1xuICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICBmdW5jdGlvbiBnZXREaXN0YW5jZVBlcmMocGVyYywgYmV6aWVyRGF0YSkge1xuICAgICAgdmFyIHBlcmNlbnRzID0gYmV6aWVyRGF0YS5wZXJjZW50cztcbiAgICAgIHZhciBsZW5ndGhzID0gYmV6aWVyRGF0YS5sZW5ndGhzO1xuICAgICAgdmFyIGxlbiA9IHBlcmNlbnRzLmxlbmd0aDtcbiAgICAgIHZhciBpbml0UG9zID0gYm1GbG9vcigobGVuIC0gMSkgKiBwZXJjKTtcbiAgICAgIHZhciBsZW5ndGhQb3MgPSBwZXJjICogYmV6aWVyRGF0YS5hZGRlZExlbmd0aDtcbiAgICAgIHZhciBsUGVyYyA9IDA7XG5cbiAgICAgIGlmIChpbml0UG9zID09PSBsZW4gLSAxIHx8IGluaXRQb3MgPT09IDAgfHwgbGVuZ3RoUG9zID09PSBsZW5ndGhzW2luaXRQb3NdKSB7XG4gICAgICAgIHJldHVybiBwZXJjZW50c1tpbml0UG9zXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpciA9IGxlbmd0aHNbaW5pdFBvc10gPiBsZW5ndGhQb3MgPyAtMSA6IDE7XG4gICAgICB2YXIgZmxhZyA9IHRydWU7XG5cbiAgICAgIHdoaWxlIChmbGFnKSB7XG4gICAgICAgIGlmIChsZW5ndGhzW2luaXRQb3NdIDw9IGxlbmd0aFBvcyAmJiBsZW5ndGhzW2luaXRQb3MgKyAxXSA+IGxlbmd0aFBvcykge1xuICAgICAgICAgIGxQZXJjID0gKGxlbmd0aFBvcyAtIGxlbmd0aHNbaW5pdFBvc10pIC8gKGxlbmd0aHNbaW5pdFBvcyArIDFdIC0gbGVuZ3Roc1tpbml0UG9zXSk7XG4gICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluaXRQb3MgKz0gZGlyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluaXRQb3MgPCAwIHx8IGluaXRQb3MgPj0gbGVuIC0gMSkge1xuICAgICAgICAgIC8vIEZJWCBmb3IgVHlwZWRBcnJheXMgdGhhdCBkb24ndCBzdG9yZSBmbG9hdGluZyBwb2ludCB2YWx1ZXMgd2l0aCBlbm91Z2ggYWNjdXJhY3lcbiAgICAgICAgICBpZiAoaW5pdFBvcyA9PT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHBlcmNlbnRzW2luaXRQb3NdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGVyY2VudHNbaW5pdFBvc10gKyAocGVyY2VudHNbaW5pdFBvcyArIDFdIC0gcGVyY2VudHNbaW5pdFBvc10pICogbFBlcmM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UG9pbnRJblNlZ21lbnQocHQxLCBwdDIsIHB0MywgcHQ0LCBwZXJjZW50LCBiZXppZXJEYXRhKSB7XG4gICAgICB2YXIgdDEgPSBnZXREaXN0YW5jZVBlcmMocGVyY2VudCwgYmV6aWVyRGF0YSk7XG4gICAgICB2YXIgdTEgPSAxIC0gdDE7XG4gICAgICB2YXIgcHRYID0gbWF0aC5yb3VuZCgodTEgKiB1MSAqIHUxICogcHQxWzBdICsgKHQxICogdTEgKiB1MSArIHUxICogdDEgKiB1MSArIHUxICogdTEgKiB0MSkgKiBwdDNbMF0gKyAodDEgKiB0MSAqIHUxICsgdTEgKiB0MSAqIHQxICsgdDEgKiB1MSAqIHQxKSAqIHB0NFswXSArIHQxICogdDEgKiB0MSAqIHB0MlswXSkgKiAxMDAwKSAvIDEwMDA7XG4gICAgICB2YXIgcHRZID0gbWF0aC5yb3VuZCgodTEgKiB1MSAqIHUxICogcHQxWzFdICsgKHQxICogdTEgKiB1MSArIHUxICogdDEgKiB1MSArIHUxICogdTEgKiB0MSkgKiBwdDNbMV0gKyAodDEgKiB0MSAqIHUxICsgdTEgKiB0MSAqIHQxICsgdDEgKiB1MSAqIHQxKSAqIHB0NFsxXSArIHQxICogdDEgKiB0MSAqIHB0MlsxXSkgKiAxMDAwKSAvIDEwMDA7XG4gICAgICByZXR1cm4gW3B0WCwgcHRZXTtcbiAgICB9XG5cbiAgICB2YXIgYmV6aWVyU2VnbWVudFBvaW50cyA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCA4KTtcblxuICAgIGZ1bmN0aW9uIGdldE5ld1NlZ21lbnQocHQxLCBwdDIsIHB0MywgcHQ0LCBzdGFydFBlcmMsIGVuZFBlcmMsIGJlemllckRhdGEpIHtcbiAgICAgIGlmIChzdGFydFBlcmMgPCAwKSB7XG4gICAgICAgIHN0YXJ0UGVyYyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0UGVyYyA+IDEpIHtcbiAgICAgICAgc3RhcnRQZXJjID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIHQwID0gZ2V0RGlzdGFuY2VQZXJjKHN0YXJ0UGVyYywgYmV6aWVyRGF0YSk7XG4gICAgICBlbmRQZXJjID0gZW5kUGVyYyA+IDEgPyAxIDogZW5kUGVyYztcbiAgICAgIHZhciB0MSA9IGdldERpc3RhbmNlUGVyYyhlbmRQZXJjLCBiZXppZXJEYXRhKTtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHB0MS5sZW5ndGg7XG4gICAgICB2YXIgdTAgPSAxIC0gdDA7XG4gICAgICB2YXIgdTEgPSAxIC0gdDE7XG4gICAgICB2YXIgdTB1MHUwID0gdTAgKiB1MCAqIHUwO1xuICAgICAgdmFyIHQwdTB1MF8zID0gdDAgKiB1MCAqIHUwICogMzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcblxuICAgICAgdmFyIHQwdDB1MF8zID0gdDAgKiB0MCAqIHUwICogMzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcblxuICAgICAgdmFyIHQwdDB0MCA9IHQwICogdDAgKiB0MDsgLy9cblxuICAgICAgdmFyIHUwdTB1MSA9IHUwICogdTAgKiB1MTtcbiAgICAgIHZhciB0MHUwdTFfMyA9IHQwICogdTAgKiB1MSArIHUwICogdDAgKiB1MSArIHUwICogdTAgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcblxuICAgICAgdmFyIHQwdDB1MV8zID0gdDAgKiB0MCAqIHUxICsgdTAgKiB0MCAqIHQxICsgdDAgKiB1MCAqIHQxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuXG4gICAgICB2YXIgdDB0MHQxID0gdDAgKiB0MCAqIHQxOyAvL1xuXG4gICAgICB2YXIgdTB1MXUxID0gdTAgKiB1MSAqIHUxO1xuICAgICAgdmFyIHQwdTF1MV8zID0gdDAgKiB1MSAqIHUxICsgdTAgKiB0MSAqIHUxICsgdTAgKiB1MSAqIHQxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuXG4gICAgICB2YXIgdDB0MXUxXzMgPSB0MCAqIHQxICogdTEgKyB1MCAqIHQxICogdDEgKyB0MCAqIHUxICogdDE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cbiAgICAgIHZhciB0MHQxdDEgPSB0MCAqIHQxICogdDE7IC8vXG5cbiAgICAgIHZhciB1MXUxdTEgPSB1MSAqIHUxICogdTE7XG4gICAgICB2YXIgdDF1MXUxXzMgPSB0MSAqIHUxICogdTEgKyB1MSAqIHQxICogdTEgKyB1MSAqIHUxICogdDE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cbiAgICAgIHZhciB0MXQxdTFfMyA9IHQxICogdDEgKiB1MSArIHUxICogdDEgKiB0MSArIHQxICogdTEgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcblxuICAgICAgdmFyIHQxdDF0MSA9IHQxICogdDEgKiB0MTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJlemllclNlZ21lbnRQb2ludHNbaSAqIDRdID0gbWF0aC5yb3VuZCgodTB1MHUwICogcHQxW2ldICsgdDB1MHUwXzMgKiBwdDNbaV0gKyB0MHQwdTBfMyAqIHB0NFtpXSArIHQwdDB0MCAqIHB0MltpXSkgKiAxMDAwKSAvIDEwMDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cbiAgICAgICAgYmV6aWVyU2VnbWVudFBvaW50c1tpICogNCArIDFdID0gbWF0aC5yb3VuZCgodTB1MHUxICogcHQxW2ldICsgdDB1MHUxXzMgKiBwdDNbaV0gKyB0MHQwdTFfMyAqIHB0NFtpXSArIHQwdDB0MSAqIHB0MltpXSkgKiAxMDAwKSAvIDEwMDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cbiAgICAgICAgYmV6aWVyU2VnbWVudFBvaW50c1tpICogNCArIDJdID0gbWF0aC5yb3VuZCgodTB1MXUxICogcHQxW2ldICsgdDB1MXUxXzMgKiBwdDNbaV0gKyB0MHQxdTFfMyAqIHB0NFtpXSArIHQwdDF0MSAqIHB0MltpXSkgKiAxMDAwKSAvIDEwMDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cbiAgICAgICAgYmV6aWVyU2VnbWVudFBvaW50c1tpICogNCArIDNdID0gbWF0aC5yb3VuZCgodTF1MXUxICogcHQxW2ldICsgdDF1MXUxXzMgKiBwdDNbaV0gKyB0MXQxdTFfMyAqIHB0NFtpXSArIHQxdDF0MSAqIHB0MltpXSkgKiAxMDAwKSAvIDEwMDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiZXppZXJTZWdtZW50UG9pbnRzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBnZXRTZWdtZW50c0xlbmd0aDogZ2V0U2VnbWVudHNMZW5ndGgsXG4gICAgICBnZXROZXdTZWdtZW50OiBnZXROZXdTZWdtZW50LFxuICAgICAgZ2V0UG9pbnRJblNlZ21lbnQ6IGdldFBvaW50SW5TZWdtZW50LFxuICAgICAgYnVpbGRCZXppZXJEYXRhOiBidWlsZEJlemllckRhdGEsXG4gICAgICBwb2ludE9uTGluZTJEOiBwb2ludE9uTGluZTJELFxuICAgICAgcG9pbnRPbkxpbmUzRDogcG9pbnRPbkxpbmUzRFxuICAgIH07XG4gIH1cblxuICB2YXIgYmV6ID0gYmV6RnVuY3Rpb24oKTtcblxuICB2YXIgaW5pdEZyYW1lID0gaW5pdGlhbERlZmF1bHRGcmFtZTtcbiAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZVZhbHVlKGZyYW1lTnVtLCBjYWNoaW5nKSB7XG4gICAgdmFyIG9mZnNldFRpbWUgPSB0aGlzLm9mZnNldFRpbWU7XG4gICAgdmFyIG5ld1ZhbHVlO1xuXG4gICAgaWYgKHRoaXMucHJvcFR5cGUgPT09ICdtdWx0aWRpbWVuc2lvbmFsJykge1xuICAgICAgbmV3VmFsdWUgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgdGhpcy5wdi5sZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciBpdGVyYXRpb25JbmRleCA9IGNhY2hpbmcubGFzdEluZGV4O1xuICAgIHZhciBpID0gaXRlcmF0aW9uSW5kZXg7XG4gICAgdmFyIGxlbiA9IHRoaXMua2V5ZnJhbWVzLmxlbmd0aCAtIDE7XG4gICAgdmFyIGZsYWcgPSB0cnVlO1xuICAgIHZhciBrZXlEYXRhO1xuICAgIHZhciBuZXh0S2V5RGF0YTtcbiAgICB2YXIga2V5ZnJhbWVNZXRhZGF0YTtcblxuICAgIHdoaWxlIChmbGFnKSB7XG4gICAgICBrZXlEYXRhID0gdGhpcy5rZXlmcmFtZXNbaV07XG4gICAgICBuZXh0S2V5RGF0YSA9IHRoaXMua2V5ZnJhbWVzW2kgKyAxXTtcblxuICAgICAgaWYgKGkgPT09IGxlbiAtIDEgJiYgZnJhbWVOdW0gPj0gbmV4dEtleURhdGEudCAtIG9mZnNldFRpbWUpIHtcbiAgICAgICAgaWYgKGtleURhdGEuaCkge1xuICAgICAgICAgIGtleURhdGEgPSBuZXh0S2V5RGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZXJhdGlvbkluZGV4ID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0S2V5RGF0YS50IC0gb2Zmc2V0VGltZSA+IGZyYW1lTnVtKSB7XG4gICAgICAgIGl0ZXJhdGlvbkluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChpIDwgbGVuIC0gMSkge1xuICAgICAgICBpICs9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRpb25JbmRleCA9IDA7XG4gICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBrZXlmcmFtZU1ldGFkYXRhID0gdGhpcy5rZXlmcmFtZXNNZXRhZGF0YVtpXSB8fCB7fTtcbiAgICB2YXIgaztcbiAgICB2YXIga0xlbjtcbiAgICB2YXIgcGVyYztcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgajtcbiAgICB2YXIgZm5jO1xuICAgIHZhciBuZXh0S2V5VGltZSA9IG5leHRLZXlEYXRhLnQgLSBvZmZzZXRUaW1lO1xuICAgIHZhciBrZXlUaW1lID0ga2V5RGF0YS50IC0gb2Zmc2V0VGltZTtcbiAgICB2YXIgZW5kVmFsdWU7XG5cbiAgICBpZiAoa2V5RGF0YS50bykge1xuICAgICAgaWYgKCFrZXlmcmFtZU1ldGFkYXRhLmJlemllckRhdGEpIHtcbiAgICAgICAga2V5ZnJhbWVNZXRhZGF0YS5iZXppZXJEYXRhID0gYmV6LmJ1aWxkQmV6aWVyRGF0YShrZXlEYXRhLnMsIG5leHRLZXlEYXRhLnMgfHwga2V5RGF0YS5lLCBrZXlEYXRhLnRvLCBrZXlEYXRhLnRpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJlemllckRhdGEgPSBrZXlmcmFtZU1ldGFkYXRhLmJlemllckRhdGE7XG5cbiAgICAgIGlmIChmcmFtZU51bSA+PSBuZXh0S2V5VGltZSB8fCBmcmFtZU51bSA8IGtleVRpbWUpIHtcbiAgICAgICAgdmFyIGluZCA9IGZyYW1lTnVtID49IG5leHRLZXlUaW1lID8gYmV6aWVyRGF0YS5wb2ludHMubGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgIGtMZW4gPSBiZXppZXJEYXRhLnBvaW50c1tpbmRdLnBvaW50Lmxlbmd0aDtcblxuICAgICAgICBmb3IgKGsgPSAwOyBrIDwga0xlbjsgayArPSAxKSB7XG4gICAgICAgICAgbmV3VmFsdWVba10gPSBiZXppZXJEYXRhLnBvaW50c1tpbmRdLnBvaW50W2tdO1xuICAgICAgICB9IC8vIGNhY2hpbmcuX2xhc3RLZXlmcmFtZUluZGV4ID0gLTE7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChrZXlmcmFtZU1ldGFkYXRhLl9fZm5jdCkge1xuICAgICAgICAgIGZuYyA9IGtleWZyYW1lTWV0YWRhdGEuX19mbmN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZuYyA9IEJlemllckZhY3RvcnkuZ2V0QmV6aWVyRWFzaW5nKGtleURhdGEuby54LCBrZXlEYXRhLm8ueSwga2V5RGF0YS5pLngsIGtleURhdGEuaS55LCBrZXlEYXRhLm4pLmdldDtcbiAgICAgICAgICBrZXlmcmFtZU1ldGFkYXRhLl9fZm5jdCA9IGZuYztcbiAgICAgICAgfVxuXG4gICAgICAgIHBlcmMgPSBmbmMoKGZyYW1lTnVtIC0ga2V5VGltZSkgLyAobmV4dEtleVRpbWUgLSBrZXlUaW1lKSk7XG4gICAgICAgIHZhciBkaXN0YW5jZUluTGluZSA9IGJlemllckRhdGEuc2VnbWVudExlbmd0aCAqIHBlcmM7XG4gICAgICAgIHZhciBzZWdtZW50UGVyYztcbiAgICAgICAgdmFyIGFkZGVkTGVuZ3RoID0gY2FjaGluZy5sYXN0RnJhbWUgPCBmcmFtZU51bSAmJiBjYWNoaW5nLl9sYXN0S2V5ZnJhbWVJbmRleCA9PT0gaSA/IGNhY2hpbmcuX2xhc3RBZGRlZExlbmd0aCA6IDA7XG4gICAgICAgIGogPSBjYWNoaW5nLmxhc3RGcmFtZSA8IGZyYW1lTnVtICYmIGNhY2hpbmcuX2xhc3RLZXlmcmFtZUluZGV4ID09PSBpID8gY2FjaGluZy5fbGFzdFBvaW50IDogMDtcbiAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgIGpMZW4gPSBiZXppZXJEYXRhLnBvaW50cy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGZsYWcpIHtcbiAgICAgICAgICBhZGRlZExlbmd0aCArPSBiZXppZXJEYXRhLnBvaW50c1tqXS5wYXJ0aWFsTGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKGRpc3RhbmNlSW5MaW5lID09PSAwIHx8IHBlcmMgPT09IDAgfHwgaiA9PT0gYmV6aWVyRGF0YS5wb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAga0xlbiA9IGJlemllckRhdGEucG9pbnRzW2pdLnBvaW50Lmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGtMZW47IGsgKz0gMSkge1xuICAgICAgICAgICAgICBuZXdWYWx1ZVtrXSA9IGJlemllckRhdGEucG9pbnRzW2pdLnBvaW50W2tdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpc3RhbmNlSW5MaW5lID49IGFkZGVkTGVuZ3RoICYmIGRpc3RhbmNlSW5MaW5lIDwgYWRkZWRMZW5ndGggKyBiZXppZXJEYXRhLnBvaW50c1tqICsgMV0ucGFydGlhbExlbmd0aCkge1xuICAgICAgICAgICAgc2VnbWVudFBlcmMgPSAoZGlzdGFuY2VJbkxpbmUgLSBhZGRlZExlbmd0aCkgLyBiZXppZXJEYXRhLnBvaW50c1tqICsgMV0ucGFydGlhbExlbmd0aDtcbiAgICAgICAgICAgIGtMZW4gPSBiZXppZXJEYXRhLnBvaW50c1tqXS5wb2ludC5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBrTGVuOyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgbmV3VmFsdWVba10gPSBiZXppZXJEYXRhLnBvaW50c1tqXS5wb2ludFtrXSArIChiZXppZXJEYXRhLnBvaW50c1tqICsgMV0ucG9pbnRba10gLSBiZXppZXJEYXRhLnBvaW50c1tqXS5wb2ludFtrXSkgKiBzZWdtZW50UGVyYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGogPCBqTGVuIC0gMSkge1xuICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2FjaGluZy5fbGFzdFBvaW50ID0gajtcbiAgICAgICAgY2FjaGluZy5fbGFzdEFkZGVkTGVuZ3RoID0gYWRkZWRMZW5ndGggLSBiZXppZXJEYXRhLnBvaW50c1tqXS5wYXJ0aWFsTGVuZ3RoO1xuICAgICAgICBjYWNoaW5nLl9sYXN0S2V5ZnJhbWVJbmRleCA9IGk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvdXRYO1xuICAgICAgdmFyIG91dFk7XG4gICAgICB2YXIgaW5YO1xuICAgICAgdmFyIGluWTtcbiAgICAgIHZhciBrZXlWYWx1ZTtcbiAgICAgIGxlbiA9IGtleURhdGEucy5sZW5ndGg7XG4gICAgICBlbmRWYWx1ZSA9IG5leHRLZXlEYXRhLnMgfHwga2V5RGF0YS5lO1xuXG4gICAgICBpZiAodGhpcy5zaCAmJiBrZXlEYXRhLmggIT09IDEpIHtcbiAgICAgICAgaWYgKGZyYW1lTnVtID49IG5leHRLZXlUaW1lKSB7XG4gICAgICAgICAgbmV3VmFsdWVbMF0gPSBlbmRWYWx1ZVswXTtcbiAgICAgICAgICBuZXdWYWx1ZVsxXSA9IGVuZFZhbHVlWzFdO1xuICAgICAgICAgIG5ld1ZhbHVlWzJdID0gZW5kVmFsdWVbMl07XG4gICAgICAgIH0gZWxzZSBpZiAoZnJhbWVOdW0gPD0ga2V5VGltZSkge1xuICAgICAgICAgIG5ld1ZhbHVlWzBdID0ga2V5RGF0YS5zWzBdO1xuICAgICAgICAgIG5ld1ZhbHVlWzFdID0ga2V5RGF0YS5zWzFdO1xuICAgICAgICAgIG5ld1ZhbHVlWzJdID0ga2V5RGF0YS5zWzJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBxdWF0U3RhcnQgPSBjcmVhdGVRdWF0ZXJuaW9uKGtleURhdGEucyk7XG4gICAgICAgICAgdmFyIHF1YXRFbmQgPSBjcmVhdGVRdWF0ZXJuaW9uKGVuZFZhbHVlKTtcbiAgICAgICAgICB2YXIgdGltZSA9IChmcmFtZU51bSAtIGtleVRpbWUpIC8gKG5leHRLZXlUaW1lIC0ga2V5VGltZSk7XG4gICAgICAgICAgcXVhdGVybmlvblRvRXVsZXIobmV3VmFsdWUsIHNsZXJwKHF1YXRTdGFydCwgcXVhdEVuZCwgdGltZSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoa2V5RGF0YS5oICE9PSAxKSB7XG4gICAgICAgICAgICBpZiAoZnJhbWVOdW0gPj0gbmV4dEtleVRpbWUpIHtcbiAgICAgICAgICAgICAgcGVyYyA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lTnVtIDwga2V5VGltZSkge1xuICAgICAgICAgICAgICBwZXJjID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChrZXlEYXRhLm8ueC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtleWZyYW1lTWV0YWRhdGEuX19mbmN0KSB7XG4gICAgICAgICAgICAgICAgICBrZXlmcmFtZU1ldGFkYXRhLl9fZm5jdCA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICgha2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3RbaV0pIHtcbiAgICAgICAgICAgICAgICAgIG91dFggPSBrZXlEYXRhLm8ueFtpXSA9PT0gdW5kZWZpbmVkID8ga2V5RGF0YS5vLnhbMF0gOiBrZXlEYXRhLm8ueFtpXTtcbiAgICAgICAgICAgICAgICAgIG91dFkgPSBrZXlEYXRhLm8ueVtpXSA9PT0gdW5kZWZpbmVkID8ga2V5RGF0YS5vLnlbMF0gOiBrZXlEYXRhLm8ueVtpXTtcbiAgICAgICAgICAgICAgICAgIGluWCA9IGtleURhdGEuaS54W2ldID09PSB1bmRlZmluZWQgPyBrZXlEYXRhLmkueFswXSA6IGtleURhdGEuaS54W2ldO1xuICAgICAgICAgICAgICAgICAgaW5ZID0ga2V5RGF0YS5pLnlbaV0gPT09IHVuZGVmaW5lZCA/IGtleURhdGEuaS55WzBdIDoga2V5RGF0YS5pLnlbaV07XG4gICAgICAgICAgICAgICAgICBmbmMgPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZyhvdXRYLCBvdXRZLCBpblgsIGluWSkuZ2V0O1xuICAgICAgICAgICAgICAgICAga2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3RbaV0gPSBmbmM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGZuYyA9IGtleWZyYW1lTWV0YWRhdGEuX19mbmN0W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgha2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3QpIHtcbiAgICAgICAgICAgICAgICBvdXRYID0ga2V5RGF0YS5vLng7XG4gICAgICAgICAgICAgICAgb3V0WSA9IGtleURhdGEuby55O1xuICAgICAgICAgICAgICAgIGluWCA9IGtleURhdGEuaS54O1xuICAgICAgICAgICAgICAgIGluWSA9IGtleURhdGEuaS55O1xuICAgICAgICAgICAgICAgIGZuYyA9IEJlemllckZhY3RvcnkuZ2V0QmV6aWVyRWFzaW5nKG91dFgsIG91dFksIGluWCwgaW5ZKS5nZXQ7XG4gICAgICAgICAgICAgICAga2V5RGF0YS5rZXlmcmFtZU1ldGFkYXRhID0gZm5jO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZuYyA9IGtleWZyYW1lTWV0YWRhdGEuX19mbmN0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcGVyYyA9IGZuYygoZnJhbWVOdW0gLSBrZXlUaW1lKSAvIChuZXh0S2V5VGltZSAtIGtleVRpbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbmRWYWx1ZSA9IG5leHRLZXlEYXRhLnMgfHwga2V5RGF0YS5lO1xuICAgICAgICAgIGtleVZhbHVlID0ga2V5RGF0YS5oID09PSAxID8ga2V5RGF0YS5zW2ldIDoga2V5RGF0YS5zW2ldICsgKGVuZFZhbHVlW2ldIC0ga2V5RGF0YS5zW2ldKSAqIHBlcmM7XG5cbiAgICAgICAgICBpZiAodGhpcy5wcm9wVHlwZSA9PT0gJ211bHRpZGltZW5zaW9uYWwnKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZVtpXSA9IGtleVZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGtleVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNhY2hpbmcubGFzdEluZGV4ID0gaXRlcmF0aW9uSW5kZXg7XG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xuICB9IC8vIGJhc2VkIG9uIEBUb2ppJ3MgaHR0cHM6Ly9naXRodWIuY29tL3RvamkvZ2wtbWF0cml4L1xuXG5cbiAgZnVuY3Rpb24gc2xlcnAoYSwgYiwgdCkge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICB2YXIgYXggPSBhWzBdO1xuICAgIHZhciBheSA9IGFbMV07XG4gICAgdmFyIGF6ID0gYVsyXTtcbiAgICB2YXIgYXcgPSBhWzNdO1xuICAgIHZhciBieCA9IGJbMF07XG4gICAgdmFyIGJ5ID0gYlsxXTtcbiAgICB2YXIgYnogPSBiWzJdO1xuICAgIHZhciBidyA9IGJbM107XG4gICAgdmFyIG9tZWdhO1xuICAgIHZhciBjb3NvbTtcbiAgICB2YXIgc2lub207XG4gICAgdmFyIHNjYWxlMDtcbiAgICB2YXIgc2NhbGUxO1xuICAgIGNvc29tID0gYXggKiBieCArIGF5ICogYnkgKyBheiAqIGJ6ICsgYXcgKiBidztcblxuICAgIGlmIChjb3NvbSA8IDAuMCkge1xuICAgICAgY29zb20gPSAtY29zb207XG4gICAgICBieCA9IC1ieDtcbiAgICAgIGJ5ID0gLWJ5O1xuICAgICAgYnogPSAtYno7XG4gICAgICBidyA9IC1idztcbiAgICB9XG5cbiAgICBpZiAoMS4wIC0gY29zb20gPiAwLjAwMDAwMSkge1xuICAgICAgb21lZ2EgPSBNYXRoLmFjb3MoY29zb20pO1xuICAgICAgc2lub20gPSBNYXRoLnNpbihvbWVnYSk7XG4gICAgICBzY2FsZTAgPSBNYXRoLnNpbigoMS4wIC0gdCkgKiBvbWVnYSkgLyBzaW5vbTtcbiAgICAgIHNjYWxlMSA9IE1hdGguc2luKHQgKiBvbWVnYSkgLyBzaW5vbTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUwID0gMS4wIC0gdDtcbiAgICAgIHNjYWxlMSA9IHQ7XG4gICAgfVxuXG4gICAgb3V0WzBdID0gc2NhbGUwICogYXggKyBzY2FsZTEgKiBieDtcbiAgICBvdXRbMV0gPSBzY2FsZTAgKiBheSArIHNjYWxlMSAqIGJ5O1xuICAgIG91dFsyXSA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XG4gICAgb3V0WzNdID0gc2NhbGUwICogYXcgKyBzY2FsZTEgKiBidztcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgZnVuY3Rpb24gcXVhdGVybmlvblRvRXVsZXIob3V0LCBxdWF0KSB7XG4gICAgdmFyIHF4ID0gcXVhdFswXTtcbiAgICB2YXIgcXkgPSBxdWF0WzFdO1xuICAgIHZhciBxeiA9IHF1YXRbMl07XG4gICAgdmFyIHF3ID0gcXVhdFszXTtcbiAgICB2YXIgaGVhZGluZyA9IE1hdGguYXRhbjIoMiAqIHF5ICogcXcgLSAyICogcXggKiBxeiwgMSAtIDIgKiBxeSAqIHF5IC0gMiAqIHF6ICogcXopO1xuICAgIHZhciBhdHRpdHVkZSA9IE1hdGguYXNpbigyICogcXggKiBxeSArIDIgKiBxeiAqIHF3KTtcbiAgICB2YXIgYmFuayA9IE1hdGguYXRhbjIoMiAqIHF4ICogcXcgLSAyICogcXkgKiBxeiwgMSAtIDIgKiBxeCAqIHF4IC0gMiAqIHF6ICogcXopO1xuICAgIG91dFswXSA9IGhlYWRpbmcgLyBkZWdUb1JhZHM7XG4gICAgb3V0WzFdID0gYXR0aXR1ZGUgLyBkZWdUb1JhZHM7XG4gICAgb3V0WzJdID0gYmFuayAvIGRlZ1RvUmFkcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVF1YXRlcm5pb24odmFsdWVzKSB7XG4gICAgdmFyIGhlYWRpbmcgPSB2YWx1ZXNbMF0gKiBkZWdUb1JhZHM7XG4gICAgdmFyIGF0dGl0dWRlID0gdmFsdWVzWzFdICogZGVnVG9SYWRzO1xuICAgIHZhciBiYW5rID0gdmFsdWVzWzJdICogZGVnVG9SYWRzO1xuICAgIHZhciBjMSA9IE1hdGguY29zKGhlYWRpbmcgLyAyKTtcbiAgICB2YXIgYzIgPSBNYXRoLmNvcyhhdHRpdHVkZSAvIDIpO1xuICAgIHZhciBjMyA9IE1hdGguY29zKGJhbmsgLyAyKTtcbiAgICB2YXIgczEgPSBNYXRoLnNpbihoZWFkaW5nIC8gMik7XG4gICAgdmFyIHMyID0gTWF0aC5zaW4oYXR0aXR1ZGUgLyAyKTtcbiAgICB2YXIgczMgPSBNYXRoLnNpbihiYW5rIC8gMik7XG4gICAgdmFyIHcgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG4gICAgdmFyIHggPSBzMSAqIHMyICogYzMgKyBjMSAqIGMyICogczM7XG4gICAgdmFyIHkgPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG4gICAgdmFyIHogPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgcmV0dXJuIFt4LCB5LCB6LCB3XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFZhbHVlQXRDdXJyZW50VGltZSgpIHtcbiAgICB2YXIgZnJhbWVOdW0gPSB0aGlzLmNvbXAucmVuZGVyZWRGcmFtZSAtIHRoaXMub2Zmc2V0VGltZTtcbiAgICB2YXIgaW5pdFRpbWUgPSB0aGlzLmtleWZyYW1lc1swXS50IC0gdGhpcy5vZmZzZXRUaW1lO1xuICAgIHZhciBlbmRUaW1lID0gdGhpcy5rZXlmcmFtZXNbdGhpcy5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAtIHRoaXMub2Zmc2V0VGltZTtcblxuICAgIGlmICghKGZyYW1lTnVtID09PSB0aGlzLl9jYWNoaW5nLmxhc3RGcmFtZSB8fCB0aGlzLl9jYWNoaW5nLmxhc3RGcmFtZSAhPT0gaW5pdEZyYW1lICYmICh0aGlzLl9jYWNoaW5nLmxhc3RGcmFtZSA+PSBlbmRUaW1lICYmIGZyYW1lTnVtID49IGVuZFRpbWUgfHwgdGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgPCBpbml0VGltZSAmJiBmcmFtZU51bSA8IGluaXRUaW1lKSkpIHtcbiAgICAgIGlmICh0aGlzLl9jYWNoaW5nLmxhc3RGcmFtZSA+PSBmcmFtZU51bSkge1xuICAgICAgICB0aGlzLl9jYWNoaW5nLl9sYXN0S2V5ZnJhbWVJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLl9jYWNoaW5nLmxhc3RJbmRleCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciByZW5kZXJSZXN1bHQgPSB0aGlzLmludGVycG9sYXRlVmFsdWUoZnJhbWVOdW0sIHRoaXMuX2NhY2hpbmcpO1xuICAgICAgdGhpcy5wdiA9IHJlbmRlclJlc3VsdDtcbiAgICB9XG5cbiAgICB0aGlzLl9jYWNoaW5nLmxhc3RGcmFtZSA9IGZyYW1lTnVtO1xuICAgIHJldHVybiB0aGlzLnB2O1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0VlZhbHVlKHZhbCkge1xuICAgIHZhciBtdWx0aXBsaWVkVmFsdWU7XG5cbiAgICBpZiAodGhpcy5wcm9wVHlwZSA9PT0gJ3VuaWRpbWVuc2lvbmFsJykge1xuICAgICAgbXVsdGlwbGllZFZhbHVlID0gdmFsICogdGhpcy5tdWx0O1xuXG4gICAgICBpZiAobWF0aEFicyh0aGlzLnYgLSBtdWx0aXBsaWVkVmFsdWUpID4gMC4wMDAwMSkge1xuICAgICAgICB0aGlzLnYgPSBtdWx0aXBsaWVkVmFsdWU7XG4gICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSB0aGlzLnYubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBtdWx0aXBsaWVkVmFsdWUgPSB2YWxbaV0gKiB0aGlzLm11bHQ7XG5cbiAgICAgICAgaWYgKG1hdGhBYnModGhpcy52W2ldIC0gbXVsdGlwbGllZFZhbHVlKSA+IDAuMDAwMDEpIHtcbiAgICAgICAgICB0aGlzLnZbaV0gPSBtdWx0aXBsaWVkVmFsdWU7XG4gICAgICAgICAgdGhpcy5fbWRmID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzRWZmZWN0c1NlcXVlbmNlKCkge1xuICAgIGlmICh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQgfHwgIXRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxvY2spIHtcbiAgICAgIHRoaXMuc2V0VlZhbHVlKHRoaXMucHYpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubG9jayA9IHRydWU7XG4gICAgdGhpcy5fbWRmID0gdGhpcy5faXNGaXJzdEZyYW1lO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGg7XG4gICAgdmFyIGZpbmFsVmFsdWUgPSB0aGlzLmtmID8gdGhpcy5wdiA6IHRoaXMuZGF0YS5rO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBmaW5hbFZhbHVlID0gdGhpcy5lZmZlY3RzU2VxdWVuY2VbaV0oZmluYWxWYWx1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRWVmFsdWUoZmluYWxWYWx1ZSk7XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gZmFsc2U7XG4gICAgdGhpcy5sb2NrID0gZmFsc2U7XG4gICAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEVmZmVjdChlZmZlY3RGdW5jdGlvbikge1xuICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlLnB1c2goZWZmZWN0RnVuY3Rpb24pO1xuICAgIHRoaXMuY29udGFpbmVyLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFZhbHVlUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wcm9wVHlwZSA9ICd1bmlkaW1lbnNpb25hbCc7XG4gICAgdGhpcy5tdWx0ID0gbXVsdCB8fCAxO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy52ID0gbXVsdCA/IGRhdGEuayAqIG11bHQgOiBkYXRhLms7XG4gICAgdGhpcy5wdiA9IGRhdGEuaztcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICB0aGlzLmtmID0gZmFsc2U7XG4gICAgdGhpcy52ZWwgPSAwO1xuICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlID0gW107XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICB0aGlzLmdldFZhbHVlID0gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZTtcbiAgICB0aGlzLnNldFZWYWx1ZSA9IHNldFZWYWx1ZTtcbiAgICB0aGlzLmFkZEVmZmVjdCA9IGFkZEVmZmVjdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIE11bHRpRGltZW5zaW9uYWxQcm9wZXJ0eShlbGVtLCBkYXRhLCBtdWx0LCBjb250YWluZXIpIHtcbiAgICB0aGlzLnByb3BUeXBlID0gJ211bHRpZGltZW5zaW9uYWwnO1xuICAgIHRoaXMubXVsdCA9IG11bHQgfHwgMTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xuICAgIHRoaXMuayA9IGZhbHNlO1xuICAgIHRoaXMua2YgPSBmYWxzZTtcbiAgICB0aGlzLmZyYW1lSWQgPSAtMTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gZGF0YS5rLmxlbmd0aDtcbiAgICB0aGlzLnYgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcbiAgICB0aGlzLnB2ID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG4gICAgdGhpcy52ZWwgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy52W2ldID0gZGF0YS5rW2ldICogdGhpcy5tdWx0O1xuICAgICAgdGhpcy5wdltpXSA9IGRhdGEua1tpXTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xuICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlID0gW107XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHByb2Nlc3NFZmZlY3RzU2VxdWVuY2U7XG4gICAgdGhpcy5zZXRWVmFsdWUgPSBzZXRWVmFsdWU7XG4gICAgdGhpcy5hZGRFZmZlY3QgPSBhZGRFZmZlY3Q7XG4gIH1cblxuICBmdW5jdGlvbiBLZXlmcmFtZWRWYWx1ZVByb3BlcnR5KGVsZW0sIGRhdGEsIG11bHQsIGNvbnRhaW5lcikge1xuICAgIHRoaXMucHJvcFR5cGUgPSAndW5pZGltZW5zaW9uYWwnO1xuICAgIHRoaXMua2V5ZnJhbWVzID0gZGF0YS5rO1xuICAgIHRoaXMua2V5ZnJhbWVzTWV0YWRhdGEgPSBbXTtcbiAgICB0aGlzLm9mZnNldFRpbWUgPSBlbGVtLmRhdGEuc3Q7XG4gICAgdGhpcy5mcmFtZUlkID0gLTE7XG4gICAgdGhpcy5fY2FjaGluZyA9IHtcbiAgICAgIGxhc3RGcmFtZTogaW5pdEZyYW1lLFxuICAgICAgbGFzdEluZGV4OiAwLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBfbGFzdEtleWZyYW1lSW5kZXg6IC0xXG4gICAgfTtcbiAgICB0aGlzLmsgPSB0cnVlO1xuICAgIHRoaXMua2YgPSB0cnVlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5tdWx0ID0gbXVsdCB8fCAxO1xuICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xuICAgIHRoaXMudiA9IGluaXRGcmFtZTtcbiAgICB0aGlzLnB2ID0gaW5pdEZyYW1lO1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHByb2Nlc3NFZmZlY3RzU2VxdWVuY2U7XG4gICAgdGhpcy5zZXRWVmFsdWUgPSBzZXRWVmFsdWU7XG4gICAgdGhpcy5pbnRlcnBvbGF0ZVZhbHVlID0gaW50ZXJwb2xhdGVWYWx1ZTtcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtnZXRWYWx1ZUF0Q3VycmVudFRpbWUuYmluZCh0aGlzKV07XG4gICAgdGhpcy5hZGRFZmZlY3QgPSBhZGRFZmZlY3Q7XG4gIH1cblxuICBmdW5jdGlvbiBLZXlmcmFtZWRNdWx0aWRpbWVuc2lvbmFsUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wcm9wVHlwZSA9ICdtdWx0aWRpbWVuc2lvbmFsJztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gZGF0YS5rLmxlbmd0aDtcbiAgICB2YXIgcztcbiAgICB2YXIgZTtcbiAgICB2YXIgdG87XG4gICAgdmFyIHRpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbiAtIDE7IGkgKz0gMSkge1xuICAgICAgaWYgKGRhdGEua1tpXS50byAmJiBkYXRhLmtbaV0ucyAmJiBkYXRhLmtbaSArIDFdICYmIGRhdGEua1tpICsgMV0ucykge1xuICAgICAgICBzID0gZGF0YS5rW2ldLnM7XG4gICAgICAgIGUgPSBkYXRhLmtbaSArIDFdLnM7XG4gICAgICAgIHRvID0gZGF0YS5rW2ldLnRvO1xuICAgICAgICB0aSA9IGRhdGEua1tpXS50aTtcblxuICAgICAgICBpZiAocy5sZW5ndGggPT09IDIgJiYgIShzWzBdID09PSBlWzBdICYmIHNbMV0gPT09IGVbMV0pICYmIGJlei5wb2ludE9uTGluZTJEKHNbMF0sIHNbMV0sIGVbMF0sIGVbMV0sIHNbMF0gKyB0b1swXSwgc1sxXSArIHRvWzFdKSAmJiBiZXoucG9pbnRPbkxpbmUyRChzWzBdLCBzWzFdLCBlWzBdLCBlWzFdLCBlWzBdICsgdGlbMF0sIGVbMV0gKyB0aVsxXSkgfHwgcy5sZW5ndGggPT09IDMgJiYgIShzWzBdID09PSBlWzBdICYmIHNbMV0gPT09IGVbMV0gJiYgc1syXSA9PT0gZVsyXSkgJiYgYmV6LnBvaW50T25MaW5lM0Qoc1swXSwgc1sxXSwgc1syXSwgZVswXSwgZVsxXSwgZVsyXSwgc1swXSArIHRvWzBdLCBzWzFdICsgdG9bMV0sIHNbMl0gKyB0b1syXSkgJiYgYmV6LnBvaW50T25MaW5lM0Qoc1swXSwgc1sxXSwgc1syXSwgZVswXSwgZVsxXSwgZVsyXSwgZVswXSArIHRpWzBdLCBlWzFdICsgdGlbMV0sIGVbMl0gKyB0aVsyXSkpIHtcbiAgICAgICAgICBkYXRhLmtbaV0udG8gPSBudWxsO1xuICAgICAgICAgIGRhdGEua1tpXS50aSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc1swXSA9PT0gZVswXSAmJiBzWzFdID09PSBlWzFdICYmIHRvWzBdID09PSAwICYmIHRvWzFdID09PSAwICYmIHRpWzBdID09PSAwICYmIHRpWzFdID09PSAwKSB7XG4gICAgICAgICAgaWYgKHMubGVuZ3RoID09PSAyIHx8IHNbMl0gPT09IGVbMl0gJiYgdG9bMl0gPT09IDAgJiYgdGlbMl0gPT09IDApIHtcbiAgICAgICAgICAgIGRhdGEua1tpXS50byA9IG51bGw7XG4gICAgICAgICAgICBkYXRhLmtbaV0udGkgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlID0gW2dldFZhbHVlQXRDdXJyZW50VGltZS5iaW5kKHRoaXMpXTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMua2V5ZnJhbWVzID0gZGF0YS5rO1xuICAgIHRoaXMua2V5ZnJhbWVzTWV0YWRhdGEgPSBbXTtcbiAgICB0aGlzLm9mZnNldFRpbWUgPSBlbGVtLmRhdGEuc3Q7XG4gICAgdGhpcy5rID0gdHJ1ZTtcbiAgICB0aGlzLmtmID0gdHJ1ZTtcbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xuICAgIHRoaXMubXVsdCA9IG11bHQgfHwgMTtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICB0aGlzLmdldFZhbHVlID0gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZTtcbiAgICB0aGlzLnNldFZWYWx1ZSA9IHNldFZWYWx1ZTtcbiAgICB0aGlzLmludGVycG9sYXRlVmFsdWUgPSBpbnRlcnBvbGF0ZVZhbHVlO1xuICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xuICAgIHZhciBhcnJMZW4gPSBkYXRhLmtbMF0ucy5sZW5ndGg7XG4gICAgdGhpcy52ID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGFyckxlbik7XG4gICAgdGhpcy5wdiA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBhcnJMZW4pO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGFyckxlbjsgaSArPSAxKSB7XG4gICAgICB0aGlzLnZbaV0gPSBpbml0RnJhbWU7XG4gICAgICB0aGlzLnB2W2ldID0gaW5pdEZyYW1lO1xuICAgIH1cblxuICAgIHRoaXMuX2NhY2hpbmcgPSB7XG4gICAgICBsYXN0RnJhbWU6IGluaXRGcmFtZSxcbiAgICAgIGxhc3RJbmRleDogMCxcbiAgICAgIHZhbHVlOiBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgYXJyTGVuKVxuICAgIH07XG4gICAgdGhpcy5hZGRFZmZlY3QgPSBhZGRFZmZlY3Q7XG4gIH1cblxuICB2YXIgUHJvcGVydHlGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGdldFByb3AoZWxlbSwgZGF0YSwgdHlwZSwgbXVsdCwgY29udGFpbmVyKSB7XG4gICAgICBpZiAoZGF0YS5zaWQpIHtcbiAgICAgICAgZGF0YSA9IGVsZW0uZ2xvYmFsRGF0YS5zbG90TWFuYWdlci5nZXRQcm9wKGRhdGEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcDtcblxuICAgICAgaWYgKCFkYXRhLmsubGVuZ3RoKSB7XG4gICAgICAgIHAgPSBuZXcgVmFsdWVQcm9wZXJ0eShlbGVtLCBkYXRhLCBtdWx0LCBjb250YWluZXIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YS5rWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICBwID0gbmV3IE11bHRpRGltZW5zaW9uYWxQcm9wZXJ0eShlbGVtLCBkYXRhLCBtdWx0LCBjb250YWluZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcCA9IG5ldyBLZXlmcmFtZWRWYWx1ZVByb3BlcnR5KGVsZW0sIGRhdGEsIG11bHQsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHAgPSBuZXcgS2V5ZnJhbWVkTXVsdGlkaW1lbnNpb25hbFByb3BlcnR5KGVsZW0sIGRhdGEsIG11bHQsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocC5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRhaW5lci5hZGREeW5hbWljUHJvcGVydHkocCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIHZhciBvYiA9IHtcbiAgICAgIGdldFByb3A6IGdldFByb3BcbiAgICB9O1xuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcigpIHt9XG5cbiAgRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyLnByb3RvdHlwZSA9IHtcbiAgICBhZGREeW5hbWljUHJvcGVydHk6IGZ1bmN0aW9uIGFkZER5bmFtaWNQcm9wZXJ0eShwcm9wKSB7XG4gICAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcbiAgICAgICAgdGhpcy5faXNBbmltYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBpdGVyYXRlRHluYW1pY1Byb3BlcnRpZXM6IGZ1bmN0aW9uIGl0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpIHtcbiAgICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLmdldFZhbHVlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV0uX21kZikge1xuICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGluaXREeW5hbWljUHJvcGVydHlDb250YWluZXI6IGZ1bmN0aW9uIGluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMgPSBbXTtcbiAgICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgICAgdGhpcy5faXNBbmltYXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcG9pbnRQb29sID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvb2xGYWN0b3J5KDgsIGNyZWF0ZSk7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBTaGFwZVBhdGgoKSB7XG4gICAgdGhpcy5jID0gZmFsc2U7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXhMZW5ndGggPSA4O1xuICAgIHRoaXMudiA9IGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKTtcbiAgICB0aGlzLm8gPSBjcmVhdGVTaXplZEFycmF5KHRoaXMuX21heExlbmd0aCk7XG4gICAgdGhpcy5pID0gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpO1xuICB9XG5cbiAgU2hhcGVQYXRoLnByb3RvdHlwZS5zZXRQYXRoRGF0YSA9IGZ1bmN0aW9uIChjbG9zZWQsIGxlbikge1xuICAgIHRoaXMuYyA9IGNsb3NlZDtcbiAgICB0aGlzLnNldExlbmd0aChsZW4pO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICB0aGlzLnZbaV0gPSBwb2ludFBvb2wubmV3RWxlbWVudCgpO1xuICAgICAgdGhpcy5vW2ldID0gcG9pbnRQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgIHRoaXMuaVtpXSA9IHBvaW50UG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICBpICs9IDE7XG4gICAgfVxuICB9O1xuXG4gIFNoYXBlUGF0aC5wcm90b3R5cGUuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKGxlbikge1xuICAgIHdoaWxlICh0aGlzLl9tYXhMZW5ndGggPCBsZW4pIHtcbiAgICAgIHRoaXMuZG91YmxlQXJyYXlMZW5ndGgoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9sZW5ndGggPSBsZW47XG4gIH07XG5cbiAgU2hhcGVQYXRoLnByb3RvdHlwZS5kb3VibGVBcnJheUxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnYgPSB0aGlzLnYuY29uY2F0KGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKSk7XG4gICAgdGhpcy5pID0gdGhpcy5pLmNvbmNhdChjcmVhdGVTaXplZEFycmF5KHRoaXMuX21heExlbmd0aCkpO1xuICAgIHRoaXMubyA9IHRoaXMuby5jb25jYXQoY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpKTtcbiAgICB0aGlzLl9tYXhMZW5ndGggKj0gMjtcbiAgfTtcblxuICBTaGFwZVBhdGgucHJvdG90eXBlLnNldFhZQXQgPSBmdW5jdGlvbiAoeCwgeSwgdHlwZSwgcG9zLCByZXBsYWNlKSB7XG4gICAgdmFyIGFycjtcbiAgICB0aGlzLl9sZW5ndGggPSBNYXRoLm1heCh0aGlzLl9sZW5ndGgsIHBvcyArIDEpO1xuXG4gICAgaWYgKHRoaXMuX2xlbmd0aCA+PSB0aGlzLl9tYXhMZW5ndGgpIHtcbiAgICAgIHRoaXMuZG91YmxlQXJyYXlMZW5ndGgoKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3YnOlxuICAgICAgICBhcnIgPSB0aGlzLnY7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdpJzpcbiAgICAgICAgYXJyID0gdGhpcy5pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbyc6XG4gICAgICAgIGFyciA9IHRoaXMubztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyciA9IFtdO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoIWFycltwb3NdIHx8IGFycltwb3NdICYmICFyZXBsYWNlKSB7XG4gICAgICBhcnJbcG9zXSA9IHBvaW50UG9vbC5uZXdFbGVtZW50KCk7XG4gICAgfVxuXG4gICAgYXJyW3Bvc11bMF0gPSB4O1xuICAgIGFycltwb3NdWzFdID0geTtcbiAgfTtcblxuICBTaGFwZVBhdGgucHJvdG90eXBlLnNldFRyaXBsZUF0ID0gZnVuY3Rpb24gKHZYLCB2WSwgb1gsIG9ZLCBpWCwgaVksIHBvcywgcmVwbGFjZSkge1xuICAgIHRoaXMuc2V0WFlBdCh2WCwgdlksICd2JywgcG9zLCByZXBsYWNlKTtcbiAgICB0aGlzLnNldFhZQXQob1gsIG9ZLCAnbycsIHBvcywgcmVwbGFjZSk7XG4gICAgdGhpcy5zZXRYWUF0KGlYLCBpWSwgJ2knLCBwb3MsIHJlcGxhY2UpO1xuICB9O1xuXG4gIFNoYXBlUGF0aC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV3UGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcbiAgICBuZXdQYXRoLnNldFBhdGhEYXRhKHRoaXMuYywgdGhpcy5fbGVuZ3RoKTtcbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnY7XG4gICAgdmFyIG91dFBvaW50cyA9IHRoaXMubztcbiAgICB2YXIgaW5Qb2ludHMgPSB0aGlzLmk7XG4gICAgdmFyIGluaXQgPSAwO1xuXG4gICAgaWYgKHRoaXMuYykge1xuICAgICAgbmV3UGF0aC5zZXRUcmlwbGVBdCh2ZXJ0aWNlc1swXVswXSwgdmVydGljZXNbMF1bMV0sIGluUG9pbnRzWzBdWzBdLCBpblBvaW50c1swXVsxXSwgb3V0UG9pbnRzWzBdWzBdLCBvdXRQb2ludHNbMF1bMV0sIDAsIGZhbHNlKTtcbiAgICAgIGluaXQgPSAxO1xuICAgIH1cblxuICAgIHZhciBjbnQgPSB0aGlzLl9sZW5ndGggLSAxO1xuICAgIHZhciBsZW4gPSB0aGlzLl9sZW5ndGg7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSBpbml0OyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIG5ld1BhdGguc2V0VHJpcGxlQXQodmVydGljZXNbY250XVswXSwgdmVydGljZXNbY250XVsxXSwgaW5Qb2ludHNbY250XVswXSwgaW5Qb2ludHNbY250XVsxXSwgb3V0UG9pbnRzW2NudF1bMF0sIG91dFBvaW50c1tjbnRdWzFdLCBpLCBmYWxzZSk7XG4gICAgICBjbnQgLT0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3UGF0aDtcbiAgfTtcblxuICBTaGFwZVBhdGgucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICB9O1xuXG4gIHZhciBzaGFwZVBvb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgcmV0dXJuIG5ldyBTaGFwZVBhdGgoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxlYXNlKHNoYXBlUGF0aCkge1xuICAgICAgdmFyIGxlbiA9IHNoYXBlUGF0aC5fbGVuZ3RoO1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBwb2ludFBvb2wucmVsZWFzZShzaGFwZVBhdGgudltpXSk7XG4gICAgICAgIHBvaW50UG9vbC5yZWxlYXNlKHNoYXBlUGF0aC5pW2ldKTtcbiAgICAgICAgcG9pbnRQb29sLnJlbGVhc2Uoc2hhcGVQYXRoLm9baV0pO1xuICAgICAgICBzaGFwZVBhdGgudltpXSA9IG51bGw7XG4gICAgICAgIHNoYXBlUGF0aC5pW2ldID0gbnVsbDtcbiAgICAgICAgc2hhcGVQYXRoLm9baV0gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBzaGFwZVBhdGguX2xlbmd0aCA9IDA7XG4gICAgICBzaGFwZVBhdGguYyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lKHNoYXBlKSB7XG4gICAgICB2YXIgY2xvbmVkID0gZmFjdG9yeS5uZXdFbGVtZW50KCk7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBzaGFwZS5fbGVuZ3RoID09PSB1bmRlZmluZWQgPyBzaGFwZS52Lmxlbmd0aCA6IHNoYXBlLl9sZW5ndGg7XG4gICAgICBjbG9uZWQuc2V0TGVuZ3RoKGxlbik7XG4gICAgICBjbG9uZWQuYyA9IHNoYXBlLmM7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBjbG9uZWQuc2V0VHJpcGxlQXQoc2hhcGUudltpXVswXSwgc2hhcGUudltpXVsxXSwgc2hhcGUub1tpXVswXSwgc2hhcGUub1tpXVsxXSwgc2hhcGUuaVtpXVswXSwgc2hhcGUuaVtpXVsxXSwgaSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfVxuXG4gICAgdmFyIGZhY3RvcnkgPSBwb29sRmFjdG9yeSg0LCBjcmVhdGUsIHJlbGVhc2UpO1xuICAgIGZhY3RvcnkuY2xvbmUgPSBjbG9uZTtcbiAgICByZXR1cm4gZmFjdG9yeTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIFNoYXBlQ29sbGVjdGlvbigpIHtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX21heExlbmd0aCA9IDQ7XG4gICAgdGhpcy5zaGFwZXMgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMuX21heExlbmd0aCk7XG4gIH1cblxuICBTaGFwZUNvbGxlY3Rpb24ucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKHNoYXBlRGF0YSkge1xuICAgIGlmICh0aGlzLl9sZW5ndGggPT09IHRoaXMuX21heExlbmd0aCkge1xuICAgICAgdGhpcy5zaGFwZXMgPSB0aGlzLnNoYXBlcy5jb25jYXQoY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpKTtcbiAgICAgIHRoaXMuX21heExlbmd0aCAqPSAyO1xuICAgIH1cblxuICAgIHRoaXMuc2hhcGVzW3RoaXMuX2xlbmd0aF0gPSBzaGFwZURhdGE7XG4gICAgdGhpcy5fbGVuZ3RoICs9IDE7XG4gIH07XG5cbiAgU2hhcGVDb2xsZWN0aW9uLnByb3RvdHlwZS5yZWxlYXNlU2hhcGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2xlbmd0aDsgaSArPSAxKSB7XG4gICAgICBzaGFwZVBvb2wucmVsZWFzZSh0aGlzLnNoYXBlc1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgfTtcblxuICB2YXIgc2hhcGVDb2xsZWN0aW9uUG9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2IgPSB7XG4gICAgICBuZXdTaGFwZUNvbGxlY3Rpb246IG5ld1NoYXBlQ29sbGVjdGlvbixcbiAgICAgIHJlbGVhc2U6IHJlbGVhc2VcbiAgICB9O1xuICAgIHZhciBfbGVuZ3RoID0gMDtcbiAgICB2YXIgX21heExlbmd0aCA9IDQ7XG4gICAgdmFyIHBvb2wgPSBjcmVhdGVTaXplZEFycmF5KF9tYXhMZW5ndGgpO1xuXG4gICAgZnVuY3Rpb24gbmV3U2hhcGVDb2xsZWN0aW9uKCkge1xuICAgICAgdmFyIHNoYXBlQ29sbGVjdGlvbjtcblxuICAgICAgaWYgKF9sZW5ndGgpIHtcbiAgICAgICAgX2xlbmd0aCAtPSAxO1xuICAgICAgICBzaGFwZUNvbGxlY3Rpb24gPSBwb29sW19sZW5ndGhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hhcGVDb2xsZWN0aW9uID0gbmV3IFNoYXBlQ29sbGVjdGlvbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2hhcGVDb2xsZWN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbGVhc2Uoc2hhcGVDb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBzaGFwZUNvbGxlY3Rpb24uX2xlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHNoYXBlUG9vbC5yZWxlYXNlKHNoYXBlQ29sbGVjdGlvbi5zaGFwZXNbaV0pO1xuICAgICAgfVxuXG4gICAgICBzaGFwZUNvbGxlY3Rpb24uX2xlbmd0aCA9IDA7XG5cbiAgICAgIGlmIChfbGVuZ3RoID09PSBfbWF4TGVuZ3RoKSB7XG4gICAgICAgIHBvb2wgPSBwb29saW5nW1wiZG91YmxlXCJdKHBvb2wpO1xuICAgICAgICBfbWF4TGVuZ3RoICo9IDI7XG4gICAgICB9XG5cbiAgICAgIHBvb2xbX2xlbmd0aF0gPSBzaGFwZUNvbGxlY3Rpb247XG4gICAgICBfbGVuZ3RoICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iO1xuICB9KCk7XG5cbiAgdmFyIFNoYXBlUHJvcGVydHlGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbml0RnJhbWUgPSAtOTk5OTk5O1xuXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVTaGFwZShmcmFtZU51bSwgcHJldmlvdXNWYWx1ZSwgY2FjaGluZykge1xuICAgICAgdmFyIGl0ZXJhdGlvbkluZGV4ID0gY2FjaGluZy5sYXN0SW5kZXg7XG4gICAgICB2YXIga2V5UHJvcFM7XG4gICAgICB2YXIga2V5UHJvcEU7XG4gICAgICB2YXIgaXNIb2xkO1xuICAgICAgdmFyIGo7XG4gICAgICB2YXIgaztcbiAgICAgIHZhciBqTGVuO1xuICAgICAgdmFyIGtMZW47XG4gICAgICB2YXIgcGVyYztcbiAgICAgIHZhciB2ZXJ0ZXhWYWx1ZTtcbiAgICAgIHZhciBrZiA9IHRoaXMua2V5ZnJhbWVzO1xuXG4gICAgICBpZiAoZnJhbWVOdW0gPCBrZlswXS50IC0gdGhpcy5vZmZzZXRUaW1lKSB7XG4gICAgICAgIGtleVByb3BTID0ga2ZbMF0uc1swXTtcbiAgICAgICAgaXNIb2xkID0gdHJ1ZTtcbiAgICAgICAgaXRlcmF0aW9uSW5kZXggPSAwO1xuICAgICAgfSBlbHNlIGlmIChmcmFtZU51bSA+PSBrZltrZi5sZW5ndGggLSAxXS50IC0gdGhpcy5vZmZzZXRUaW1lKSB7XG4gICAgICAgIGtleVByb3BTID0ga2Zba2YubGVuZ3RoIC0gMV0ucyA/IGtmW2tmLmxlbmd0aCAtIDFdLnNbMF0gOiBrZltrZi5sZW5ndGggLSAyXS5lWzBdO1xuICAgICAgICAvKiBpZihrZltrZi5sZW5ndGggLSAxXS5zKXtcclxuICAgICAgICAgICAgICAgICAga2V5UHJvcFMgPSBrZltrZi5sZW5ndGggLSAxXS5zWzBdO1xyXG4gICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICBrZXlQcm9wUyA9IGtmW2tmLmxlbmd0aCAtIDJdLmVbMF07XHJcbiAgICAgICAgICAgICAgfSAqL1xuXG4gICAgICAgIGlzSG9sZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9IGl0ZXJhdGlvbkluZGV4O1xuICAgICAgICB2YXIgbGVuID0ga2YubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGZsYWcgPSB0cnVlO1xuICAgICAgICB2YXIga2V5RGF0YTtcbiAgICAgICAgdmFyIG5leHRLZXlEYXRhO1xuICAgICAgICB2YXIga2V5ZnJhbWVNZXRhZGF0YTtcblxuICAgICAgICB3aGlsZSAoZmxhZykge1xuICAgICAgICAgIGtleURhdGEgPSBrZltpXTtcbiAgICAgICAgICBuZXh0S2V5RGF0YSA9IGtmW2kgKyAxXTtcblxuICAgICAgICAgIGlmIChuZXh0S2V5RGF0YS50IC0gdGhpcy5vZmZzZXRUaW1lID4gZnJhbWVOdW0pIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpIDwgbGVuIC0gMSkge1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAga2V5ZnJhbWVNZXRhZGF0YSA9IHRoaXMua2V5ZnJhbWVzTWV0YWRhdGFbaV0gfHwge307XG4gICAgICAgIGlzSG9sZCA9IGtleURhdGEuaCA9PT0gMTtcbiAgICAgICAgaXRlcmF0aW9uSW5kZXggPSBpO1xuXG4gICAgICAgIGlmICghaXNIb2xkKSB7XG4gICAgICAgICAgaWYgKGZyYW1lTnVtID49IG5leHRLZXlEYXRhLnQgLSB0aGlzLm9mZnNldFRpbWUpIHtcbiAgICAgICAgICAgIHBlcmMgPSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZnJhbWVOdW0gPCBrZXlEYXRhLnQgLSB0aGlzLm9mZnNldFRpbWUpIHtcbiAgICAgICAgICAgIHBlcmMgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZm5jO1xuXG4gICAgICAgICAgICBpZiAoa2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3QpIHtcbiAgICAgICAgICAgICAgZm5jID0ga2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3Q7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmbmMgPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZyhrZXlEYXRhLm8ueCwga2V5RGF0YS5vLnksIGtleURhdGEuaS54LCBrZXlEYXRhLmkueSkuZ2V0O1xuICAgICAgICAgICAgICBrZXlmcmFtZU1ldGFkYXRhLl9fZm5jdCA9IGZuYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGVyYyA9IGZuYygoZnJhbWVOdW0gLSAoa2V5RGF0YS50IC0gdGhpcy5vZmZzZXRUaW1lKSkgLyAobmV4dEtleURhdGEudCAtIHRoaXMub2Zmc2V0VGltZSAtIChrZXlEYXRhLnQgLSB0aGlzLm9mZnNldFRpbWUpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAga2V5UHJvcEUgPSBuZXh0S2V5RGF0YS5zID8gbmV4dEtleURhdGEuc1swXSA6IGtleURhdGEuZVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleVByb3BTID0ga2V5RGF0YS5zWzBdO1xuICAgICAgfVxuXG4gICAgICBqTGVuID0gcHJldmlvdXNWYWx1ZS5fbGVuZ3RoO1xuICAgICAga0xlbiA9IGtleVByb3BTLmlbMF0ubGVuZ3RoO1xuICAgICAgY2FjaGluZy5sYXN0SW5kZXggPSBpdGVyYXRpb25JbmRleDtcblxuICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwga0xlbjsgayArPSAxKSB7XG4gICAgICAgICAgdmVydGV4VmFsdWUgPSBpc0hvbGQgPyBrZXlQcm9wUy5pW2pdW2tdIDoga2V5UHJvcFMuaVtqXVtrXSArIChrZXlQcm9wRS5pW2pdW2tdIC0ga2V5UHJvcFMuaVtqXVtrXSkgKiBwZXJjO1xuICAgICAgICAgIHByZXZpb3VzVmFsdWUuaVtqXVtrXSA9IHZlcnRleFZhbHVlO1xuICAgICAgICAgIHZlcnRleFZhbHVlID0gaXNIb2xkID8ga2V5UHJvcFMub1tqXVtrXSA6IGtleVByb3BTLm9bal1ba10gKyAoa2V5UHJvcEUub1tqXVtrXSAtIGtleVByb3BTLm9bal1ba10pICogcGVyYztcbiAgICAgICAgICBwcmV2aW91c1ZhbHVlLm9bal1ba10gPSB2ZXJ0ZXhWYWx1ZTtcbiAgICAgICAgICB2ZXJ0ZXhWYWx1ZSA9IGlzSG9sZCA/IGtleVByb3BTLnZbal1ba10gOiBrZXlQcm9wUy52W2pdW2tdICsgKGtleVByb3BFLnZbal1ba10gLSBrZXlQcm9wUy52W2pdW2tdKSAqIHBlcmM7XG4gICAgICAgICAgcHJldmlvdXNWYWx1ZS52W2pdW2tdID0gdmVydGV4VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZVNoYXBlQ3VycmVudFRpbWUoKSB7XG4gICAgICB2YXIgZnJhbWVOdW0gPSB0aGlzLmNvbXAucmVuZGVyZWRGcmFtZSAtIHRoaXMub2Zmc2V0VGltZTtcbiAgICAgIHZhciBpbml0VGltZSA9IHRoaXMua2V5ZnJhbWVzWzBdLnQgLSB0aGlzLm9mZnNldFRpbWU7XG4gICAgICB2YXIgZW5kVGltZSA9IHRoaXMua2V5ZnJhbWVzW3RoaXMua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQgLSB0aGlzLm9mZnNldFRpbWU7XG4gICAgICB2YXIgbGFzdEZyYW1lID0gdGhpcy5fY2FjaGluZy5sYXN0RnJhbWU7XG5cbiAgICAgIGlmICghKGxhc3RGcmFtZSAhPT0gaW5pdEZyYW1lICYmIChsYXN0RnJhbWUgPCBpbml0VGltZSAmJiBmcmFtZU51bSA8IGluaXRUaW1lIHx8IGxhc3RGcmFtZSA+IGVuZFRpbWUgJiYgZnJhbWVOdW0gPiBlbmRUaW1lKSkpIHtcbiAgICAgICAgLy8vIC9cbiAgICAgICAgdGhpcy5fY2FjaGluZy5sYXN0SW5kZXggPSBsYXN0RnJhbWUgPCBmcmFtZU51bSA/IHRoaXMuX2NhY2hpbmcubGFzdEluZGV4IDogMDtcbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0ZVNoYXBlKGZyYW1lTnVtLCB0aGlzLnB2LCB0aGlzLl9jYWNoaW5nKTsgLy8vIC9cbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgPSBmcmFtZU51bTtcbiAgICAgIHJldHVybiB0aGlzLnB2O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2V0U2hhcGUoKSB7XG4gICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaGFwZXNFcXVhbChzaGFwZTEsIHNoYXBlMikge1xuICAgICAgaWYgKHNoYXBlMS5fbGVuZ3RoICE9PSBzaGFwZTIuX2xlbmd0aCB8fCBzaGFwZTEuYyAhPT0gc2hhcGUyLmMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBzaGFwZTEuX2xlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmIChzaGFwZTEudltpXVswXSAhPT0gc2hhcGUyLnZbaV1bMF0gfHwgc2hhcGUxLnZbaV1bMV0gIT09IHNoYXBlMi52W2ldWzFdIHx8IHNoYXBlMS5vW2ldWzBdICE9PSBzaGFwZTIub1tpXVswXSB8fCBzaGFwZTEub1tpXVsxXSAhPT0gc2hhcGUyLm9baV1bMV0gfHwgc2hhcGUxLmlbaV1bMF0gIT09IHNoYXBlMi5pW2ldWzBdIHx8IHNoYXBlMS5pW2ldWzFdICE9PSBzaGFwZTIuaVtpXVsxXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRWVmFsdWUobmV3UGF0aCkge1xuICAgICAgaWYgKCFzaGFwZXNFcXVhbCh0aGlzLnYsIG5ld1BhdGgpKSB7XG4gICAgICAgIHRoaXMudiA9IHNoYXBlUG9vbC5jbG9uZShuZXdQYXRoKTtcbiAgICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbi5yZWxlYXNlU2hhcGVzKCk7XG4gICAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy52KTtcbiAgICAgICAgdGhpcy5fbWRmID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYXRocyA9IHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZSgpIHtcbiAgICAgIGlmICh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5sb2NrKSB7XG4gICAgICAgIHRoaXMuc2V0VlZhbHVlKHRoaXMucHYpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9jayA9IHRydWU7XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICAgIHZhciBmaW5hbFZhbHVlO1xuXG4gICAgICBpZiAodGhpcy5rZikge1xuICAgICAgICBmaW5hbFZhbHVlID0gdGhpcy5wdjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmtzKSB7XG4gICAgICAgIGZpbmFsVmFsdWUgPSB0aGlzLmRhdGEua3MuaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmFsVmFsdWUgPSB0aGlzLmRhdGEucHQuaztcbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gdGhpcy5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgZmluYWxWYWx1ZSA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlW2ldKGZpbmFsVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFZWYWx1ZShmaW5hbFZhbHVlKTtcbiAgICAgIHRoaXMubG9jayA9IGZhbHNlO1xuICAgICAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBTaGFwZVByb3BlcnR5KGVsZW0sIGRhdGEsIHR5cGUpIHtcbiAgICAgIHRoaXMucHJvcFR5cGUgPSAnc2hhcGUnO1xuICAgICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xuICAgICAgdGhpcy5jb250YWluZXIgPSBlbGVtO1xuICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICAgIHRoaXMua2YgPSBmYWxzZTtcbiAgICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgICAgdmFyIHBhdGhEYXRhID0gdHlwZSA9PT0gMyA/IGRhdGEucHQuayA6IGRhdGEua3MuaztcbiAgICAgIHRoaXMudiA9IHNoYXBlUG9vbC5jbG9uZShwYXRoRGF0YSk7XG4gICAgICB0aGlzLnB2ID0gc2hhcGVQb29sLmNsb25lKHRoaXMudik7XG4gICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKTtcbiAgICAgIHRoaXMucGF0aHMgPSB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgdGhpcy5wYXRocy5hZGRTaGFwZSh0aGlzLnYpO1xuICAgICAgdGhpcy5yZXNldCA9IHJlc2V0U2hhcGU7XG4gICAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEVmZmVjdChlZmZlY3RGdW5jdGlvbikge1xuICAgICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UucHVzaChlZmZlY3RGdW5jdGlvbik7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hZGREeW5hbWljUHJvcGVydHkodGhpcyk7XG4gICAgfVxuXG4gICAgU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuaW50ZXJwb2xhdGVTaGFwZSA9IGludGVycG9sYXRlU2hhcGU7XG4gICAgU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBwcm9jZXNzRWZmZWN0c1NlcXVlbmNlO1xuICAgIFNoYXBlUHJvcGVydHkucHJvdG90eXBlLnNldFZWYWx1ZSA9IHNldFZWYWx1ZTtcbiAgICBTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5hZGRFZmZlY3QgPSBhZGRFZmZlY3Q7XG5cbiAgICBmdW5jdGlvbiBLZXlmcmFtZWRTaGFwZVByb3BlcnR5KGVsZW0sIGRhdGEsIHR5cGUpIHtcbiAgICAgIHRoaXMucHJvcFR5cGUgPSAnc2hhcGUnO1xuICAgICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xuICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gZWxlbTtcbiAgICAgIHRoaXMub2Zmc2V0VGltZSA9IGVsZW0uZGF0YS5zdDtcbiAgICAgIHRoaXMua2V5ZnJhbWVzID0gdHlwZSA9PT0gMyA/IGRhdGEucHQuayA6IGRhdGEua3MuaztcbiAgICAgIHRoaXMua2V5ZnJhbWVzTWV0YWRhdGEgPSBbXTtcbiAgICAgIHRoaXMuayA9IHRydWU7XG4gICAgICB0aGlzLmtmID0gdHJ1ZTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmtleWZyYW1lc1swXS5zWzBdLmkubGVuZ3RoO1xuICAgICAgdGhpcy52ID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgIHRoaXMudi5zZXRQYXRoRGF0YSh0aGlzLmtleWZyYW1lc1swXS5zWzBdLmMsIGxlbik7XG4gICAgICB0aGlzLnB2ID0gc2hhcGVQb29sLmNsb25lKHRoaXMudik7XG4gICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKTtcbiAgICAgIHRoaXMucGF0aHMgPSB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgdGhpcy5wYXRocy5hZGRTaGFwZSh0aGlzLnYpO1xuICAgICAgdGhpcy5sYXN0RnJhbWUgPSBpbml0RnJhbWU7XG4gICAgICB0aGlzLnJlc2V0ID0gcmVzZXRTaGFwZTtcbiAgICAgIHRoaXMuX2NhY2hpbmcgPSB7XG4gICAgICAgIGxhc3RGcmFtZTogaW5pdEZyYW1lLFxuICAgICAgICBsYXN0SW5kZXg6IDBcbiAgICAgIH07XG4gICAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtpbnRlcnBvbGF0ZVNoYXBlQ3VycmVudFRpbWUuYmluZCh0aGlzKV07XG4gICAgfVxuXG4gICAgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBwcm9jZXNzRWZmZWN0c1NlcXVlbmNlO1xuICAgIEtleWZyYW1lZFNoYXBlUHJvcGVydHkucHJvdG90eXBlLmludGVycG9sYXRlU2hhcGUgPSBpbnRlcnBvbGF0ZVNoYXBlO1xuICAgIEtleWZyYW1lZFNoYXBlUHJvcGVydHkucHJvdG90eXBlLnNldFZWYWx1ZSA9IHNldFZWYWx1ZTtcbiAgICBLZXlmcmFtZWRTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5hZGRFZmZlY3QgPSBhZGRFZmZlY3Q7XG5cbiAgICB2YXIgRWxsU2hhcGVQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjUG9pbnQgPSByb3VuZENvcm5lcjtcblxuICAgICAgZnVuY3Rpb24gRWxsU2hhcGVQcm9wZXJ0eUZhY3RvcnkoZWxlbSwgZGF0YSkge1xuICAgICAgICB0aGlzLnYgPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xuICAgICAgICB0aGlzLnYuc2V0UGF0aERhdGEodHJ1ZSwgNCk7XG4gICAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZUNvbGxlY3Rpb25Qb29sLm5ld1NoYXBlQ29sbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnYpO1xuICAgICAgICB0aGlzLmQgPSBkYXRhLmQ7XG4gICAgICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICAgICAgdGhpcy5mcmFtZUlkID0gLTE7XG4gICAgICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcbiAgICAgICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5wLCAxLCAwLCB0aGlzKTtcbiAgICAgICAgdGhpcy5zID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5zLCAxLCAwLCB0aGlzKTtcblxuICAgICAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmsgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuayA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuY29udmVydEVsbFRvUGF0aCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIEVsbFNoYXBlUHJvcGVydHlGYWN0b3J5LnByb3RvdHlwZSA9IHtcbiAgICAgICAgcmVzZXQ6IHJlc2V0U2hhcGUsXG4gICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcbiAgICAgICAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX21kZikge1xuICAgICAgICAgICAgdGhpcy5jb252ZXJ0RWxsVG9QYXRoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb252ZXJ0RWxsVG9QYXRoOiBmdW5jdGlvbiBjb252ZXJ0RWxsVG9QYXRoKCkge1xuICAgICAgICAgIHZhciBwMCA9IHRoaXMucC52WzBdO1xuICAgICAgICAgIHZhciBwMSA9IHRoaXMucC52WzFdO1xuICAgICAgICAgIHZhciBzMCA9IHRoaXMucy52WzBdIC8gMjtcbiAgICAgICAgICB2YXIgczEgPSB0aGlzLnMudlsxXSAvIDI7XG5cbiAgICAgICAgICB2YXIgX2N3ID0gdGhpcy5kICE9PSAzO1xuXG4gICAgICAgICAgdmFyIF92ID0gdGhpcy52O1xuICAgICAgICAgIF92LnZbMF1bMF0gPSBwMDtcbiAgICAgICAgICBfdi52WzBdWzFdID0gcDEgLSBzMTtcbiAgICAgICAgICBfdi52WzFdWzBdID0gX2N3ID8gcDAgKyBzMCA6IHAwIC0gczA7XG4gICAgICAgICAgX3YudlsxXVsxXSA9IHAxO1xuICAgICAgICAgIF92LnZbMl1bMF0gPSBwMDtcbiAgICAgICAgICBfdi52WzJdWzFdID0gcDEgKyBzMTtcbiAgICAgICAgICBfdi52WzNdWzBdID0gX2N3ID8gcDAgLSBzMCA6IHAwICsgczA7XG4gICAgICAgICAgX3YudlszXVsxXSA9IHAxO1xuICAgICAgICAgIF92LmlbMF1bMF0gPSBfY3cgPyBwMCAtIHMwICogY1BvaW50IDogcDAgKyBzMCAqIGNQb2ludDtcbiAgICAgICAgICBfdi5pWzBdWzFdID0gcDEgLSBzMTtcbiAgICAgICAgICBfdi5pWzFdWzBdID0gX2N3ID8gcDAgKyBzMCA6IHAwIC0gczA7XG4gICAgICAgICAgX3YuaVsxXVsxXSA9IHAxIC0gczEgKiBjUG9pbnQ7XG4gICAgICAgICAgX3YuaVsyXVswXSA9IF9jdyA/IHAwICsgczAgKiBjUG9pbnQgOiBwMCAtIHMwICogY1BvaW50O1xuICAgICAgICAgIF92LmlbMl1bMV0gPSBwMSArIHMxO1xuICAgICAgICAgIF92LmlbM11bMF0gPSBfY3cgPyBwMCAtIHMwIDogcDAgKyBzMDtcbiAgICAgICAgICBfdi5pWzNdWzFdID0gcDEgKyBzMSAqIGNQb2ludDtcbiAgICAgICAgICBfdi5vWzBdWzBdID0gX2N3ID8gcDAgKyBzMCAqIGNQb2ludCA6IHAwIC0gczAgKiBjUG9pbnQ7XG4gICAgICAgICAgX3Yub1swXVsxXSA9IHAxIC0gczE7XG4gICAgICAgICAgX3Yub1sxXVswXSA9IF9jdyA/IHAwICsgczAgOiBwMCAtIHMwO1xuICAgICAgICAgIF92Lm9bMV1bMV0gPSBwMSArIHMxICogY1BvaW50O1xuICAgICAgICAgIF92Lm9bMl1bMF0gPSBfY3cgPyBwMCAtIHMwICogY1BvaW50IDogcDAgKyBzMCAqIGNQb2ludDtcbiAgICAgICAgICBfdi5vWzJdWzFdID0gcDEgKyBzMTtcbiAgICAgICAgICBfdi5vWzNdWzBdID0gX2N3ID8gcDAgLSBzMCA6IHAwICsgczA7XG4gICAgICAgICAgX3Yub1szXVsxXSA9IHAxIC0gczEgKiBjUG9pbnQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIEVsbFNoYXBlUHJvcGVydHlGYWN0b3J5KTtcbiAgICAgIHJldHVybiBFbGxTaGFwZVByb3BlcnR5RmFjdG9yeTtcbiAgICB9KCk7XG5cbiAgICB2YXIgU3RhclNoYXBlUHJvcGVydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTdGFyU2hhcGVQcm9wZXJ0eUZhY3RvcnkoZWxlbSwgZGF0YSkge1xuICAgICAgICB0aGlzLnYgPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xuICAgICAgICB0aGlzLnYuc2V0UGF0aERhdGEodHJ1ZSwgMCk7XG4gICAgICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5mcmFtZUlkID0gLTE7XG4gICAgICAgIHRoaXMuZCA9IGRhdGEuZDtcbiAgICAgICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuXG4gICAgICAgIGlmIChkYXRhLnN5ID09PSAxKSB7XG4gICAgICAgICAgdGhpcy5pciA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuaXIsIDAsIDAsIHRoaXMpO1xuICAgICAgICAgIHRoaXMuaXMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmlzLCAwLCAwLjAxLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLmNvbnZlcnRUb1BhdGggPSB0aGlzLmNvbnZlcnRTdGFyVG9QYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY29udmVydFRvUGF0aCA9IHRoaXMuY29udmVydFBvbHlnb25Ub1BhdGg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnB0ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5wdCwgMCwgMCwgdGhpcyk7XG4gICAgICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucCwgMSwgMCwgdGhpcyk7XG4gICAgICAgIHRoaXMuciA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuciwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vciA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEub3IsIDAsIDAsIHRoaXMpO1xuICAgICAgICB0aGlzLm9zID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5vcywgMCwgMC4wMSwgdGhpcyk7XG4gICAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZUNvbGxlY3Rpb25Qb29sLm5ld1NoYXBlQ29sbGVjdGlvbigpO1xuICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uLmFkZFNoYXBlKHRoaXMudik7XG4gICAgICAgIHRoaXMucGF0aHMgPSB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuayA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5rID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5jb252ZXJ0VG9QYXRoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgU3RhclNoYXBlUHJvcGVydHlGYWN0b3J5LnByb3RvdHlwZSA9IHtcbiAgICAgICAgcmVzZXQ6IHJlc2V0U2hhcGUsXG4gICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcbiAgICAgICAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX21kZikge1xuICAgICAgICAgICAgdGhpcy5jb252ZXJ0VG9QYXRoKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb252ZXJ0U3RhclRvUGF0aDogZnVuY3Rpb24gY29udmVydFN0YXJUb1BhdGgoKSB7XG4gICAgICAgICAgdmFyIG51bVB0cyA9IE1hdGguZmxvb3IodGhpcy5wdC52KSAqIDI7XG4gICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5QSSAqIDIgLyBudW1QdHM7XG4gICAgICAgICAgLyogdGhpcy52LnYubGVuZ3RoID0gbnVtUHRzO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLnYuaS5sZW5ndGggPSBudW1QdHM7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXMudi5vLmxlbmd0aCA9IG51bVB0czsgKi9cblxuICAgICAgICAgIHZhciBsb25nRmxhZyA9IHRydWU7XG4gICAgICAgICAgdmFyIGxvbmdSYWQgPSB0aGlzLm9yLnY7XG4gICAgICAgICAgdmFyIHNob3J0UmFkID0gdGhpcy5pci52O1xuICAgICAgICAgIHZhciBsb25nUm91bmQgPSB0aGlzLm9zLnY7XG4gICAgICAgICAgdmFyIHNob3J0Um91bmQgPSB0aGlzLmlzLnY7XG4gICAgICAgICAgdmFyIGxvbmdQZXJpbVNlZ21lbnQgPSAyICogTWF0aC5QSSAqIGxvbmdSYWQgLyAobnVtUHRzICogMik7XG4gICAgICAgICAgdmFyIHNob3J0UGVyaW1TZWdtZW50ID0gMiAqIE1hdGguUEkgKiBzaG9ydFJhZCAvIChudW1QdHMgKiAyKTtcbiAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICB2YXIgcmFkO1xuICAgICAgICAgIHZhciByb3VuZG5lc3M7XG4gICAgICAgICAgdmFyIHBlcmltU2VnbWVudDtcbiAgICAgICAgICB2YXIgY3VycmVudEFuZyA9IC1NYXRoLlBJIC8gMjtcbiAgICAgICAgICBjdXJyZW50QW5nICs9IHRoaXMuci52O1xuICAgICAgICAgIHZhciBkaXIgPSB0aGlzLmRhdGEuZCA9PT0gMyA/IC0xIDogMTtcbiAgICAgICAgICB0aGlzLnYuX2xlbmd0aCA9IDA7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUHRzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHJhZCA9IGxvbmdGbGFnID8gbG9uZ1JhZCA6IHNob3J0UmFkO1xuICAgICAgICAgICAgcm91bmRuZXNzID0gbG9uZ0ZsYWcgPyBsb25nUm91bmQgOiBzaG9ydFJvdW5kO1xuICAgICAgICAgICAgcGVyaW1TZWdtZW50ID0gbG9uZ0ZsYWcgPyBsb25nUGVyaW1TZWdtZW50IDogc2hvcnRQZXJpbVNlZ21lbnQ7XG4gICAgICAgICAgICB2YXIgeCA9IHJhZCAqIE1hdGguY29zKGN1cnJlbnRBbmcpO1xuICAgICAgICAgICAgdmFyIHkgPSByYWQgKiBNYXRoLnNpbihjdXJyZW50QW5nKTtcbiAgICAgICAgICAgIHZhciBveCA9IHggPT09IDAgJiYgeSA9PT0gMCA/IDAgOiB5IC8gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICAgICAgdmFyIG95ID0geCA9PT0gMCAmJiB5ID09PSAwID8gMCA6IC14IC8gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICAgICAgeCArPSArdGhpcy5wLnZbMF07XG4gICAgICAgICAgICB5ICs9ICt0aGlzLnAudlsxXTtcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdCh4LCB5LCB4IC0gb3ggKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIHkgLSBveSAqIHBlcmltU2VnbWVudCAqIHJvdW5kbmVzcyAqIGRpciwgeCArIG94ICogcGVyaW1TZWdtZW50ICogcm91bmRuZXNzICogZGlyLCB5ICsgb3kgKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIGksIHRydWUpO1xuICAgICAgICAgICAgLyogdGhpcy52LnZbaV0gPSBbeCx5XTtcclxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMudi5pW2ldID0gW3grb3gqcGVyaW1TZWdtZW50KnJvdW5kbmVzcypkaXIseStveSpwZXJpbVNlZ21lbnQqcm91bmRuZXNzKmRpcl07XHJcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnYub1tpXSA9IFt4LW94KnBlcmltU2VnbWVudCpyb3VuZG5lc3MqZGlyLHktb3kqcGVyaW1TZWdtZW50KnJvdW5kbmVzcypkaXJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy52Ll9sZW5ndGggPSBudW1QdHM7ICovXG5cbiAgICAgICAgICAgIGxvbmdGbGFnID0gIWxvbmdGbGFnO1xuICAgICAgICAgICAgY3VycmVudEFuZyArPSBhbmdsZSAqIGRpcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnZlcnRQb2x5Z29uVG9QYXRoOiBmdW5jdGlvbiBjb252ZXJ0UG9seWdvblRvUGF0aCgpIHtcbiAgICAgICAgICB2YXIgbnVtUHRzID0gTWF0aC5mbG9vcih0aGlzLnB0LnYpO1xuICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguUEkgKiAyIC8gbnVtUHRzO1xuICAgICAgICAgIHZhciByYWQgPSB0aGlzLm9yLnY7XG4gICAgICAgICAgdmFyIHJvdW5kbmVzcyA9IHRoaXMub3MudjtcbiAgICAgICAgICB2YXIgcGVyaW1TZWdtZW50ID0gMiAqIE1hdGguUEkgKiByYWQgLyAobnVtUHRzICogNCk7XG4gICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgdmFyIGN1cnJlbnRBbmcgPSAtTWF0aC5QSSAqIDAuNTtcbiAgICAgICAgICB2YXIgZGlyID0gdGhpcy5kYXRhLmQgPT09IDMgPyAtMSA6IDE7XG4gICAgICAgICAgY3VycmVudEFuZyArPSB0aGlzLnIudjtcbiAgICAgICAgICB0aGlzLnYuX2xlbmd0aCA9IDA7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUHRzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcmFkICogTWF0aC5jb3MoY3VycmVudEFuZyk7XG4gICAgICAgICAgICB2YXIgeSA9IHJhZCAqIE1hdGguc2luKGN1cnJlbnRBbmcpO1xuICAgICAgICAgICAgdmFyIG94ID0geCA9PT0gMCAmJiB5ID09PSAwID8gMCA6IHkgLyBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgICAgICAgICB2YXIgb3kgPSB4ID09PSAwICYmIHkgPT09IDAgPyAwIDogLXggLyBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgICAgICAgICB4ICs9ICt0aGlzLnAudlswXTtcbiAgICAgICAgICAgIHkgKz0gK3RoaXMucC52WzFdO1xuICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHgsIHksIHggLSBveCAqIHBlcmltU2VnbWVudCAqIHJvdW5kbmVzcyAqIGRpciwgeSAtIG95ICogcGVyaW1TZWdtZW50ICogcm91bmRuZXNzICogZGlyLCB4ICsgb3ggKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIHkgKyBveSAqIHBlcmltU2VnbWVudCAqIHJvdW5kbmVzcyAqIGRpciwgaSwgdHJ1ZSk7XG4gICAgICAgICAgICBjdXJyZW50QW5nICs9IGFuZ2xlICogZGlyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucGF0aHMubGVuZ3RoID0gMDtcbiAgICAgICAgICB0aGlzLnBhdGhzWzBdID0gdGhpcy52O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBTdGFyU2hhcGVQcm9wZXJ0eUZhY3RvcnkpO1xuICAgICAgcmV0dXJuIFN0YXJTaGFwZVByb3BlcnR5RmFjdG9yeTtcbiAgICB9KCk7XG5cbiAgICB2YXIgUmVjdFNoYXBlUHJvcGVydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBSZWN0U2hhcGVQcm9wZXJ0eUZhY3RvcnkoZWxlbSwgZGF0YSkge1xuICAgICAgICB0aGlzLnYgPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xuICAgICAgICB0aGlzLnYuYyA9IHRydWU7XG4gICAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZUNvbGxlY3Rpb25Qb29sLm5ld1NoYXBlQ29sbGVjdGlvbigpO1xuICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uLmFkZFNoYXBlKHRoaXMudik7XG4gICAgICAgIHRoaXMucGF0aHMgPSB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XG4gICAgICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xuICAgICAgICB0aGlzLmQgPSBkYXRhLmQ7XG4gICAgICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcbiAgICAgICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5wLCAxLCAwLCB0aGlzKTtcbiAgICAgICAgdGhpcy5zID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5zLCAxLCAwLCB0aGlzKTtcbiAgICAgICAgdGhpcy5yID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yLCAwLCAwLCB0aGlzKTtcblxuICAgICAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmsgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuayA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuY29udmVydFJlY3RUb1BhdGgoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBSZWN0U2hhcGVQcm9wZXJ0eUZhY3RvcnkucHJvdG90eXBlID0ge1xuICAgICAgICBjb252ZXJ0UmVjdFRvUGF0aDogZnVuY3Rpb24gY29udmVydFJlY3RUb1BhdGgoKSB7XG4gICAgICAgICAgdmFyIHAwID0gdGhpcy5wLnZbMF07XG4gICAgICAgICAgdmFyIHAxID0gdGhpcy5wLnZbMV07XG4gICAgICAgICAgdmFyIHYwID0gdGhpcy5zLnZbMF0gLyAyO1xuICAgICAgICAgIHZhciB2MSA9IHRoaXMucy52WzFdIC8gMjtcbiAgICAgICAgICB2YXIgcm91bmQgPSBibU1pbih2MCwgdjEsIHRoaXMuci52KTtcbiAgICAgICAgICB2YXIgY1BvaW50ID0gcm91bmQgKiAoMSAtIHJvdW5kQ29ybmVyKTtcbiAgICAgICAgICB0aGlzLnYuX2xlbmd0aCA9IDA7XG5cbiAgICAgICAgICBpZiAodGhpcy5kID09PSAyIHx8IHRoaXMuZCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAsIHAxIC0gdjEgKyByb3VuZCwgcDAgKyB2MCwgcDEgLSB2MSArIHJvdW5kLCBwMCArIHYwLCBwMSAtIHYxICsgY1BvaW50LCAwLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCArIHYwLCBwMSArIHYxIC0gcm91bmQsIHAwICsgdjAsIHAxICsgdjEgLSBjUG9pbnQsIHAwICsgdjAsIHAxICsgdjEgLSByb3VuZCwgMSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChyb3VuZCAhPT0gMCkge1xuICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCAtIHJvdW5kLCBwMSArIHYxLCBwMCArIHYwIC0gcm91bmQsIHAxICsgdjEsIHAwICsgdjAgLSBjUG9pbnQsIHAxICsgdjEsIDIsIHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCArIHJvdW5kLCBwMSArIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSArIHYxLCBwMCAtIHYwICsgcm91bmQsIHAxICsgdjEsIDMsIHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCwgcDEgKyB2MSAtIHJvdW5kLCBwMCAtIHYwLCBwMSArIHYxIC0gcm91bmQsIHAwIC0gdjAsIHAxICsgdjEgLSBjUG9pbnQsIDQsIHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCwgcDEgLSB2MSArIHJvdW5kLCBwMCAtIHYwLCBwMSAtIHYxICsgY1BvaW50LCBwMCAtIHYwLCBwMSAtIHYxICsgcm91bmQsIDUsIHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCArIHJvdW5kLCBwMSAtIHYxLCBwMCAtIHYwICsgcm91bmQsIHAxIC0gdjEsIHAwIC0gdjAgKyBjUG9pbnQsIHAxIC0gdjEsIDYsIHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCAtIHJvdW5kLCBwMSAtIHYxLCBwMCArIHYwIC0gY1BvaW50LCBwMSAtIHYxLCBwMCArIHYwIC0gcm91bmQsIHAxIC0gdjEsIDcsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxICsgdjEsIHAwIC0gdjAgKyBjUG9pbnQsIHAxICsgdjEsIHAwIC0gdjAsIHAxICsgdjEsIDIpO1xuICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCwgcDEgLSB2MSwgcDAgLSB2MCwgcDEgLSB2MSArIGNQb2ludCwgcDAgLSB2MCwgcDEgLSB2MSwgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCArIHYwLCBwMSAtIHYxICsgcm91bmQsIHAwICsgdjAsIHAxIC0gdjEgKyBjUG9pbnQsIHAwICsgdjAsIHAxIC0gdjEgKyByb3VuZCwgMCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChyb3VuZCAhPT0gMCkge1xuICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCAtIHJvdW5kLCBwMSAtIHYxLCBwMCArIHYwIC0gcm91bmQsIHAxIC0gdjEsIHAwICsgdjAgLSBjUG9pbnQsIHAxIC0gdjEsIDEsIHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCArIHJvdW5kLCBwMSAtIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSAtIHYxLCBwMCAtIHYwICsgcm91bmQsIHAxIC0gdjEsIDIsIHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCwgcDEgLSB2MSArIHJvdW5kLCBwMCAtIHYwLCBwMSAtIHYxICsgcm91bmQsIHAwIC0gdjAsIHAxIC0gdjEgKyBjUG9pbnQsIDMsIHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCwgcDEgKyB2MSAtIHJvdW5kLCBwMCAtIHYwLCBwMSArIHYxIC0gY1BvaW50LCBwMCAtIHYwLCBwMSArIHYxIC0gcm91bmQsIDQsIHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCArIHJvdW5kLCBwMSArIHYxLCBwMCAtIHYwICsgcm91bmQsIHAxICsgdjEsIHAwIC0gdjAgKyBjUG9pbnQsIHAxICsgdjEsIDUsIHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCAtIHJvdW5kLCBwMSArIHYxLCBwMCArIHYwIC0gY1BvaW50LCBwMSArIHYxLCBwMCArIHYwIC0gcm91bmQsIHAxICsgdjEsIDYsIHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCwgcDEgKyB2MSAtIHJvdW5kLCBwMCArIHYwLCBwMSArIHYxIC0gcm91bmQsIHAwICsgdjAsIHAxICsgdjEgLSBjUG9pbnQsIDcsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxIC0gdjEsIHAwIC0gdjAgKyBjUG9pbnQsIHAxIC0gdjEsIHAwIC0gdjAsIHAxIC0gdjEsIDEsIHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCwgcDEgKyB2MSwgcDAgLSB2MCwgcDEgKyB2MSAtIGNQb2ludCwgcDAgLSB2MCwgcDEgKyB2MSwgMiwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCArIHYwLCBwMSArIHYxLCBwMCArIHYwIC0gY1BvaW50LCBwMSArIHYxLCBwMCArIHYwLCBwMSArIHYxLCAzLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcbiAgICAgICAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX21kZikge1xuICAgICAgICAgICAgdGhpcy5jb252ZXJ0UmVjdFRvUGF0aCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6IHJlc2V0U2hhcGVcbiAgICAgIH07XG4gICAgICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFJlY3RTaGFwZVByb3BlcnR5RmFjdG9yeSk7XG4gICAgICByZXR1cm4gUmVjdFNoYXBlUHJvcGVydHlGYWN0b3J5O1xuICAgIH0oKTtcblxuICAgIGZ1bmN0aW9uIGdldFNoYXBlUHJvcChlbGVtLCBkYXRhLCB0eXBlKSB7XG4gICAgICB2YXIgcHJvcDtcblxuICAgICAgaWYgKHR5cGUgPT09IDMgfHwgdHlwZSA9PT0gNCkge1xuICAgICAgICB2YXIgZGF0YVByb3AgPSB0eXBlID09PSAzID8gZGF0YS5wdCA6IGRhdGEua3M7XG4gICAgICAgIHZhciBrZXlzID0gZGF0YVByb3AuaztcblxuICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICBwcm9wID0gbmV3IEtleWZyYW1lZFNoYXBlUHJvcGVydHkoZWxlbSwgZGF0YSwgdHlwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcCA9IG5ldyBTaGFwZVByb3BlcnR5KGVsZW0sIGRhdGEsIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDUpIHtcbiAgICAgICAgcHJvcCA9IG5ldyBSZWN0U2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNikge1xuICAgICAgICBwcm9wID0gbmV3IEVsbFNoYXBlUHJvcGVydHkoZWxlbSwgZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDcpIHtcbiAgICAgICAgcHJvcCA9IG5ldyBTdGFyU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3Auaykge1xuICAgICAgICBlbGVtLmFkZER5bmFtaWNQcm9wZXJ0eShwcm9wKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3JGdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBTaGFwZVByb3BlcnR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEtleWZyYW1lZENvbnN0cnVjdG9yRnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eTtcbiAgICB9XG5cbiAgICB2YXIgb2IgPSB7fTtcbiAgICBvYi5nZXRTaGFwZVByb3AgPSBnZXRTaGFwZVByb3A7XG4gICAgb2IuZ2V0Q29uc3RydWN0b3JGdW5jdGlvbiA9IGdldENvbnN0cnVjdG9yRnVuY3Rpb247XG4gICAgb2IuZ2V0S2V5ZnJhbWVkQ29uc3RydWN0b3JGdW5jdGlvbiA9IGdldEtleWZyYW1lZENvbnN0cnVjdG9yRnVuY3Rpb247XG4gICAgcmV0dXJuIG9iO1xuICB9KCk7XG5cbiAgLyohXHJcbiAgIFRyYW5zZm9ybWF0aW9uIE1hdHJpeCB2Mi4wXHJcbiAgIChjKSBFcGlzdGVtZXggMjAxNC0yMDE1XHJcbiAgIHd3dy5lcGlzdGVtZXguY29tXHJcbiAgIEJ5IEtlbiBGeXJzdGVuYmVyZ1xyXG4gICBDb250cmlidXRpb25zIGJ5IGxlZW9uaXlhLlxyXG4gICBMaWNlbnNlOiBNSVQsIGhlYWRlciByZXF1aXJlZC5cclxuICAgKi9cblxuICAvKipcclxuICAgKiAyRCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2JqZWN0IGluaXRpYWxpemVkIHdpdGggaWRlbnRpdHkgbWF0cml4LlxyXG4gICAqXHJcbiAgICogVGhlIG1hdHJpeCBjYW4gc3luY2hyb25pemUgYSBjYW52YXMgY29udGV4dCBieSBzdXBwbHlpbmcgdGhlIGNvbnRleHRcclxuICAgKiBhcyBhbiBhcmd1bWVudCwgb3IgbGF0ZXIgYXBwbHkgY3VycmVudCBhYnNvbHV0ZSB0cmFuc2Zvcm0gdG8gYW5cclxuICAgKiBleGlzdGluZyBjb250ZXh0LlxyXG4gICAqXHJcbiAgICogQWxsIHZhbHVlcyBhcmUgaGFuZGxlZCBhcyBmbG9hdGluZyBwb2ludCB2YWx1ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gW2NvbnRleHRdIC0gT3B0aW9uYWwgY29udGV4dCB0byBzeW5jIHdpdGggTWF0cml4XHJcbiAgICogQHByb3Age251bWJlcn0gYSAtIHNjYWxlIHhcclxuICAgKiBAcHJvcCB7bnVtYmVyfSBiIC0gc2hlYXIgeVxyXG4gICAqIEBwcm9wIHtudW1iZXJ9IGMgLSBzaGVhciB4XHJcbiAgICogQHByb3Age251bWJlcn0gZCAtIHNjYWxlIHlcclxuICAgKiBAcHJvcCB7bnVtYmVyfSBlIC0gdHJhbnNsYXRlIHhcclxuICAgKiBAcHJvcCB7bnVtYmVyfSBmIC0gdHJhbnNsYXRlIHlcclxuICAgKiBAcHJvcCB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfG51bGx9IFtjb250ZXh0PW51bGxdIC0gc2V0IG9yIGdldCBjdXJyZW50IGNhbnZhcyBjb250ZXh0XHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICovXG5cbiAgdmFyIE1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2NvcyA9IE1hdGguY29zO1xuICAgIHZhciBfc2luID0gTWF0aC5zaW47XG4gICAgdmFyIF90YW4gPSBNYXRoLnRhbjtcbiAgICB2YXIgX3JuZCA9IE1hdGgucm91bmQ7XG5cbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMucHJvcHNbMF0gPSAxO1xuICAgICAgdGhpcy5wcm9wc1sxXSA9IDA7XG4gICAgICB0aGlzLnByb3BzWzJdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbM10gPSAwO1xuICAgICAgdGhpcy5wcm9wc1s0XSA9IDA7XG4gICAgICB0aGlzLnByb3BzWzVdID0gMTtcbiAgICAgIHRoaXMucHJvcHNbNl0gPSAwO1xuICAgICAgdGhpcy5wcm9wc1s3XSA9IDA7XG4gICAgICB0aGlzLnByb3BzWzhdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbOV0gPSAwO1xuICAgICAgdGhpcy5wcm9wc1sxMF0gPSAxO1xuICAgICAgdGhpcy5wcm9wc1sxMV0gPSAwO1xuICAgICAgdGhpcy5wcm9wc1sxMl0gPSAwO1xuICAgICAgdGhpcy5wcm9wc1sxM10gPSAwO1xuICAgICAgdGhpcy5wcm9wc1sxNF0gPSAwO1xuICAgICAgdGhpcy5wcm9wc1sxNV0gPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm90YXRlKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBtQ29zID0gX2NvcyhhbmdsZSk7XG5cbiAgICAgIHZhciBtU2luID0gX3NpbihhbmdsZSk7XG5cbiAgICAgIHJldHVybiB0aGlzLl90KG1Db3MsIC1tU2luLCAwLCAwLCBtU2luLCBtQ29zLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByb3RhdGVYKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBtQ29zID0gX2NvcyhhbmdsZSk7XG5cbiAgICAgIHZhciBtU2luID0gX3NpbihhbmdsZSk7XG5cbiAgICAgIHJldHVybiB0aGlzLl90KDEsIDAsIDAsIDAsIDAsIG1Db3MsIC1tU2luLCAwLCAwLCBtU2luLCBtQ29zLCAwLCAwLCAwLCAwLCAxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByb3RhdGVZKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBtQ29zID0gX2NvcyhhbmdsZSk7XG5cbiAgICAgIHZhciBtU2luID0gX3NpbihhbmdsZSk7XG5cbiAgICAgIHJldHVybiB0aGlzLl90KG1Db3MsIDAsIG1TaW4sIDAsIDAsIDEsIDAsIDAsIC1tU2luLCAwLCBtQ29zLCAwLCAwLCAwLCAwLCAxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByb3RhdGVaKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBtQ29zID0gX2NvcyhhbmdsZSk7XG5cbiAgICAgIHZhciBtU2luID0gX3NpbihhbmdsZSk7XG5cbiAgICAgIHJldHVybiB0aGlzLl90KG1Db3MsIC1tU2luLCAwLCAwLCBtU2luLCBtQ29zLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaGVhcihzeCwgc3kpIHtcbiAgICAgIHJldHVybiB0aGlzLl90KDEsIHN5LCBzeCwgMSwgMCwgMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tldyhheCwgYXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNoZWFyKF90YW4oYXgpLCBfdGFuKGF5KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tld0Zyb21BeGlzKGF4LCBhbmdsZSkge1xuICAgICAgdmFyIG1Db3MgPSBfY29zKGFuZ2xlKTtcblxuICAgICAgdmFyIG1TaW4gPSBfc2luKGFuZ2xlKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3QobUNvcywgbVNpbiwgMCwgMCwgLW1TaW4sIG1Db3MsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpLl90KDEsIDAsIDAsIDAsIF90YW4oYXgpLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKS5fdChtQ29zLCAtbVNpbiwgMCwgMCwgbVNpbiwgbUNvcywgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSk7IC8vIHJldHVybiB0aGlzLl90KG1Db3MsIG1TaW4sIC1tU2luLCBtQ29zLCAwLCAwKS5fdCgxLCAwLCBfdGFuKGF4KSwgMSwgMCwgMCkuX3QobUNvcywgLW1TaW4sIG1TaW4sIG1Db3MsIDAsIDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYWxlKHN4LCBzeSwgc3opIHtcbiAgICAgIGlmICghc3ogJiYgc3ogIT09IDApIHtcbiAgICAgICAgc3ogPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3ggPT09IDEgJiYgc3kgPT09IDEgJiYgc3ogPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl90KHN4LCAwLCAwLCAwLCAwLCBzeSwgMCwgMCwgMCwgMCwgc3osIDAsIDAsIDAsIDAsIDEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsLCBtLCBuLCBvLCBwKSB7XG4gICAgICB0aGlzLnByb3BzWzBdID0gYTtcbiAgICAgIHRoaXMucHJvcHNbMV0gPSBiO1xuICAgICAgdGhpcy5wcm9wc1syXSA9IGM7XG4gICAgICB0aGlzLnByb3BzWzNdID0gZDtcbiAgICAgIHRoaXMucHJvcHNbNF0gPSBlO1xuICAgICAgdGhpcy5wcm9wc1s1XSA9IGY7XG4gICAgICB0aGlzLnByb3BzWzZdID0gZztcbiAgICAgIHRoaXMucHJvcHNbN10gPSBoO1xuICAgICAgdGhpcy5wcm9wc1s4XSA9IGk7XG4gICAgICB0aGlzLnByb3BzWzldID0gajtcbiAgICAgIHRoaXMucHJvcHNbMTBdID0gaztcbiAgICAgIHRoaXMucHJvcHNbMTFdID0gbDtcbiAgICAgIHRoaXMucHJvcHNbMTJdID0gbTtcbiAgICAgIHRoaXMucHJvcHNbMTNdID0gbjtcbiAgICAgIHRoaXMucHJvcHNbMTRdID0gbztcbiAgICAgIHRoaXMucHJvcHNbMTVdID0gcDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZSh0eCwgdHksIHR6KSB7XG4gICAgICB0eiA9IHR6IHx8IDA7XG5cbiAgICAgIGlmICh0eCAhPT0gMCB8fCB0eSAhPT0gMCB8fCB0eiAhPT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdCgxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCB0eCwgdHksIHR6LCAxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIsIGcyLCBoMiwgaTIsIGoyLCBrMiwgbDIsIG0yLCBuMiwgbzIsIHAyKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLnByb3BzO1xuXG4gICAgICBpZiAoYTIgPT09IDEgJiYgYjIgPT09IDAgJiYgYzIgPT09IDAgJiYgZDIgPT09IDAgJiYgZTIgPT09IDAgJiYgZjIgPT09IDEgJiYgZzIgPT09IDAgJiYgaDIgPT09IDAgJiYgaTIgPT09IDAgJiYgajIgPT09IDAgJiYgazIgPT09IDEgJiYgbDIgPT09IDApIHtcbiAgICAgICAgLy8gTk9URTogY29tbWVudGluZyB0aGlzIGNvbmRpdGlvbiBiZWNhdXNlIFR1cmJvRmFuIGRlb3B0aW1pemVzIGNvZGUgd2hlbiBwcmVzZW50XG4gICAgICAgIC8vIGlmKG0yICE9PSAwIHx8IG4yICE9PSAwIHx8IG8yICE9PSAwKXtcbiAgICAgICAgX3BbMTJdID0gX3BbMTJdICogYTIgKyBfcFsxNV0gKiBtMjtcbiAgICAgICAgX3BbMTNdID0gX3BbMTNdICogZjIgKyBfcFsxNV0gKiBuMjtcbiAgICAgICAgX3BbMTRdID0gX3BbMTRdICogazIgKyBfcFsxNV0gKiBvMjtcbiAgICAgICAgX3BbMTVdICo9IHAyOyAvLyB9XG5cbiAgICAgICAgdGhpcy5faWRlbnRpdHlDYWxjdWxhdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgYTEgPSBfcFswXTtcbiAgICAgIHZhciBiMSA9IF9wWzFdO1xuICAgICAgdmFyIGMxID0gX3BbMl07XG4gICAgICB2YXIgZDEgPSBfcFszXTtcbiAgICAgIHZhciBlMSA9IF9wWzRdO1xuICAgICAgdmFyIGYxID0gX3BbNV07XG4gICAgICB2YXIgZzEgPSBfcFs2XTtcbiAgICAgIHZhciBoMSA9IF9wWzddO1xuICAgICAgdmFyIGkxID0gX3BbOF07XG4gICAgICB2YXIgajEgPSBfcFs5XTtcbiAgICAgIHZhciBrMSA9IF9wWzEwXTtcbiAgICAgIHZhciBsMSA9IF9wWzExXTtcbiAgICAgIHZhciBtMSA9IF9wWzEyXTtcbiAgICAgIHZhciBuMSA9IF9wWzEzXTtcbiAgICAgIHZhciBvMSA9IF9wWzE0XTtcbiAgICAgIHZhciBwMSA9IF9wWzE1XTtcbiAgICAgIC8qIG1hdHJpeCBvcmRlciAoY2FudmFzIGNvbXBhdGlibGUpOlxyXG4gICAgICAgICAgICogYWNlXHJcbiAgICAgICAgICAgKiBiZGZcclxuICAgICAgICAgICAqIDAwMVxyXG4gICAgICAgICAgICovXG5cbiAgICAgIF9wWzBdID0gYTEgKiBhMiArIGIxICogZTIgKyBjMSAqIGkyICsgZDEgKiBtMjtcbiAgICAgIF9wWzFdID0gYTEgKiBiMiArIGIxICogZjIgKyBjMSAqIGoyICsgZDEgKiBuMjtcbiAgICAgIF9wWzJdID0gYTEgKiBjMiArIGIxICogZzIgKyBjMSAqIGsyICsgZDEgKiBvMjtcbiAgICAgIF9wWzNdID0gYTEgKiBkMiArIGIxICogaDIgKyBjMSAqIGwyICsgZDEgKiBwMjtcbiAgICAgIF9wWzRdID0gZTEgKiBhMiArIGYxICogZTIgKyBnMSAqIGkyICsgaDEgKiBtMjtcbiAgICAgIF9wWzVdID0gZTEgKiBiMiArIGYxICogZjIgKyBnMSAqIGoyICsgaDEgKiBuMjtcbiAgICAgIF9wWzZdID0gZTEgKiBjMiArIGYxICogZzIgKyBnMSAqIGsyICsgaDEgKiBvMjtcbiAgICAgIF9wWzddID0gZTEgKiBkMiArIGYxICogaDIgKyBnMSAqIGwyICsgaDEgKiBwMjtcbiAgICAgIF9wWzhdID0gaTEgKiBhMiArIGoxICogZTIgKyBrMSAqIGkyICsgbDEgKiBtMjtcbiAgICAgIF9wWzldID0gaTEgKiBiMiArIGoxICogZjIgKyBrMSAqIGoyICsgbDEgKiBuMjtcbiAgICAgIF9wWzEwXSA9IGkxICogYzIgKyBqMSAqIGcyICsgazEgKiBrMiArIGwxICogbzI7XG4gICAgICBfcFsxMV0gPSBpMSAqIGQyICsgajEgKiBoMiArIGsxICogbDIgKyBsMSAqIHAyO1xuICAgICAgX3BbMTJdID0gbTEgKiBhMiArIG4xICogZTIgKyBvMSAqIGkyICsgcDEgKiBtMjtcbiAgICAgIF9wWzEzXSA9IG0xICogYjIgKyBuMSAqIGYyICsgbzEgKiBqMiArIHAxICogbjI7XG4gICAgICBfcFsxNF0gPSBtMSAqIGMyICsgbjEgKiBnMiArIG8xICogazIgKyBwMSAqIG8yO1xuICAgICAgX3BbMTVdID0gbTEgKiBkMiArIG4xICogaDIgKyBvMSAqIGwyICsgcDEgKiBwMjtcbiAgICAgIHRoaXMuX2lkZW50aXR5Q2FsY3VsYXRlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXVsdGlwbHkobWF0cml4KSB7XG4gICAgICB2YXIgbWF0cml4UHJvcHMgPSBtYXRyaXgucHJvcHM7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0obWF0cml4UHJvcHNbMF0sIG1hdHJpeFByb3BzWzFdLCBtYXRyaXhQcm9wc1syXSwgbWF0cml4UHJvcHNbM10sIG1hdHJpeFByb3BzWzRdLCBtYXRyaXhQcm9wc1s1XSwgbWF0cml4UHJvcHNbNl0sIG1hdHJpeFByb3BzWzddLCBtYXRyaXhQcm9wc1s4XSwgbWF0cml4UHJvcHNbOV0sIG1hdHJpeFByb3BzWzEwXSwgbWF0cml4UHJvcHNbMTFdLCBtYXRyaXhQcm9wc1sxMl0sIG1hdHJpeFByb3BzWzEzXSwgbWF0cml4UHJvcHNbMTRdLCBtYXRyaXhQcm9wc1sxNV0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSWRlbnRpdHkoKSB7XG4gICAgICBpZiAoIXRoaXMuX2lkZW50aXR5Q2FsY3VsYXRlZCkge1xuICAgICAgICB0aGlzLl9pZGVudGl0eSA9ICEodGhpcy5wcm9wc1swXSAhPT0gMSB8fCB0aGlzLnByb3BzWzFdICE9PSAwIHx8IHRoaXMucHJvcHNbMl0gIT09IDAgfHwgdGhpcy5wcm9wc1szXSAhPT0gMCB8fCB0aGlzLnByb3BzWzRdICE9PSAwIHx8IHRoaXMucHJvcHNbNV0gIT09IDEgfHwgdGhpcy5wcm9wc1s2XSAhPT0gMCB8fCB0aGlzLnByb3BzWzddICE9PSAwIHx8IHRoaXMucHJvcHNbOF0gIT09IDAgfHwgdGhpcy5wcm9wc1s5XSAhPT0gMCB8fCB0aGlzLnByb3BzWzEwXSAhPT0gMSB8fCB0aGlzLnByb3BzWzExXSAhPT0gMCB8fCB0aGlzLnByb3BzWzEyXSAhPT0gMCB8fCB0aGlzLnByb3BzWzEzXSAhPT0gMCB8fCB0aGlzLnByb3BzWzE0XSAhPT0gMCB8fCB0aGlzLnByb3BzWzE1XSAhPT0gMSk7XG4gICAgICAgIHRoaXMuX2lkZW50aXR5Q2FsY3VsYXRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9pZGVudGl0eTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcXVhbHMobWF0cikge1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IDE2KSB7XG4gICAgICAgIGlmIChtYXRyLnByb3BzW2ldICE9PSB0aGlzLnByb3BzW2ldKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZShtYXRyKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgICAgbWF0ci5wcm9wc1tpXSA9IHRoaXMucHJvcHNbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lRnJvbVByb3BzKHByb3BzKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5wcm9wc1tpXSA9IHByb3BzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5VG9Qb2ludCh4LCB5LCB6KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICogdGhpcy5wcm9wc1swXSArIHkgKiB0aGlzLnByb3BzWzRdICsgeiAqIHRoaXMucHJvcHNbOF0gKyB0aGlzLnByb3BzWzEyXSxcbiAgICAgICAgeTogeCAqIHRoaXMucHJvcHNbMV0gKyB5ICogdGhpcy5wcm9wc1s1XSArIHogKiB0aGlzLnByb3BzWzldICsgdGhpcy5wcm9wc1sxM10sXG4gICAgICAgIHo6IHggKiB0aGlzLnByb3BzWzJdICsgeSAqIHRoaXMucHJvcHNbNl0gKyB6ICogdGhpcy5wcm9wc1sxMF0gKyB0aGlzLnByb3BzWzE0XVxuICAgICAgfTtcbiAgICAgIC8qIHJldHVybiB7XHJcbiAgICAgICAgICAgeDogeCAqIG1lLmEgKyB5ICogbWUuYyArIG1lLmUsXHJcbiAgICAgICAgICAgeTogeCAqIG1lLmIgKyB5ICogbWUuZCArIG1lLmZcclxuICAgICAgICAgICB9OyAqL1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5VG9YKHgsIHksIHopIHtcbiAgICAgIHJldHVybiB4ICogdGhpcy5wcm9wc1swXSArIHkgKiB0aGlzLnByb3BzWzRdICsgeiAqIHRoaXMucHJvcHNbOF0gKyB0aGlzLnByb3BzWzEyXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVRvWSh4LCB5LCB6KSB7XG4gICAgICByZXR1cm4geCAqIHRoaXMucHJvcHNbMV0gKyB5ICogdGhpcy5wcm9wc1s1XSArIHogKiB0aGlzLnByb3BzWzldICsgdGhpcy5wcm9wc1sxM107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlUb1ooeCwgeSwgeikge1xuICAgICAgcmV0dXJuIHggKiB0aGlzLnByb3BzWzJdICsgeSAqIHRoaXMucHJvcHNbNl0gKyB6ICogdGhpcy5wcm9wc1sxMF0gKyB0aGlzLnByb3BzWzE0XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJbnZlcnNlTWF0cml4KCkge1xuICAgICAgdmFyIGRldGVybWluYW50ID0gdGhpcy5wcm9wc1swXSAqIHRoaXMucHJvcHNbNV0gLSB0aGlzLnByb3BzWzFdICogdGhpcy5wcm9wc1s0XTtcbiAgICAgIHZhciBhID0gdGhpcy5wcm9wc1s1XSAvIGRldGVybWluYW50O1xuICAgICAgdmFyIGIgPSAtdGhpcy5wcm9wc1sxXSAvIGRldGVybWluYW50O1xuICAgICAgdmFyIGMgPSAtdGhpcy5wcm9wc1s0XSAvIGRldGVybWluYW50O1xuICAgICAgdmFyIGQgPSB0aGlzLnByb3BzWzBdIC8gZGV0ZXJtaW5hbnQ7XG4gICAgICB2YXIgZSA9ICh0aGlzLnByb3BzWzRdICogdGhpcy5wcm9wc1sxM10gLSB0aGlzLnByb3BzWzVdICogdGhpcy5wcm9wc1sxMl0pIC8gZGV0ZXJtaW5hbnQ7XG4gICAgICB2YXIgZiA9IC0odGhpcy5wcm9wc1swXSAqIHRoaXMucHJvcHNbMTNdIC0gdGhpcy5wcm9wc1sxXSAqIHRoaXMucHJvcHNbMTJdKSAvIGRldGVybWluYW50O1xuICAgICAgdmFyIGludmVyc2VNYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgICBpbnZlcnNlTWF0cml4LnByb3BzWzBdID0gYTtcbiAgICAgIGludmVyc2VNYXRyaXgucHJvcHNbMV0gPSBiO1xuICAgICAgaW52ZXJzZU1hdHJpeC5wcm9wc1s0XSA9IGM7XG4gICAgICBpbnZlcnNlTWF0cml4LnByb3BzWzVdID0gZDtcbiAgICAgIGludmVyc2VNYXRyaXgucHJvcHNbMTJdID0gZTtcbiAgICAgIGludmVyc2VNYXRyaXgucHJvcHNbMTNdID0gZjtcbiAgICAgIHJldHVybiBpbnZlcnNlTWF0cml4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmVyc2VQb2ludChwdCkge1xuICAgICAgdmFyIGludmVyc2VNYXRyaXggPSB0aGlzLmdldEludmVyc2VNYXRyaXgoKTtcbiAgICAgIHJldHVybiBpbnZlcnNlTWF0cml4LmFwcGx5VG9Qb2ludEFycmF5KHB0WzBdLCBwdFsxXSwgcHRbMl0gfHwgMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52ZXJzZVBvaW50cyhwdHMpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHB0cy5sZW5ndGg7XG4gICAgICB2YXIgcmV0UHRzID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZXRQdHNbaV0gPSBpbnZlcnNlUG9pbnQocHRzW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldFB0cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVRvVHJpcGxlUG9pbnRzKHB0MSwgcHQyLCBwdDMpIHtcbiAgICAgIHZhciBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgNik7XG5cbiAgICAgIGlmICh0aGlzLmlzSWRlbnRpdHkoKSkge1xuICAgICAgICBhcnJbMF0gPSBwdDFbMF07XG4gICAgICAgIGFyclsxXSA9IHB0MVsxXTtcbiAgICAgICAgYXJyWzJdID0gcHQyWzBdO1xuICAgICAgICBhcnJbM10gPSBwdDJbMV07XG4gICAgICAgIGFycls0XSA9IHB0M1swXTtcbiAgICAgICAgYXJyWzVdID0gcHQzWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHAwID0gdGhpcy5wcm9wc1swXTtcbiAgICAgICAgdmFyIHAxID0gdGhpcy5wcm9wc1sxXTtcbiAgICAgICAgdmFyIHA0ID0gdGhpcy5wcm9wc1s0XTtcbiAgICAgICAgdmFyIHA1ID0gdGhpcy5wcm9wc1s1XTtcbiAgICAgICAgdmFyIHAxMiA9IHRoaXMucHJvcHNbMTJdO1xuICAgICAgICB2YXIgcDEzID0gdGhpcy5wcm9wc1sxM107XG4gICAgICAgIGFyclswXSA9IHB0MVswXSAqIHAwICsgcHQxWzFdICogcDQgKyBwMTI7XG4gICAgICAgIGFyclsxXSA9IHB0MVswXSAqIHAxICsgcHQxWzFdICogcDUgKyBwMTM7XG4gICAgICAgIGFyclsyXSA9IHB0MlswXSAqIHAwICsgcHQyWzFdICogcDQgKyBwMTI7XG4gICAgICAgIGFyclszXSA9IHB0MlswXSAqIHAxICsgcHQyWzFdICogcDUgKyBwMTM7XG4gICAgICAgIGFycls0XSA9IHB0M1swXSAqIHAwICsgcHQzWzFdICogcDQgKyBwMTI7XG4gICAgICAgIGFycls1XSA9IHB0M1swXSAqIHAxICsgcHQzWzFdICogcDUgKyBwMTM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlUb1BvaW50QXJyYXkoeCwgeSwgeikge1xuICAgICAgdmFyIGFycjtcblxuICAgICAgaWYgKHRoaXMuaXNJZGVudGl0eSgpKSB7XG4gICAgICAgIGFyciA9IFt4LCB5LCB6XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyciA9IFt4ICogdGhpcy5wcm9wc1swXSArIHkgKiB0aGlzLnByb3BzWzRdICsgeiAqIHRoaXMucHJvcHNbOF0gKyB0aGlzLnByb3BzWzEyXSwgeCAqIHRoaXMucHJvcHNbMV0gKyB5ICogdGhpcy5wcm9wc1s1XSArIHogKiB0aGlzLnByb3BzWzldICsgdGhpcy5wcm9wc1sxM10sIHggKiB0aGlzLnByb3BzWzJdICsgeSAqIHRoaXMucHJvcHNbNl0gKyB6ICogdGhpcy5wcm9wc1sxMF0gKyB0aGlzLnByb3BzWzE0XV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoeCwgeSkge1xuICAgICAgaWYgKHRoaXMuaXNJZGVudGl0eSgpKSB7XG4gICAgICAgIHJldHVybiB4ICsgJywnICsgeTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9wID0gdGhpcy5wcm9wcztcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKCh4ICogX3BbMF0gKyB5ICogX3BbNF0gKyBfcFsxMl0pICogMTAwKSAvIDEwMCArICcsJyArIE1hdGgucm91bmQoKHggKiBfcFsxXSArIHkgKiBfcFs1XSArIF9wWzEzXSkgKiAxMDApIC8gMTAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQ1NTKCkge1xuICAgICAgLy8gRG9lc24ndCBtYWtlIG11Y2ggc2Vuc2UgdG8gYWRkIHRoaXMgb3B0aW1pemF0aW9uLiBJZiBpdCBpcyBhbiBpZGVudGl0eSBtYXRyaXgsIGl0J3MgdmVyeSBsaWtlbHkgdGhpcyB3aWxsIGdldCBjYWxsZWQgb25seSBvbmNlIHNpbmNlIGl0IHdvbid0IGJlIGtleWZyYW1lZC5cblxuICAgICAgLyogaWYodGhpcy5pc0lkZW50aXR5KCkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICB9ICovXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIGNzc1ZhbHVlID0gJ21hdHJpeDNkKCc7XG4gICAgICB2YXIgdiA9IDEwMDAwO1xuXG4gICAgICB3aGlsZSAoaSA8IDE2KSB7XG4gICAgICAgIGNzc1ZhbHVlICs9IF9ybmQocHJvcHNbaV0gKiB2KSAvIHY7XG4gICAgICAgIGNzc1ZhbHVlICs9IGkgPT09IDE1ID8gJyknIDogJywnO1xuICAgICAgICBpICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjc3NWYWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByb3VuZE1hdHJpeFByb3BlcnR5KHZhbCkge1xuICAgICAgdmFyIHYgPSAxMDAwMDtcblxuICAgICAgaWYgKHZhbCA8IDAuMDAwMDAxICYmIHZhbCA+IDAgfHwgdmFsID4gLTAuMDAwMDAxICYmIHZhbCA8IDApIHtcbiAgICAgICAgcmV0dXJuIF9ybmQodmFsICogdikgLyB2O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvMmRDU1MoKSB7XG4gICAgICAvLyBEb2Vzbid0IG1ha2UgbXVjaCBzZW5zZSB0byBhZGQgdGhpcyBvcHRpbWl6YXRpb24uIElmIGl0IGlzIGFuIGlkZW50aXR5IG1hdHJpeCwgaXQncyB2ZXJ5IGxpa2VseSB0aGlzIHdpbGwgZ2V0IGNhbGxlZCBvbmx5IG9uY2Ugc2luY2UgaXQgd29uJ3QgYmUga2V5ZnJhbWVkLlxuXG4gICAgICAvKiBpZih0aGlzLmlzSWRlbnRpdHkoKSkge1xyXG4gICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgIH0gKi9cbiAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG5cbiAgICAgIHZhciBfYSA9IHJvdW5kTWF0cml4UHJvcGVydHkocHJvcHNbMF0pO1xuXG4gICAgICB2YXIgX2IgPSByb3VuZE1hdHJpeFByb3BlcnR5KHByb3BzWzFdKTtcblxuICAgICAgdmFyIF9jID0gcm91bmRNYXRyaXhQcm9wZXJ0eShwcm9wc1s0XSk7XG5cbiAgICAgIHZhciBfZCA9IHJvdW5kTWF0cml4UHJvcGVydHkocHJvcHNbNV0pO1xuXG4gICAgICB2YXIgX2UgPSByb3VuZE1hdHJpeFByb3BlcnR5KHByb3BzWzEyXSk7XG5cbiAgICAgIHZhciBfZiA9IHJvdW5kTWF0cml4UHJvcGVydHkocHJvcHNbMTNdKTtcblxuICAgICAgcmV0dXJuICdtYXRyaXgoJyArIF9hICsgJywnICsgX2IgKyAnLCcgKyBfYyArICcsJyArIF9kICsgJywnICsgX2UgKyAnLCcgKyBfZiArICcpJztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5yZXNldCA9IHJlc2V0O1xuICAgICAgdGhpcy5yb3RhdGUgPSByb3RhdGU7XG4gICAgICB0aGlzLnJvdGF0ZVggPSByb3RhdGVYO1xuICAgICAgdGhpcy5yb3RhdGVZID0gcm90YXRlWTtcbiAgICAgIHRoaXMucm90YXRlWiA9IHJvdGF0ZVo7XG4gICAgICB0aGlzLnNrZXcgPSBza2V3O1xuICAgICAgdGhpcy5za2V3RnJvbUF4aXMgPSBza2V3RnJvbUF4aXM7XG4gICAgICB0aGlzLnNoZWFyID0gc2hlYXI7XG4gICAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgICB0aGlzLnNldFRyYW5zZm9ybSA9IHNldFRyYW5zZm9ybTtcbiAgICAgIHRoaXMudHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICB0aGlzLm11bHRpcGx5ID0gbXVsdGlwbHk7XG4gICAgICB0aGlzLmFwcGx5VG9Qb2ludCA9IGFwcGx5VG9Qb2ludDtcbiAgICAgIHRoaXMuYXBwbHlUb1ggPSBhcHBseVRvWDtcbiAgICAgIHRoaXMuYXBwbHlUb1kgPSBhcHBseVRvWTtcbiAgICAgIHRoaXMuYXBwbHlUb1ogPSBhcHBseVRvWjtcbiAgICAgIHRoaXMuYXBwbHlUb1BvaW50QXJyYXkgPSBhcHBseVRvUG9pbnRBcnJheTtcbiAgICAgIHRoaXMuYXBwbHlUb1RyaXBsZVBvaW50cyA9IGFwcGx5VG9UcmlwbGVQb2ludHM7XG4gICAgICB0aGlzLmFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkID0gYXBwbHlUb1BvaW50U3RyaW5naWZpZWQ7XG4gICAgICB0aGlzLnRvQ1NTID0gdG9DU1M7XG4gICAgICB0aGlzLnRvMmRDU1MgPSB0bzJkQ1NTO1xuICAgICAgdGhpcy5jbG9uZSA9IGNsb25lO1xuICAgICAgdGhpcy5jbG9uZUZyb21Qcm9wcyA9IGNsb25lRnJvbVByb3BzO1xuICAgICAgdGhpcy5lcXVhbHMgPSBlcXVhbHM7XG4gICAgICB0aGlzLmludmVyc2VQb2ludHMgPSBpbnZlcnNlUG9pbnRzO1xuICAgICAgdGhpcy5pbnZlcnNlUG9pbnQgPSBpbnZlcnNlUG9pbnQ7XG4gICAgICB0aGlzLmdldEludmVyc2VNYXRyaXggPSBnZXRJbnZlcnNlTWF0cml4O1xuICAgICAgdGhpcy5fdCA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgdGhpcy5pc0lkZW50aXR5ID0gaXNJZGVudGl0eTtcbiAgICAgIHRoaXMuX2lkZW50aXR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2lkZW50aXR5Q2FsY3VsYXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5wcm9wcyA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCAxNik7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIF90eXBlb2YkMyhvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiQzID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YkMyA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mJDMob2JqKTsgfVxuICB2YXIgbG90dGllID0ge307XG4gIHZhciBzdGFuZGFsb25lID0gJ19fW1NUQU5EQUxPTkVdX18nO1xuICB2YXIgYW5pbWF0aW9uRGF0YSA9ICdfX1tBTklNQVRJT05EQVRBXV9fJztcbiAgdmFyIHJlbmRlcmVyID0gJyc7XG5cbiAgZnVuY3Rpb24gc2V0TG9jYXRpb24oaHJlZikge1xuICAgIHNldExvY2F0aW9uSHJlZihocmVmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlYXJjaEFuaW1hdGlvbnMoKSB7XG4gICAgaWYgKHN0YW5kYWxvbmUgPT09IHRydWUpIHtcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIuc2VhcmNoQW5pbWF0aW9ucyhhbmltYXRpb25EYXRhLCBzdGFuZGFsb25lLCByZW5kZXJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIuc2VhcmNoQW5pbWF0aW9ucygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFN1YmZyYW1lUmVuZGVyaW5nKGZsYWcpIHtcbiAgICBzZXRTdWJmcmFtZUVuYWJsZWQoZmxhZyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRQcmVmaXgocHJlZml4KSB7XG4gICAgc2V0SWRQcmVmaXgocHJlZml4KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvYWRBbmltYXRpb24ocGFyYW1zKSB7XG4gICAgaWYgKHN0YW5kYWxvbmUgPT09IHRydWUpIHtcbiAgICAgIHBhcmFtcy5hbmltYXRpb25EYXRhID0gSlNPTi5wYXJzZShhbmltYXRpb25EYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0aW9uTWFuYWdlci5sb2FkQW5pbWF0aW9uKHBhcmFtcyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRRdWFsaXR5KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgY2FzZSAnaGlnaCc6XG4gICAgICAgICAgc2V0RGVmYXVsdEN1cnZlU2VnbWVudHMoMjAwKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICBjYXNlICdtZWRpdW0nOlxuICAgICAgICAgIHNldERlZmF1bHRDdXJ2ZVNlZ21lbnRzKDUwKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdsb3cnOlxuICAgICAgICAgIHNldERlZmF1bHRDdXJ2ZVNlZ21lbnRzKDEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc05hTih2YWx1ZSkgJiYgdmFsdWUgPiAxKSB7XG4gICAgICBzZXREZWZhdWx0Q3VydmVTZWdtZW50cyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGdldERlZmF1bHRDdXJ2ZVNlZ21lbnRzKCkgPj0gNTApIHtcbiAgICAgIHJvdW5kVmFsdWVzKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm91bmRWYWx1ZXModHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5Ccm93c2VyKCkge1xuICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3RhbGxQbHVnaW4odHlwZSwgcGx1Z2luKSB7XG4gICAgaWYgKHR5cGUgPT09ICdleHByZXNzaW9ucycpIHtcbiAgICAgIHNldEV4cHJlc3Npb25zUGx1Z2luKHBsdWdpbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RmFjdG9yeShuYW1lKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdwcm9wZXJ0eUZhY3RvcnknOlxuICAgICAgICByZXR1cm4gUHJvcGVydHlGYWN0b3J5O1xuXG4gICAgICBjYXNlICdzaGFwZVByb3BlcnR5RmFjdG9yeSc6XG4gICAgICAgIHJldHVybiBTaGFwZVByb3BlcnR5RmFjdG9yeTtcblxuICAgICAgY2FzZSAnbWF0cml4JzpcbiAgICAgICAgcmV0dXJuIE1hdHJpeDtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgbG90dGllLnBsYXkgPSBhbmltYXRpb25NYW5hZ2VyLnBsYXk7XG4gIGxvdHRpZS5wYXVzZSA9IGFuaW1hdGlvbk1hbmFnZXIucGF1c2U7XG4gIGxvdHRpZS5zZXRMb2NhdGlvbkhyZWYgPSBzZXRMb2NhdGlvbjtcbiAgbG90dGllLnRvZ2dsZVBhdXNlID0gYW5pbWF0aW9uTWFuYWdlci50b2dnbGVQYXVzZTtcbiAgbG90dGllLnNldFNwZWVkID0gYW5pbWF0aW9uTWFuYWdlci5zZXRTcGVlZDtcbiAgbG90dGllLnNldERpcmVjdGlvbiA9IGFuaW1hdGlvbk1hbmFnZXIuc2V0RGlyZWN0aW9uO1xuICBsb3R0aWUuc3RvcCA9IGFuaW1hdGlvbk1hbmFnZXIuc3RvcDtcbiAgbG90dGllLnNlYXJjaEFuaW1hdGlvbnMgPSBzZWFyY2hBbmltYXRpb25zO1xuICBsb3R0aWUucmVnaXN0ZXJBbmltYXRpb24gPSBhbmltYXRpb25NYW5hZ2VyLnJlZ2lzdGVyQW5pbWF0aW9uO1xuICBsb3R0aWUubG9hZEFuaW1hdGlvbiA9IGxvYWRBbmltYXRpb247XG4gIGxvdHRpZS5zZXRTdWJmcmFtZVJlbmRlcmluZyA9IHNldFN1YmZyYW1lUmVuZGVyaW5nO1xuICBsb3R0aWUucmVzaXplID0gYW5pbWF0aW9uTWFuYWdlci5yZXNpemU7IC8vIGxvdHRpZS5zdGFydCA9IHN0YXJ0O1xuXG4gIGxvdHRpZS5nb1RvQW5kU3RvcCA9IGFuaW1hdGlvbk1hbmFnZXIuZ29Ub0FuZFN0b3A7XG4gIGxvdHRpZS5kZXN0cm95ID0gYW5pbWF0aW9uTWFuYWdlci5kZXN0cm95O1xuICBsb3R0aWUuc2V0UXVhbGl0eSA9IHNldFF1YWxpdHk7XG4gIGxvdHRpZS5pbkJyb3dzZXIgPSBpbkJyb3dzZXI7XG4gIGxvdHRpZS5pbnN0YWxsUGx1Z2luID0gaW5zdGFsbFBsdWdpbjtcbiAgbG90dGllLmZyZWV6ZSA9IGFuaW1hdGlvbk1hbmFnZXIuZnJlZXplO1xuICBsb3R0aWUudW5mcmVlemUgPSBhbmltYXRpb25NYW5hZ2VyLnVuZnJlZXplO1xuICBsb3R0aWUuc2V0Vm9sdW1lID0gYW5pbWF0aW9uTWFuYWdlci5zZXRWb2x1bWU7XG4gIGxvdHRpZS5tdXRlID0gYW5pbWF0aW9uTWFuYWdlci5tdXRlO1xuICBsb3R0aWUudW5tdXRlID0gYW5pbWF0aW9uTWFuYWdlci51bm11dGU7XG4gIGxvdHRpZS5nZXRSZWdpc3RlcmVkQW5pbWF0aW9ucyA9IGFuaW1hdGlvbk1hbmFnZXIuZ2V0UmVnaXN0ZXJlZEFuaW1hdGlvbnM7XG4gIGxvdHRpZS51c2VXZWJXb3JrZXIgPSBzZXRXZWJXb3JrZXI7XG4gIGxvdHRpZS5zZXRJRFByZWZpeCA9IHNldFByZWZpeDtcbiAgbG90dGllLl9fZ2V0RmFjdG9yeSA9IGdldEZhY3Rvcnk7XG4gIGxvdHRpZS52ZXJzaW9uID0gJzUuMTIuMic7XG5cbiAgZnVuY3Rpb24gY2hlY2tSZWFkeSgpIHtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgY2xlYXJJbnRlcnZhbChyZWFkeVN0YXRlQ2hlY2tJbnRlcnZhbCk7XG4gICAgICBzZWFyY2hBbmltYXRpb25zKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UXVlcnlWYXJpYWJsZSh2YXJpYWJsZSkge1xuICAgIHZhciB2YXJzID0gcXVlcnlTdHJpbmcuc3BsaXQoJyYnKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIHBhaXIgPSB2YXJzW2ldLnNwbGl0KCc9Jyk7XG5cbiAgICAgIGlmIChkZWNvZGVVUklDb21wb25lbnQocGFpclswXSkgPT0gdmFyaWFibGUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBxdWVyeVN0cmluZyA9ICcnO1xuXG4gIGlmIChzdGFuZGFsb25lKSB7XG4gICAgdmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG4gICAgdmFyIGluZGV4ID0gc2NyaXB0cy5sZW5ndGggLSAxO1xuICAgIHZhciBteVNjcmlwdCA9IHNjcmlwdHNbaW5kZXhdIHx8IHtcbiAgICAgIHNyYzogJydcbiAgICB9O1xuICAgIHF1ZXJ5U3RyaW5nID0gbXlTY3JpcHQuc3JjID8gbXlTY3JpcHQuc3JjLnJlcGxhY2UoL15bXlxcP10rXFw/Py8sICcnKSA6ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG5cbiAgICByZW5kZXJlciA9IGdldFF1ZXJ5VmFyaWFibGUoJ3JlbmRlcmVyJyk7XG4gIH1cblxuICB2YXIgcmVhZHlTdGF0ZUNoZWNrSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChjaGVja1JlYWR5LCAxMDApOyAvLyB0aGlzIGFkZHMgYm9keW1vdmluIHRvIHRoZSB3aW5kb3cgb2JqZWN0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG4gIHRyeSB7XG4gICAgaWYgKCEoKHR5cGVvZiBleHBvcnRzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YkMyhleHBvcnRzKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSAmJiAhKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICkge1xuICAgICAgd2luZG93LmJvZHltb3ZpbiA9IGxvdHRpZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikgey8vXG4gIH1cblxuICB2YXIgU2hhcGVNb2RpZmllcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iID0ge307XG4gICAgdmFyIG1vZGlmaWVycyA9IHt9O1xuICAgIG9iLnJlZ2lzdGVyTW9kaWZpZXIgPSByZWdpc3Rlck1vZGlmaWVyO1xuICAgIG9iLmdldE1vZGlmaWVyID0gZ2V0TW9kaWZpZXI7XG5cbiAgICBmdW5jdGlvbiByZWdpc3Rlck1vZGlmaWVyKG5tLCBmYWN0b3J5KSB7XG4gICAgICBpZiAoIW1vZGlmaWVyc1tubV0pIHtcbiAgICAgICAgbW9kaWZpZXJzW25tXSA9IGZhY3Rvcnk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TW9kaWZpZXIobm0sIGVsZW0sIGRhdGEpIHtcbiAgICAgIHJldHVybiBuZXcgbW9kaWZpZXJzW25tXShlbGVtLCBkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2I7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBTaGFwZU1vZGlmaWVyKCkge31cblxuICBTaGFwZU1vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge307XG5cbiAgU2hhcGVNb2RpZmllci5wcm90b3R5cGUuYWRkU2hhcGVUb01vZGlmaWVyID0gZnVuY3Rpb24gKCkge307XG5cbiAgU2hhcGVNb2RpZmllci5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICghdGhpcy5jbG9zZWQpIHtcbiAgICAgIC8vIEFkZGluZyBzaGFwZSB0byBkeW5hbWljIHByb3BlcnRpZXMuIEl0IGNvdmVycyB0aGUgY2FzZSB3aGVyZSBhIHNoYXBlIGhhcyBubyBlZmZlY3RzIGFwcGxpZWQsIHRvIHJlc2V0IGl0J3MgX21kZiBzdGF0ZSBvbiBldmVyeSB0aWNrLlxuICAgICAgZGF0YS5zaC5jb250YWluZXIuYWRkRHluYW1pY1Byb3BlcnR5KGRhdGEuc2gpO1xuICAgICAgdmFyIHNoYXBlRGF0YSA9IHtcbiAgICAgICAgc2hhcGU6IGRhdGEuc2gsXG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uOiBzaGFwZUNvbGxlY3Rpb25Qb29sLm5ld1NoYXBlQ29sbGVjdGlvbigpXG4gICAgICB9O1xuICAgICAgdGhpcy5zaGFwZXMucHVzaChzaGFwZURhdGEpO1xuICAgICAgdGhpcy5hZGRTaGFwZVRvTW9kaWZpZXIoc2hhcGVEYXRhKTtcblxuICAgICAgaWYgKHRoaXMuX2lzQW5pbWF0ZWQpIHtcbiAgICAgICAgZGF0YS5zZXRBc0FuaW1hdGVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNoYXBlTW9kaWZpZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSkge1xuICAgIHRoaXMuc2hhcGVzID0gW107XG4gICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgdGhpcy5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzKGVsZW0sIGRhdGEpO1xuICAgIHRoaXMuZnJhbWVJZCA9IGluaXRpYWxEZWZhdWx0RnJhbWU7XG4gICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLmsgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5rID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgU2hhcGVNb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc0tleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcbiAgfTtcblxuICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFNoYXBlTW9kaWZpZXIpO1xuXG4gIGZ1bmN0aW9uIFRyaW1Nb2RpZmllcigpIHt9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtTaGFwZU1vZGlmaWVyXSwgVHJpbU1vZGlmaWVyKTtcblxuICBUcmltTW9kaWZpZXIucHJvdG90eXBlLmluaXRNb2RpZmllclByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSkge1xuICAgIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucywgMCwgMC4wMSwgdGhpcyk7XG4gICAgdGhpcy5lID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5lLCAwLCAwLjAxLCB0aGlzKTtcbiAgICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm8sIDAsIDAsIHRoaXMpO1xuICAgIHRoaXMuc1ZhbHVlID0gMDtcbiAgICB0aGlzLmVWYWx1ZSA9IDA7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMucHJvY2Vzc0tleXM7XG4gICAgdGhpcy5tID0gZGF0YS5tO1xuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMucy5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoIHx8ICEhdGhpcy5lLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggfHwgISF0aGlzLm8uZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcbiAgfTtcblxuICBUcmltTW9kaWZpZXIucHJvdG90eXBlLmFkZFNoYXBlVG9Nb2RpZmllciA9IGZ1bmN0aW9uIChzaGFwZURhdGEpIHtcbiAgICBzaGFwZURhdGEucGF0aHNEYXRhID0gW107XG4gIH07XG5cbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5jYWxjdWxhdGVTaGFwZUVkZ2VzID0gZnVuY3Rpb24gKHMsIGUsIHNoYXBlTGVuZ3RoLCBhZGRlZExlbmd0aCwgdG90YWxNb2RpZmllckxlbmd0aCkge1xuICAgIHZhciBzZWdtZW50cyA9IFtdO1xuXG4gICAgaWYgKGUgPD0gMSkge1xuICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgIHM6IHMsXG4gICAgICAgIGU6IGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocyA+PSAxKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgczogcyAtIDEsXG4gICAgICAgIGU6IGUgLSAxXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgIHM6IHMsXG4gICAgICAgIGU6IDFcbiAgICAgIH0pO1xuICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgIHM6IDAsXG4gICAgICAgIGU6IGUgLSAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgc2hhcGVTZWdtZW50cyA9IFtdO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgdmFyIHNlZ21lbnRPYjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgc2VnbWVudE9iID0gc2VnbWVudHNbaV07XG5cbiAgICAgIGlmICghKHNlZ21lbnRPYi5lICogdG90YWxNb2RpZmllckxlbmd0aCA8IGFkZGVkTGVuZ3RoIHx8IHNlZ21lbnRPYi5zICogdG90YWxNb2RpZmllckxlbmd0aCA+IGFkZGVkTGVuZ3RoICsgc2hhcGVMZW5ndGgpKSB7XG4gICAgICAgIHZhciBzaGFwZVM7XG4gICAgICAgIHZhciBzaGFwZUU7XG5cbiAgICAgICAgaWYgKHNlZ21lbnRPYi5zICogdG90YWxNb2RpZmllckxlbmd0aCA8PSBhZGRlZExlbmd0aCkge1xuICAgICAgICAgIHNoYXBlUyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hhcGVTID0gKHNlZ21lbnRPYi5zICogdG90YWxNb2RpZmllckxlbmd0aCAtIGFkZGVkTGVuZ3RoKSAvIHNoYXBlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlZ21lbnRPYi5lICogdG90YWxNb2RpZmllckxlbmd0aCA+PSBhZGRlZExlbmd0aCArIHNoYXBlTGVuZ3RoKSB7XG4gICAgICAgICAgc2hhcGVFID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaGFwZUUgPSAoc2VnbWVudE9iLmUgKiB0b3RhbE1vZGlmaWVyTGVuZ3RoIC0gYWRkZWRMZW5ndGgpIC8gc2hhcGVMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBzaGFwZVNlZ21lbnRzLnB1c2goW3NoYXBlUywgc2hhcGVFXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzaGFwZVNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgc2hhcGVTZWdtZW50cy5wdXNoKFswLCAwXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYXBlU2VnbWVudHM7XG4gIH07XG5cbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5yZWxlYXNlUGF0aHNEYXRhID0gZnVuY3Rpb24gKHBhdGhzRGF0YSkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBwYXRoc0RhdGEubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBzZWdtZW50c0xlbmd0aFBvb2wucmVsZWFzZShwYXRoc0RhdGFbaV0pO1xuICAgIH1cblxuICAgIHBhdGhzRGF0YS5sZW5ndGggPSAwO1xuICAgIHJldHVybiBwYXRoc0RhdGE7XG4gIH07XG5cbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzU2hhcGVzID0gZnVuY3Rpb24gKF9pc0ZpcnN0RnJhbWUpIHtcbiAgICB2YXIgcztcbiAgICB2YXIgZTtcblxuICAgIGlmICh0aGlzLl9tZGYgfHwgX2lzRmlyc3RGcmFtZSkge1xuICAgICAgdmFyIG8gPSB0aGlzLm8udiAlIDM2MCAvIDM2MDtcblxuICAgICAgaWYgKG8gPCAwKSB7XG4gICAgICAgIG8gKz0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucy52ID4gMSkge1xuICAgICAgICBzID0gMSArIG87XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucy52IDwgMCkge1xuICAgICAgICBzID0gMCArIG87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzID0gdGhpcy5zLnYgKyBvO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5lLnYgPiAxKSB7XG4gICAgICAgIGUgPSAxICsgbztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5lLnYgPCAwKSB7XG4gICAgICAgIGUgPSAwICsgbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGUgPSB0aGlzLmUudiArIG87XG4gICAgICB9XG5cbiAgICAgIGlmIChzID4gZSkge1xuICAgICAgICB2YXIgX3MgPSBzO1xuICAgICAgICBzID0gZTtcbiAgICAgICAgZSA9IF9zO1xuICAgICAgfVxuXG4gICAgICBzID0gTWF0aC5yb3VuZChzICogMTAwMDApICogMC4wMDAxO1xuICAgICAgZSA9IE1hdGgucm91bmQoZSAqIDEwMDAwKSAqIDAuMDAwMTtcbiAgICAgIHRoaXMuc1ZhbHVlID0gcztcbiAgICAgIHRoaXMuZVZhbHVlID0gZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IHRoaXMuc1ZhbHVlO1xuICAgICAgZSA9IHRoaXMuZVZhbHVlO1xuICAgIH1cblxuICAgIHZhciBzaGFwZVBhdGhzO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLnNoYXBlcy5sZW5ndGg7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIHBhdGhzRGF0YTtcbiAgICB2YXIgcGF0aERhdGE7XG4gICAgdmFyIHRvdGFsU2hhcGVMZW5ndGg7XG4gICAgdmFyIHRvdGFsTW9kaWZpZXJMZW5ndGggPSAwO1xuXG4gICAgaWYgKGUgPT09IHMpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB0aGlzLnNoYXBlc1tpXS5sb2NhbFNoYXBlQ29sbGVjdGlvbi5yZWxlYXNlU2hhcGVzKCk7XG4gICAgICAgIHRoaXMuc2hhcGVzW2ldLnNoYXBlLl9tZGYgPSB0cnVlO1xuICAgICAgICB0aGlzLnNoYXBlc1tpXS5zaGFwZS5wYXRocyA9IHRoaXMuc2hhcGVzW2ldLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLl9tZGYpIHtcbiAgICAgICAgICB0aGlzLnNoYXBlc1tpXS5wYXRoc0RhdGEubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShlID09PSAxICYmIHMgPT09IDAgfHwgZSA9PT0gMCAmJiBzID09PSAxKSkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gW107XG4gICAgICB2YXIgc2hhcGVEYXRhO1xuICAgICAgdmFyIGxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgc2hhcGVEYXRhID0gdGhpcy5zaGFwZXNbaV07IC8vIGlmIHNoYXBlIGhhc24ndCBjaGFuZ2VkIGFuZCB0cmltIHByb3BlcnRpZXMgaGF2ZW4ndCBjaGFuZ2VkLCBjYWNoZWQgcHJldmlvdXMgcGF0aCBjYW4gYmUgdXNlZFxuXG4gICAgICAgIGlmICghc2hhcGVEYXRhLnNoYXBlLl9tZGYgJiYgIXRoaXMuX21kZiAmJiAhX2lzRmlyc3RGcmFtZSAmJiB0aGlzLm0gIT09IDIpIHtcbiAgICAgICAgICBzaGFwZURhdGEuc2hhcGUucGF0aHMgPSBzaGFwZURhdGEubG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hhcGVQYXRocyA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocztcbiAgICAgICAgICBqTGVuID0gc2hhcGVQYXRocy5fbGVuZ3RoO1xuICAgICAgICAgIHRvdGFsU2hhcGVMZW5ndGggPSAwO1xuXG4gICAgICAgICAgaWYgKCFzaGFwZURhdGEuc2hhcGUuX21kZiAmJiBzaGFwZURhdGEucGF0aHNEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgdG90YWxTaGFwZUxlbmd0aCA9IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRoc0RhdGEgPSB0aGlzLnJlbGVhc2VQYXRoc0RhdGEoc2hhcGVEYXRhLnBhdGhzRGF0YSk7XG5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgcGF0aERhdGEgPSBiZXouZ2V0U2VnbWVudHNMZW5ndGgoc2hhcGVQYXRocy5zaGFwZXNbal0pO1xuICAgICAgICAgICAgICBwYXRoc0RhdGEucHVzaChwYXRoRGF0YSk7XG4gICAgICAgICAgICAgIHRvdGFsU2hhcGVMZW5ndGggKz0gcGF0aERhdGEudG90YWxMZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoID0gdG90YWxTaGFwZUxlbmd0aDtcbiAgICAgICAgICAgIHNoYXBlRGF0YS5wYXRoc0RhdGEgPSBwYXRoc0RhdGE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG90YWxNb2RpZmllckxlbmd0aCArPSB0b3RhbFNoYXBlTGVuZ3RoO1xuICAgICAgICAgIHNoYXBlRGF0YS5zaGFwZS5fbWRmID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc2hhcGVTID0gcztcbiAgICAgIHZhciBzaGFwZUUgPSBlO1xuICAgICAgdmFyIGFkZGVkTGVuZ3RoID0gMDtcbiAgICAgIHZhciBlZGdlcztcblxuICAgICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgc2hhcGVEYXRhID0gdGhpcy5zaGFwZXNbaV07XG5cbiAgICAgICAgaWYgKHNoYXBlRGF0YS5zaGFwZS5fbWRmKSB7XG4gICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZURhdGEubG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpOyAvLyBpZiBtID09PSAyIG1lYW5zIHBhdGhzIGFyZSB0cmltbWVkIGluZGl2aWR1YWxseSBzbyBlZGdlcyBuZWVkIHRvIGJlIGZvdW5kIGZvciB0aGlzIHNwZWNpZmljIHNoYXBlIHJlbGF0aXZlIHRvIHdob2VsIGdyb3VwXG5cbiAgICAgICAgICBpZiAodGhpcy5tID09PSAyICYmIGxlbiA+IDEpIHtcbiAgICAgICAgICAgIGVkZ2VzID0gdGhpcy5jYWxjdWxhdGVTaGFwZUVkZ2VzKHMsIGUsIHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoLCBhZGRlZExlbmd0aCwgdG90YWxNb2RpZmllckxlbmd0aCk7XG4gICAgICAgICAgICBhZGRlZExlbmd0aCArPSBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWRnZXMgPSBbW3NoYXBlUywgc2hhcGVFXV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgakxlbiA9IGVkZ2VzLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgIHNoYXBlUyA9IGVkZ2VzW2pdWzBdO1xuICAgICAgICAgICAgc2hhcGVFID0gZWRnZXNbal1bMV07XG4gICAgICAgICAgICBzZWdtZW50cy5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICBpZiAoc2hhcGVFIDw9IDEpIHtcbiAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgczogc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGggKiBzaGFwZVMsXG4gICAgICAgICAgICAgICAgZTogc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGggKiBzaGFwZUVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlUyA+PSAxKSB7XG4gICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHM6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogKHNoYXBlUyAtIDEpLFxuICAgICAgICAgICAgICAgIGU6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogKHNoYXBlRSAtIDEpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgczogc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGggKiBzaGFwZVMsXG4gICAgICAgICAgICAgICAgZTogc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGhcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHM6IDAsXG4gICAgICAgICAgICAgICAgZTogc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGggKiAoc2hhcGVFIC0gMSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuZXdTaGFwZXNEYXRhID0gdGhpcy5hZGRTaGFwZXMoc2hhcGVEYXRhLCBzZWdtZW50c1swXSk7XG5cbiAgICAgICAgICAgIGlmIChzZWdtZW50c1swXS5zICE9PSBzZWdtZW50c1swXS5lKSB7XG4gICAgICAgICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RTaGFwZUluQ29sbGVjdGlvbiA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5zaGFwZXNbc2hhcGVEYXRhLnNoYXBlLnBhdGhzLl9sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgICAgIGlmIChsYXN0U2hhcGVJbkNvbGxlY3Rpb24uYykge1xuICAgICAgICAgICAgICAgICAgdmFyIGxhc3RTaGFwZSA9IG5ld1NoYXBlc0RhdGEucG9wKCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFkZFBhdGhzKG5ld1NoYXBlc0RhdGEsIGxvY2FsU2hhcGVDb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIG5ld1NoYXBlc0RhdGEgPSB0aGlzLmFkZFNoYXBlcyhzaGFwZURhdGEsIHNlZ21lbnRzWzFdLCBsYXN0U2hhcGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFkZFBhdGhzKG5ld1NoYXBlc0RhdGEsIGxvY2FsU2hhcGVDb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIG5ld1NoYXBlc0RhdGEgPSB0aGlzLmFkZFNoYXBlcyhzaGFwZURhdGEsIHNlZ21lbnRzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLmFkZFBhdGhzKG5ld1NoYXBlc0RhdGEsIGxvY2FsU2hhcGVDb2xsZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzaGFwZURhdGEuc2hhcGUucGF0aHMgPSBsb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fbWRmKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgLy8gUmVsZWFzaWduIFRyaW0gQ2FjaGVkIHBhdGhzIGRhdGEgd2hlbiBubyB0cmltIGFwcGxpZWQgaW4gY2FzZSBzaGFwZXMgYXJlIG1vZGlmaWVkIGluYmV0d2Vlbi5cbiAgICAgICAgLy8gRG9uJ3QgcmVtb3ZlIHRoaXMgZXZlbiBpZiBpdCdzIGxvc2luZyBjYWNoZWQgaW5mby5cbiAgICAgICAgdGhpcy5zaGFwZXNbaV0ucGF0aHNEYXRhLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuc2hhcGVzW2ldLnNoYXBlLl9tZGYgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBUcmltTW9kaWZpZXIucHJvdG90eXBlLmFkZFBhdGhzID0gZnVuY3Rpb24gKG5ld1BhdGhzLCBsb2NhbFNoYXBlQ29sbGVjdGlvbikge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBuZXdQYXRocy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uLmFkZFNoYXBlKG5ld1BhdGhzW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5hZGRTZWdtZW50ID0gZnVuY3Rpb24gKHB0MSwgcHQyLCBwdDMsIHB0NCwgc2hhcGVQYXRoLCBwb3MsIG5ld1NoYXBlKSB7XG4gICAgc2hhcGVQYXRoLnNldFhZQXQocHQyWzBdLCBwdDJbMV0sICdvJywgcG9zKTtcbiAgICBzaGFwZVBhdGguc2V0WFlBdChwdDNbMF0sIHB0M1sxXSwgJ2knLCBwb3MgKyAxKTtcblxuICAgIGlmIChuZXdTaGFwZSkge1xuICAgICAgc2hhcGVQYXRoLnNldFhZQXQocHQxWzBdLCBwdDFbMV0sICd2JywgcG9zKTtcbiAgICB9XG5cbiAgICBzaGFwZVBhdGguc2V0WFlBdChwdDRbMF0sIHB0NFsxXSwgJ3YnLCBwb3MgKyAxKTtcbiAgfTtcblxuICBUcmltTW9kaWZpZXIucHJvdG90eXBlLmFkZFNlZ21lbnRGcm9tQXJyYXkgPSBmdW5jdGlvbiAocG9pbnRzLCBzaGFwZVBhdGgsIHBvcywgbmV3U2hhcGUpIHtcbiAgICBzaGFwZVBhdGguc2V0WFlBdChwb2ludHNbMV0sIHBvaW50c1s1XSwgJ28nLCBwb3MpO1xuICAgIHNoYXBlUGF0aC5zZXRYWUF0KHBvaW50c1syXSwgcG9pbnRzWzZdLCAnaScsIHBvcyArIDEpO1xuXG4gICAgaWYgKG5ld1NoYXBlKSB7XG4gICAgICBzaGFwZVBhdGguc2V0WFlBdChwb2ludHNbMF0sIHBvaW50c1s0XSwgJ3YnLCBwb3MpO1xuICAgIH1cblxuICAgIHNoYXBlUGF0aC5zZXRYWUF0KHBvaW50c1szXSwgcG9pbnRzWzddLCAndicsIHBvcyArIDEpO1xuICB9O1xuXG4gIFRyaW1Nb2RpZmllci5wcm90b3R5cGUuYWRkU2hhcGVzID0gZnVuY3Rpb24gKHNoYXBlRGF0YSwgc2hhcGVTZWdtZW50LCBzaGFwZVBhdGgpIHtcbiAgICB2YXIgcGF0aHNEYXRhID0gc2hhcGVEYXRhLnBhdGhzRGF0YTtcbiAgICB2YXIgc2hhcGVQYXRocyA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5zaGFwZXM7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5fbGVuZ3RoO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBhZGRlZExlbmd0aCA9IDA7XG4gICAgdmFyIGN1cnJlbnRMZW5ndGhEYXRhO1xuICAgIHZhciBzZWdtZW50Q291bnQ7XG4gICAgdmFyIGxlbmd0aHM7XG4gICAgdmFyIHNlZ21lbnQ7XG4gICAgdmFyIHNoYXBlcyA9IFtdO1xuICAgIHZhciBpbml0UG9zO1xuICAgIHZhciBuZXdTaGFwZSA9IHRydWU7XG5cbiAgICBpZiAoIXNoYXBlUGF0aCkge1xuICAgICAgc2hhcGVQYXRoID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgIHNlZ21lbnRDb3VudCA9IDA7XG4gICAgICBpbml0UG9zID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VnbWVudENvdW50ID0gc2hhcGVQYXRoLl9sZW5ndGg7XG4gICAgICBpbml0UG9zID0gc2hhcGVQYXRoLl9sZW5ndGg7XG4gICAgfVxuXG4gICAgc2hhcGVzLnB1c2goc2hhcGVQYXRoKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgbGVuZ3RocyA9IHBhdGhzRGF0YVtpXS5sZW5ndGhzO1xuICAgICAgc2hhcGVQYXRoLmMgPSBzaGFwZVBhdGhzW2ldLmM7XG4gICAgICBqTGVuID0gc2hhcGVQYXRoc1tpXS5jID8gbGVuZ3Rocy5sZW5ndGggOiBsZW5ndGhzLmxlbmd0aCArIDE7XG5cbiAgICAgIGZvciAoaiA9IDE7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgY3VycmVudExlbmd0aERhdGEgPSBsZW5ndGhzW2ogLSAxXTtcblxuICAgICAgICBpZiAoYWRkZWRMZW5ndGggKyBjdXJyZW50TGVuZ3RoRGF0YS5hZGRlZExlbmd0aCA8IHNoYXBlU2VnbWVudC5zKSB7XG4gICAgICAgICAgYWRkZWRMZW5ndGggKz0gY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGg7XG4gICAgICAgICAgc2hhcGVQYXRoLmMgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChhZGRlZExlbmd0aCA+IHNoYXBlU2VnbWVudC5lKSB7XG4gICAgICAgICAgc2hhcGVQYXRoLmMgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2hhcGVTZWdtZW50LnMgPD0gYWRkZWRMZW5ndGggJiYgc2hhcGVTZWdtZW50LmUgPj0gYWRkZWRMZW5ndGggKyBjdXJyZW50TGVuZ3RoRGF0YS5hZGRlZExlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5hZGRTZWdtZW50KHNoYXBlUGF0aHNbaV0udltqIC0gMV0sIHNoYXBlUGF0aHNbaV0ub1tqIC0gMV0sIHNoYXBlUGF0aHNbaV0uaVtqXSwgc2hhcGVQYXRoc1tpXS52W2pdLCBzaGFwZVBhdGgsIHNlZ21lbnRDb3VudCwgbmV3U2hhcGUpO1xuICAgICAgICAgICAgbmV3U2hhcGUgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VnbWVudCA9IGJlei5nZXROZXdTZWdtZW50KHNoYXBlUGF0aHNbaV0udltqIC0gMV0sIHNoYXBlUGF0aHNbaV0udltqXSwgc2hhcGVQYXRoc1tpXS5vW2ogLSAxXSwgc2hhcGVQYXRoc1tpXS5pW2pdLCAoc2hhcGVTZWdtZW50LnMgLSBhZGRlZExlbmd0aCkgLyBjdXJyZW50TGVuZ3RoRGF0YS5hZGRlZExlbmd0aCwgKHNoYXBlU2VnbWVudC5lIC0gYWRkZWRMZW5ndGgpIC8gY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGgsIGxlbmd0aHNbaiAtIDFdKTtcbiAgICAgICAgICAgIHRoaXMuYWRkU2VnbWVudEZyb21BcnJheShzZWdtZW50LCBzaGFwZVBhdGgsIHNlZ21lbnRDb3VudCwgbmV3U2hhcGUpOyAvLyB0aGlzLmFkZFNlZ21lbnQoc2VnbWVudC5wdDEsIHNlZ21lbnQucHQzLCBzZWdtZW50LnB0NCwgc2VnbWVudC5wdDIsIHNoYXBlUGF0aCwgc2VnbWVudENvdW50LCBuZXdTaGFwZSk7XG5cbiAgICAgICAgICAgIG5ld1NoYXBlID0gZmFsc2U7XG4gICAgICAgICAgICBzaGFwZVBhdGguYyA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFkZGVkTGVuZ3RoICs9IGN1cnJlbnRMZW5ndGhEYXRhLmFkZGVkTGVuZ3RoO1xuICAgICAgICAgIHNlZ21lbnRDb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaGFwZVBhdGhzW2ldLmMgJiYgbGVuZ3Rocy5sZW5ndGgpIHtcbiAgICAgICAgY3VycmVudExlbmd0aERhdGEgPSBsZW5ndGhzW2ogLSAxXTtcblxuICAgICAgICBpZiAoYWRkZWRMZW5ndGggPD0gc2hhcGVTZWdtZW50LmUpIHtcbiAgICAgICAgICB2YXIgc2VnbWVudExlbmd0aCA9IGxlbmd0aHNbaiAtIDFdLmFkZGVkTGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKHNoYXBlU2VnbWVudC5zIDw9IGFkZGVkTGVuZ3RoICYmIHNoYXBlU2VnbWVudC5lID49IGFkZGVkTGVuZ3RoICsgc2VnbWVudExlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5hZGRTZWdtZW50KHNoYXBlUGF0aHNbaV0udltqIC0gMV0sIHNoYXBlUGF0aHNbaV0ub1tqIC0gMV0sIHNoYXBlUGF0aHNbaV0uaVswXSwgc2hhcGVQYXRoc1tpXS52WzBdLCBzaGFwZVBhdGgsIHNlZ21lbnRDb3VudCwgbmV3U2hhcGUpO1xuICAgICAgICAgICAgbmV3U2hhcGUgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VnbWVudCA9IGJlei5nZXROZXdTZWdtZW50KHNoYXBlUGF0aHNbaV0udltqIC0gMV0sIHNoYXBlUGF0aHNbaV0udlswXSwgc2hhcGVQYXRoc1tpXS5vW2ogLSAxXSwgc2hhcGVQYXRoc1tpXS5pWzBdLCAoc2hhcGVTZWdtZW50LnMgLSBhZGRlZExlbmd0aCkgLyBzZWdtZW50TGVuZ3RoLCAoc2hhcGVTZWdtZW50LmUgLSBhZGRlZExlbmd0aCkgLyBzZWdtZW50TGVuZ3RoLCBsZW5ndGhzW2ogLSAxXSk7XG4gICAgICAgICAgICB0aGlzLmFkZFNlZ21lbnRGcm9tQXJyYXkoc2VnbWVudCwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTsgLy8gdGhpcy5hZGRTZWdtZW50KHNlZ21lbnQucHQxLCBzZWdtZW50LnB0Mywgc2VnbWVudC5wdDQsIHNlZ21lbnQucHQyLCBzaGFwZVBhdGgsIHNlZ21lbnRDb3VudCwgbmV3U2hhcGUpO1xuXG4gICAgICAgICAgICBuZXdTaGFwZSA9IGZhbHNlO1xuICAgICAgICAgICAgc2hhcGVQYXRoLmMgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hhcGVQYXRoLmMgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZGVkTGVuZ3RoICs9IGN1cnJlbnRMZW5ndGhEYXRhLmFkZGVkTGVuZ3RoO1xuICAgICAgICBzZWdtZW50Q291bnQgKz0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNoYXBlUGF0aC5fbGVuZ3RoKSB7XG4gICAgICAgIHNoYXBlUGF0aC5zZXRYWUF0KHNoYXBlUGF0aC52W2luaXRQb3NdWzBdLCBzaGFwZVBhdGgudltpbml0UG9zXVsxXSwgJ2knLCBpbml0UG9zKTtcbiAgICAgICAgc2hhcGVQYXRoLnNldFhZQXQoc2hhcGVQYXRoLnZbc2hhcGVQYXRoLl9sZW5ndGggLSAxXVswXSwgc2hhcGVQYXRoLnZbc2hhcGVQYXRoLl9sZW5ndGggLSAxXVsxXSwgJ28nLCBzaGFwZVBhdGguX2xlbmd0aCAtIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkZWRMZW5ndGggPiBzaGFwZVNlZ21lbnQuZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPCBsZW4gLSAxKSB7XG4gICAgICAgIHNoYXBlUGF0aCA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICAgIG5ld1NoYXBlID0gdHJ1ZTtcbiAgICAgICAgc2hhcGVzLnB1c2goc2hhcGVQYXRoKTtcbiAgICAgICAgc2VnbWVudENvdW50ID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2hhcGVzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFB1Y2tlckFuZEJsb2F0TW9kaWZpZXIoKSB7fVxuXG4gIGV4dGVuZFByb3RvdHlwZShbU2hhcGVNb2RpZmllcl0sIFB1Y2tlckFuZEJsb2F0TW9kaWZpZXIpO1xuXG4gIFB1Y2tlckFuZEJsb2F0TW9kaWZpZXIucHJvdG90eXBlLmluaXRNb2RpZmllclByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSkge1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLnByb2Nlc3NLZXlzO1xuICAgIHRoaXMuYW1vdW50ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5hLCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLmFtb3VudC5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoO1xuICB9O1xuXG4gIFB1Y2tlckFuZEJsb2F0TW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NQYXRoID0gZnVuY3Rpb24gKHBhdGgsIGFtb3VudCkge1xuICAgIHZhciBwZXJjZW50ID0gYW1vdW50IC8gMTAwO1xuICAgIHZhciBjZW50ZXJQb2ludCA9IFswLCAwXTtcbiAgICB2YXIgcGF0aExlbmd0aCA9IHBhdGguX2xlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aExlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjZW50ZXJQb2ludFswXSArPSBwYXRoLnZbaV1bMF07XG4gICAgICBjZW50ZXJQb2ludFsxXSArPSBwYXRoLnZbaV1bMV07XG4gICAgfVxuXG4gICAgY2VudGVyUG9pbnRbMF0gLz0gcGF0aExlbmd0aDtcbiAgICBjZW50ZXJQb2ludFsxXSAvPSBwYXRoTGVuZ3RoO1xuICAgIHZhciBjbG9uZWRQYXRoID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICBjbG9uZWRQYXRoLmMgPSBwYXRoLmM7XG4gICAgdmFyIHZYO1xuICAgIHZhciB2WTtcbiAgICB2YXIgb1g7XG4gICAgdmFyIG9ZO1xuICAgIHZhciBpWDtcbiAgICB2YXIgaVk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aExlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2WCA9IHBhdGgudltpXVswXSArIChjZW50ZXJQb2ludFswXSAtIHBhdGgudltpXVswXSkgKiBwZXJjZW50O1xuICAgICAgdlkgPSBwYXRoLnZbaV1bMV0gKyAoY2VudGVyUG9pbnRbMV0gLSBwYXRoLnZbaV1bMV0pICogcGVyY2VudDtcbiAgICAgIG9YID0gcGF0aC5vW2ldWzBdICsgKGNlbnRlclBvaW50WzBdIC0gcGF0aC5vW2ldWzBdKSAqIC1wZXJjZW50O1xuICAgICAgb1kgPSBwYXRoLm9baV1bMV0gKyAoY2VudGVyUG9pbnRbMV0gLSBwYXRoLm9baV1bMV0pICogLXBlcmNlbnQ7XG4gICAgICBpWCA9IHBhdGguaVtpXVswXSArIChjZW50ZXJQb2ludFswXSAtIHBhdGguaVtpXVswXSkgKiAtcGVyY2VudDtcbiAgICAgIGlZID0gcGF0aC5pW2ldWzFdICsgKGNlbnRlclBvaW50WzFdIC0gcGF0aC5pW2ldWzFdKSAqIC1wZXJjZW50O1xuICAgICAgY2xvbmVkUGF0aC5zZXRUcmlwbGVBdCh2WCwgdlksIG9YLCBvWSwgaVgsIGlZLCBpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmVkUGF0aDtcbiAgfTtcblxuICBQdWNrZXJBbmRCbG9hdE1vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzU2hhcGVzID0gZnVuY3Rpb24gKF9pc0ZpcnN0RnJhbWUpIHtcbiAgICB2YXIgc2hhcGVQYXRocztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5zaGFwZXMubGVuZ3RoO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBhbW91bnQgPSB0aGlzLmFtb3VudC52O1xuXG4gICAgaWYgKGFtb3VudCAhPT0gMCkge1xuICAgICAgdmFyIHNoYXBlRGF0YTtcbiAgICAgIHZhciBsb2NhbFNoYXBlQ29sbGVjdGlvbjtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHNoYXBlRGF0YSA9IHRoaXMuc2hhcGVzW2ldO1xuICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlRGF0YS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcblxuICAgICAgICBpZiAoISghc2hhcGVEYXRhLnNoYXBlLl9tZGYgJiYgIXRoaXMuX21kZiAmJiAhX2lzRmlyc3RGcmFtZSkpIHtcbiAgICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5yZWxlYXNlU2hhcGVzKCk7XG4gICAgICAgICAgc2hhcGVEYXRhLnNoYXBlLl9tZGYgPSB0cnVlO1xuICAgICAgICAgIHNoYXBlUGF0aHMgPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuc2hhcGVzO1xuICAgICAgICAgIGpMZW4gPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuX2xlbmd0aDtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uLmFkZFNoYXBlKHRoaXMucHJvY2Vzc1BhdGgoc2hhcGVQYXRoc1tqXSwgYW1vdW50KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgVHJhbnNmb3JtUHJvcGVydHlGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkZWZhdWx0VmVjdG9yID0gWzAsIDBdO1xuXG4gICAgZnVuY3Rpb24gYXBwbHlUb01hdHJpeChtYXQpIHtcbiAgICAgIHZhciBfbWRmID0gdGhpcy5fbWRmO1xuICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcbiAgICAgIHRoaXMuX21kZiA9IHRoaXMuX21kZiB8fCBfbWRmO1xuXG4gICAgICBpZiAodGhpcy5hKSB7XG4gICAgICAgIG1hdC50cmFuc2xhdGUoLXRoaXMuYS52WzBdLCAtdGhpcy5hLnZbMV0sIHRoaXMuYS52WzJdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucykge1xuICAgICAgICBtYXQuc2NhbGUodGhpcy5zLnZbMF0sIHRoaXMucy52WzFdLCB0aGlzLnMudlsyXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNrKSB7XG4gICAgICAgIG1hdC5za2V3RnJvbUF4aXMoLXRoaXMuc2sudiwgdGhpcy5zYS52KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucikge1xuICAgICAgICBtYXQucm90YXRlKC10aGlzLnIudik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXQucm90YXRlWigtdGhpcy5yei52KS5yb3RhdGVZKHRoaXMucnkudikucm90YXRlWCh0aGlzLnJ4LnYpLnJvdGF0ZVooLXRoaXMub3IudlsyXSkucm90YXRlWSh0aGlzLm9yLnZbMV0pLnJvdGF0ZVgodGhpcy5vci52WzBdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZGF0YS5wLnMpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5wLnopIHtcbiAgICAgICAgICBtYXQudHJhbnNsYXRlKHRoaXMucHgudiwgdGhpcy5weS52LCAtdGhpcy5wei52KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXQudHJhbnNsYXRlKHRoaXMucHgudiwgdGhpcy5weS52LCAwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0LnRyYW5zbGF0ZSh0aGlzLnAudlswXSwgdGhpcy5wLnZbMV0sIC10aGlzLnAudlsyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0tleXMoZm9yY2VSZW5kZXIpIHtcbiAgICAgIGlmICh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faXNEaXJ0eSkge1xuICAgICAgICB0aGlzLnByZWNhbGN1bGF0ZU1hdHJpeCgpO1xuICAgICAgICB0aGlzLl9pc0RpcnR5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCk7XG5cbiAgICAgIGlmICh0aGlzLl9tZGYgfHwgZm9yY2VSZW5kZXIpIHtcbiAgICAgICAgdmFyIGZyYW1lUmF0ZTtcbiAgICAgICAgdGhpcy52LmNsb25lRnJvbVByb3BzKHRoaXMucHJlLnByb3BzKTtcblxuICAgICAgICBpZiAodGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgMSkge1xuICAgICAgICAgIHRoaXMudi50cmFuc2xhdGUoLXRoaXMuYS52WzBdLCAtdGhpcy5hLnZbMV0sIHRoaXMuYS52WzJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCAyKSB7XG4gICAgICAgICAgdGhpcy52LnNjYWxlKHRoaXMucy52WzBdLCB0aGlzLnMudlsxXSwgdGhpcy5zLnZbMl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2sgJiYgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgMykge1xuICAgICAgICAgIHRoaXMudi5za2V3RnJvbUF4aXMoLXRoaXMuc2sudiwgdGhpcy5zYS52KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnIgJiYgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgNCkge1xuICAgICAgICAgIHRoaXMudi5yb3RhdGUoLXRoaXMuci52KTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5yICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDQpIHtcbiAgICAgICAgICB0aGlzLnYucm90YXRlWigtdGhpcy5yei52KS5yb3RhdGVZKHRoaXMucnkudikucm90YXRlWCh0aGlzLnJ4LnYpLnJvdGF0ZVooLXRoaXMub3IudlsyXSkucm90YXRlWSh0aGlzLm9yLnZbMV0pLnJvdGF0ZVgodGhpcy5vci52WzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmF1dG9PcmllbnRlZCkge1xuICAgICAgICAgIHZhciB2MTtcbiAgICAgICAgICB2YXIgdjI7XG4gICAgICAgICAgZnJhbWVSYXRlID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuXG4gICAgICAgICAgaWYgKHRoaXMucCAmJiB0aGlzLnAua2V5ZnJhbWVzICYmIHRoaXMucC5nZXRWYWx1ZUF0VGltZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucC5fY2FjaGluZy5sYXN0RnJhbWUgKyB0aGlzLnAub2Zmc2V0VGltZSA8PSB0aGlzLnAua2V5ZnJhbWVzWzBdLnQpIHtcbiAgICAgICAgICAgICAgdjEgPSB0aGlzLnAuZ2V0VmFsdWVBdFRpbWUoKHRoaXMucC5rZXlmcmFtZXNbMF0udCArIDAuMDEpIC8gZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgICAgICAgdjIgPSB0aGlzLnAuZ2V0VmFsdWVBdFRpbWUodGhpcy5wLmtleWZyYW1lc1swXS50IC8gZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wLl9jYWNoaW5nLmxhc3RGcmFtZSArIHRoaXMucC5vZmZzZXRUaW1lID49IHRoaXMucC5rZXlmcmFtZXNbdGhpcy5wLmtleWZyYW1lcy5sZW5ndGggLSAxXS50KSB7XG4gICAgICAgICAgICAgIHYxID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKHRoaXMucC5rZXlmcmFtZXNbdGhpcy5wLmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC8gZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgICAgICAgdjIgPSB0aGlzLnAuZ2V0VmFsdWVBdFRpbWUoKHRoaXMucC5rZXlmcmFtZXNbdGhpcy5wLmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC0gMC4wNSkgLyBmcmFtZVJhdGUsIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdjEgPSB0aGlzLnAucHY7XG4gICAgICAgICAgICAgIHYyID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKCh0aGlzLnAuX2NhY2hpbmcubGFzdEZyYW1lICsgdGhpcy5wLm9mZnNldFRpbWUgLSAwLjAxKSAvIGZyYW1lUmF0ZSwgdGhpcy5wLm9mZnNldFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5weCAmJiB0aGlzLnB4LmtleWZyYW1lcyAmJiB0aGlzLnB5LmtleWZyYW1lcyAmJiB0aGlzLnB4LmdldFZhbHVlQXRUaW1lICYmIHRoaXMucHkuZ2V0VmFsdWVBdFRpbWUpIHtcbiAgICAgICAgICAgIHYxID0gW107XG4gICAgICAgICAgICB2MiA9IFtdO1xuICAgICAgICAgICAgdmFyIHB4ID0gdGhpcy5weDtcbiAgICAgICAgICAgIHZhciBweSA9IHRoaXMucHk7XG5cbiAgICAgICAgICAgIGlmIChweC5fY2FjaGluZy5sYXN0RnJhbWUgKyBweC5vZmZzZXRUaW1lIDw9IHB4LmtleWZyYW1lc1swXS50KSB7XG4gICAgICAgICAgICAgIHYxWzBdID0gcHguZ2V0VmFsdWVBdFRpbWUoKHB4LmtleWZyYW1lc1swXS50ICsgMC4wMSkgLyBmcmFtZVJhdGUsIDApO1xuICAgICAgICAgICAgICB2MVsxXSA9IHB5LmdldFZhbHVlQXRUaW1lKChweS5rZXlmcmFtZXNbMF0udCArIDAuMDEpIC8gZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgICAgICAgdjJbMF0gPSBweC5nZXRWYWx1ZUF0VGltZShweC5rZXlmcmFtZXNbMF0udCAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICAgIHYyWzFdID0gcHkuZ2V0VmFsdWVBdFRpbWUocHkua2V5ZnJhbWVzWzBdLnQgLyBmcmFtZVJhdGUsIDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChweC5fY2FjaGluZy5sYXN0RnJhbWUgKyBweC5vZmZzZXRUaW1lID49IHB4LmtleWZyYW1lc1tweC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCkge1xuICAgICAgICAgICAgICB2MVswXSA9IHB4LmdldFZhbHVlQXRUaW1lKHB4LmtleWZyYW1lc1tweC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICAgIHYxWzFdID0gcHkuZ2V0VmFsdWVBdFRpbWUocHkua2V5ZnJhbWVzW3B5LmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC8gZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgICAgICAgdjJbMF0gPSBweC5nZXRWYWx1ZUF0VGltZSgocHgua2V5ZnJhbWVzW3B4LmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC0gMC4wMSkgLyBmcmFtZVJhdGUsIDApO1xuICAgICAgICAgICAgICB2MlsxXSA9IHB5LmdldFZhbHVlQXRUaW1lKChweS5rZXlmcmFtZXNbcHkua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQgLSAwLjAxKSAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2MSA9IFtweC5wdiwgcHkucHZdO1xuICAgICAgICAgICAgICB2MlswXSA9IHB4LmdldFZhbHVlQXRUaW1lKChweC5fY2FjaGluZy5sYXN0RnJhbWUgKyBweC5vZmZzZXRUaW1lIC0gMC4wMSkgLyBmcmFtZVJhdGUsIHB4Lm9mZnNldFRpbWUpO1xuICAgICAgICAgICAgICB2MlsxXSA9IHB5LmdldFZhbHVlQXRUaW1lKChweS5fY2FjaGluZy5sYXN0RnJhbWUgKyBweS5vZmZzZXRUaW1lIC0gMC4wMSkgLyBmcmFtZVJhdGUsIHB5Lm9mZnNldFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2MiA9IGRlZmF1bHRWZWN0b3I7XG4gICAgICAgICAgICB2MSA9IHYyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudi5yb3RhdGUoLU1hdGguYXRhbjIodjFbMV0gLSB2MlsxXSwgdjFbMF0gLSB2MlswXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5wICYmIHRoaXMuZGF0YS5wLnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5kYXRhLnAueikge1xuICAgICAgICAgICAgdGhpcy52LnRyYW5zbGF0ZSh0aGlzLnB4LnYsIHRoaXMucHkudiwgLXRoaXMucHoudik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudi50cmFuc2xhdGUodGhpcy5weC52LCB0aGlzLnB5LnYsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnYudHJhbnNsYXRlKHRoaXMucC52WzBdLCB0aGlzLnAudlsxXSwgLXRoaXMucC52WzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZWNhbGN1bGF0ZU1hdHJpeCgpIHtcbiAgICAgIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA9IDA7XG4gICAgICB0aGlzLnByZS5yZXNldCgpO1xuXG4gICAgICBpZiAoIXRoaXMuYS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHJlLnRyYW5zbGF0ZSgtdGhpcy5hLnZbMF0sIC10aGlzLmEudlsxXSwgdGhpcy5hLnZbMl0pO1xuICAgICAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMucy5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHJlLnNjYWxlKHRoaXMucy52WzBdLCB0aGlzLnMudlsxXSwgdGhpcy5zLnZbMl0pO1xuICAgICAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaykge1xuICAgICAgICBpZiAoIXRoaXMuc2suZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCAmJiAhdGhpcy5zYS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5wcmUuc2tld0Zyb21BeGlzKC10aGlzLnNrLnYsIHRoaXMuc2Eudik7XG4gICAgICAgICAgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zID0gMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucikge1xuICAgICAgICBpZiAoIXRoaXMuci5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5wcmUucm90YXRlKC10aGlzLnIudik7XG4gICAgICAgICAgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zID0gNDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghdGhpcy5yei5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoICYmICF0aGlzLnJ5LmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggJiYgIXRoaXMucnguZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCAmJiAhdGhpcy5vci5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHJlLnJvdGF0ZVooLXRoaXMucnoudikucm90YXRlWSh0aGlzLnJ5LnYpLnJvdGF0ZVgodGhpcy5yeC52KS5yb3RhdGVaKC10aGlzLm9yLnZbMl0pLnJvdGF0ZVkodGhpcy5vci52WzFdKS5yb3RhdGVYKHRoaXMub3IudlswXSk7XG4gICAgICAgIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA9IDQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXV0b09yaWVudCgpIHsvL1xuICAgICAgLy8gdmFyIHByZXZQID0gdGhpcy5nZXRWYWx1ZUF0VGltZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZER5bmFtaWNQcm9wZXJ0eShwcm9wKSB7XG4gICAgICB0aGlzLl9hZGREeW5hbWljUHJvcGVydHkocHJvcCk7XG5cbiAgICAgIHRoaXMuZWxlbS5hZGREeW5hbWljUHJvcGVydHkocHJvcCk7XG4gICAgICB0aGlzLl9pc0RpcnR5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm1Qcm9wZXJ0eShlbGVtLCBkYXRhLCBjb250YWluZXIpIHtcbiAgICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgICB0aGlzLmZyYW1lSWQgPSAtMTtcbiAgICAgIHRoaXMucHJvcFR5cGUgPSAndHJhbnNmb3JtJztcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICB0aGlzLnYgPSBuZXcgTWF0cml4KCk7IC8vIFByZWNhbGN1bGF0ZWQgbWF0cml4IHdpdGggbm9uIGFuaW1hdGVkIHByb3BlcnRpZXNcblxuICAgICAgdGhpcy5wcmUgPSBuZXcgTWF0cml4KCk7XG4gICAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSAwO1xuICAgICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGNvbnRhaW5lciB8fCBlbGVtKTtcblxuICAgICAgaWYgKGRhdGEucCAmJiBkYXRhLnAucykge1xuICAgICAgICB0aGlzLnB4ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5wLngsIDAsIDAsIHRoaXMpO1xuICAgICAgICB0aGlzLnB5ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5wLnksIDAsIDAsIHRoaXMpO1xuXG4gICAgICAgIGlmIChkYXRhLnAueikge1xuICAgICAgICAgIHRoaXMucHogPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnAueiwgMCwgMCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucCB8fCB7XG4gICAgICAgICAgazogWzAsIDAsIDBdXG4gICAgICAgIH0sIDEsIDAsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5yeCkge1xuICAgICAgICB0aGlzLnJ4ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yeCwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5yeSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucnksIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgICAgIHRoaXMucnogPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnJ6LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xuXG4gICAgICAgIGlmIChkYXRhLm9yLmtbMF0udGkpIHtcbiAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICB2YXIgbGVuID0gZGF0YS5vci5rLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgZGF0YS5vci5rW2ldLnRvID0gbnVsbDtcbiAgICAgICAgICAgIGRhdGEub3Iua1tpXS50aSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vciA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEub3IsIDEsIGRlZ1RvUmFkcywgdGhpcyk7IC8vIHNoIEluZGljYXRlcyBpdCBuZWVkcyB0byBiZSBjYXBwZWQgYmV0d2VlbiAtMTgwIGFuZCAxODBcblxuICAgICAgICB0aGlzLm9yLnNoID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuciA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuciB8fCB7XG4gICAgICAgICAgazogMFxuICAgICAgICB9LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5zaykge1xuICAgICAgICB0aGlzLnNrID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5zaywgMCwgZGVnVG9SYWRzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5zYSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuc2EsIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuYSB8fCB7XG4gICAgICAgIGs6IFswLCAwLCAwXVxuICAgICAgfSwgMSwgMCwgdGhpcyk7XG4gICAgICB0aGlzLnMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnMgfHwge1xuICAgICAgICBrOiBbMTAwLCAxMDAsIDEwMF1cbiAgICAgIH0sIDEsIDAuMDEsIHRoaXMpOyAvLyBPcGFjaXR5IGlzIG5vdCBwYXJ0IG9mIHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcywgdGhhdCdzIHdoeSBpdCB3b24ndCB1c2UgdGhpcy5keW5hbWljUHJvcGVydGllcy4gVGhhdCB3YXkgdHJhbnNmb3JtcyB3b24ndCBnZXQgdXBkYXRlZCBpZiBvcGFjaXR5IGNoYW5nZXMuXG5cbiAgICAgIGlmIChkYXRhLm8pIHtcbiAgICAgICAgdGhpcy5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5vLCAwLCAwLjAxLCBlbGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubyA9IHtcbiAgICAgICAgICBfbWRmOiBmYWxzZSxcbiAgICAgICAgICB2OiAxXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lzRGlydHkgPSB0cnVlO1xuXG4gICAgICBpZiAoIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZ2V0VmFsdWUodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgVHJhbnNmb3JtUHJvcGVydHkucHJvdG90eXBlID0ge1xuICAgICAgYXBwbHlUb01hdHJpeDogYXBwbHlUb01hdHJpeCxcbiAgICAgIGdldFZhbHVlOiBwcm9jZXNzS2V5cyxcbiAgICAgIHByZWNhbGN1bGF0ZU1hdHJpeDogcHJlY2FsY3VsYXRlTWF0cml4LFxuICAgICAgYXV0b09yaWVudDogYXV0b09yaWVudFxuICAgIH07XG4gICAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBUcmFuc2Zvcm1Qcm9wZXJ0eSk7XG4gICAgVHJhbnNmb3JtUHJvcGVydHkucHJvdG90eXBlLmFkZER5bmFtaWNQcm9wZXJ0eSA9IGFkZER5bmFtaWNQcm9wZXJ0eTtcbiAgICBUcmFuc2Zvcm1Qcm9wZXJ0eS5wcm90b3R5cGUuX2FkZER5bmFtaWNQcm9wZXJ0eSA9IER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lci5wcm90b3R5cGUuYWRkRHluYW1pY1Byb3BlcnR5O1xuXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtUHJvcGVydHkoZWxlbSwgZGF0YSwgY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVByb3BlcnR5KGVsZW0sIGRhdGEsIGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdldFRyYW5zZm9ybVByb3BlcnR5OiBnZXRUcmFuc2Zvcm1Qcm9wZXJ0eVxuICAgIH07XG4gIH0oKTtcblxuICBmdW5jdGlvbiBSZXBlYXRlck1vZGlmaWVyKCkge31cblxuICBleHRlbmRQcm90b3R5cGUoW1NoYXBlTW9kaWZpZXJdLCBSZXBlYXRlck1vZGlmaWVyKTtcblxuICBSZXBlYXRlck1vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5wcm9jZXNzS2V5cztcbiAgICB0aGlzLmMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmMsIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubywgMCwgbnVsbCwgdGhpcyk7XG4gICAgdGhpcy50ciA9IFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeS5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eShlbGVtLCBkYXRhLnRyLCB0aGlzKTtcbiAgICB0aGlzLnNvID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS50ci5zbywgMCwgMC4wMSwgdGhpcyk7XG4gICAgdGhpcy5lbyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudHIuZW8sIDAsIDAuMDEsIHRoaXMpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICBpZiAoIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmdldFZhbHVlKHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoO1xuICAgIHRoaXMucE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLnJNYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5zTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMudE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgfTtcblxuICBSZXBlYXRlck1vZGlmaWVyLnByb3RvdHlwZS5hcHBseVRyYW5zZm9ybXMgPSBmdW5jdGlvbiAocE1hdHJpeCwgck1hdHJpeCwgc01hdHJpeCwgdHJhbnNmb3JtLCBwZXJjLCBpbnYpIHtcbiAgICB2YXIgZGlyID0gaW52ID8gLTEgOiAxO1xuICAgIHZhciBzY2FsZVggPSB0cmFuc2Zvcm0ucy52WzBdICsgKDEgLSB0cmFuc2Zvcm0ucy52WzBdKSAqICgxIC0gcGVyYyk7XG4gICAgdmFyIHNjYWxlWSA9IHRyYW5zZm9ybS5zLnZbMV0gKyAoMSAtIHRyYW5zZm9ybS5zLnZbMV0pICogKDEgLSBwZXJjKTtcbiAgICBwTWF0cml4LnRyYW5zbGF0ZSh0cmFuc2Zvcm0ucC52WzBdICogZGlyICogcGVyYywgdHJhbnNmb3JtLnAudlsxXSAqIGRpciAqIHBlcmMsIHRyYW5zZm9ybS5wLnZbMl0pO1xuICAgIHJNYXRyaXgudHJhbnNsYXRlKC10cmFuc2Zvcm0uYS52WzBdLCAtdHJhbnNmb3JtLmEudlsxXSwgdHJhbnNmb3JtLmEudlsyXSk7XG4gICAgck1hdHJpeC5yb3RhdGUoLXRyYW5zZm9ybS5yLnYgKiBkaXIgKiBwZXJjKTtcbiAgICByTWF0cml4LnRyYW5zbGF0ZSh0cmFuc2Zvcm0uYS52WzBdLCB0cmFuc2Zvcm0uYS52WzFdLCB0cmFuc2Zvcm0uYS52WzJdKTtcbiAgICBzTWF0cml4LnRyYW5zbGF0ZSgtdHJhbnNmb3JtLmEudlswXSwgLXRyYW5zZm9ybS5hLnZbMV0sIHRyYW5zZm9ybS5hLnZbMl0pO1xuICAgIHNNYXRyaXguc2NhbGUoaW52ID8gMSAvIHNjYWxlWCA6IHNjYWxlWCwgaW52ID8gMSAvIHNjYWxlWSA6IHNjYWxlWSk7XG4gICAgc01hdHJpeC50cmFuc2xhdGUodHJhbnNmb3JtLmEudlswXSwgdHJhbnNmb3JtLmEudlsxXSwgdHJhbnNmb3JtLmEudlsyXSk7XG4gIH07XG5cbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChlbGVtLCBhcnIsIHBvcywgZWxlbXNEYXRhKSB7XG4gICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICB0aGlzLmFyciA9IGFycjtcbiAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB0aGlzLmVsZW1zRGF0YSA9IGVsZW1zRGF0YTtcbiAgICB0aGlzLl9jdXJyZW50Q29waWVzID0gMDtcbiAgICB0aGlzLl9lbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuX2dyb3VwcyA9IFtdO1xuICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xuICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcbiAgICB0aGlzLmluaXRNb2RpZmllclByb3BlcnRpZXMoZWxlbSwgYXJyW3Bvc10pO1xuXG4gICAgd2hpbGUgKHBvcyA+IDApIHtcbiAgICAgIHBvcyAtPSAxOyAvLyB0aGlzLl9lbGVtZW50cy51bnNoaWZ0KGFyci5zcGxpY2UocG9zLDEpWzBdKTtcblxuICAgICAgdGhpcy5fZWxlbWVudHMudW5zaGlmdChhcnJbcG9zXSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmsgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdldFZhbHVlKHRydWUpO1xuICAgIH1cbiAgfTtcblxuICBSZXBlYXRlck1vZGlmaWVyLnByb3RvdHlwZS5yZXNldEVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZW1lbnRzKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgZWxlbWVudHNbaV0uX3Byb2Nlc3NlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoZWxlbWVudHNbaV0udHkgPT09ICdncicpIHtcbiAgICAgICAgdGhpcy5yZXNldEVsZW1lbnRzKGVsZW1lbnRzW2ldLml0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuY2xvbmVFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgIHZhciBuZXdFbGVtZW50cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZWxlbWVudHMpKTtcbiAgICB0aGlzLnJlc2V0RWxlbWVudHMobmV3RWxlbWVudHMpO1xuICAgIHJldHVybiBuZXdFbGVtZW50cztcbiAgfTtcblxuICBSZXBlYXRlck1vZGlmaWVyLnByb3RvdHlwZS5jaGFuZ2VHcm91cFJlbmRlciA9IGZ1bmN0aW9uIChlbGVtZW50cywgcmVuZGVyRmxhZykge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBlbGVtZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGVsZW1lbnRzW2ldLl9yZW5kZXIgPSByZW5kZXJGbGFnO1xuXG4gICAgICBpZiAoZWxlbWVudHNbaV0udHkgPT09ICdncicpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VHcm91cFJlbmRlcihlbGVtZW50c1tpXS5pdCwgcmVuZGVyRmxhZyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFJlcGVhdGVyTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NTaGFwZXMgPSBmdW5jdGlvbiAoX2lzRmlyc3RGcmFtZSkge1xuICAgIHZhciBpdGVtcztcbiAgICB2YXIgaXRlbXNUcmFuc2Zvcm07XG4gICAgdmFyIGk7XG4gICAgdmFyIGRpcjtcbiAgICB2YXIgY29udDtcbiAgICB2YXIgaGFzUmVsb2FkZWQgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLl9tZGYgfHwgX2lzRmlyc3RGcmFtZSkge1xuICAgICAgdmFyIGNvcGllcyA9IE1hdGguY2VpbCh0aGlzLmMudik7XG5cbiAgICAgIGlmICh0aGlzLl9ncm91cHMubGVuZ3RoIDwgY29waWVzKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9ncm91cHMubGVuZ3RoIDwgY29waWVzKSB7XG4gICAgICAgICAgdmFyIGdyb3VwID0ge1xuICAgICAgICAgICAgaXQ6IHRoaXMuY2xvbmVFbGVtZW50cyh0aGlzLl9lbGVtZW50cyksXG4gICAgICAgICAgICB0eTogJ2dyJ1xuICAgICAgICAgIH07XG4gICAgICAgICAgZ3JvdXAuaXQucHVzaCh7XG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgIGE6IDAsXG4gICAgICAgICAgICAgIGl4OiAxLFxuICAgICAgICAgICAgICBrOiBbMCwgMF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBubTogJ1RyYW5zZm9ybScsXG4gICAgICAgICAgICBvOiB7XG4gICAgICAgICAgICAgIGE6IDAsXG4gICAgICAgICAgICAgIGl4OiA3LFxuICAgICAgICAgICAgICBrOiAxMDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwOiB7XG4gICAgICAgICAgICAgIGE6IDAsXG4gICAgICAgICAgICAgIGl4OiAyLFxuICAgICAgICAgICAgICBrOiBbMCwgMF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByOiB7XG4gICAgICAgICAgICAgIGE6IDEsXG4gICAgICAgICAgICAgIGl4OiA2LFxuICAgICAgICAgICAgICBrOiBbe1xuICAgICAgICAgICAgICAgIHM6IDAsXG4gICAgICAgICAgICAgICAgZTogMCxcbiAgICAgICAgICAgICAgICB0OiAwXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBzOiAwLFxuICAgICAgICAgICAgICAgIGU6IDAsXG4gICAgICAgICAgICAgICAgdDogMVxuICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHM6IHtcbiAgICAgICAgICAgICAgYTogMCxcbiAgICAgICAgICAgICAgaXg6IDMsXG4gICAgICAgICAgICAgIGs6IFsxMDAsIDEwMF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYToge1xuICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICBpeDogNSxcbiAgICAgICAgICAgICAgazogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNrOiB7XG4gICAgICAgICAgICAgIGE6IDAsXG4gICAgICAgICAgICAgIGl4OiA0LFxuICAgICAgICAgICAgICBrOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHk6ICd0cidcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmFyci5zcGxpY2UoMCwgMCwgZ3JvdXApO1xuXG4gICAgICAgICAgdGhpcy5fZ3JvdXBzLnNwbGljZSgwLCAwLCBncm91cCk7XG5cbiAgICAgICAgICB0aGlzLl9jdXJyZW50Q29waWVzICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsZW0ucmVsb2FkU2hhcGVzKCk7XG4gICAgICAgIGhhc1JlbG9hZGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY29udCA9IDA7XG4gICAgICB2YXIgcmVuZGVyRmxhZztcblxuICAgICAgZm9yIChpID0gMDsgaSA8PSB0aGlzLl9ncm91cHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgICAgIHJlbmRlckZsYWcgPSBjb250IDwgY29waWVzO1xuICAgICAgICB0aGlzLl9ncm91cHNbaV0uX3JlbmRlciA9IHJlbmRlckZsYWc7XG4gICAgICAgIHRoaXMuY2hhbmdlR3JvdXBSZW5kZXIodGhpcy5fZ3JvdXBzW2ldLml0LCByZW5kZXJGbGFnKTtcblxuICAgICAgICBpZiAoIXJlbmRlckZsYWcpIHtcbiAgICAgICAgICB2YXIgZWxlbXMgPSB0aGlzLmVsZW1zRGF0YVtpXS5pdDtcbiAgICAgICAgICB2YXIgdHJhbnNmb3JtRGF0YSA9IGVsZW1zW2VsZW1zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKHRyYW5zZm9ybURhdGEudHJhbnNmb3JtLm9wLnYgIT09IDApIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybURhdGEudHJhbnNmb3JtLm9wLl9tZGYgPSB0cnVlO1xuICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS50cmFuc2Zvcm0ub3AudiA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybURhdGEudHJhbnNmb3JtLm9wLl9tZGYgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2N1cnJlbnRDb3BpZXMgPSBjb3BpZXM7IC8vLyAvXG5cbiAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm8udjtcbiAgICAgIHZhciBvZmZzZXRNb2R1bG8gPSBvZmZzZXQgJSAxO1xuICAgICAgdmFyIHJvdW5kT2Zmc2V0ID0gb2Zmc2V0ID4gMCA/IE1hdGguZmxvb3Iob2Zmc2V0KSA6IE1hdGguY2VpbChvZmZzZXQpO1xuICAgICAgdmFyIHBQcm9wcyA9IHRoaXMucE1hdHJpeC5wcm9wcztcbiAgICAgIHZhciByUHJvcHMgPSB0aGlzLnJNYXRyaXgucHJvcHM7XG4gICAgICB2YXIgc1Byb3BzID0gdGhpcy5zTWF0cml4LnByb3BzO1xuICAgICAgdGhpcy5wTWF0cml4LnJlc2V0KCk7XG4gICAgICB0aGlzLnJNYXRyaXgucmVzZXQoKTtcbiAgICAgIHRoaXMuc01hdHJpeC5yZXNldCgpO1xuICAgICAgdGhpcy50TWF0cml4LnJlc2V0KCk7XG4gICAgICB0aGlzLm1hdHJpeC5yZXNldCgpO1xuICAgICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG5cbiAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgIHdoaWxlIChpdGVyYXRpb24gPCByb3VuZE9mZnNldCkge1xuICAgICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1zKHRoaXMucE1hdHJpeCwgdGhpcy5yTWF0cml4LCB0aGlzLnNNYXRyaXgsIHRoaXMudHIsIDEsIGZhbHNlKTtcbiAgICAgICAgICBpdGVyYXRpb24gKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvZmZzZXRNb2R1bG8pIHtcbiAgICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3Jtcyh0aGlzLnBNYXRyaXgsIHRoaXMuck1hdHJpeCwgdGhpcy5zTWF0cml4LCB0aGlzLnRyLCBvZmZzZXRNb2R1bG8sIGZhbHNlKTtcbiAgICAgICAgICBpdGVyYXRpb24gKz0gb2Zmc2V0TW9kdWxvO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgd2hpbGUgKGl0ZXJhdGlvbiA+IHJvdW5kT2Zmc2V0KSB7XG4gICAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybXModGhpcy5wTWF0cml4LCB0aGlzLnJNYXRyaXgsIHRoaXMuc01hdHJpeCwgdGhpcy50ciwgMSwgdHJ1ZSk7XG4gICAgICAgICAgaXRlcmF0aW9uIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2Zmc2V0TW9kdWxvKSB7XG4gICAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybXModGhpcy5wTWF0cml4LCB0aGlzLnJNYXRyaXgsIHRoaXMuc01hdHJpeCwgdGhpcy50ciwgLW9mZnNldE1vZHVsbywgdHJ1ZSk7XG4gICAgICAgICAgaXRlcmF0aW9uIC09IG9mZnNldE1vZHVsbztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpID0gdGhpcy5kYXRhLm0gPT09IDEgPyAwIDogdGhpcy5fY3VycmVudENvcGllcyAtIDE7XG4gICAgICBkaXIgPSB0aGlzLmRhdGEubSA9PT0gMSA/IDEgOiAtMTtcbiAgICAgIGNvbnQgPSB0aGlzLl9jdXJyZW50Q29waWVzO1xuICAgICAgdmFyIGo7XG4gICAgICB2YXIgakxlbjtcblxuICAgICAgd2hpbGUgKGNvbnQpIHtcbiAgICAgICAgaXRlbXMgPSB0aGlzLmVsZW1zRGF0YVtpXS5pdDtcbiAgICAgICAgaXRlbXNUcmFuc2Zvcm0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ubVByb3BzLnYucHJvcHM7XG4gICAgICAgIGpMZW4gPSBpdGVtc1RyYW5zZm9ybS5sZW5ndGg7XG4gICAgICAgIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnRyYW5zZm9ybS5tUHJvcHMuX21kZiA9IHRydWU7XG4gICAgICAgIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnRyYW5zZm9ybS5vcC5fbWRmID0gdHJ1ZTtcbiAgICAgICAgaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm9wLnYgPSB0aGlzLl9jdXJyZW50Q29waWVzID09PSAxID8gdGhpcy5zby52IDogdGhpcy5zby52ICsgKHRoaXMuZW8udiAtIHRoaXMuc28udikgKiAoaSAvICh0aGlzLl9jdXJyZW50Q29waWVzIC0gMSkpO1xuXG4gICAgICAgIGlmIChpdGVyYXRpb24gIT09IDApIHtcbiAgICAgICAgICBpZiAoaSAhPT0gMCAmJiBkaXIgPT09IDEgfHwgaSAhPT0gdGhpcy5fY3VycmVudENvcGllcyAtIDEgJiYgZGlyID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybXModGhpcy5wTWF0cml4LCB0aGlzLnJNYXRyaXgsIHRoaXMuc01hdHJpeCwgdGhpcy50ciwgMSwgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubWF0cml4LnRyYW5zZm9ybShyUHJvcHNbMF0sIHJQcm9wc1sxXSwgclByb3BzWzJdLCByUHJvcHNbM10sIHJQcm9wc1s0XSwgclByb3BzWzVdLCByUHJvcHNbNl0sIHJQcm9wc1s3XSwgclByb3BzWzhdLCByUHJvcHNbOV0sIHJQcm9wc1sxMF0sIHJQcm9wc1sxMV0sIHJQcm9wc1sxMl0sIHJQcm9wc1sxM10sIHJQcm9wc1sxNF0sIHJQcm9wc1sxNV0pO1xuICAgICAgICAgIHRoaXMubWF0cml4LnRyYW5zZm9ybShzUHJvcHNbMF0sIHNQcm9wc1sxXSwgc1Byb3BzWzJdLCBzUHJvcHNbM10sIHNQcm9wc1s0XSwgc1Byb3BzWzVdLCBzUHJvcHNbNl0sIHNQcm9wc1s3XSwgc1Byb3BzWzhdLCBzUHJvcHNbOV0sIHNQcm9wc1sxMF0sIHNQcm9wc1sxMV0sIHNQcm9wc1sxMl0sIHNQcm9wc1sxM10sIHNQcm9wc1sxNF0sIHNQcm9wc1sxNV0pO1xuICAgICAgICAgIHRoaXMubWF0cml4LnRyYW5zZm9ybShwUHJvcHNbMF0sIHBQcm9wc1sxXSwgcFByb3BzWzJdLCBwUHJvcHNbM10sIHBQcm9wc1s0XSwgcFByb3BzWzVdLCBwUHJvcHNbNl0sIHBQcm9wc1s3XSwgcFByb3BzWzhdLCBwUHJvcHNbOV0sIHBQcm9wc1sxMF0sIHBQcm9wc1sxMV0sIHBQcm9wc1sxMl0sIHBQcm9wc1sxM10sIHBQcm9wc1sxNF0sIHBQcm9wc1sxNV0pO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgaXRlbXNUcmFuc2Zvcm1bal0gPSB0aGlzLm1hdHJpeC5wcm9wc1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm1hdHJpeC5yZXNldCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubWF0cml4LnJlc2V0KCk7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBpdGVtc1RyYW5zZm9ybVtqXSA9IHRoaXMubWF0cml4LnByb3BzW2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZXJhdGlvbiArPSAxO1xuICAgICAgICBjb250IC09IDE7XG4gICAgICAgIGkgKz0gZGlyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ID0gdGhpcy5fY3VycmVudENvcGllcztcbiAgICAgIGkgPSAwO1xuICAgICAgZGlyID0gMTtcblxuICAgICAgd2hpbGUgKGNvbnQpIHtcbiAgICAgICAgaXRlbXMgPSB0aGlzLmVsZW1zRGF0YVtpXS5pdDtcbiAgICAgICAgaXRlbXNUcmFuc2Zvcm0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ubVByb3BzLnYucHJvcHM7XG4gICAgICAgIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnRyYW5zZm9ybS5tUHJvcHMuX21kZiA9IGZhbHNlO1xuICAgICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ub3AuX21kZiA9IGZhbHNlO1xuICAgICAgICBjb250IC09IDE7XG4gICAgICAgIGkgKz0gZGlyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoYXNSZWxvYWRlZDtcbiAgfTtcblxuICBSZXBlYXRlck1vZGlmaWVyLnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGZ1bmN0aW9uIFJvdW5kQ29ybmVyc01vZGlmaWVyKCkge31cblxuICBleHRlbmRQcm90b3R5cGUoW1NoYXBlTW9kaWZpZXJdLCBSb3VuZENvcm5lcnNNb2RpZmllcik7XG5cbiAgUm91bmRDb3JuZXJzTW9kaWZpZXIucHJvdG90eXBlLmluaXRNb2RpZmllclByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSkge1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLnByb2Nlc3NLZXlzO1xuICAgIHRoaXMucmQgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnIsIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMucmQuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcbiAgfTtcblxuICBSb3VuZENvcm5lcnNNb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1BhdGggPSBmdW5jdGlvbiAocGF0aCwgcm91bmQpIHtcbiAgICB2YXIgY2xvbmVkUGF0aCA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgY2xvbmVkUGF0aC5jID0gcGF0aC5jO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBwYXRoLl9sZW5ndGg7XG4gICAgdmFyIGN1cnJlbnRWO1xuICAgIHZhciBjdXJyZW50STtcbiAgICB2YXIgY3VycmVudE87XG4gICAgdmFyIGNsb3NlclY7XG4gICAgdmFyIGRpc3RhbmNlO1xuICAgIHZhciBuZXdQb3NQZXJjO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHZYO1xuICAgIHZhciB2WTtcbiAgICB2YXIgb1g7XG4gICAgdmFyIG9ZO1xuICAgIHZhciBpWDtcbiAgICB2YXIgaVk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGN1cnJlbnRWID0gcGF0aC52W2ldO1xuICAgICAgY3VycmVudE8gPSBwYXRoLm9baV07XG4gICAgICBjdXJyZW50SSA9IHBhdGguaVtpXTtcblxuICAgICAgaWYgKGN1cnJlbnRWWzBdID09PSBjdXJyZW50T1swXSAmJiBjdXJyZW50VlsxXSA9PT0gY3VycmVudE9bMV0gJiYgY3VycmVudFZbMF0gPT09IGN1cnJlbnRJWzBdICYmIGN1cnJlbnRWWzFdID09PSBjdXJyZW50SVsxXSkge1xuICAgICAgICBpZiAoKGkgPT09IDAgfHwgaSA9PT0gbGVuIC0gMSkgJiYgIXBhdGguYykge1xuICAgICAgICAgIGNsb25lZFBhdGguc2V0VHJpcGxlQXQoY3VycmVudFZbMF0sIGN1cnJlbnRWWzFdLCBjdXJyZW50T1swXSwgY3VycmVudE9bMV0sIGN1cnJlbnRJWzBdLCBjdXJyZW50SVsxXSwgaW5kZXgpO1xuICAgICAgICAgIC8qIGNsb25lZFBhdGgudltpbmRleF0gPSBjdXJyZW50VjtcclxuICAgICAgICAgICAgICAgICAgY2xvbmVkUGF0aC5vW2luZGV4XSA9IGN1cnJlbnRPO1xyXG4gICAgICAgICAgICAgICAgICBjbG9uZWRQYXRoLmlbaW5kZXhdID0gY3VycmVudEk7ICovXG5cbiAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBjbG9zZXJWID0gcGF0aC52W2xlbiAtIDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbG9zZXJWID0gcGF0aC52W2kgLSAxXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyhjdXJyZW50VlswXSAtIGNsb3NlclZbMF0sIDIpICsgTWF0aC5wb3coY3VycmVudFZbMV0gLSBjbG9zZXJWWzFdLCAyKSk7XG4gICAgICAgICAgbmV3UG9zUGVyYyA9IGRpc3RhbmNlID8gTWF0aC5taW4oZGlzdGFuY2UgLyAyLCByb3VuZCkgLyBkaXN0YW5jZSA6IDA7XG4gICAgICAgICAgaVggPSBjdXJyZW50VlswXSArIChjbG9zZXJWWzBdIC0gY3VycmVudFZbMF0pICogbmV3UG9zUGVyYztcbiAgICAgICAgICB2WCA9IGlYO1xuICAgICAgICAgIGlZID0gY3VycmVudFZbMV0gLSAoY3VycmVudFZbMV0gLSBjbG9zZXJWWzFdKSAqIG5ld1Bvc1BlcmM7XG4gICAgICAgICAgdlkgPSBpWTtcbiAgICAgICAgICBvWCA9IHZYIC0gKHZYIC0gY3VycmVudFZbMF0pICogcm91bmRDb3JuZXI7XG4gICAgICAgICAgb1kgPSB2WSAtICh2WSAtIGN1cnJlbnRWWzFdKSAqIHJvdW5kQ29ybmVyO1xuICAgICAgICAgIGNsb25lZFBhdGguc2V0VHJpcGxlQXQodlgsIHZZLCBvWCwgb1ksIGlYLCBpWSwgaW5kZXgpO1xuICAgICAgICAgIGluZGV4ICs9IDE7XG5cbiAgICAgICAgICBpZiAoaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgY2xvc2VyViA9IHBhdGgudlswXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xvc2VyViA9IHBhdGgudltpICsgMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coY3VycmVudFZbMF0gLSBjbG9zZXJWWzBdLCAyKSArIE1hdGgucG93KGN1cnJlbnRWWzFdIC0gY2xvc2VyVlsxXSwgMikpO1xuICAgICAgICAgIG5ld1Bvc1BlcmMgPSBkaXN0YW5jZSA/IE1hdGgubWluKGRpc3RhbmNlIC8gMiwgcm91bmQpIC8gZGlzdGFuY2UgOiAwO1xuICAgICAgICAgIG9YID0gY3VycmVudFZbMF0gKyAoY2xvc2VyVlswXSAtIGN1cnJlbnRWWzBdKSAqIG5ld1Bvc1BlcmM7XG4gICAgICAgICAgdlggPSBvWDtcbiAgICAgICAgICBvWSA9IGN1cnJlbnRWWzFdICsgKGNsb3NlclZbMV0gLSBjdXJyZW50VlsxXSkgKiBuZXdQb3NQZXJjO1xuICAgICAgICAgIHZZID0gb1k7XG4gICAgICAgICAgaVggPSB2WCAtICh2WCAtIGN1cnJlbnRWWzBdKSAqIHJvdW5kQ29ybmVyO1xuICAgICAgICAgIGlZID0gdlkgLSAodlkgLSBjdXJyZW50VlsxXSkgKiByb3VuZENvcm5lcjtcbiAgICAgICAgICBjbG9uZWRQYXRoLnNldFRyaXBsZUF0KHZYLCB2WSwgb1gsIG9ZLCBpWCwgaVksIGluZGV4KTtcbiAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9uZWRQYXRoLnNldFRyaXBsZUF0KHBhdGgudltpXVswXSwgcGF0aC52W2ldWzFdLCBwYXRoLm9baV1bMF0sIHBhdGgub1tpXVsxXSwgcGF0aC5pW2ldWzBdLCBwYXRoLmlbaV1bMV0sIGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmVkUGF0aDtcbiAgfTtcblxuICBSb3VuZENvcm5lcnNNb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1NoYXBlcyA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XG4gICAgdmFyIHNoYXBlUGF0aHM7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc2hhcGVzLmxlbmd0aDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgcmQgPSB0aGlzLnJkLnY7XG5cbiAgICBpZiAocmQgIT09IDApIHtcbiAgICAgIHZhciBzaGFwZURhdGE7XG4gICAgICB2YXIgbG9jYWxTaGFwZUNvbGxlY3Rpb247XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBzaGFwZURhdGEgPSB0aGlzLnNoYXBlc1tpXTtcbiAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZURhdGEubG9jYWxTaGFwZUNvbGxlY3Rpb247XG5cbiAgICAgICAgaWYgKCEoIXNoYXBlRGF0YS5zaGFwZS5fbWRmICYmICF0aGlzLl9tZGYgJiYgIV9pc0ZpcnN0RnJhbWUpKSB7XG4gICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xuICAgICAgICAgIHNoYXBlRGF0YS5zaGFwZS5fbWRmID0gdHJ1ZTtcbiAgICAgICAgICBzaGFwZVBhdGhzID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLnNoYXBlcztcbiAgICAgICAgICBqTGVuID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLl9sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnByb2Nlc3NQYXRoKHNoYXBlUGF0aHNbal0sIHJkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBmbG9hdEVxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpICogMTAwMDAwIDw9IE1hdGgubWluKE1hdGguYWJzKGEpLCBNYXRoLmFicyhiKSk7XG4gIH1cblxuICBmdW5jdGlvbiBmbG9hdFplcm8oZikge1xuICAgIHJldHVybiBNYXRoLmFicyhmKSA8PSAwLjAwMDAxO1xuICB9XG5cbiAgZnVuY3Rpb24gbGVycChwMCwgcDEsIGFtb3VudCkge1xuICAgIHJldHVybiBwMCAqICgxIC0gYW1vdW50KSArIHAxICogYW1vdW50O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVycFBvaW50KHAwLCBwMSwgYW1vdW50KSB7XG4gICAgcmV0dXJuIFtsZXJwKHAwWzBdLCBwMVswXSwgYW1vdW50KSwgbGVycChwMFsxXSwgcDFbMV0sIGFtb3VudCldO1xuICB9XG5cbiAgZnVuY3Rpb24gcXVhZFJvb3RzKGEsIGIsIGMpIHtcbiAgICAvLyBubyByb290XG4gICAgaWYgKGEgPT09IDApIHJldHVybiBbXTtcbiAgICB2YXIgcyA9IGIgKiBiIC0gNCAqIGEgKiBjOyAvLyBDb21wbGV4IHJvb3RzXG5cbiAgICBpZiAocyA8IDApIHJldHVybiBbXTtcbiAgICB2YXIgc2luZ2xlUm9vdCA9IC1iIC8gKDIgKiBhKTsgLy8gMSByb290XG5cbiAgICBpZiAocyA9PT0gMCkgcmV0dXJuIFtzaW5nbGVSb290XTtcbiAgICB2YXIgZGVsdGEgPSBNYXRoLnNxcnQocykgLyAoMiAqIGEpOyAvLyAyIHJvb3RzXG5cbiAgICByZXR1cm4gW3NpbmdsZVJvb3QgLSBkZWx0YSwgc2luZ2xlUm9vdCArIGRlbHRhXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvbHlub21pYWxDb2VmZmljaWVudHMocDAsIHAxLCBwMiwgcDMpIHtcbiAgICByZXR1cm4gWy1wMCArIDMgKiBwMSAtIDMgKiBwMiArIHAzLCAzICogcDAgLSA2ICogcDEgKyAzICogcDIsIC0zICogcDAgKyAzICogcDEsIHAwXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpbmdsZVBvaW50KHApIHtcbiAgICByZXR1cm4gbmV3IFBvbHlub21pYWxCZXppZXIocCwgcCwgcCwgcCwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gUG9seW5vbWlhbEJlemllcihwMCwgcDEsIHAyLCBwMywgbGluZWFyaXplKSB7XG4gICAgaWYgKGxpbmVhcml6ZSAmJiBwb2ludEVxdWFsKHAwLCBwMSkpIHtcbiAgICAgIHAxID0gbGVycFBvaW50KHAwLCBwMywgMSAvIDMpO1xuICAgIH1cblxuICAgIGlmIChsaW5lYXJpemUgJiYgcG9pbnRFcXVhbChwMiwgcDMpKSB7XG4gICAgICBwMiA9IGxlcnBQb2ludChwMCwgcDMsIDIgLyAzKTtcbiAgICB9XG5cbiAgICB2YXIgY29lZmZ4ID0gcG9seW5vbWlhbENvZWZmaWNpZW50cyhwMFswXSwgcDFbMF0sIHAyWzBdLCBwM1swXSk7XG4gICAgdmFyIGNvZWZmeSA9IHBvbHlub21pYWxDb2VmZmljaWVudHMocDBbMV0sIHAxWzFdLCBwMlsxXSwgcDNbMV0pO1xuICAgIHRoaXMuYSA9IFtjb2VmZnhbMF0sIGNvZWZmeVswXV07XG4gICAgdGhpcy5iID0gW2NvZWZmeFsxXSwgY29lZmZ5WzFdXTtcbiAgICB0aGlzLmMgPSBbY29lZmZ4WzJdLCBjb2VmZnlbMl1dO1xuICAgIHRoaXMuZCA9IFtjb2VmZnhbM10sIGNvZWZmeVszXV07XG4gICAgdGhpcy5wb2ludHMgPSBbcDAsIHAxLCBwMiwgcDNdO1xuICB9XG5cbiAgUG9seW5vbWlhbEJlemllci5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBbKCh0aGlzLmFbMF0gKiB0ICsgdGhpcy5iWzBdKSAqIHQgKyB0aGlzLmNbMF0pICogdCArIHRoaXMuZFswXSwgKCh0aGlzLmFbMV0gKiB0ICsgdGhpcy5iWzFdKSAqIHQgKyB0aGlzLmNbMV0pICogdCArIHRoaXMuZFsxXV07XG4gIH07XG5cbiAgUG9seW5vbWlhbEJlemllci5wcm90b3R5cGUuZGVyaXZhdGl2ZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIFsoMyAqIHQgKiB0aGlzLmFbMF0gKyAyICogdGhpcy5iWzBdKSAqIHQgKyB0aGlzLmNbMF0sICgzICogdCAqIHRoaXMuYVsxXSArIDIgKiB0aGlzLmJbMV0pICogdCArIHRoaXMuY1sxXV07XG4gIH07XG5cbiAgUG9seW5vbWlhbEJlemllci5wcm90b3R5cGUudGFuZ2VudEFuZ2xlID0gZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgcCA9IHRoaXMuZGVyaXZhdGl2ZSh0KTtcbiAgICByZXR1cm4gTWF0aC5hdGFuMihwWzFdLCBwWzBdKTtcbiAgfTtcblxuICBQb2x5bm9taWFsQmV6aWVyLnByb3RvdHlwZS5ub3JtYWxBbmdsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHAgPSB0aGlzLmRlcml2YXRpdmUodCk7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIocFswXSwgcFsxXSk7XG4gIH07XG5cbiAgUG9seW5vbWlhbEJlemllci5wcm90b3R5cGUuaW5mbGVjdGlvblBvaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGVub20gPSB0aGlzLmFbMV0gKiB0aGlzLmJbMF0gLSB0aGlzLmFbMF0gKiB0aGlzLmJbMV07XG4gICAgaWYgKGZsb2F0WmVybyhkZW5vbSkpIHJldHVybiBbXTtcbiAgICB2YXIgdGN1c3AgPSAtMC41ICogKHRoaXMuYVsxXSAqIHRoaXMuY1swXSAtIHRoaXMuYVswXSAqIHRoaXMuY1sxXSkgLyBkZW5vbTtcbiAgICB2YXIgc3F1YXJlID0gdGN1c3AgKiB0Y3VzcCAtIDEgLyAzICogKHRoaXMuYlsxXSAqIHRoaXMuY1swXSAtIHRoaXMuYlswXSAqIHRoaXMuY1sxXSkgLyBkZW5vbTtcbiAgICBpZiAoc3F1YXJlIDwgMCkgcmV0dXJuIFtdO1xuICAgIHZhciByb290ID0gTWF0aC5zcXJ0KHNxdWFyZSk7XG5cbiAgICBpZiAoZmxvYXRaZXJvKHJvb3QpKSB7XG4gICAgICBpZiAocm9vdCA+IDAgJiYgcm9vdCA8IDEpIHJldHVybiBbdGN1c3BdO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiBbdGN1c3AgLSByb290LCB0Y3VzcCArIHJvb3RdLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIHIgPiAwICYmIHIgPCAxO1xuICAgIH0pO1xuICB9O1xuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICBpZiAodCA8PSAwKSByZXR1cm4gW3NpbmdsZVBvaW50KHRoaXMucG9pbnRzWzBdKSwgdGhpc107XG4gICAgaWYgKHQgPj0gMSkgcmV0dXJuIFt0aGlzLCBzaW5nbGVQb2ludCh0aGlzLnBvaW50c1t0aGlzLnBvaW50cy5sZW5ndGggLSAxXSldO1xuICAgIHZhciBwMTAgPSBsZXJwUG9pbnQodGhpcy5wb2ludHNbMF0sIHRoaXMucG9pbnRzWzFdLCB0KTtcbiAgICB2YXIgcDExID0gbGVycFBvaW50KHRoaXMucG9pbnRzWzFdLCB0aGlzLnBvaW50c1syXSwgdCk7XG4gICAgdmFyIHAxMiA9IGxlcnBQb2ludCh0aGlzLnBvaW50c1syXSwgdGhpcy5wb2ludHNbM10sIHQpO1xuICAgIHZhciBwMjAgPSBsZXJwUG9pbnQocDEwLCBwMTEsIHQpO1xuICAgIHZhciBwMjEgPSBsZXJwUG9pbnQocDExLCBwMTIsIHQpO1xuICAgIHZhciBwMyA9IGxlcnBQb2ludChwMjAsIHAyMSwgdCk7XG4gICAgcmV0dXJuIFtuZXcgUG9seW5vbWlhbEJlemllcih0aGlzLnBvaW50c1swXSwgcDEwLCBwMjAsIHAzLCB0cnVlKSwgbmV3IFBvbHlub21pYWxCZXppZXIocDMsIHAyMSwgcDEyLCB0aGlzLnBvaW50c1szXSwgdHJ1ZSldO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGV4dHJlbWEoYmV6LCBjb21wKSB7XG4gICAgdmFyIG1pbiA9IGJlei5wb2ludHNbMF1bY29tcF07XG4gICAgdmFyIG1heCA9IGJlei5wb2ludHNbYmV6LnBvaW50cy5sZW5ndGggLSAxXVtjb21wXTtcblxuICAgIGlmIChtaW4gPiBtYXgpIHtcbiAgICAgIHZhciBlID0gbWF4O1xuICAgICAgbWF4ID0gbWluO1xuICAgICAgbWluID0gZTtcbiAgICB9IC8vIERlcml2YXRpdmUgcm9vdHMgdG8gZmluZCBtaW4vbWF4XG5cblxuICAgIHZhciBmID0gcXVhZFJvb3RzKDMgKiBiZXouYVtjb21wXSwgMiAqIGJlei5iW2NvbXBdLCBiZXouY1tjb21wXSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGYubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChmW2ldID4gMCAmJiBmW2ldIDwgMSkge1xuICAgICAgICB2YXIgdmFsID0gYmV6LnBvaW50KGZbaV0pW2NvbXBdO1xuICAgICAgICBpZiAodmFsIDwgbWluKSBtaW4gPSB2YWw7ZWxzZSBpZiAodmFsID4gbWF4KSBtYXggPSB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogbWluLFxuICAgICAgbWF4OiBtYXhcbiAgICB9O1xuICB9XG5cbiAgUG9seW5vbWlhbEJlemllci5wcm90b3R5cGUuYm91bmRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBleHRyZW1hKHRoaXMsIDApLFxuICAgICAgeTogZXh0cmVtYSh0aGlzLCAxKVxuICAgIH07XG4gIH07XG5cbiAgUG9seW5vbWlhbEJlemllci5wcm90b3R5cGUuYm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuYm91bmRzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGJvdW5kcy54Lm1pbixcbiAgICAgIHJpZ2h0OiBib3VuZHMueC5tYXgsXG4gICAgICB0b3A6IGJvdW5kcy55Lm1pbixcbiAgICAgIGJvdHRvbTogYm91bmRzLnkubWF4LFxuICAgICAgd2lkdGg6IGJvdW5kcy54Lm1heCAtIGJvdW5kcy54Lm1pbixcbiAgICAgIGhlaWdodDogYm91bmRzLnkubWF4IC0gYm91bmRzLnkubWluLFxuICAgICAgY3g6IChib3VuZHMueC5tYXggKyBib3VuZHMueC5taW4pIC8gMixcbiAgICAgIGN5OiAoYm91bmRzLnkubWF4ICsgYm91bmRzLnkubWluKSAvIDJcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGludGVyc2VjdERhdGEoYmV6LCB0MSwgdDIpIHtcbiAgICB2YXIgYm94ID0gYmV6LmJvdW5kaW5nQm94KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN4OiBib3guY3gsXG4gICAgICBjeTogYm94LmN5LFxuICAgICAgd2lkdGg6IGJveC53aWR0aCxcbiAgICAgIGhlaWdodDogYm94LmhlaWdodCxcbiAgICAgIGJlejogYmV6LFxuICAgICAgdDogKHQxICsgdDIpIC8gMixcbiAgICAgIHQxOiB0MSxcbiAgICAgIHQyOiB0MlxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzcGxpdERhdGEoZGF0YSkge1xuICAgIHZhciBzcGxpdCA9IGRhdGEuYmV6LnNwbGl0KDAuNSk7XG4gICAgcmV0dXJuIFtpbnRlcnNlY3REYXRhKHNwbGl0WzBdLCBkYXRhLnQxLCBkYXRhLnQpLCBpbnRlcnNlY3REYXRhKHNwbGl0WzFdLCBkYXRhLnQsIGRhdGEudDIpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJveEludGVyc2VjdChiMSwgYjIpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYjEuY3ggLSBiMi5jeCkgKiAyIDwgYjEud2lkdGggKyBiMi53aWR0aCAmJiBNYXRoLmFicyhiMS5jeSAtIGIyLmN5KSAqIDIgPCBiMS5oZWlnaHQgKyBiMi5oZWlnaHQ7XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnNlY3RzSW1wbChkMSwgZDIsIGRlcHRoLCB0b2xlcmFuY2UsIGludGVyc2VjdGlvbnMsIG1heFJlY3Vyc2lvbikge1xuICAgIGlmICghYm94SW50ZXJzZWN0KGQxLCBkMikpIHJldHVybjtcblxuICAgIGlmIChkZXB0aCA+PSBtYXhSZWN1cnNpb24gfHwgZDEud2lkdGggPD0gdG9sZXJhbmNlICYmIGQxLmhlaWdodCA8PSB0b2xlcmFuY2UgJiYgZDIud2lkdGggPD0gdG9sZXJhbmNlICYmIGQyLmhlaWdodCA8PSB0b2xlcmFuY2UpIHtcbiAgICAgIGludGVyc2VjdGlvbnMucHVzaChbZDEudCwgZDIudF0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkMXMgPSBzcGxpdERhdGEoZDEpO1xuICAgIHZhciBkMnMgPSBzcGxpdERhdGEoZDIpO1xuICAgIGludGVyc2VjdHNJbXBsKGQxc1swXSwgZDJzWzBdLCBkZXB0aCArIDEsIHRvbGVyYW5jZSwgaW50ZXJzZWN0aW9ucywgbWF4UmVjdXJzaW9uKTtcbiAgICBpbnRlcnNlY3RzSW1wbChkMXNbMF0sIGQyc1sxXSwgZGVwdGggKyAxLCB0b2xlcmFuY2UsIGludGVyc2VjdGlvbnMsIG1heFJlY3Vyc2lvbik7XG4gICAgaW50ZXJzZWN0c0ltcGwoZDFzWzFdLCBkMnNbMF0sIGRlcHRoICsgMSwgdG9sZXJhbmNlLCBpbnRlcnNlY3Rpb25zLCBtYXhSZWN1cnNpb24pO1xuICAgIGludGVyc2VjdHNJbXBsKGQxc1sxXSwgZDJzWzFdLCBkZXB0aCArIDEsIHRvbGVyYW5jZSwgaW50ZXJzZWN0aW9ucywgbWF4UmVjdXJzaW9uKTtcbiAgfVxuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLmludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiAob3RoZXIsIHRvbGVyYW5jZSwgbWF4UmVjdXJzaW9uKSB7XG4gICAgaWYgKHRvbGVyYW5jZSA9PT0gdW5kZWZpbmVkKSB0b2xlcmFuY2UgPSAyO1xuICAgIGlmIChtYXhSZWN1cnNpb24gPT09IHVuZGVmaW5lZCkgbWF4UmVjdXJzaW9uID0gNztcbiAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgIGludGVyc2VjdHNJbXBsKGludGVyc2VjdERhdGEodGhpcywgMCwgMSksIGludGVyc2VjdERhdGEob3RoZXIsIDAsIDEpLCAwLCB0b2xlcmFuY2UsIGludGVyc2VjdGlvbnMsIG1heFJlY3Vyc2lvbik7XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH07XG5cbiAgUG9seW5vbWlhbEJlemllci5zaGFwZVNlZ21lbnQgPSBmdW5jdGlvbiAoc2hhcGVQYXRoLCBpbmRleCkge1xuICAgIHZhciBuZXh0SW5kZXggPSAoaW5kZXggKyAxKSAlIHNoYXBlUGF0aC5sZW5ndGgoKTtcbiAgICByZXR1cm4gbmV3IFBvbHlub21pYWxCZXppZXIoc2hhcGVQYXRoLnZbaW5kZXhdLCBzaGFwZVBhdGgub1tpbmRleF0sIHNoYXBlUGF0aC5pW25leHRJbmRleF0sIHNoYXBlUGF0aC52W25leHRJbmRleF0sIHRydWUpO1xuICB9O1xuXG4gIFBvbHlub21pYWxCZXppZXIuc2hhcGVTZWdtZW50SW52ZXJ0ZWQgPSBmdW5jdGlvbiAoc2hhcGVQYXRoLCBpbmRleCkge1xuICAgIHZhciBuZXh0SW5kZXggPSAoaW5kZXggKyAxKSAlIHNoYXBlUGF0aC5sZW5ndGgoKTtcbiAgICByZXR1cm4gbmV3IFBvbHlub21pYWxCZXppZXIoc2hhcGVQYXRoLnZbbmV4dEluZGV4XSwgc2hhcGVQYXRoLmlbbmV4dEluZGV4XSwgc2hhcGVQYXRoLm9baW5kZXhdLCBzaGFwZVBhdGgudltpbmRleF0sIHRydWUpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNyb3NzUHJvZHVjdChhLCBiKSB7XG4gICAgcmV0dXJuIFthWzFdICogYlsyXSAtIGFbMl0gKiBiWzFdLCBhWzJdICogYlswXSAtIGFbMF0gKiBiWzJdLCBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmVJbnRlcnNlY3Rpb24oc3RhcnQxLCBlbmQxLCBzdGFydDIsIGVuZDIpIHtcbiAgICB2YXIgdjEgPSBbc3RhcnQxWzBdLCBzdGFydDFbMV0sIDFdO1xuICAgIHZhciB2MiA9IFtlbmQxWzBdLCBlbmQxWzFdLCAxXTtcbiAgICB2YXIgdjMgPSBbc3RhcnQyWzBdLCBzdGFydDJbMV0sIDFdO1xuICAgIHZhciB2NCA9IFtlbmQyWzBdLCBlbmQyWzFdLCAxXTtcbiAgICB2YXIgciA9IGNyb3NzUHJvZHVjdChjcm9zc1Byb2R1Y3QodjEsIHYyKSwgY3Jvc3NQcm9kdWN0KHYzLCB2NCkpO1xuICAgIGlmIChmbG9hdFplcm8oclsyXSkpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBbclswXSAvIHJbMl0sIHJbMV0gLyByWzJdXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvbGFyT2Zmc2V0KHAsIGFuZ2xlLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gW3BbMF0gKyBNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgsIHBbMV0gLSBNYXRoLnNpbihhbmdsZSkgKiBsZW5ndGhdO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9pbnREaXN0YW5jZShwMSwgcDIpIHtcbiAgICByZXR1cm4gTWF0aC5oeXBvdChwMVswXSAtIHAyWzBdLCBwMVsxXSAtIHAyWzFdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvaW50RXF1YWwocDEsIHAyKSB7XG4gICAgcmV0dXJuIGZsb2F0RXF1YWwocDFbMF0sIHAyWzBdKSAmJiBmbG9hdEVxdWFsKHAxWzFdLCBwMlsxXSk7XG4gIH1cblxuICBmdW5jdGlvbiBaaWdaYWdNb2RpZmllcigpIHt9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtTaGFwZU1vZGlmaWVyXSwgWmlnWmFnTW9kaWZpZXIpO1xuXG4gIFppZ1phZ01vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5wcm9jZXNzS2V5cztcbiAgICB0aGlzLmFtcGxpdHVkZSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucywgMCwgbnVsbCwgdGhpcyk7XG4gICAgdGhpcy5mcmVxdWVuY3kgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnIsIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMucG9pbnRzVHlwZSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucHQsIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSB0aGlzLmFtcGxpdHVkZS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoICE9PSAwIHx8IHRoaXMuZnJlcXVlbmN5LmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggIT09IDAgfHwgdGhpcy5wb2ludHNUeXBlLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggIT09IDA7XG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0UG9pbnQob3V0cHV0QmV6aWVyLCBwb2ludCwgYW5nbGUsIGRpcmVjdGlvbiwgYW1wbGl0dWRlLCBvdXRBbXBsaXR1ZGUsIGluQW1wbGl0dWRlKSB7XG4gICAgdmFyIGFuZ08gPSBhbmdsZSAtIE1hdGguUEkgLyAyO1xuICAgIHZhciBhbmdJID0gYW5nbGUgKyBNYXRoLlBJIC8gMjtcbiAgICB2YXIgcHggPSBwb2ludFswXSArIE1hdGguY29zKGFuZ2xlKSAqIGRpcmVjdGlvbiAqIGFtcGxpdHVkZTtcbiAgICB2YXIgcHkgPSBwb2ludFsxXSAtIE1hdGguc2luKGFuZ2xlKSAqIGRpcmVjdGlvbiAqIGFtcGxpdHVkZTtcbiAgICBvdXRwdXRCZXppZXIuc2V0VHJpcGxlQXQocHgsIHB5LCBweCArIE1hdGguY29zKGFuZ08pICogb3V0QW1wbGl0dWRlLCBweSAtIE1hdGguc2luKGFuZ08pICogb3V0QW1wbGl0dWRlLCBweCArIE1hdGguY29zKGFuZ0kpICogaW5BbXBsaXR1ZGUsIHB5IC0gTWF0aC5zaW4oYW5nSSkgKiBpbkFtcGxpdHVkZSwgb3V0cHV0QmV6aWVyLmxlbmd0aCgpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBlcnBlbmRpY3VsYXJWZWN0b3IocHQxLCBwdDIpIHtcbiAgICB2YXIgdmVjdG9yID0gW3B0MlswXSAtIHB0MVswXSwgcHQyWzFdIC0gcHQxWzFdXTtcbiAgICB2YXIgcm90ID0gLU1hdGguUEkgKiAwLjU7XG4gICAgdmFyIHJvdGF0ZWRWZWN0b3IgPSBbTWF0aC5jb3Mocm90KSAqIHZlY3RvclswXSAtIE1hdGguc2luKHJvdCkgKiB2ZWN0b3JbMV0sIE1hdGguc2luKHJvdCkgKiB2ZWN0b3JbMF0gKyBNYXRoLmNvcyhyb3QpICogdmVjdG9yWzFdXTtcbiAgICByZXR1cm4gcm90YXRlZFZlY3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFByb2plY3RpbmdBbmdsZShwYXRoLCBjdXIpIHtcbiAgICB2YXIgcHJldkluZGV4ID0gY3VyID09PSAwID8gcGF0aC5sZW5ndGgoKSAtIDEgOiBjdXIgLSAxO1xuICAgIHZhciBuZXh0SW5kZXggPSAoY3VyICsgMSkgJSBwYXRoLmxlbmd0aCgpO1xuICAgIHZhciBwcmV2UG9pbnQgPSBwYXRoLnZbcHJldkluZGV4XTtcbiAgICB2YXIgbmV4dFBvaW50ID0gcGF0aC52W25leHRJbmRleF07XG4gICAgdmFyIHBWZWN0b3IgPSBnZXRQZXJwZW5kaWN1bGFyVmVjdG9yKHByZXZQb2ludCwgbmV4dFBvaW50KTtcbiAgICByZXR1cm4gTWF0aC5hdGFuMigwLCAxKSAtIE1hdGguYXRhbjIocFZlY3RvclsxXSwgcFZlY3RvclswXSk7XG4gIH1cblxuICBmdW5jdGlvbiB6aWdaYWdDb3JuZXIob3V0cHV0QmV6aWVyLCBwYXRoLCBjdXIsIGFtcGxpdHVkZSwgZnJlcXVlbmN5LCBwb2ludFR5cGUsIGRpcmVjdGlvbikge1xuICAgIHZhciBhbmdsZSA9IGdldFByb2plY3RpbmdBbmdsZShwYXRoLCBjdXIpO1xuICAgIHZhciBwb2ludCA9IHBhdGgudltjdXIgJSBwYXRoLl9sZW5ndGhdO1xuICAgIHZhciBwcmV2UG9pbnQgPSBwYXRoLnZbY3VyID09PSAwID8gcGF0aC5fbGVuZ3RoIC0gMSA6IGN1ciAtIDFdO1xuICAgIHZhciBuZXh0UG9pbnQgPSBwYXRoLnZbKGN1ciArIDEpICUgcGF0aC5fbGVuZ3RoXTtcbiAgICB2YXIgcHJldkRpc3QgPSBwb2ludFR5cGUgPT09IDIgPyBNYXRoLnNxcnQoTWF0aC5wb3cocG9pbnRbMF0gLSBwcmV2UG9pbnRbMF0sIDIpICsgTWF0aC5wb3cocG9pbnRbMV0gLSBwcmV2UG9pbnRbMV0sIDIpKSA6IDA7XG4gICAgdmFyIG5leHREaXN0ID0gcG9pbnRUeXBlID09PSAyID8gTWF0aC5zcXJ0KE1hdGgucG93KHBvaW50WzBdIC0gbmV4dFBvaW50WzBdLCAyKSArIE1hdGgucG93KHBvaW50WzFdIC0gbmV4dFBvaW50WzFdLCAyKSkgOiAwO1xuICAgIHNldFBvaW50KG91dHB1dEJlemllciwgcGF0aC52W2N1ciAlIHBhdGguX2xlbmd0aF0sIGFuZ2xlLCBkaXJlY3Rpb24sIGFtcGxpdHVkZSwgbmV4dERpc3QgLyAoKGZyZXF1ZW5jeSArIDEpICogMiksIHByZXZEaXN0IC8gKChmcmVxdWVuY3kgKyAxKSAqIDIpLCBwb2ludFR5cGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gemlnWmFnU2VnbWVudChvdXRwdXRCZXppZXIsIHNlZ21lbnQsIGFtcGxpdHVkZSwgZnJlcXVlbmN5LCBwb2ludFR5cGUsIGRpcmVjdGlvbikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJlcXVlbmN5OyBpICs9IDEpIHtcbiAgICAgIHZhciB0ID0gKGkgKyAxKSAvIChmcmVxdWVuY3kgKyAxKTtcbiAgICAgIHZhciBkaXN0ID0gcG9pbnRUeXBlID09PSAyID8gTWF0aC5zcXJ0KE1hdGgucG93KHNlZ21lbnQucG9pbnRzWzNdWzBdIC0gc2VnbWVudC5wb2ludHNbMF1bMF0sIDIpICsgTWF0aC5wb3coc2VnbWVudC5wb2ludHNbM11bMV0gLSBzZWdtZW50LnBvaW50c1swXVsxXSwgMikpIDogMDtcbiAgICAgIHZhciBhbmdsZSA9IHNlZ21lbnQubm9ybWFsQW5nbGUodCk7XG4gICAgICB2YXIgcG9pbnQgPSBzZWdtZW50LnBvaW50KHQpO1xuICAgICAgc2V0UG9pbnQob3V0cHV0QmV6aWVyLCBwb2ludCwgYW5nbGUsIGRpcmVjdGlvbiwgYW1wbGl0dWRlLCBkaXN0IC8gKChmcmVxdWVuY3kgKyAxKSAqIDIpLCBkaXN0IC8gKChmcmVxdWVuY3kgKyAxKSAqIDIpLCBwb2ludFR5cGUpO1xuICAgICAgZGlyZWN0aW9uID0gLWRpcmVjdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlyZWN0aW9uO1xuICB9XG5cbiAgWmlnWmFnTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NQYXRoID0gZnVuY3Rpb24gKHBhdGgsIGFtcGxpdHVkZSwgZnJlcXVlbmN5LCBwb2ludFR5cGUpIHtcbiAgICB2YXIgY291bnQgPSBwYXRoLl9sZW5ndGg7XG4gICAgdmFyIGNsb25lZFBhdGggPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xuICAgIGNsb25lZFBhdGguYyA9IHBhdGguYztcblxuICAgIGlmICghcGF0aC5jKSB7XG4gICAgICBjb3VudCAtPSAxO1xuICAgIH1cblxuICAgIGlmIChjb3VudCA9PT0gMCkgcmV0dXJuIGNsb25lZFBhdGg7XG4gICAgdmFyIGRpcmVjdGlvbiA9IC0xO1xuICAgIHZhciBzZWdtZW50ID0gUG9seW5vbWlhbEJlemllci5zaGFwZVNlZ21lbnQocGF0aCwgMCk7XG4gICAgemlnWmFnQ29ybmVyKGNsb25lZFBhdGgsIHBhdGgsIDAsIGFtcGxpdHVkZSwgZnJlcXVlbmN5LCBwb2ludFR5cGUsIGRpcmVjdGlvbik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpICs9IDEpIHtcbiAgICAgIGRpcmVjdGlvbiA9IHppZ1phZ1NlZ21lbnQoY2xvbmVkUGF0aCwgc2VnbWVudCwgYW1wbGl0dWRlLCBmcmVxdWVuY3ksIHBvaW50VHlwZSwgLWRpcmVjdGlvbik7XG5cbiAgICAgIGlmIChpID09PSBjb3VudCAtIDEgJiYgIXBhdGguYykge1xuICAgICAgICBzZWdtZW50ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZ21lbnQgPSBQb2x5bm9taWFsQmV6aWVyLnNoYXBlU2VnbWVudChwYXRoLCAoaSArIDEpICUgY291bnQpO1xuICAgICAgfVxuXG4gICAgICB6aWdaYWdDb3JuZXIoY2xvbmVkUGF0aCwgcGF0aCwgaSArIDEsIGFtcGxpdHVkZSwgZnJlcXVlbmN5LCBwb2ludFR5cGUsIGRpcmVjdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lZFBhdGg7XG4gIH07XG5cbiAgWmlnWmFnTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NTaGFwZXMgPSBmdW5jdGlvbiAoX2lzRmlyc3RGcmFtZSkge1xuICAgIHZhciBzaGFwZVBhdGhzO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLnNoYXBlcy5sZW5ndGg7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIGFtcGxpdHVkZSA9IHRoaXMuYW1wbGl0dWRlLnY7XG4gICAgdmFyIGZyZXF1ZW5jeSA9IE1hdGgubWF4KDAsIE1hdGgucm91bmQodGhpcy5mcmVxdWVuY3kudikpO1xuICAgIHZhciBwb2ludFR5cGUgPSB0aGlzLnBvaW50c1R5cGUudjtcblxuICAgIGlmIChhbXBsaXR1ZGUgIT09IDApIHtcbiAgICAgIHZhciBzaGFwZURhdGE7XG4gICAgICB2YXIgbG9jYWxTaGFwZUNvbGxlY3Rpb247XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBzaGFwZURhdGEgPSB0aGlzLnNoYXBlc1tpXTtcbiAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZURhdGEubG9jYWxTaGFwZUNvbGxlY3Rpb247XG5cbiAgICAgICAgaWYgKCEoIXNoYXBlRGF0YS5zaGFwZS5fbWRmICYmICF0aGlzLl9tZGYgJiYgIV9pc0ZpcnN0RnJhbWUpKSB7XG4gICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xuICAgICAgICAgIHNoYXBlRGF0YS5zaGFwZS5fbWRmID0gdHJ1ZTtcbiAgICAgICAgICBzaGFwZVBhdGhzID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLnNoYXBlcztcbiAgICAgICAgICBqTGVuID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLl9sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnByb2Nlc3NQYXRoKHNoYXBlUGF0aHNbal0sIGFtcGxpdHVkZSwgZnJlcXVlbmN5LCBwb2ludFR5cGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzaGFwZURhdGEuc2hhcGUucGF0aHMgPSBzaGFwZURhdGEubG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGxpbmVhck9mZnNldChwMSwgcDIsIGFtb3VudCkge1xuICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIocDJbMF0gLSBwMVswXSwgcDJbMV0gLSBwMVsxXSk7XG4gICAgcmV0dXJuIFtwb2xhck9mZnNldChwMSwgYW5nbGUsIGFtb3VudCksIHBvbGFyT2Zmc2V0KHAyLCBhbmdsZSwgYW1vdW50KV07XG4gIH1cblxuICBmdW5jdGlvbiBvZmZzZXRTZWdtZW50KHNlZ21lbnQsIGFtb3VudCkge1xuICAgIHZhciBwMDtcbiAgICB2YXIgcDFhO1xuICAgIHZhciBwMWI7XG4gICAgdmFyIHAyYjtcbiAgICB2YXIgcDJhO1xuICAgIHZhciBwMztcbiAgICB2YXIgZTtcbiAgICBlID0gbGluZWFyT2Zmc2V0KHNlZ21lbnQucG9pbnRzWzBdLCBzZWdtZW50LnBvaW50c1sxXSwgYW1vdW50KTtcbiAgICBwMCA9IGVbMF07XG4gICAgcDFhID0gZVsxXTtcbiAgICBlID0gbGluZWFyT2Zmc2V0KHNlZ21lbnQucG9pbnRzWzFdLCBzZWdtZW50LnBvaW50c1syXSwgYW1vdW50KTtcbiAgICBwMWIgPSBlWzBdO1xuICAgIHAyYiA9IGVbMV07XG4gICAgZSA9IGxpbmVhck9mZnNldChzZWdtZW50LnBvaW50c1syXSwgc2VnbWVudC5wb2ludHNbM10sIGFtb3VudCk7XG4gICAgcDJhID0gZVswXTtcbiAgICBwMyA9IGVbMV07XG4gICAgdmFyIHAxID0gbGluZUludGVyc2VjdGlvbihwMCwgcDFhLCBwMWIsIHAyYik7XG4gICAgaWYgKHAxID09PSBudWxsKSBwMSA9IHAxYTtcbiAgICB2YXIgcDIgPSBsaW5lSW50ZXJzZWN0aW9uKHAyYSwgcDMsIHAxYiwgcDJiKTtcbiAgICBpZiAocDIgPT09IG51bGwpIHAyID0gcDJhO1xuICAgIHJldHVybiBuZXcgUG9seW5vbWlhbEJlemllcihwMCwgcDEsIHAyLCBwMyk7XG4gIH1cblxuICBmdW5jdGlvbiBqb2luTGluZXMob3V0cHV0QmV6aWVyLCBzZWcxLCBzZWcyLCBsaW5lSm9pbiwgbWl0ZXJMaW1pdCkge1xuICAgIHZhciBwMCA9IHNlZzEucG9pbnRzWzNdO1xuICAgIHZhciBwMSA9IHNlZzIucG9pbnRzWzBdOyAvLyBCZXZlbFxuXG4gICAgaWYgKGxpbmVKb2luID09PSAzKSByZXR1cm4gcDA7IC8vIENvbm5lY3RlZCwgdGhleSBkb24ndCBuZWVkIGEgam9pbnRcblxuICAgIGlmIChwb2ludEVxdWFsKHAwLCBwMSkpIHJldHVybiBwMDsgLy8gUm91bmRcblxuICAgIGlmIChsaW5lSm9pbiA9PT0gMikge1xuICAgICAgdmFyIGFuZ2xlT3V0ID0gLXNlZzEudGFuZ2VudEFuZ2xlKDEpO1xuICAgICAgdmFyIGFuZ2xlSW4gPSAtc2VnMi50YW5nZW50QW5nbGUoMCkgKyBNYXRoLlBJO1xuICAgICAgdmFyIGNlbnRlciA9IGxpbmVJbnRlcnNlY3Rpb24ocDAsIHBvbGFyT2Zmc2V0KHAwLCBhbmdsZU91dCArIE1hdGguUEkgLyAyLCAxMDApLCBwMSwgcG9sYXJPZmZzZXQocDEsIGFuZ2xlT3V0ICsgTWF0aC5QSSAvIDIsIDEwMCkpO1xuICAgICAgdmFyIHJhZGl1cyA9IGNlbnRlciA/IHBvaW50RGlzdGFuY2UoY2VudGVyLCBwMCkgOiBwb2ludERpc3RhbmNlKHAwLCBwMSkgLyAyO1xuICAgICAgdmFyIHRhbiA9IHBvbGFyT2Zmc2V0KHAwLCBhbmdsZU91dCwgMiAqIHJhZGl1cyAqIHJvdW5kQ29ybmVyKTtcbiAgICAgIG91dHB1dEJlemllci5zZXRYWUF0KHRhblswXSwgdGFuWzFdLCAnbycsIG91dHB1dEJlemllci5sZW5ndGgoKSAtIDEpO1xuICAgICAgdGFuID0gcG9sYXJPZmZzZXQocDEsIGFuZ2xlSW4sIDIgKiByYWRpdXMgKiByb3VuZENvcm5lcik7XG4gICAgICBvdXRwdXRCZXppZXIuc2V0VHJpcGxlQXQocDFbMF0sIHAxWzFdLCBwMVswXSwgcDFbMV0sIHRhblswXSwgdGFuWzFdLCBvdXRwdXRCZXppZXIubGVuZ3RoKCkpO1xuICAgICAgcmV0dXJuIHAxO1xuICAgIH0gLy8gTWl0ZXJcblxuXG4gICAgdmFyIHQwID0gcG9pbnRFcXVhbChwMCwgc2VnMS5wb2ludHNbMl0pID8gc2VnMS5wb2ludHNbMF0gOiBzZWcxLnBvaW50c1syXTtcbiAgICB2YXIgdDEgPSBwb2ludEVxdWFsKHAxLCBzZWcyLnBvaW50c1sxXSkgPyBzZWcyLnBvaW50c1szXSA6IHNlZzIucG9pbnRzWzFdO1xuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBsaW5lSW50ZXJzZWN0aW9uKHQwLCBwMCwgcDEsIHQxKTtcblxuICAgIGlmIChpbnRlcnNlY3Rpb24gJiYgcG9pbnREaXN0YW5jZShpbnRlcnNlY3Rpb24sIHAwKSA8IG1pdGVyTGltaXQpIHtcbiAgICAgIG91dHB1dEJlemllci5zZXRUcmlwbGVBdChpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXSwgaW50ZXJzZWN0aW9uWzBdLCBpbnRlcnNlY3Rpb25bMV0sIGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdLCBvdXRwdXRCZXppZXIubGVuZ3RoKCkpO1xuICAgICAgcmV0dXJuIGludGVyc2VjdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gcDA7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb24oYSwgYikge1xuICAgIHZhciBpbnRlcnNlY3QgPSBhLmludGVyc2VjdGlvbnMoYik7XG4gICAgaWYgKGludGVyc2VjdC5sZW5ndGggJiYgZmxvYXRFcXVhbChpbnRlcnNlY3RbMF1bMF0sIDEpKSBpbnRlcnNlY3Quc2hpZnQoKTtcbiAgICBpZiAoaW50ZXJzZWN0Lmxlbmd0aCkgcmV0dXJuIGludGVyc2VjdFswXTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBydW5lU2VnbWVudEludGVyc2VjdGlvbihhLCBiKSB7XG4gICAgdmFyIG91dGEgPSBhLnNsaWNlKCk7XG4gICAgdmFyIG91dGIgPSBiLnNsaWNlKCk7XG4gICAgdmFyIGludGVyc2VjdCA9IGdldEludGVyc2VjdGlvbihhW2EubGVuZ3RoIC0gMV0sIGJbMF0pO1xuXG4gICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgb3V0YVthLmxlbmd0aCAtIDFdID0gYVthLmxlbmd0aCAtIDFdLnNwbGl0KGludGVyc2VjdFswXSlbMF07XG4gICAgICBvdXRiWzBdID0gYlswXS5zcGxpdChpbnRlcnNlY3RbMV0pWzFdO1xuICAgIH1cblxuICAgIGlmIChhLmxlbmd0aCA+IDEgJiYgYi5sZW5ndGggPiAxKSB7XG4gICAgICBpbnRlcnNlY3QgPSBnZXRJbnRlcnNlY3Rpb24oYVswXSwgYltiLmxlbmd0aCAtIDFdKTtcblxuICAgICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgICByZXR1cm4gW1thWzBdLnNwbGl0KGludGVyc2VjdFswXSlbMF1dLCBbYltiLmxlbmd0aCAtIDFdLnNwbGl0KGludGVyc2VjdFsxXSlbMV1dXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW291dGEsIG91dGJdO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJ1bmVJbnRlcnNlY3Rpb25zKHNlZ21lbnRzKSB7XG4gICAgdmFyIGU7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBlID0gcHJ1bmVTZWdtZW50SW50ZXJzZWN0aW9uKHNlZ21lbnRzW2kgLSAxXSwgc2VnbWVudHNbaV0pO1xuICAgICAgc2VnbWVudHNbaSAtIDFdID0gZVswXTtcbiAgICAgIHNlZ21lbnRzW2ldID0gZVsxXTtcbiAgICB9XG5cbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgZSA9IHBydW5lU2VnbWVudEludGVyc2VjdGlvbihzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSwgc2VnbWVudHNbMF0pO1xuICAgICAgc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0gPSBlWzBdO1xuICAgICAgc2VnbWVudHNbMF0gPSBlWzFdO1xuICAgIH1cblxuICAgIHJldHVybiBzZWdtZW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIG9mZnNldFNlZ21lbnRTcGxpdChzZWdtZW50LCBhbW91bnQpIHtcbiAgICAvKlxyXG4gICAgICBXZSBzcGxpdCBlYWNoIGJlemllciBzZWdtZW50IGludG8gc21hbGxlciBwaWVjZXMgYmFzZWRcclxuICAgICAgb24gaW5mbGVjdGlvbiBwb2ludHMsIHRoaXMgZW5zdXJlcyB0aGUgY29udHJvbCBwb2ludFxyXG4gICAgICBwb2x5Z29uIGlzIGNvbnZleC5cclxuICAgICAgICAoQSBjdWJpYyBiZXppZXIgY2FuIGhhdmUgbm9uZSwgb25lLCBvciB0d28gaW5mbGVjdGlvbiBwb2ludHMpXHJcbiAgICAqL1xuICAgIHZhciBmbGV4ID0gc2VnbWVudC5pbmZsZWN0aW9uUG9pbnRzKCk7XG4gICAgdmFyIGxlZnQ7XG4gICAgdmFyIHJpZ2h0O1xuICAgIHZhciBzcGxpdDtcbiAgICB2YXIgbWlkO1xuXG4gICAgaWYgKGZsZXgubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW29mZnNldFNlZ21lbnQoc2VnbWVudCwgYW1vdW50KV07XG4gICAgfVxuXG4gICAgaWYgKGZsZXgubGVuZ3RoID09PSAxIHx8IGZsb2F0RXF1YWwoZmxleFsxXSwgMSkpIHtcbiAgICAgIHNwbGl0ID0gc2VnbWVudC5zcGxpdChmbGV4WzBdKTtcbiAgICAgIGxlZnQgPSBzcGxpdFswXTtcbiAgICAgIHJpZ2h0ID0gc3BsaXRbMV07XG4gICAgICByZXR1cm4gW29mZnNldFNlZ21lbnQobGVmdCwgYW1vdW50KSwgb2Zmc2V0U2VnbWVudChyaWdodCwgYW1vdW50KV07XG4gICAgfVxuXG4gICAgc3BsaXQgPSBzZWdtZW50LnNwbGl0KGZsZXhbMF0pO1xuICAgIGxlZnQgPSBzcGxpdFswXTtcbiAgICB2YXIgdCA9IChmbGV4WzFdIC0gZmxleFswXSkgLyAoMSAtIGZsZXhbMF0pO1xuICAgIHNwbGl0ID0gc3BsaXRbMV0uc3BsaXQodCk7XG4gICAgbWlkID0gc3BsaXRbMF07XG4gICAgcmlnaHQgPSBzcGxpdFsxXTtcbiAgICByZXR1cm4gW29mZnNldFNlZ21lbnQobGVmdCwgYW1vdW50KSwgb2Zmc2V0U2VnbWVudChtaWQsIGFtb3VudCksIG9mZnNldFNlZ21lbnQocmlnaHQsIGFtb3VudCldO1xuICB9XG5cbiAgZnVuY3Rpb24gT2Zmc2V0UGF0aE1vZGlmaWVyKCkge31cblxuICBleHRlbmRQcm90b3R5cGUoW1NoYXBlTW9kaWZpZXJdLCBPZmZzZXRQYXRoTW9kaWZpZXIpO1xuXG4gIE9mZnNldFBhdGhNb2RpZmllci5wcm90b3R5cGUuaW5pdE1vZGlmaWVyUHJvcGVydGllcyA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhKSB7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMucHJvY2Vzc0tleXM7XG4gICAgdGhpcy5hbW91bnQgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmEsIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMubWl0ZXJMaW1pdCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubWwsIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMubGluZUpvaW4gPSBkYXRhLmxqO1xuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSB0aGlzLmFtb3VudC5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoICE9PSAwO1xuICB9O1xuXG4gIE9mZnNldFBhdGhNb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1BhdGggPSBmdW5jdGlvbiAoaW5wdXRCZXppZXIsIGFtb3VudCwgbGluZUpvaW4sIG1pdGVyTGltaXQpIHtcbiAgICB2YXIgb3V0cHV0QmV6aWVyID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICBvdXRwdXRCZXppZXIuYyA9IGlucHV0QmV6aWVyLmM7XG4gICAgdmFyIGNvdW50ID0gaW5wdXRCZXppZXIubGVuZ3RoKCk7XG5cbiAgICBpZiAoIWlucHV0QmV6aWVyLmMpIHtcbiAgICAgIGNvdW50IC09IDE7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGo7XG4gICAgdmFyIHNlZ21lbnQ7XG4gICAgdmFyIG11bHRpU2VnbWVudHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBzZWdtZW50ID0gUG9seW5vbWlhbEJlemllci5zaGFwZVNlZ21lbnQoaW5wdXRCZXppZXIsIGkpO1xuICAgICAgbXVsdGlTZWdtZW50cy5wdXNoKG9mZnNldFNlZ21lbnRTcGxpdChzZWdtZW50LCBhbW91bnQpKTtcbiAgICB9XG5cbiAgICBpZiAoIWlucHV0QmV6aWVyLmMpIHtcbiAgICAgIGZvciAoaSA9IGNvdW50IC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgc2VnbWVudCA9IFBvbHlub21pYWxCZXppZXIuc2hhcGVTZWdtZW50SW52ZXJ0ZWQoaW5wdXRCZXppZXIsIGkpO1xuICAgICAgICBtdWx0aVNlZ21lbnRzLnB1c2gob2Zmc2V0U2VnbWVudFNwbGl0KHNlZ21lbnQsIGFtb3VudCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG11bHRpU2VnbWVudHMgPSBwcnVuZUludGVyc2VjdGlvbnMobXVsdGlTZWdtZW50cyk7IC8vIEFkZCBiZXppZXIgc2VnbWVudHMgdG8gdGhlIG91dHB1dCBhbmQgYXBwbHkgbGluZSBqb2ludHNcblxuICAgIHZhciBsYXN0UG9pbnQgPSBudWxsO1xuICAgIHZhciBsYXN0U2VnID0gbnVsbDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBtdWx0aVNlZ21lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgbXVsdGlTZWdtZW50ID0gbXVsdGlTZWdtZW50c1tpXTtcbiAgICAgIGlmIChsYXN0U2VnKSBsYXN0UG9pbnQgPSBqb2luTGluZXMob3V0cHV0QmV6aWVyLCBsYXN0U2VnLCBtdWx0aVNlZ21lbnRbMF0sIGxpbmVKb2luLCBtaXRlckxpbWl0KTtcbiAgICAgIGxhc3RTZWcgPSBtdWx0aVNlZ21lbnRbbXVsdGlTZWdtZW50Lmxlbmd0aCAtIDFdO1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgbXVsdGlTZWdtZW50Lmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIHNlZ21lbnQgPSBtdWx0aVNlZ21lbnRbal07XG5cbiAgICAgICAgaWYgKGxhc3RQb2ludCAmJiBwb2ludEVxdWFsKHNlZ21lbnQucG9pbnRzWzBdLCBsYXN0UG9pbnQpKSB7XG4gICAgICAgICAgb3V0cHV0QmV6aWVyLnNldFhZQXQoc2VnbWVudC5wb2ludHNbMV1bMF0sIHNlZ21lbnQucG9pbnRzWzFdWzFdLCAnbycsIG91dHB1dEJlemllci5sZW5ndGgoKSAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dEJlemllci5zZXRUcmlwbGVBdChzZWdtZW50LnBvaW50c1swXVswXSwgc2VnbWVudC5wb2ludHNbMF1bMV0sIHNlZ21lbnQucG9pbnRzWzFdWzBdLCBzZWdtZW50LnBvaW50c1sxXVsxXSwgc2VnbWVudC5wb2ludHNbMF1bMF0sIHNlZ21lbnQucG9pbnRzWzBdWzFdLCBvdXRwdXRCZXppZXIubGVuZ3RoKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0QmV6aWVyLnNldFRyaXBsZUF0KHNlZ21lbnQucG9pbnRzWzNdWzBdLCBzZWdtZW50LnBvaW50c1szXVsxXSwgc2VnbWVudC5wb2ludHNbM11bMF0sIHNlZ21lbnQucG9pbnRzWzNdWzFdLCBzZWdtZW50LnBvaW50c1syXVswXSwgc2VnbWVudC5wb2ludHNbMl1bMV0sIG91dHB1dEJlemllci5sZW5ndGgoKSk7XG4gICAgICAgIGxhc3RQb2ludCA9IHNlZ21lbnQucG9pbnRzWzNdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtdWx0aVNlZ21lbnRzLmxlbmd0aCkgam9pbkxpbmVzKG91dHB1dEJlemllciwgbGFzdFNlZywgbXVsdGlTZWdtZW50c1swXVswXSwgbGluZUpvaW4sIG1pdGVyTGltaXQpO1xuICAgIHJldHVybiBvdXRwdXRCZXppZXI7XG4gIH07XG5cbiAgT2Zmc2V0UGF0aE1vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzU2hhcGVzID0gZnVuY3Rpb24gKF9pc0ZpcnN0RnJhbWUpIHtcbiAgICB2YXIgc2hhcGVQYXRocztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5zaGFwZXMubGVuZ3RoO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBhbW91bnQgPSB0aGlzLmFtb3VudC52O1xuICAgIHZhciBtaXRlckxpbWl0ID0gdGhpcy5taXRlckxpbWl0LnY7XG4gICAgdmFyIGxpbmVKb2luID0gdGhpcy5saW5lSm9pbjtcblxuICAgIGlmIChhbW91bnQgIT09IDApIHtcbiAgICAgIHZhciBzaGFwZURhdGE7XG4gICAgICB2YXIgbG9jYWxTaGFwZUNvbGxlY3Rpb247XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBzaGFwZURhdGEgPSB0aGlzLnNoYXBlc1tpXTtcbiAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZURhdGEubG9jYWxTaGFwZUNvbGxlY3Rpb247XG5cbiAgICAgICAgaWYgKCEoIXNoYXBlRGF0YS5zaGFwZS5fbWRmICYmICF0aGlzLl9tZGYgJiYgIV9pc0ZpcnN0RnJhbWUpKSB7XG4gICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xuICAgICAgICAgIHNoYXBlRGF0YS5zaGFwZS5fbWRmID0gdHJ1ZTtcbiAgICAgICAgICBzaGFwZVBhdGhzID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLnNoYXBlcztcbiAgICAgICAgICBqTGVuID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLl9sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnByb2Nlc3NQYXRoKHNoYXBlUGF0aHNbal0sIGFtb3VudCwgbGluZUpvaW4sIG1pdGVyTGltaXQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzaGFwZURhdGEuc2hhcGUucGF0aHMgPSBzaGFwZURhdGEubG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldEZvbnRQcm9wZXJ0aWVzKGZvbnREYXRhKSB7XG4gICAgdmFyIHN0eWxlcyA9IGZvbnREYXRhLmZTdHlsZSA/IGZvbnREYXRhLmZTdHlsZS5zcGxpdCgnICcpIDogW107XG4gICAgdmFyIGZXZWlnaHQgPSAnbm9ybWFsJztcbiAgICB2YXIgZlN0eWxlID0gJ25vcm1hbCc7XG4gICAgdmFyIGxlbiA9IHN0eWxlcy5sZW5ndGg7XG4gICAgdmFyIHN0eWxlTmFtZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHN0eWxlTmFtZSA9IHN0eWxlc1tpXS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBzd2l0Y2ggKHN0eWxlTmFtZSkge1xuICAgICAgICBjYXNlICdpdGFsaWMnOlxuICAgICAgICAgIGZTdHlsZSA9ICdpdGFsaWMnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2JvbGQnOlxuICAgICAgICAgIGZXZWlnaHQgPSAnNzAwJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdibGFjayc6XG4gICAgICAgICAgZldlaWdodCA9ICc5MDAnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ21lZGl1bSc6XG4gICAgICAgICAgZldlaWdodCA9ICc1MDAnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JlZ3VsYXInOlxuICAgICAgICBjYXNlICdub3JtYWwnOlxuICAgICAgICAgIGZXZWlnaHQgPSAnNDAwJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdsaWdodCc6XG4gICAgICAgIGNhc2UgJ3RoaW4nOlxuICAgICAgICAgIGZXZWlnaHQgPSAnMjAwJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdHlsZTogZlN0eWxlLFxuICAgICAgd2VpZ2h0OiBmb250RGF0YS5mV2VpZ2h0IHx8IGZXZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgdmFyIEZvbnRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtYXhXYWl0aW5nVGltZSA9IDUwMDA7XG4gICAgdmFyIGVtcHR5Q2hhciA9IHtcbiAgICAgIHc6IDAsXG4gICAgICBzaXplOiAwLFxuICAgICAgc2hhcGVzOiBbXSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc2hhcGVzOiBbXVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGNvbWJpbmVkQ2hhcmFjdGVycyA9IFtdOyAvLyBIaW5kaSBjaGFyYWN0ZXJzXG5cbiAgICBjb21iaW5lZENoYXJhY3RlcnMgPSBjb21iaW5lZENoYXJhY3RlcnMuY29uY2F0KFsyMzA0LCAyMzA1LCAyMzA2LCAyMzA3LCAyMzYyLCAyMzYzLCAyMzY0LCAyMzY0LCAyMzY2LCAyMzY3LCAyMzY4LCAyMzY5LCAyMzcwLCAyMzcxLCAyMzcyLCAyMzczLCAyMzc0LCAyMzc1LCAyMzc2LCAyMzc3LCAyMzc4LCAyMzc5LCAyMzgwLCAyMzgxLCAyMzgyLCAyMzgzLCAyMzg3LCAyMzg4LCAyMzg5LCAyMzkwLCAyMzkxLCAyNDAyLCAyNDAzXSk7XG4gICAgdmFyIEJMQUNLX0ZMQUdfQ09ERV9QT0lOVCA9IDEyNzk4ODtcbiAgICB2YXIgQ0FOQ0VMX1RBR19DT0RFX1BPSU5UID0gOTE3NjMxO1xuICAgIHZhciBBX1RBR19DT0RFX1BPSU5UID0gOTE3NjAxO1xuICAgIHZhciBaX1RBR19DT0RFX1BPSU5UID0gOTE3NjI2O1xuICAgIHZhciBWQVJJQVRJT05fU0VMRUNUT1JfMTZfQ09ERV9QT0lOVCA9IDY1MDM5O1xuICAgIHZhciBaRVJPX1dJRFRIX0pPSU5FUl9DT0RFX1BPSU5UID0gODIwNTtcbiAgICB2YXIgUkVHSU9OQUxfQ0hBUkFDVEVSX0FfQ09ERV9QT0lOVCA9IDEyNzQ2MjtcbiAgICB2YXIgUkVHSU9OQUxfQ0hBUkFDVEVSX1pfQ09ERV9QT0lOVCA9IDEyNzQ4NztcbiAgICB2YXIgc3Vycm9nYXRlTW9kaWZpZXJzID0gWydkODNjZGZmYicsICdkODNjZGZmYycsICdkODNjZGZmZCcsICdkODNjZGZmZScsICdkODNjZGZmZiddO1xuXG4gICAgZnVuY3Rpb24gdHJpbUZvbnRPcHRpb25zKGZvbnQpIHtcbiAgICAgIHZhciBmYW1pbHlBcnJheSA9IGZvbnQuc3BsaXQoJywnKTtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IGZhbWlseUFycmF5Lmxlbmd0aDtcbiAgICAgIHZhciBlbmFibGVkRmFtaWxpZXMgPSBbXTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmIChmYW1pbHlBcnJheVtpXSAhPT0gJ3NhbnMtc2VyaWYnICYmIGZhbWlseUFycmF5W2ldICE9PSAnbW9ub3NwYWNlJykge1xuICAgICAgICAgIGVuYWJsZWRGYW1pbGllcy5wdXNoKGZhbWlseUFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW5hYmxlZEZhbWlsaWVzLmpvaW4oJywnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRVcE5vZGUoZm9udCwgZmFtaWx5KSB7XG4gICAgICB2YXIgcGFyZW50Tm9kZSA9IGNyZWF0ZVRhZygnc3BhbicpOyAvLyBOb2RlIGlzIGludmlzaWJsZSB0byBzY3JlZW4gcmVhZGVycy5cblxuICAgICAgcGFyZW50Tm9kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG4gICAgICBwYXJlbnROb2RlLnN0eWxlLmZvbnRGYW1pbHkgPSBmYW1pbHk7XG4gICAgICB2YXIgbm9kZSA9IGNyZWF0ZVRhZygnc3BhbicpOyAvLyBDaGFyYWN0ZXJzIHRoYXQgdmFyeSBzaWduaWZpY2FudGx5IGFtb25nIGRpZmZlcmVudCBmb250c1xuXG4gICAgICBub2RlLmlubmVyVGV4dCA9ICdnaUl0VDFXUXlAIS0vIyc7IC8vIFZpc2libGUgLSBzbyB3ZSBjYW4gbWVhc3VyZSBpdCAtIGJ1dCBub3Qgb24gdGhlIHNjcmVlblxuXG4gICAgICBwYXJlbnROb2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIHBhcmVudE5vZGUuc3R5bGUubGVmdCA9ICctMTAwMDBweCc7XG4gICAgICBwYXJlbnROb2RlLnN0eWxlLnRvcCA9ICctMTAwMDBweCc7IC8vIExhcmdlIGZvbnQgc2l6ZSBtYWtlcyBldmVuIHN1YnRsZSBjaGFuZ2VzIG9idmlvdXNcblxuICAgICAgcGFyZW50Tm9kZS5zdHlsZS5mb250U2l6ZSA9ICczMDBweCc7IC8vIFJlc2V0IGFueSBmb250IHByb3BlcnRpZXNcblxuICAgICAgcGFyZW50Tm9kZS5zdHlsZS5mb250VmFyaWFudCA9ICdub3JtYWwnO1xuICAgICAgcGFyZW50Tm9kZS5zdHlsZS5mb250U3R5bGUgPSAnbm9ybWFsJztcbiAgICAgIHBhcmVudE5vZGUuc3R5bGUuZm9udFdlaWdodCA9ICdub3JtYWwnO1xuICAgICAgcGFyZW50Tm9kZS5zdHlsZS5sZXR0ZXJTcGFjaW5nID0gJzAnO1xuICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocGFyZW50Tm9kZSk7IC8vIFJlbWVtYmVyIHdpZHRoIHdpdGggbm8gYXBwbGllZCB3ZWIgZm9udFxuXG4gICAgICB2YXIgd2lkdGggPSBub2RlLm9mZnNldFdpZHRoO1xuICAgICAgbm9kZS5zdHlsZS5mb250RmFtaWx5ID0gdHJpbUZvbnRPcHRpb25zKGZvbnQpICsgJywgJyArIGZhbWlseTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIHc6IHdpZHRoLFxuICAgICAgICBwYXJlbnQ6IHBhcmVudE5vZGVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tMb2FkZWRGb250cygpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZm9udHMubGVuZ3RoO1xuICAgICAgdmFyIG5vZGU7XG4gICAgICB2YXIgdztcbiAgICAgIHZhciBsb2FkZWRDb3VudCA9IGxlbjtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLmZvbnRzW2ldLmxvYWRlZCkge1xuICAgICAgICAgIGxvYWRlZENvdW50IC09IDE7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5mb250c1tpXS5mT3JpZ2luID09PSAnbicgfHwgdGhpcy5mb250c1tpXS5vcmlnaW4gPT09IDApIHtcbiAgICAgICAgICB0aGlzLmZvbnRzW2ldLmxvYWRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuZm9udHNbaV0ubW9ub0Nhc2Uubm9kZTtcbiAgICAgICAgICB3ID0gdGhpcy5mb250c1tpXS5tb25vQ2FzZS53O1xuXG4gICAgICAgICAgaWYgKG5vZGUub2Zmc2V0V2lkdGggIT09IHcpIHtcbiAgICAgICAgICAgIGxvYWRlZENvdW50IC09IDE7XG4gICAgICAgICAgICB0aGlzLmZvbnRzW2ldLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLmZvbnRzW2ldLnNhbnNDYXNlLm5vZGU7XG4gICAgICAgICAgICB3ID0gdGhpcy5mb250c1tpXS5zYW5zQ2FzZS53O1xuXG4gICAgICAgICAgICBpZiAobm9kZS5vZmZzZXRXaWR0aCAhPT0gdykge1xuICAgICAgICAgICAgICBsb2FkZWRDb3VudCAtPSAxO1xuICAgICAgICAgICAgICB0aGlzLmZvbnRzW2ldLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuZm9udHNbaV0ubG9hZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmZvbnRzW2ldLnNhbnNDYXNlLnBhcmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9udHNbaV0uc2Fuc0Nhc2UucGFyZW50KTtcbiAgICAgICAgICAgIHRoaXMuZm9udHNbaV0ubW9ub0Nhc2UucGFyZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb250c1tpXS5tb25vQ2FzZS5wYXJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobG9hZGVkQ291bnQgIT09IDAgJiYgRGF0ZS5ub3coKSAtIHRoaXMuaW5pdFRpbWUgPCBtYXhXYWl0aW5nVGltZSkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY2hlY2tMb2FkZWRGb250c0JpbmRlZCwgMjApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnNldElzTG9hZGVkQmluZGVkLCAxMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSGVscGVyKGZvbnREYXRhLCBkZWYpIHtcbiAgICAgIHZhciBlbmdpbmUgPSBkb2N1bWVudC5ib2R5ICYmIGRlZiA/ICdzdmcnIDogJ2NhbnZhcyc7XG4gICAgICB2YXIgaGVscGVyO1xuICAgICAgdmFyIGZvbnRQcm9wcyA9IGdldEZvbnRQcm9wZXJ0aWVzKGZvbnREYXRhKTtcblxuICAgICAgaWYgKGVuZ2luZSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgdmFyIHRIZWxwZXIgPSBjcmVhdGVOUygndGV4dCcpO1xuICAgICAgICB0SGVscGVyLnN0eWxlLmZvbnRTaXplID0gJzEwMHB4JzsgLy8gdEhlbHBlci5zdHlsZS5mb250RmFtaWx5ID0gZm9udERhdGEuZkZhbWlseTtcblxuICAgICAgICB0SGVscGVyLnNldEF0dHJpYnV0ZSgnZm9udC1mYW1pbHknLCBmb250RGF0YS5mRmFtaWx5KTtcbiAgICAgICAgdEhlbHBlci5zZXRBdHRyaWJ1dGUoJ2ZvbnQtc3R5bGUnLCBmb250UHJvcHMuc3R5bGUpO1xuICAgICAgICB0SGVscGVyLnNldEF0dHJpYnV0ZSgnZm9udC13ZWlnaHQnLCBmb250UHJvcHMud2VpZ2h0KTtcbiAgICAgICAgdEhlbHBlci50ZXh0Q29udGVudCA9ICcxJztcblxuICAgICAgICBpZiAoZm9udERhdGEuZkNsYXNzKSB7XG4gICAgICAgICAgdEhlbHBlci5zdHlsZS5mb250RmFtaWx5ID0gJ2luaGVyaXQnO1xuICAgICAgICAgIHRIZWxwZXIuc2V0QXR0cmlidXRlKCdjbGFzcycsIGZvbnREYXRhLmZDbGFzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdEhlbHBlci5zdHlsZS5mb250RmFtaWx5ID0gZm9udERhdGEuZkZhbWlseTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZi5hcHBlbmRDaGlsZCh0SGVscGVyKTtcbiAgICAgICAgaGVscGVyID0gdEhlbHBlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0Q2FudmFzSGVscGVyID0gbmV3IE9mZnNjcmVlbkNhbnZhcyg1MDAsIDUwMCkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdENhbnZhc0hlbHBlci5mb250ID0gZm9udFByb3BzLnN0eWxlICsgJyAnICsgZm9udFByb3BzLndlaWdodCArICcgMTAwcHggJyArIGZvbnREYXRhLmZGYW1pbHk7XG4gICAgICAgIGhlbHBlciA9IHRDYW52YXNIZWxwZXI7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG1lYXN1cmUodGV4dCkge1xuICAgICAgICBpZiAoZW5naW5lID09PSAnc3ZnJykge1xuICAgICAgICAgIGhlbHBlci50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgICAgcmV0dXJuIGhlbHBlci5nZXRDb21wdXRlZFRleHRMZW5ndGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZWxwZXIubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1lYXN1cmVUZXh0OiBtZWFzdXJlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEZvbnRzKGZvbnREYXRhLCBkZWZzKSB7XG4gICAgICBpZiAoIWZvbnREYXRhKSB7XG4gICAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNoYXJzKSB7XG4gICAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmZvbnRzID0gZm9udERhdGEubGlzdDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XG4gICAgICAgIGZvbnREYXRhLmxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIGRhdGEuaGVscGVyID0gY3JlYXRlSGVscGVyKGRhdGEpO1xuICAgICAgICAgIGRhdGEuY2FjaGUgPSB7fTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZm9udHMgPSBmb250RGF0YS5saXN0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBmb250QXJyID0gZm9udERhdGEubGlzdDtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IGZvbnRBcnIubGVuZ3RoO1xuICAgICAgdmFyIF9wZW5kaW5nRm9udHMgPSBsZW47XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB2YXIgc2hvdWxkTG9hZEZvbnQgPSB0cnVlO1xuICAgICAgICB2YXIgbG9hZGVkU2VsZWN0b3I7XG4gICAgICAgIHZhciBqO1xuICAgICAgICBmb250QXJyW2ldLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICBmb250QXJyW2ldLm1vbm9DYXNlID0gc2V0VXBOb2RlKGZvbnRBcnJbaV0uZkZhbWlseSwgJ21vbm9zcGFjZScpO1xuICAgICAgICBmb250QXJyW2ldLnNhbnNDYXNlID0gc2V0VXBOb2RlKGZvbnRBcnJbaV0uZkZhbWlseSwgJ3NhbnMtc2VyaWYnKTtcblxuICAgICAgICBpZiAoIWZvbnRBcnJbaV0uZlBhdGgpIHtcbiAgICAgICAgICBmb250QXJyW2ldLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgX3BlbmRpbmdGb250cyAtPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGZvbnRBcnJbaV0uZk9yaWdpbiA9PT0gJ3AnIHx8IGZvbnRBcnJbaV0ub3JpZ2luID09PSAzKSB7XG4gICAgICAgICAgbG9hZGVkU2VsZWN0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZVtmLWZvcmlnaW49XCJwXCJdW2YtZmFtaWx5PVwiJyArIGZvbnRBcnJbaV0uZkZhbWlseSArICdcIl0sIHN0eWxlW2Ytb3JpZ2luPVwiM1wiXVtmLWZhbWlseT1cIicgKyBmb250QXJyW2ldLmZGYW1pbHkgKyAnXCJdJyk7XG5cbiAgICAgICAgICBpZiAobG9hZGVkU2VsZWN0b3IubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2hvdWxkTG9hZEZvbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2hvdWxkTG9hZEZvbnQpIHtcbiAgICAgICAgICAgIHZhciBzID0gY3JlYXRlVGFnKCdzdHlsZScpO1xuICAgICAgICAgICAgcy5zZXRBdHRyaWJ1dGUoJ2YtZm9yaWdpbicsIGZvbnRBcnJbaV0uZk9yaWdpbik7XG4gICAgICAgICAgICBzLnNldEF0dHJpYnV0ZSgnZi1vcmlnaW4nLCBmb250QXJyW2ldLm9yaWdpbik7XG4gICAgICAgICAgICBzLnNldEF0dHJpYnV0ZSgnZi1mYW1pbHknLCBmb250QXJyW2ldLmZGYW1pbHkpO1xuICAgICAgICAgICAgcy50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgICAgICAgIHMuaW5uZXJUZXh0ID0gJ0Bmb250LWZhY2Uge2ZvbnQtZmFtaWx5OiAnICsgZm9udEFycltpXS5mRmFtaWx5ICsgXCI7IGZvbnQtc3R5bGU6IG5vcm1hbDsgc3JjOiB1cmwoJ1wiICsgZm9udEFycltpXS5mUGF0aCArIFwiJyk7fVwiO1xuICAgICAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZm9udEFycltpXS5mT3JpZ2luID09PSAnZycgfHwgZm9udEFycltpXS5vcmlnaW4gPT09IDEpIHtcbiAgICAgICAgICBsb2FkZWRTZWxlY3RvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmtbZi1mb3JpZ2luPVwiZ1wiXSwgbGlua1tmLW9yaWdpbj1cIjFcIl0nKTtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsb2FkZWRTZWxlY3Rvci5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgaWYgKGxvYWRlZFNlbGVjdG9yW2pdLmhyZWYuaW5kZXhPZihmb250QXJyW2ldLmZQYXRoKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgLy8gRm9udCBpcyBhbHJlYWR5IGxvYWRlZFxuICAgICAgICAgICAgICBzaG91bGRMb2FkRm9udCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzaG91bGRMb2FkRm9udCkge1xuICAgICAgICAgICAgdmFyIGwgPSBjcmVhdGVUYWcoJ2xpbmsnKTtcbiAgICAgICAgICAgIGwuc2V0QXR0cmlidXRlKCdmLWZvcmlnaW4nLCBmb250QXJyW2ldLmZPcmlnaW4pO1xuICAgICAgICAgICAgbC5zZXRBdHRyaWJ1dGUoJ2Ytb3JpZ2luJywgZm9udEFycltpXS5vcmlnaW4pO1xuICAgICAgICAgICAgbC50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgICAgICAgIGwucmVsID0gJ3N0eWxlc2hlZXQnO1xuICAgICAgICAgICAgbC5ocmVmID0gZm9udEFycltpXS5mUGF0aDtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZvbnRBcnJbaV0uZk9yaWdpbiA9PT0gJ3QnIHx8IGZvbnRBcnJbaV0ub3JpZ2luID09PSAyKSB7XG4gICAgICAgICAgbG9hZGVkU2VsZWN0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHRbZi1mb3JpZ2luPVwidFwiXSwgc2NyaXB0W2Ytb3JpZ2luPVwiMlwiXScpO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxvYWRlZFNlbGVjdG9yLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBpZiAoZm9udEFycltpXS5mUGF0aCA9PT0gbG9hZGVkU2VsZWN0b3Jbal0uc3JjKSB7XG4gICAgICAgICAgICAgIC8vIEZvbnQgaXMgYWxyZWFkeSBsb2FkZWRcbiAgICAgICAgICAgICAgc2hvdWxkTG9hZEZvbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2hvdWxkTG9hZEZvbnQpIHtcbiAgICAgICAgICAgIHZhciBzYyA9IGNyZWF0ZVRhZygnbGluaycpO1xuICAgICAgICAgICAgc2Muc2V0QXR0cmlidXRlKCdmLWZvcmlnaW4nLCBmb250QXJyW2ldLmZPcmlnaW4pO1xuICAgICAgICAgICAgc2Muc2V0QXR0cmlidXRlKCdmLW9yaWdpbicsIGZvbnRBcnJbaV0ub3JpZ2luKTtcbiAgICAgICAgICAgIHNjLnNldEF0dHJpYnV0ZSgncmVsJywgJ3N0eWxlc2hlZXQnKTtcbiAgICAgICAgICAgIHNjLnNldEF0dHJpYnV0ZSgnaHJlZicsIGZvbnRBcnJbaV0uZlBhdGgpO1xuICAgICAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChzYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9udEFycltpXS5oZWxwZXIgPSBjcmVhdGVIZWxwZXIoZm9udEFycltpXSwgZGVmcyk7XG4gICAgICAgIGZvbnRBcnJbaV0uY2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5mb250cy5wdXNoKGZvbnRBcnJbaV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3BlbmRpbmdGb250cyA9PT0gMCkge1xuICAgICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE9uIHNvbWUgY2FzZXMgZXZlbiBpZiB0aGUgZm9udCBpcyBsb2FkZWQsIGl0IHdvbid0IGxvYWQgY29ycmVjdGx5IHdoZW4gbWVhc3VyaW5nIHRleHQgb24gY2FudmFzLlxuICAgICAgICAvLyBBZGRpbmcgdGhpcyB0aW1lb3V0IHNlZW1zIHRvIGZpeCBpdFxuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY2hlY2tMb2FkZWRGb250cy5iaW5kKHRoaXMpLCAxMDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZENoYXJzKGNoYXJzKSB7XG4gICAgICBpZiAoIWNoYXJzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmNoYXJzKSB7XG4gICAgICAgIHRoaXMuY2hhcnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gY2hhcnMubGVuZ3RoO1xuICAgICAgdmFyIGo7XG4gICAgICB2YXIgakxlbiA9IHRoaXMuY2hhcnMubGVuZ3RoO1xuICAgICAgdmFyIGZvdW5kO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaiA9IDA7XG4gICAgICAgIGZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUgKGogPCBqTGVuKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY2hhcnNbal0uc3R5bGUgPT09IGNoYXJzW2ldLnN0eWxlICYmIHRoaXMuY2hhcnNbal0uZkZhbWlseSA9PT0gY2hhcnNbaV0uZkZhbWlseSAmJiB0aGlzLmNoYXJzW2pdLmNoID09PSBjaGFyc1tpXS5jaCkge1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICB0aGlzLmNoYXJzLnB1c2goY2hhcnNbaV0pO1xuICAgICAgICAgIGpMZW4gKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENoYXJEYXRhKF9jaGFyLCBzdHlsZSwgZm9udCkge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuY2hhcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAodGhpcy5jaGFyc1tpXS5jaCA9PT0gX2NoYXIgJiYgdGhpcy5jaGFyc1tpXS5zdHlsZSA9PT0gc3R5bGUgJiYgdGhpcy5jaGFyc1tpXS5mRmFtaWx5ID09PSBmb250KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2hhcnNbaV07XG4gICAgICAgIH1cblxuICAgICAgICBpICs9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmICgodHlwZW9mIF9jaGFyID09PSAnc3RyaW5nJyAmJiBfY2hhci5jaGFyQ29kZUF0KDApICE9PSAxMyB8fCAhX2NoYXIpICYmIGNvbnNvbGUgJiYgY29uc29sZS53YXJuIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgJiYgIXRoaXMuX3dhcm5lZCkge1xuICAgICAgICB0aGlzLl93YXJuZWQgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLndhcm4oJ01pc3NpbmcgY2hhcmFjdGVyIGZyb20gZXhwb3J0ZWQgY2hhcmFjdGVycyBsaXN0OiAnLCBfY2hhciwgc3R5bGUsIGZvbnQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVtcHR5Q2hhcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZWFzdXJlVGV4dChfY2hhcjIsIGZvbnROYW1lLCBzaXplKSB7XG4gICAgICB2YXIgZm9udERhdGEgPSB0aGlzLmdldEZvbnRCeU5hbWUoZm9udE5hbWUpOyAvLyBVc2luZyB0aGUgY2hhciBpbnN0ZWFkIG9mIGNoYXIuY2hhckNvZGVBdCgwKVxuICAgICAgLy8gdG8gYXZvaWQgY29sbGlzaW9ucyBiZXR3ZWVuIGVxdWFsIGNoYXJzXG5cbiAgICAgIHZhciBpbmRleCA9IF9jaGFyMjtcblxuICAgICAgaWYgKCFmb250RGF0YS5jYWNoZVtpbmRleF0pIHtcbiAgICAgICAgdmFyIHRIZWxwZXIgPSBmb250RGF0YS5oZWxwZXI7XG5cbiAgICAgICAgaWYgKF9jaGFyMiA9PT0gJyAnKSB7XG4gICAgICAgICAgdmFyIGRvdWJsZVNpemUgPSB0SGVscGVyLm1lYXN1cmVUZXh0KCd8JyArIF9jaGFyMiArICd8Jyk7XG4gICAgICAgICAgdmFyIHNpbmdsZVNpemUgPSB0SGVscGVyLm1lYXN1cmVUZXh0KCd8fCcpO1xuICAgICAgICAgIGZvbnREYXRhLmNhY2hlW2luZGV4XSA9IChkb3VibGVTaXplIC0gc2luZ2xlU2l6ZSkgLyAxMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9udERhdGEuY2FjaGVbaW5kZXhdID0gdEhlbHBlci5tZWFzdXJlVGV4dChfY2hhcjIpIC8gMTAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmb250RGF0YS5jYWNoZVtpbmRleF0gKiBzaXplO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEZvbnRCeU5hbWUobmFtZSkge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZm9udHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAodGhpcy5mb250c1tpXS5mTmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZvbnRzW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5mb250c1swXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDb2RlUG9pbnQoc3RyaW5nKSB7XG4gICAgICB2YXIgY29kZVBvaW50ID0gMDtcbiAgICAgIHZhciBmaXJzdCA9IHN0cmluZy5jaGFyQ29kZUF0KDApO1xuXG4gICAgICBpZiAoZmlyc3QgPj0gMHhEODAwICYmIGZpcnN0IDw9IDB4REJGRikge1xuICAgICAgICB2YXIgc2Vjb25kID0gc3RyaW5nLmNoYXJDb2RlQXQoMSk7XG5cbiAgICAgICAgaWYgKHNlY29uZCA+PSAweERDMDAgJiYgc2Vjb25kIDw9IDB4REZGRikge1xuICAgICAgICAgIGNvZGVQb2ludCA9IChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvZGVQb2ludDtcbiAgICB9IC8vIFNraW4gdG9uZSBtb2RpZmllcnNcblxuXG4gICAgZnVuY3Rpb24gaXNNb2RpZmllcihmaXJzdENoYXJDb2RlLCBzZWNvbmRDaGFyQ29kZSkge1xuICAgICAgdmFyIHN1bSA9IGZpcnN0Q2hhckNvZGUudG9TdHJpbmcoMTYpICsgc2Vjb25kQ2hhckNvZGUudG9TdHJpbmcoMTYpO1xuICAgICAgcmV0dXJuIHN1cnJvZ2F0ZU1vZGlmaWVycy5pbmRleE9mKHN1bSkgIT09IC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzWmVyb1dpZHRoSm9pbmVyKGNoYXJDb2RlKSB7XG4gICAgICByZXR1cm4gY2hhckNvZGUgPT09IFpFUk9fV0lEVEhfSk9JTkVSX0NPREVfUE9JTlQ7XG4gICAgfSAvLyBUaGlzIGNvZGVwb2ludCBtYXkgY2hhbmdlIHRoZSBhcHBlYXJhbmNlIG9mIHRoZSBwcmVjZWRpbmcgY2hhcmFjdGVyLlxuICAgIC8vIElmIHRoYXQgaXMgYSBzeW1ib2wsIGRpbmdiYXQgb3IgZW1vamksIFUrRkUwRiBmb3JjZXMgaXQgdG8gYmUgcmVuZGVyZWRcbiAgICAvLyBhcyBhIGNvbG9yZnVsIGltYWdlIGFzIGNvbXBhcmVkIHRvIGEgbW9ub2Nocm9tZSB0ZXh0IHZhcmlhbnQuXG5cblxuICAgIGZ1bmN0aW9uIGlzVmFyaWF0aW9uU2VsZWN0b3IoY2hhckNvZGUpIHtcbiAgICAgIHJldHVybiBjaGFyQ29kZSA9PT0gVkFSSUFUSU9OX1NFTEVDVE9SXzE2X0NPREVfUE9JTlQ7XG4gICAgfSAvLyBUaGUgcmVnaW9uYWwgaW5kaWNhdG9yIHN5bWJvbHMgYXJlIGEgc2V0IG9mIDI2IGFscGhhYmV0aWMgVW5pY29kZVxuICAgIC8vLyBjaGFyYWN0ZXJzIChB4oCTWikgaW50ZW5kZWQgdG8gYmUgdXNlZCB0byBlbmNvZGUgSVNPIDMxNjYtMSBhbHBoYS0yXG4gICAgLy8gdHdvLWxldHRlciBjb3VudHJ5IGNvZGVzIGluIGEgd2F5IHRoYXQgYWxsb3dzIG9wdGlvbmFsIHNwZWNpYWwgdHJlYXRtZW50LlxuXG5cbiAgICBmdW5jdGlvbiBpc1JlZ2lvbmFsQ29kZShzdHJpbmcpIHtcbiAgICAgIHZhciBjb2RlUG9pbnQgPSBnZXRDb2RlUG9pbnQoc3RyaW5nKTtcblxuICAgICAgaWYgKGNvZGVQb2ludCA+PSBSRUdJT05BTF9DSEFSQUNURVJfQV9DT0RFX1BPSU5UICYmIGNvZGVQb2ludCA8PSBSRUdJT05BTF9DSEFSQUNURVJfWl9DT0RFX1BPSU5UKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBTb21lIEVtb2ppIGltcGxlbWVudGF0aW9ucyByZXByZXNlbnQgY29tYmluYXRpb25zIG9mXG4gICAgLy8gdHdvIOKAnHJlZ2lvbmFsIGluZGljYXRvcuKAnSBsZXR0ZXJzIGFzIGEgc2luZ2xlIGZsYWcgc3ltYm9sLlxuXG5cbiAgICBmdW5jdGlvbiBpc0ZsYWdFbW9qaShzdHJpbmcpIHtcbiAgICAgIHJldHVybiBpc1JlZ2lvbmFsQ29kZShzdHJpbmcuc3Vic3RyKDAsIDIpKSAmJiBpc1JlZ2lvbmFsQ29kZShzdHJpbmcuc3Vic3RyKDIsIDIpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0NvbWJpbmVkQ2hhcmFjdGVyKF9jaGFyMykge1xuICAgICAgcmV0dXJuIGNvbWJpbmVkQ2hhcmFjdGVycy5pbmRleE9mKF9jaGFyMykgIT09IC0xO1xuICAgIH0gLy8gUmVnaW9uYWwgZmxhZ3Mgc3RhcnQgd2l0aCBhIEJMQUNLX0ZMQUdfQ09ERV9QT0lOVFxuICAgIC8vIGZvbG93ZWQgYnkgNSBjaGFycyBpbiB0aGUgVEFHIHJhbmdlXG4gICAgLy8gYW5kIGVuZCB3aXRoIGEgQ0FOQ0VMX1RBR19DT0RFX1BPSU5UXG5cblxuICAgIGZ1bmN0aW9uIGlzUmVnaW9uYWxGbGFnKHRleHQsIGluZGV4KSB7XG4gICAgICB2YXIgY29kZVBvaW50ID0gZ2V0Q29kZVBvaW50KHRleHQuc3Vic3RyKGluZGV4LCAyKSk7XG5cbiAgICAgIGlmIChjb2RlUG9pbnQgIT09IEJMQUNLX0ZMQUdfQ09ERV9QT0lOVCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICBpbmRleCArPSAyO1xuXG4gICAgICB3aGlsZSAoY291bnQgPCA1KSB7XG4gICAgICAgIGNvZGVQb2ludCA9IGdldENvZGVQb2ludCh0ZXh0LnN1YnN0cihpbmRleCwgMikpO1xuXG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCBBX1RBR19DT0RFX1BPSU5UIHx8IGNvZGVQb2ludCA+IFpfVEFHX0NPREVfUE9JTlQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICBpbmRleCArPSAyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0Q29kZVBvaW50KHRleHQuc3Vic3RyKGluZGV4LCAyKSkgPT09IENBTkNFTF9UQUdfQ09ERV9QT0lOVDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRJc0xvYWRlZCgpIHtcbiAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBGb250ID0gZnVuY3Rpb24gRm9udCgpIHtcbiAgICAgIHRoaXMuZm9udHMgPSBbXTtcbiAgICAgIHRoaXMuY2hhcnMgPSBudWxsO1xuICAgICAgdGhpcy50eXBla2l0TG9hZGVkID0gMDtcbiAgICAgIHRoaXMuaXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3dhcm5lZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pbml0VGltZSA9IERhdGUubm93KCk7XG4gICAgICB0aGlzLnNldElzTG9hZGVkQmluZGVkID0gdGhpcy5zZXRJc0xvYWRlZC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5jaGVja0xvYWRlZEZvbnRzQmluZGVkID0gdGhpcy5jaGVja0xvYWRlZEZvbnRzLmJpbmQodGhpcyk7XG4gICAgfTtcblxuICAgIEZvbnQuaXNNb2RpZmllciA9IGlzTW9kaWZpZXI7XG4gICAgRm9udC5pc1plcm9XaWR0aEpvaW5lciA9IGlzWmVyb1dpZHRoSm9pbmVyO1xuICAgIEZvbnQuaXNGbGFnRW1vamkgPSBpc0ZsYWdFbW9qaTtcbiAgICBGb250LmlzUmVnaW9uYWxDb2RlID0gaXNSZWdpb25hbENvZGU7XG4gICAgRm9udC5pc0NvbWJpbmVkQ2hhcmFjdGVyID0gaXNDb21iaW5lZENoYXJhY3RlcjtcbiAgICBGb250LmlzUmVnaW9uYWxGbGFnID0gaXNSZWdpb25hbEZsYWc7XG4gICAgRm9udC5pc1ZhcmlhdGlvblNlbGVjdG9yID0gaXNWYXJpYXRpb25TZWxlY3RvcjtcbiAgICBGb250LkJMQUNLX0ZMQUdfQ09ERV9QT0lOVCA9IEJMQUNLX0ZMQUdfQ09ERV9QT0lOVDtcbiAgICB2YXIgZm9udFByb3RvdHlwZSA9IHtcbiAgICAgIGFkZENoYXJzOiBhZGRDaGFycyxcbiAgICAgIGFkZEZvbnRzOiBhZGRGb250cyxcbiAgICAgIGdldENoYXJEYXRhOiBnZXRDaGFyRGF0YSxcbiAgICAgIGdldEZvbnRCeU5hbWU6IGdldEZvbnRCeU5hbWUsXG4gICAgICBtZWFzdXJlVGV4dDogbWVhc3VyZVRleHQsXG4gICAgICBjaGVja0xvYWRlZEZvbnRzOiBjaGVja0xvYWRlZEZvbnRzLFxuICAgICAgc2V0SXNMb2FkZWQ6IHNldElzTG9hZGVkXG4gICAgfTtcbiAgICBGb250LnByb3RvdHlwZSA9IGZvbnRQcm90b3R5cGU7XG4gICAgcmV0dXJuIEZvbnQ7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBTbG90TWFuYWdlcihhbmltYXRpb25EYXRhKSB7XG4gICAgdGhpcy5hbmltYXRpb25EYXRhID0gYW5pbWF0aW9uRGF0YTtcbiAgfVxuXG4gIFNsb3RNYW5hZ2VyLnByb3RvdHlwZS5nZXRQcm9wID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25EYXRhLnNsb3RzICYmIHRoaXMuYW5pbWF0aW9uRGF0YS5zbG90c1tkYXRhLnNpZF0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRhdGEsIHRoaXMuYW5pbWF0aW9uRGF0YS5zbG90c1tkYXRhLnNpZF0ucCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgZnVuY3Rpb24gc2xvdEZhY3RvcnkoYW5pbWF0aW9uRGF0YSkge1xuICAgIHJldHVybiBuZXcgU2xvdE1hbmFnZXIoYW5pbWF0aW9uRGF0YSk7XG4gIH1cblxuICBmdW5jdGlvbiBSZW5kZXJhYmxlRWxlbWVudCgpIHt9XG5cbiAgUmVuZGVyYWJsZUVsZW1lbnQucHJvdG90eXBlID0ge1xuICAgIGluaXRSZW5kZXJhYmxlOiBmdW5jdGlvbiBpbml0UmVuZGVyYWJsZSgpIHtcbiAgICAgIC8vIGxheWVyJ3MgdmlzaWJpbGl0eSByZWxhdGVkIHRvIGlucG9pbnQgYW5kIG91dHBvaW50LiBSZW5hbWUgaXNWaXNpYmxlIHRvIGlzSW5SYW5nZVxuICAgICAgdGhpcy5pc0luUmFuZ2UgPSBmYWxzZTsgLy8gbGF5ZXIncyBkaXNwbGF5IHN0YXRlXG5cbiAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7IC8vIElmIGxheWVyJ3MgdHJhbnNwYXJlbmN5IGVxdWFscyAwLCBpdCBjYW4gYmUgaGlkZGVuXG5cbiAgICAgIHRoaXMuaXNUcmFuc3BhcmVudCA9IGZhbHNlOyAvLyBsaXN0IG9mIGFuaW1hdGVkIGNvbXBvbmVudHNcblxuICAgICAgdGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cyA9IFtdO1xuICAgIH0sXG4gICAgYWRkUmVuZGVyYWJsZUNvbXBvbmVudDogZnVuY3Rpb24gYWRkUmVuZGVyYWJsZUNvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmFibGVDb21wb25lbnRzLmluZGV4T2YoY29tcG9uZW50KSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVSZW5kZXJhYmxlQ29tcG9uZW50OiBmdW5jdGlvbiByZW1vdmVSZW5kZXJhYmxlQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMuaW5kZXhPZihjb21wb25lbnQpICE9PSAtMSkge1xuICAgICAgICB0aGlzLnJlbmRlcmFibGVDb21wb25lbnRzLnNwbGljZSh0aGlzLnJlbmRlcmFibGVDb21wb25lbnRzLmluZGV4T2YoY29tcG9uZW50KSwgMSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwcmVwYXJlUmVuZGVyYWJsZUZyYW1lOiBmdW5jdGlvbiBwcmVwYXJlUmVuZGVyYWJsZUZyYW1lKG51bSkge1xuICAgICAgdGhpcy5jaGVja0xheWVyTGltaXRzKG51bSk7XG4gICAgfSxcbiAgICBjaGVja1RyYW5zcGFyZW5jeTogZnVuY3Rpb24gY2hlY2tUcmFuc3BhcmVuY3koKSB7XG4gICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5vLnYgPD0gMCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNUcmFuc3BhcmVudCAmJiB0aGlzLmdsb2JhbERhdGEucmVuZGVyQ29uZmlnLmhpZGVPblRyYW5zcGFyZW50KSB7XG4gICAgICAgICAgdGhpcy5pc1RyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzVHJhbnNwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5pc1RyYW5zcGFyZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqIEluaXRpYWxpemVzIGZyYW1lIHJlbGF0ZWQgcHJvcGVydGllcy5cclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bVxyXG4gICAgICAgKiBjdXJyZW50IGZyYW1lIG51bWJlciBpbiBMYXllcidzIHRpbWVcclxuICAgICAgICpcclxuICAgICAgICovXG4gICAgY2hlY2tMYXllckxpbWl0czogZnVuY3Rpb24gY2hlY2tMYXllckxpbWl0cyhudW0pIHtcbiAgICAgIGlmICh0aGlzLmRhdGEuaXAgLSB0aGlzLmRhdGEuc3QgPD0gbnVtICYmIHRoaXMuZGF0YS5vcCAtIHRoaXMuZGF0YS5zdCA+IG51bSkge1xuICAgICAgICBpZiAodGhpcy5pc0luUmFuZ2UgIT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuX21kZiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fbWRmID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmlzSW5SYW5nZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0luUmFuZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5fbWRmID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0luUmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJSZW5kZXJhYmxlOiBmdW5jdGlvbiByZW5kZXJSZW5kZXJhYmxlKCkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gdGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB0aGlzLnJlbmRlcmFibGVDb21wb25lbnRzW2ldLnJlbmRlckZyYW1lKHRoaXMuX2lzRmlyc3RGcmFtZSk7XG4gICAgICB9XG4gICAgICAvKiB0aGlzLm1hc2tNYW5hZ2VyLnJlbmRlckZyYW1lKHRoaXMuZmluYWxUcmFuc2Zvcm0ubWF0KTtcclxuICAgICAgICAgIHRoaXMucmVuZGVyYWJsZUVmZmVjdHNNYW5hZ2VyLnJlbmRlckZyYW1lKHRoaXMuX2lzRmlyc3RGcmFtZSk7ICovXG5cbiAgICB9LFxuICAgIHNvdXJjZVJlY3RBdFRpbWU6IGZ1bmN0aW9uIHNvdXJjZVJlY3RBdFRpbWUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHdpZHRoOiAxMDAsXG4gICAgICAgIGhlaWdodDogMTAwXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0TGF5ZXJTaXplOiBmdW5jdGlvbiBnZXRMYXllclNpemUoKSB7XG4gICAgICBpZiAodGhpcy5kYXRhLnR5ID09PSA1KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdzogdGhpcy5kYXRhLnRleHREYXRhLndpZHRoLFxuICAgICAgICAgIGg6IHRoaXMuZGF0YS50ZXh0RGF0YS5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdzogdGhpcy5kYXRhLndpZHRoLFxuICAgICAgICBoOiB0aGlzLmRhdGEuaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0QmxlbmRNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBibGVuZE1vZGVFbnVtcyA9IHtcbiAgICAgIDA6ICdzb3VyY2Utb3ZlcicsXG4gICAgICAxOiAnbXVsdGlwbHknLFxuICAgICAgMjogJ3NjcmVlbicsXG4gICAgICAzOiAnb3ZlcmxheScsXG4gICAgICA0OiAnZGFya2VuJyxcbiAgICAgIDU6ICdsaWdodGVuJyxcbiAgICAgIDY6ICdjb2xvci1kb2RnZScsXG4gICAgICA3OiAnY29sb3ItYnVybicsXG4gICAgICA4OiAnaGFyZC1saWdodCcsXG4gICAgICA5OiAnc29mdC1saWdodCcsXG4gICAgICAxMDogJ2RpZmZlcmVuY2UnLFxuICAgICAgMTE6ICdleGNsdXNpb24nLFxuICAgICAgMTI6ICdodWUnLFxuICAgICAgMTM6ICdzYXR1cmF0aW9uJyxcbiAgICAgIDE0OiAnY29sb3InLFxuICAgICAgMTU6ICdsdW1pbm9zaXR5J1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgICByZXR1cm4gYmxlbmRNb2RlRW51bXNbbW9kZV0gfHwgJyc7XG4gICAgfTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIFNsaWRlckVmZmVjdChkYXRhLCBlbGVtLCBjb250YWluZXIpIHtcbiAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnYsIDAsIDAsIGNvbnRhaW5lcik7XG4gIH1cblxuICBmdW5jdGlvbiBBbmdsZUVmZmVjdChkYXRhLCBlbGVtLCBjb250YWluZXIpIHtcbiAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnYsIDAsIDAsIGNvbnRhaW5lcik7XG4gIH1cblxuICBmdW5jdGlvbiBDb2xvckVmZmVjdChkYXRhLCBlbGVtLCBjb250YWluZXIpIHtcbiAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnYsIDEsIDAsIGNvbnRhaW5lcik7XG4gIH1cblxuICBmdW5jdGlvbiBQb2ludEVmZmVjdChkYXRhLCBlbGVtLCBjb250YWluZXIpIHtcbiAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnYsIDEsIDAsIGNvbnRhaW5lcik7XG4gIH1cblxuICBmdW5jdGlvbiBMYXllckluZGV4RWZmZWN0KGRhdGEsIGVsZW0sIGNvbnRhaW5lcikge1xuICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudiwgMCwgMCwgY29udGFpbmVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIE1hc2tJbmRleEVmZmVjdChkYXRhLCBlbGVtLCBjb250YWluZXIpIHtcbiAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnYsIDAsIDAsIGNvbnRhaW5lcik7XG4gIH1cblxuICBmdW5jdGlvbiBDaGVja2JveEVmZmVjdChkYXRhLCBlbGVtLCBjb250YWluZXIpIHtcbiAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnYsIDAsIDAsIGNvbnRhaW5lcik7XG4gIH1cblxuICBmdW5jdGlvbiBOb1ZhbHVlRWZmZWN0KCkge1xuICAgIHRoaXMucCA9IHt9O1xuICB9XG5cbiAgZnVuY3Rpb24gRWZmZWN0c01hbmFnZXIoZGF0YSwgZWxlbWVudCkge1xuICAgIHZhciBlZmZlY3RzID0gZGF0YS5lZiB8fCBbXTtcbiAgICB0aGlzLmVmZmVjdEVsZW1lbnRzID0gW107XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGVmZmVjdHMubGVuZ3RoO1xuICAgIHZhciBlZmZlY3RJdGVtO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBlZmZlY3RJdGVtID0gbmV3IEdyb3VwRWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQpO1xuICAgICAgdGhpcy5lZmZlY3RFbGVtZW50cy5wdXNoKGVmZmVjdEl0ZW0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEdyb3VwRWZmZWN0KGRhdGEsIGVsZW1lbnQpIHtcbiAgICB0aGlzLmluaXQoZGF0YSwgZWxlbWVudCk7XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIEdyb3VwRWZmZWN0KTtcbiAgR3JvdXBFZmZlY3QucHJvdG90eXBlLmdldFZhbHVlID0gR3JvdXBFZmZlY3QucHJvdG90eXBlLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcztcblxuICBHcm91cEVmZmVjdC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChkYXRhLCBlbGVtZW50KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmVmZmVjdEVsZW1lbnRzID0gW107XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW1lbnQpO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmRhdGEuZWYubGVuZ3RoO1xuICAgIHZhciBlZmY7XG4gICAgdmFyIGVmZmVjdHMgPSB0aGlzLmRhdGEuZWY7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGVmZiA9IG51bGw7XG5cbiAgICAgIHN3aXRjaCAoZWZmZWN0c1tpXS50eSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgZWZmID0gbmV3IFNsaWRlckVmZmVjdChlZmZlY3RzW2ldLCBlbGVtZW50LCB0aGlzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgZWZmID0gbmV3IEFuZ2xlRWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBlZmYgPSBuZXcgQ29sb3JFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGVmZiA9IG5ldyBQb2ludEVmZmVjdChlZmZlY3RzW2ldLCBlbGVtZW50LCB0aGlzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBlZmYgPSBuZXcgQ2hlY2tib3hFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBlZmYgPSBuZXcgTGF5ZXJJbmRleEVmZmVjdChlZmZlY3RzW2ldLCBlbGVtZW50LCB0aGlzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIGVmZiA9IG5ldyBNYXNrSW5kZXhFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGVmZiA9IG5ldyBFZmZlY3RzTWFuYWdlcihlZmZlY3RzW2ldLCBlbGVtZW50LCB0aGlzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gY2FzZSA2OlxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZWZmID0gbmV3IE5vVmFsdWVFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmYpIHtcbiAgICAgICAgdGhpcy5lZmZlY3RFbGVtZW50cy5wdXNoKGVmZik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEJhc2VFbGVtZW50KCkge31cblxuICBCYXNlRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gICAgY2hlY2tNYXNrczogZnVuY3Rpb24gY2hlY2tNYXNrcygpIHtcbiAgICAgIGlmICghdGhpcy5kYXRhLmhhc01hc2spIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gdGhpcy5kYXRhLm1hc2tzUHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEubWFza3NQcm9wZXJ0aWVzW2ldLm1vZGUgIT09ICduJyAmJiB0aGlzLmRhdGEubWFza3NQcm9wZXJ0aWVzW2ldLmNsICE9PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBpbml0RXhwcmVzc2lvbnM6IGZ1bmN0aW9uIGluaXRFeHByZXNzaW9ucygpIHtcbiAgICAgIHZhciBleHByZXNzaW9uc0ludGVyZmFjZXMgPSBnZXRFeHByZXNzaW9uSW50ZXJmYWNlcygpO1xuXG4gICAgICBpZiAoIWV4cHJlc3Npb25zSW50ZXJmYWNlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBMYXllckV4cHJlc3Npb25JbnRlcmZhY2UgPSBleHByZXNzaW9uc0ludGVyZmFjZXMoJ2xheWVyJyk7XG4gICAgICB2YXIgRWZmZWN0c0V4cHJlc3Npb25JbnRlcmZhY2UgPSBleHByZXNzaW9uc0ludGVyZmFjZXMoJ2VmZmVjdHMnKTtcbiAgICAgIHZhciBTaGFwZUV4cHJlc3Npb25JbnRlcmZhY2UgPSBleHByZXNzaW9uc0ludGVyZmFjZXMoJ3NoYXBlJyk7XG4gICAgICB2YXIgVGV4dEV4cHJlc3Npb25JbnRlcmZhY2UgPSBleHByZXNzaW9uc0ludGVyZmFjZXMoJ3RleHQnKTtcbiAgICAgIHZhciBDb21wRXhwcmVzc2lvbkludGVyZmFjZSA9IGV4cHJlc3Npb25zSW50ZXJmYWNlcygnY29tcCcpO1xuICAgICAgdGhpcy5sYXllckludGVyZmFjZSA9IExheWVyRXhwcmVzc2lvbkludGVyZmFjZSh0aGlzKTtcblxuICAgICAgaWYgKHRoaXMuZGF0YS5oYXNNYXNrICYmIHRoaXMubWFza01hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5sYXllckludGVyZmFjZS5yZWdpc3Rlck1hc2tJbnRlcmZhY2UodGhpcy5tYXNrTWFuYWdlcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBlZmZlY3RzSW50ZXJmYWNlID0gRWZmZWN0c0V4cHJlc3Npb25JbnRlcmZhY2UuY3JlYXRlRWZmZWN0c0ludGVyZmFjZSh0aGlzLCB0aGlzLmxheWVySW50ZXJmYWNlKTtcbiAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2UucmVnaXN0ZXJFZmZlY3RzSW50ZXJmYWNlKGVmZmVjdHNJbnRlcmZhY2UpO1xuXG4gICAgICBpZiAodGhpcy5kYXRhLnR5ID09PSAwIHx8IHRoaXMuZGF0YS54dCkge1xuICAgICAgICB0aGlzLmNvbXBJbnRlcmZhY2UgPSBDb21wRXhwcmVzc2lvbkludGVyZmFjZSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLnR5ID09PSA0KSB7XG4gICAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2Uuc2hhcGVJbnRlcmZhY2UgPSBTaGFwZUV4cHJlc3Npb25JbnRlcmZhY2UodGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdGhpcy5sYXllckludGVyZmFjZSk7XG4gICAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2UuY29udGVudCA9IHRoaXMubGF5ZXJJbnRlcmZhY2Uuc2hhcGVJbnRlcmZhY2U7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS50eSA9PT0gNSkge1xuICAgICAgICB0aGlzLmxheWVySW50ZXJmYWNlLnRleHRJbnRlcmZhY2UgPSBUZXh0RXhwcmVzc2lvbkludGVyZmFjZSh0aGlzKTtcbiAgICAgICAgdGhpcy5sYXllckludGVyZmFjZS50ZXh0ID0gdGhpcy5sYXllckludGVyZmFjZS50ZXh0SW50ZXJmYWNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0QmxlbmRNb2RlOiBmdW5jdGlvbiBzZXRCbGVuZE1vZGUoKSB7XG4gICAgICB2YXIgYmxlbmRNb2RlVmFsdWUgPSBnZXRCbGVuZE1vZGUodGhpcy5kYXRhLmJtKTtcbiAgICAgIHZhciBlbGVtID0gdGhpcy5iYXNlRWxlbWVudCB8fCB0aGlzLmxheWVyRWxlbWVudDtcbiAgICAgIGVsZW0uc3R5bGVbJ21peC1ibGVuZC1tb2RlJ10gPSBibGVuZE1vZGVWYWx1ZTtcbiAgICB9LFxuICAgIGluaXRCYXNlRGF0YTogZnVuY3Rpb24gaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICAgIHRoaXMuZ2xvYmFsRGF0YSA9IGdsb2JhbERhdGE7XG4gICAgICB0aGlzLmNvbXAgPSBjb21wO1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgIHRoaXMubGF5ZXJJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpOyAvLyBTdHJldGNoIGZhY3RvciBmb3Igb2xkIGFuaW1hdGlvbnMgbWlzc2luZyB0aGlzIHByb3BlcnR5LlxuXG4gICAgICBpZiAoIXRoaXMuZGF0YS5zcikge1xuICAgICAgICB0aGlzLmRhdGEuc3IgPSAxO1xuICAgICAgfSAvLyBlZmZlY3RzIG1hbmFnZXJcblxuXG4gICAgICB0aGlzLmVmZmVjdHNNYW5hZ2VyID0gbmV3IEVmZmVjdHNNYW5hZ2VyKHRoaXMuZGF0YSwgdGhpcywgdGhpcy5keW5hbWljUHJvcGVydGllcyk7XG4gICAgfSxcbiAgICBnZXRUeXBlOiBmdW5jdGlvbiBnZXRUeXBlKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgICB9LFxuICAgIHNvdXJjZVJlY3RBdFRpbWU6IGZ1bmN0aW9uIHNvdXJjZVJlY3RBdFRpbWUoKSB7fVxuICB9O1xuXG4gIC8qKlxyXG4gICAqIEBmaWxlXHJcbiAgICogSGFuZGxlcyBlbGVtZW50J3MgbGF5ZXIgZnJhbWUgdXBkYXRlLlxyXG4gICAqIENoZWNrcyBsYXllciBpbiBwb2ludCBhbmQgb3V0IHBvaW50XHJcbiAgICpcclxuICAgKi9cbiAgZnVuY3Rpb24gRnJhbWVFbGVtZW50KCkge31cblxuICBGcmFtZUVsZW1lbnQucHJvdG90eXBlID0ge1xuICAgIC8qKlxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogSW5pdGlhbGl6ZXMgZnJhbWUgcmVsYXRlZCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgKlxyXG4gICAgICAgKi9cbiAgICBpbml0RnJhbWU6IGZ1bmN0aW9uIGluaXRGcmFtZSgpIHtcbiAgICAgIC8vIHNldCB0byB0cnVlIHdoZW4gaW5wb2ludCBpcyByZW5kZXJlZFxuICAgICAgdGhpcy5faXNGaXJzdEZyYW1lID0gZmFsc2U7IC8vIGxpc3Qgb2YgYW5pbWF0ZWQgcHJvcGVydGllc1xuXG4gICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gW107IC8vIElmIGxheWVyIGhhcyBiZWVuIG1vZGlmaWVkIGluIGN1cnJlbnQgdGljayB0aGlzIHdpbGwgYmUgdHJ1ZVxuXG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKiBDYWxjdWxhdGVzIGFsbCBkeW5hbWljIHZhbHVlc1xyXG4gICAgICAgKlxyXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtXHJcbiAgICAgICAqIGN1cnJlbnQgZnJhbWUgbnVtYmVyIGluIExheWVyJ3MgdGltZVxyXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmlzaWJsZVxyXG4gICAgICAgKiBpZiBsYXllcnMgaXMgY3VycmVudGx5IGluIHJhbmdlXHJcbiAgICAgICAqXHJcbiAgICAgICAqL1xuICAgIHByZXBhcmVQcm9wZXJ0aWVzOiBmdW5jdGlvbiBwcmVwYXJlUHJvcGVydGllcyhudW0sIGlzVmlzaWJsZSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoaXNWaXNpYmxlIHx8IHRoaXMuX2lzUGFyZW50ICYmIHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV0ucHJvcFR5cGUgPT09ICd0cmFuc2Zvcm0nKSB7XG4gICAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllc1tpXS5nZXRWYWx1ZSgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV0uX21kZikge1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLl9tZGYgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fbWRmID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFkZER5bmFtaWNQcm9wZXJ0eTogZnVuY3Rpb24gYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApIHtcbiAgICAgIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gRm9vdGFnZUVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMuaW5pdEZyYW1lKCk7XG4gICAgdGhpcy5pbml0UmVuZGVyYWJsZSgpO1xuICAgIHRoaXMuYXNzZXREYXRhID0gZ2xvYmFsRGF0YS5nZXRBc3NldERhdGEoZGF0YS5yZWZJZCk7XG4gICAgdGhpcy5mb290YWdlRGF0YSA9IGdsb2JhbERhdGEuaW1hZ2VMb2FkZXIuZ2V0QXNzZXQodGhpcy5hc3NldERhdGEpO1xuICAgIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG5cbiAgRm9vdGFnZUVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGV4dGVuZFByb3RvdHlwZShbUmVuZGVyYWJsZUVsZW1lbnQsIEJhc2VFbGVtZW50LCBGcmFtZUVsZW1lbnRdLCBGb290YWdlRWxlbWVudCk7XG5cbiAgRm9vdGFnZUVsZW1lbnQucHJvdG90eXBlLmdldEJhc2VFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIEZvb3RhZ2VFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIEZvb3RhZ2VFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge307XG5cbiAgRm9vdGFnZUVsZW1lbnQucHJvdG90eXBlLmluaXRFeHByZXNzaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXhwcmVzc2lvbnNJbnRlcmZhY2VzID0gZ2V0RXhwcmVzc2lvbkludGVyZmFjZXMoKTtcblxuICAgIGlmICghZXhwcmVzc2lvbnNJbnRlcmZhY2VzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIEZvb3RhZ2VJbnRlcmZhY2UgPSBleHByZXNzaW9uc0ludGVyZmFjZXMoJ2Zvb3RhZ2UnKTtcbiAgICB0aGlzLmxheWVySW50ZXJmYWNlID0gRm9vdGFnZUludGVyZmFjZSh0aGlzKTtcbiAgfTtcblxuICBGb290YWdlRWxlbWVudC5wcm90b3R5cGUuZ2V0Rm9vdGFnZURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9vdGFnZURhdGE7XG4gIH07XG5cbiAgZnVuY3Rpb24gQXVkaW9FbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmluaXRGcmFtZSgpO1xuICAgIHRoaXMuaW5pdFJlbmRlcmFibGUoKTtcbiAgICB0aGlzLmFzc2V0RGF0YSA9IGdsb2JhbERhdGEuZ2V0QXNzZXREYXRhKGRhdGEucmVmSWQpO1xuICAgIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2NhblBsYXkgPSBmYWxzZTtcbiAgICB2YXIgYXNzZXRQYXRoID0gdGhpcy5nbG9iYWxEYXRhLmdldEFzc2V0c1BhdGgodGhpcy5hc3NldERhdGEpO1xuICAgIHRoaXMuYXVkaW8gPSB0aGlzLmdsb2JhbERhdGEuYXVkaW9Db250cm9sbGVyLmNyZWF0ZUF1ZGlvKGFzc2V0UGF0aCk7XG4gICAgdGhpcy5fY3VycmVudFRpbWUgPSAwO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5hdWRpb0NvbnRyb2xsZXIuYWRkQXVkaW8odGhpcyk7XG4gICAgdGhpcy5fdm9sdW1lTXVsdGlwbGllciA9IDE7XG4gICAgdGhpcy5fdm9sdW1lID0gMTtcbiAgICB0aGlzLl9wcmV2aW91c1ZvbHVtZSA9IG51bGw7XG4gICAgdGhpcy50bSA9IGRhdGEudG0gPyBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLnRtLCAwLCBnbG9iYWxEYXRhLmZyYW1lUmF0ZSwgdGhpcykgOiB7XG4gICAgICBfcGxhY2Vob2xkZXI6IHRydWVcbiAgICB9O1xuICAgIHRoaXMubHYgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLmF1ICYmIGRhdGEuYXUubHYgPyBkYXRhLmF1Lmx2IDoge1xuICAgICAgazogWzEwMF1cbiAgICB9LCAxLCAwLjAxLCB0aGlzKTtcbiAgfVxuXG4gIEF1ZGlvRWxlbWVudC5wcm90b3R5cGUucHJlcGFyZUZyYW1lID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHRoaXMucHJlcGFyZVJlbmRlcmFibGVGcmFtZShudW0sIHRydWUpO1xuICAgIHRoaXMucHJlcGFyZVByb3BlcnRpZXMobnVtLCB0cnVlKTtcblxuICAgIGlmICghdGhpcy50bS5fcGxhY2Vob2xkZXIpIHtcbiAgICAgIHZhciB0aW1lUmVtYXBwZWQgPSB0aGlzLnRtLnY7XG4gICAgICB0aGlzLl9jdXJyZW50VGltZSA9IHRpbWVSZW1hcHBlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSBudW0gLyB0aGlzLmRhdGEuc3I7XG4gICAgfVxuXG4gICAgdGhpcy5fdm9sdW1lID0gdGhpcy5sdi52WzBdO1xuICAgIHZhciB0b3RhbFZvbHVtZSA9IHRoaXMuX3ZvbHVtZSAqIHRoaXMuX3ZvbHVtZU11bHRpcGxpZXI7XG5cbiAgICBpZiAodGhpcy5fcHJldmlvdXNWb2x1bWUgIT09IHRvdGFsVm9sdW1lKSB7XG4gICAgICB0aGlzLl9wcmV2aW91c1ZvbHVtZSA9IHRvdGFsVm9sdW1lO1xuICAgICAgdGhpcy5hdWRpby52b2x1bWUodG90YWxWb2x1bWUpO1xuICAgIH1cbiAgfTtcblxuICBleHRlbmRQcm90b3R5cGUoW1JlbmRlcmFibGVFbGVtZW50LCBCYXNlRWxlbWVudCwgRnJhbWVFbGVtZW50XSwgQXVkaW9FbGVtZW50KTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmlzSW5SYW5nZSAmJiB0aGlzLl9jYW5QbGF5KSB7XG4gICAgICBpZiAoIXRoaXMuX2lzUGxheWluZykge1xuICAgICAgICB0aGlzLmF1ZGlvLnBsYXkoKTtcbiAgICAgICAgdGhpcy5hdWRpby5zZWVrKHRoaXMuX2N1cnJlbnRUaW1lIC8gdGhpcy5nbG9iYWxEYXRhLmZyYW1lUmF0ZSk7XG4gICAgICAgIHRoaXMuX2lzUGxheWluZyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmF1ZGlvLnBsYXlpbmcoKSB8fCBNYXRoLmFicyh0aGlzLl9jdXJyZW50VGltZSAvIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZVJhdGUgLSB0aGlzLmF1ZGlvLnNlZWsoKSkgPiAwLjEpIHtcbiAgICAgICAgdGhpcy5hdWRpby5zZWVrKHRoaXMuX2N1cnJlbnRUaW1lIC8gdGhpcy5nbG9iYWxEYXRhLmZyYW1lUmF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEF1ZGlvRWxlbWVudC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHsvLyB0aGlzLmF1ZGlvLnBsYXkoKVxuICB9O1xuXG4gIEF1ZGlvRWxlbWVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmF1ZGlvLnBhdXNlKCk7XG4gICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gIH07XG5cbiAgQXVkaW9FbGVtZW50LnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmF1ZGlvLnBhdXNlKCk7XG4gICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fY2FuUGxheSA9IGZhbHNlO1xuICB9O1xuXG4gIEF1ZGlvRWxlbWVudC5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NhblBsYXkgPSB0cnVlO1xuICB9O1xuXG4gIEF1ZGlvRWxlbWVudC5wcm90b3R5cGUuc2V0UmF0ZSA9IGZ1bmN0aW9uIChyYXRlVmFsdWUpIHtcbiAgICB0aGlzLmF1ZGlvLnJhdGUocmF0ZVZhbHVlKTtcbiAgfTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uICh2b2x1bWVWYWx1ZSkge1xuICAgIHRoaXMuX3ZvbHVtZU11bHRpcGxpZXIgPSB2b2x1bWVWYWx1ZTtcbiAgICB0aGlzLl9wcmV2aW91c1ZvbHVtZSA9IHZvbHVtZVZhbHVlICogdGhpcy5fdm9sdW1lO1xuICAgIHRoaXMuYXVkaW8udm9sdW1lKHRoaXMuX3ByZXZpb3VzVm9sdW1lKTtcbiAgfTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLmdldEJhc2VFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIEF1ZGlvRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIEF1ZGlvRWxlbWVudC5wcm90b3R5cGUuc291cmNlUmVjdEF0VGltZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIEF1ZGlvRWxlbWVudC5wcm90b3R5cGUuaW5pdEV4cHJlc3Npb25zID0gZnVuY3Rpb24gKCkge307XG5cbiAgZnVuY3Rpb24gQmFzZVJlbmRlcmVyKCkge31cblxuICBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmNoZWNrTGF5ZXJzID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG4gICAgdmFyIGRhdGE7XG4gICAgdGhpcy5jb21wbGV0ZUxheWVycyA9IHRydWU7XG5cbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKCF0aGlzLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgIGRhdGEgPSB0aGlzLmxheWVyc1tpXTtcblxuICAgICAgICBpZiAoZGF0YS5pcCAtIGRhdGEuc3QgPD0gbnVtIC0gdGhpcy5sYXllcnNbaV0uc3QgJiYgZGF0YS5vcCAtIGRhdGEuc3QgPiBudW0gLSB0aGlzLmxheWVyc1tpXS5zdCkge1xuICAgICAgICAgIHRoaXMuYnVpbGRJdGVtKGkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29tcGxldGVMYXllcnMgPSB0aGlzLmVsZW1lbnRzW2ldID8gdGhpcy5jb21wbGV0ZUxheWVycyA6IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuY2hlY2tQZW5kaW5nRWxlbWVudHMoKTtcbiAgfTtcblxuICBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUl0ZW0gPSBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICBzd2l0Y2ggKGxheWVyLnR5KSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUltYWdlKGxheWVyKTtcblxuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDb21wKGxheWVyKTtcblxuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTb2xpZChsYXllcik7XG5cbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTnVsbChsYXllcik7XG5cbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2hhcGUobGF5ZXIpO1xuXG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRleHQobGF5ZXIpO1xuXG4gICAgICBjYXNlIDY6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUF1ZGlvKGxheWVyKTtcblxuICAgICAgY2FzZSAxMzpcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ2FtZXJhKGxheWVyKTtcblxuICAgICAgY2FzZSAxNTpcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRm9vdGFnZShsYXllcik7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU51bGwobGF5ZXIpO1xuICAgIH1cbiAgfTtcblxuICBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNhbWVyYSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdVxcJ3JlIHVzaW5nIGEgM2QgY2FtZXJhLiBUcnkgdGhlIGh0bWwgcmVuZGVyZXIuJyk7XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVBdWRpbyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBBdWRpb0VsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUZvb3RhZ2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgRm9vdGFnZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkQWxsSXRlbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy5idWlsZEl0ZW0oaSk7XG4gICAgfVxuXG4gICAgdGhpcy5jaGVja1BlbmRpbmdFbGVtZW50cygpO1xuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuaW5jbHVkZUxheWVycyA9IGZ1bmN0aW9uIChuZXdMYXllcnMpIHtcbiAgICB0aGlzLmNvbXBsZXRlTGF5ZXJzID0gZmFsc2U7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IG5ld0xheWVycy5sZW5ndGg7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGogPSAwO1xuXG4gICAgICB3aGlsZSAoaiA8IGpMZW4pIHtcbiAgICAgICAgaWYgKHRoaXMubGF5ZXJzW2pdLmlkID09PSBuZXdMYXllcnNbaV0uaWQpIHtcbiAgICAgICAgICB0aGlzLmxheWVyc1tqXSA9IG5ld0xheWVyc1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGogKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5zZXRQcm9qZWN0SW50ZXJmYWNlID0gZnVuY3Rpb24gKHBJbnRlcmZhY2UpIHtcbiAgICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZSA9IHBJbnRlcmZhY2U7XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5pbml0SXRlbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmdsb2JhbERhdGEucHJvZ3Jlc3NpdmVMb2FkKSB7XG4gICAgICB0aGlzLmJ1aWxkQWxsSXRlbXMoKTtcbiAgICB9XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5idWlsZEVsZW1lbnRQYXJlbnRpbmcgPSBmdW5jdGlvbiAoZWxlbWVudCwgcGFyZW50TmFtZSwgaGllcmFyY2h5KSB7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnM7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBsYXllcnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGlmIChsYXllcnNbaV0uaW5kID09IHBhcmVudE5hbWUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgaWYgKCFlbGVtZW50c1tpXSB8fCBlbGVtZW50c1tpXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMuYnVpbGRJdGVtKGkpO1xuICAgICAgICAgIHRoaXMuYWRkUGVuZGluZ0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGllcmFyY2h5LnB1c2goZWxlbWVudHNbaV0pO1xuICAgICAgICAgIGVsZW1lbnRzW2ldLnNldEFzUGFyZW50KCk7XG5cbiAgICAgICAgICBpZiAobGF5ZXJzW2ldLnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkRWxlbWVudFBhcmVudGluZyhlbGVtZW50LCBsYXllcnNbaV0ucGFyZW50LCBoaWVyYXJjaHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEhpZXJhcmNoeShoaWVyYXJjaHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuYWRkUGVuZGluZ0VsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHRoaXMucGVuZGluZ0VsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5zZWFyY2hFeHRyYUNvbXBvc2l0aW9ucyA9IGZ1bmN0aW9uIChhc3NldHMpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gYXNzZXRzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKGFzc2V0c1tpXS54dCkge1xuICAgICAgICB2YXIgY29tcCA9IHRoaXMuY3JlYXRlQ29tcChhc3NldHNbaV0pO1xuICAgICAgICBjb21wLmluaXRFeHByZXNzaW9ucygpO1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5yZWdpc3RlckNvbXBvc2l0aW9uKGNvbXApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmdldEVsZW1lbnRCeUlkID0gZnVuY3Rpb24gKGluZCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0uZGF0YS5pbmQgPT09IGluZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50c1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmdldEVsZW1lbnRCeVBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciBwYXRoVmFsdWUgPSBwYXRoLnNoaWZ0KCk7XG4gICAgdmFyIGVsZW1lbnQ7XG5cbiAgICBpZiAodHlwZW9mIHBhdGhWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3BhdGhWYWx1ZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0uZGF0YS5ubSA9PT0gcGF0aFZhbHVlKSB7XG4gICAgICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50LmdldEVsZW1lbnRCeVBhdGgocGF0aCk7XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5zZXR1cEdsb2JhbERhdGEgPSBmdW5jdGlvbiAoYW5pbURhdGEsIGZvbnRzQ29udGFpbmVyKSB7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyID0gbmV3IEZvbnRNYW5hZ2VyKCk7XG4gICAgdGhpcy5nbG9iYWxEYXRhLnNsb3RNYW5hZ2VyID0gc2xvdEZhY3RvcnkoYW5pbURhdGEpO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5hZGRDaGFycyhhbmltRGF0YS5jaGFycyk7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmFkZEZvbnRzKGFuaW1EYXRhLmZvbnRzLCBmb250c0NvbnRhaW5lcik7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmdldEFzc2V0RGF0YSA9IHRoaXMuYW5pbWF0aW9uSXRlbS5nZXRBc3NldERhdGEuYmluZCh0aGlzLmFuaW1hdGlvbkl0ZW0pO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5nZXRBc3NldHNQYXRoID0gdGhpcy5hbmltYXRpb25JdGVtLmdldEFzc2V0c1BhdGguYmluZCh0aGlzLmFuaW1hdGlvbkl0ZW0pO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5pbWFnZUxvYWRlciA9IHRoaXMuYW5pbWF0aW9uSXRlbS5pbWFnZVByZWxvYWRlcjtcbiAgICB0aGlzLmdsb2JhbERhdGEuYXVkaW9Db250cm9sbGVyID0gdGhpcy5hbmltYXRpb25JdGVtLmF1ZGlvQ29udHJvbGxlcjtcbiAgICB0aGlzLmdsb2JhbERhdGEuZnJhbWVJZCA9IDA7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lUmF0ZSA9IGFuaW1EYXRhLmZyO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5ubSA9IGFuaW1EYXRhLm5tO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZSA9IHtcbiAgICAgIHc6IGFuaW1EYXRhLncsXG4gICAgICBoOiBhbmltRGF0YS5oXG4gICAgfTtcbiAgfTtcblxuICB2YXIgZWZmZWN0VHlwZXMgPSB7XG4gICAgVFJBTlNGT1JNX0VGRkVDVDogJ3RyYW5zZm9ybUVGZmVjdCdcbiAgfTtcblxuICBmdW5jdGlvbiBUcmFuc2Zvcm1FbGVtZW50KCkge31cblxuICBUcmFuc2Zvcm1FbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgICBpbml0VHJhbnNmb3JtOiBmdW5jdGlvbiBpbml0VHJhbnNmb3JtKCkge1xuICAgICAgdmFyIG1hdCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0gPSB7XG4gICAgICAgIG1Qcm9wOiB0aGlzLmRhdGEua3MgPyBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkuZ2V0VHJhbnNmb3JtUHJvcGVydHkodGhpcywgdGhpcy5kYXRhLmtzLCB0aGlzKSA6IHtcbiAgICAgICAgICBvOiAwXG4gICAgICAgIH0sXG4gICAgICAgIF9tYXRNZGY6IGZhbHNlLFxuICAgICAgICBfbG9jYWxNYXRNZGY6IGZhbHNlLFxuICAgICAgICBfb3BNZGY6IGZhbHNlLFxuICAgICAgICBtYXQ6IG1hdCxcbiAgICAgICAgbG9jYWxNYXQ6IG1hdCxcbiAgICAgICAgbG9jYWxPcGFjaXR5OiAxXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5kYXRhLmFvKSB7XG4gICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3AuYXV0b09yaWVudGVkID0gdHJ1ZTtcbiAgICAgIH0gLy8gVE9ETzogY2hlY2sgVFlQRSAxMTogR3VpZGVkIGVsZW1lbnRzXG5cblxuICAgICAgaWYgKHRoaXMuZGF0YS50eSAhPT0gMTEpIHsvLyB0aGlzLmNyZWF0ZUVsZW1lbnRzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJUcmFuc2Zvcm06IGZ1bmN0aW9uIHJlbmRlclRyYW5zZm9ybSgpIHtcbiAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX29wTWRmID0gdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5vLl9tZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lO1xuICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmID0gdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZTtcblxuICAgICAgaWYgKHRoaXMuaGllcmFyY2h5KSB7XG4gICAgICAgIHZhciBtYXQ7XG4gICAgICAgIHZhciBmaW5hbE1hdCA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubWF0O1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IC8vIENoZWNraW5nIGlmIGFueSBvZiB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cmljZXMgaW4gdGhlIGhpZXJhcmNoeSBjaGFpbiBoYXMgY2hhbmdlZC5cblxuICAgICAgICBpZiAoIXRoaXMuZmluYWxUcmFuc2Zvcm0uX21hdE1kZikge1xuICAgICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oaWVyYXJjaHlbaV0uZmluYWxUcmFuc2Zvcm0ubVByb3AuX21kZikge1xuICAgICAgICAgICAgICB0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGYgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGYpIHtcbiAgICAgICAgICBtYXQgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLnYucHJvcHM7XG4gICAgICAgICAgZmluYWxNYXQuY2xvbmVGcm9tUHJvcHMobWF0KTtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgZmluYWxNYXQubXVsdGlwbHkodGhpcy5oaWVyYXJjaHlbaV0uZmluYWxUcmFuc2Zvcm0ubVByb3Audik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGYpIHtcbiAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5fbG9jYWxNYXRNZGYgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGY7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmZpbmFsVHJhbnNmb3JtLl9vcE1kZikge1xuICAgICAgICB0aGlzLmZpbmFsVHJhbnNmb3JtLmxvY2FsT3BhY2l0eSA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3Auby52O1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyTG9jYWxUcmFuc2Zvcm06IGZ1bmN0aW9uIHJlbmRlckxvY2FsVHJhbnNmb3JtKCkge1xuICAgICAgaWYgKHRoaXMubG9jYWxUcmFuc2Zvcm1zKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMubG9jYWxUcmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5fbG9jYWxNYXRNZGYgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGY7XG5cbiAgICAgICAgaWYgKCF0aGlzLmZpbmFsVHJhbnNmb3JtLl9sb2NhbE1hdE1kZiB8fCAhdGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYpIHtcbiAgICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgaWYgKHRoaXMubG9jYWxUcmFuc2Zvcm1zW2ldLl9tZGYpIHtcbiAgICAgICAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5fbG9jYWxNYXRNZGYgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5sb2NhbFRyYW5zZm9ybXNbaV0uX29wTWRmICYmICF0aGlzLmZpbmFsVHJhbnNmb3JtLl9vcE1kZikge1xuICAgICAgICAgICAgICB0aGlzLmZpbmFsVHJhbnNmb3JtLmxvY2FsT3BhY2l0eSA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3Auby52O1xuICAgICAgICAgICAgICB0aGlzLmZpbmFsVHJhbnNmb3JtLl9vcE1kZiA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fbG9jYWxNYXRNZGYpIHtcbiAgICAgICAgICB2YXIgbG9jYWxNYXQgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLmxvY2FsTWF0O1xuICAgICAgICAgIHRoaXMubG9jYWxUcmFuc2Zvcm1zWzBdLm1hdHJpeC5jbG9uZShsb2NhbE1hdCk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBsbWF0ID0gdGhpcy5sb2NhbFRyYW5zZm9ybXNbaV0ubWF0cml4O1xuICAgICAgICAgICAgbG9jYWxNYXQubXVsdGlwbHkobG1hdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbG9jYWxNYXQubXVsdGlwbHkodGhpcy5maW5hbFRyYW5zZm9ybS5tYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZmluYWxUcmFuc2Zvcm0uX29wTWRmKSB7XG4gICAgICAgICAgdmFyIGxvY2FsT3AgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLmxvY2FsT3BhY2l0eTtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgbG9jYWxPcCAqPSB0aGlzLmxvY2FsVHJhbnNmb3Jtc1tpXS5vcGFjaXR5ICogMC4wMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmZpbmFsVHJhbnNmb3JtLmxvY2FsT3BhY2l0eSA9IGxvY2FsT3A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNlYXJjaEVmZmVjdFRyYW5zZm9ybXM6IGZ1bmN0aW9uIHNlYXJjaEVmZmVjdFRyYW5zZm9ybXMoKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJhYmxlRWZmZWN0c01hbmFnZXIpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybUVmZmVjdHMgPSB0aGlzLnJlbmRlcmFibGVFZmZlY3RzTWFuYWdlci5nZXRFZmZlY3RzKGVmZmVjdFR5cGVzLlRSQU5TRk9STV9FRkZFQ1QpO1xuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1FZmZlY3RzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMubG9jYWxUcmFuc2Zvcm1zID0gW107XG4gICAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE1hdCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgdmFyIGxlbiA9IHRyYW5zZm9ybUVmZmVjdHMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsVHJhbnNmb3Jtcy5wdXNoKHRyYW5zZm9ybUVmZmVjdHNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2xvYmFsVG9Mb2NhbDogZnVuY3Rpb24gZ2xvYmFsVG9Mb2NhbChwdCkge1xuICAgICAgdmFyIHRyYW5zZm9ybXMgPSBbXTtcbiAgICAgIHRyYW5zZm9ybXMucHVzaCh0aGlzLmZpbmFsVHJhbnNmb3JtKTtcbiAgICAgIHZhciBmbGFnID0gdHJ1ZTtcbiAgICAgIHZhciBjb21wID0gdGhpcy5jb21wO1xuXG4gICAgICB3aGlsZSAoZmxhZykge1xuICAgICAgICBpZiAoY29tcC5maW5hbFRyYW5zZm9ybSkge1xuICAgICAgICAgIGlmIChjb21wLmRhdGEuaGFzTWFzaykge1xuICAgICAgICAgICAgdHJhbnNmb3Jtcy5zcGxpY2UoMCwgMCwgY29tcC5maW5hbFRyYW5zZm9ybSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29tcCA9IGNvbXAuY29tcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG4gICAgICB2YXIgcHROZXc7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBwdE5ldyA9IHRyYW5zZm9ybXNbaV0ubWF0LmFwcGx5VG9Qb2ludEFycmF5KDAsIDAsIDApOyAvLyBwdE5ldyA9IHRyYW5zZm9ybXNbaV0ubWF0LmFwcGx5VG9Qb2ludEFycmF5KHB0WzBdLHB0WzFdLHB0WzJdKTtcblxuICAgICAgICBwdCA9IFtwdFswXSAtIHB0TmV3WzBdLCBwdFsxXSAtIHB0TmV3WzFdLCAwXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHB0O1xuICAgIH0sXG4gICAgbUhlbHBlcjogbmV3IE1hdHJpeCgpXG4gIH07XG5cbiAgZnVuY3Rpb24gTWFza0VsZW1lbnQoZGF0YSwgZWxlbWVudCwgZ2xvYmFsRGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmdsb2JhbERhdGEgPSBnbG9iYWxEYXRhO1xuICAgIHRoaXMuc3RvcmVkRGF0YSA9IFtdO1xuICAgIHRoaXMubWFza3NQcm9wZXJ0aWVzID0gdGhpcy5kYXRhLm1hc2tzUHJvcGVydGllcyB8fCBbXTtcbiAgICB0aGlzLm1hc2tFbGVtZW50ID0gbnVsbDtcbiAgICB2YXIgZGVmcyA9IHRoaXMuZ2xvYmFsRGF0YS5kZWZzO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLm1hc2tzUHJvcGVydGllcyA/IHRoaXMubWFza3NQcm9wZXJ0aWVzLmxlbmd0aCA6IDA7XG4gICAgdGhpcy52aWV3RGF0YSA9IGNyZWF0ZVNpemVkQXJyYXkobGVuKTtcbiAgICB0aGlzLnNvbGlkUGF0aCA9ICcnO1xuICAgIHZhciBwYXRoO1xuICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5tYXNrc1Byb3BlcnRpZXM7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgY3VycmVudE1hc2tzID0gW107XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIGxheWVySWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICB2YXIgcmVjdDtcbiAgICB2YXIgZXhwYW5zb3I7XG4gICAgdmFyIGZlTW9ycGg7XG4gICAgdmFyIHg7XG4gICAgdmFyIG1hc2tUeXBlID0gJ2NsaXBQYXRoJztcbiAgICB2YXIgbWFza1JlZiA9ICdjbGlwLXBhdGgnO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAocHJvcGVydGllc1tpXS5tb2RlICE9PSAnYScgJiYgcHJvcGVydGllc1tpXS5tb2RlICE9PSAnbicgfHwgcHJvcGVydGllc1tpXS5pbnYgfHwgcHJvcGVydGllc1tpXS5vLmsgIT09IDEwMCB8fCBwcm9wZXJ0aWVzW2ldLm8ueCkge1xuICAgICAgICBtYXNrVHlwZSA9ICdtYXNrJztcbiAgICAgICAgbWFza1JlZiA9ICdtYXNrJztcbiAgICAgIH1cblxuICAgICAgaWYgKChwcm9wZXJ0aWVzW2ldLm1vZGUgPT09ICdzJyB8fCBwcm9wZXJ0aWVzW2ldLm1vZGUgPT09ICdpJykgJiYgY291bnQgPT09IDApIHtcbiAgICAgICAgcmVjdCA9IGNyZWF0ZU5TKCdyZWN0Jyk7XG4gICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCdmaWxsJywgJyNmZmZmZmYnKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5lbGVtZW50LmNvbXAuZGF0YS53IHx8IDApO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5lbGVtZW50LmNvbXAuZGF0YS5oIHx8IDApO1xuICAgICAgICBjdXJyZW50TWFza3MucHVzaChyZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY3QgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBwYXRoID0gY3JlYXRlTlMoJ3BhdGgnKTtcblxuICAgICAgaWYgKHByb3BlcnRpZXNbaV0ubW9kZSA9PT0gJ24nKSB7XG4gICAgICAgIC8vIFRPRE8gbW92ZSB0aGlzIHRvIGEgZmFjdG9yeSBvciB0byBhIGNvbnN0cnVjdG9yXG4gICAgICAgIHRoaXMudmlld0RhdGFbaV0gPSB7XG4gICAgICAgICAgb3A6IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMuZWxlbWVudCwgcHJvcGVydGllc1tpXS5vLCAwLCAwLjAxLCB0aGlzLmVsZW1lbnQpLFxuICAgICAgICAgIHByb3A6IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcCh0aGlzLmVsZW1lbnQsIHByb3BlcnRpZXNbaV0sIDMpLFxuICAgICAgICAgIGVsZW06IHBhdGgsXG4gICAgICAgICAgbGFzdFBhdGg6ICcnXG4gICAgICAgIH07XG4gICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQocGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsIHByb3BlcnRpZXNbaV0ubW9kZSA9PT0gJ3MnID8gJyMwMDAwMDAnIDogJyNmZmZmZmYnKTtcbiAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2NsaXAtcnVsZScsICdub256ZXJvJyk7XG4gICAgICAgIHZhciBmaWx0ZXJJRDtcblxuICAgICAgICBpZiAocHJvcGVydGllc1tpXS54LmsgIT09IDApIHtcbiAgICAgICAgICBtYXNrVHlwZSA9ICdtYXNrJztcbiAgICAgICAgICBtYXNrUmVmID0gJ21hc2snO1xuICAgICAgICAgIHggPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLmVsZW1lbnQsIHByb3BlcnRpZXNbaV0ueCwgMCwgbnVsbCwgdGhpcy5lbGVtZW50KTtcbiAgICAgICAgICBmaWx0ZXJJRCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgICAgIGV4cGFuc29yID0gY3JlYXRlTlMoJ2ZpbHRlcicpO1xuICAgICAgICAgIGV4cGFuc29yLnNldEF0dHJpYnV0ZSgnaWQnLCBmaWx0ZXJJRCk7XG4gICAgICAgICAgZmVNb3JwaCA9IGNyZWF0ZU5TKCdmZU1vcnBob2xvZ3knKTtcbiAgICAgICAgICBmZU1vcnBoLnNldEF0dHJpYnV0ZSgnb3BlcmF0b3InLCAnZXJvZGUnKTtcbiAgICAgICAgICBmZU1vcnBoLnNldEF0dHJpYnV0ZSgnaW4nLCAnU291cmNlR3JhcGhpYycpO1xuICAgICAgICAgIGZlTW9ycGguc2V0QXR0cmlidXRlKCdyYWRpdXMnLCAnMCcpO1xuICAgICAgICAgIGV4cGFuc29yLmFwcGVuZENoaWxkKGZlTW9ycGgpO1xuICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoZXhwYW5zb3IpO1xuICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCBwcm9wZXJ0aWVzW2ldLm1vZGUgPT09ICdzJyA/ICcjMDAwMDAwJyA6ICcjZmZmZmZmJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmVNb3JwaCA9IG51bGw7XG4gICAgICAgICAgeCA9IG51bGw7XG4gICAgICAgIH0gLy8gVE9ETyBtb3ZlIHRoaXMgdG8gYSBmYWN0b3J5IG9yIHRvIGEgY29uc3RydWN0b3JcblxuXG4gICAgICAgIHRoaXMuc3RvcmVkRGF0YVtpXSA9IHtcbiAgICAgICAgICBlbGVtOiBwYXRoLFxuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgZXhwYW46IGZlTW9ycGgsXG4gICAgICAgICAgbGFzdFBhdGg6ICcnLFxuICAgICAgICAgIGxhc3RPcGVyYXRvcjogJycsXG4gICAgICAgICAgZmlsdGVySWQ6IGZpbHRlcklELFxuICAgICAgICAgIGxhc3RSYWRpdXM6IDBcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocHJvcGVydGllc1tpXS5tb2RlID09PSAnaScpIHtcbiAgICAgICAgICBqTGVuID0gY3VycmVudE1hc2tzLmxlbmd0aDtcbiAgICAgICAgICB2YXIgZyA9IGNyZWF0ZU5TKCdnJyk7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBnLmFwcGVuZENoaWxkKGN1cnJlbnRNYXNrc1tqXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG1hc2sgPSBjcmVhdGVOUygnbWFzaycpO1xuICAgICAgICAgIG1hc2suc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCAnYWxwaGEnKTtcbiAgICAgICAgICBtYXNrLnNldEF0dHJpYnV0ZSgnaWQnLCBsYXllcklkICsgJ18nICsgY291bnQpO1xuICAgICAgICAgIG1hc2suYXBwZW5kQ2hpbGQocGF0aCk7XG4gICAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChtYXNrKTtcbiAgICAgICAgICBnLnNldEF0dHJpYnV0ZSgnbWFzaycsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgbGF5ZXJJZCArICdfJyArIGNvdW50ICsgJyknKTtcbiAgICAgICAgICBjdXJyZW50TWFza3MubGVuZ3RoID0gMDtcbiAgICAgICAgICBjdXJyZW50TWFza3MucHVzaChnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50TWFza3MucHVzaChwYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzW2ldLmludiAmJiAhdGhpcy5zb2xpZFBhdGgpIHtcbiAgICAgICAgICB0aGlzLnNvbGlkUGF0aCA9IHRoaXMuY3JlYXRlTGF5ZXJTb2xpZFBhdGgoKTtcbiAgICAgICAgfSAvLyBUT0RPIG1vdmUgdGhpcyB0byBhIGZhY3Rvcnkgb3IgdG8gYSBjb25zdHJ1Y3RvclxuXG5cbiAgICAgICAgdGhpcy52aWV3RGF0YVtpXSA9IHtcbiAgICAgICAgICBlbGVtOiBwYXRoLFxuICAgICAgICAgIGxhc3RQYXRoOiAnJyxcbiAgICAgICAgICBvcDogUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcy5lbGVtZW50LCBwcm9wZXJ0aWVzW2ldLm8sIDAsIDAuMDEsIHRoaXMuZWxlbWVudCksXG4gICAgICAgICAgcHJvcDogU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0U2hhcGVQcm9wKHRoaXMuZWxlbWVudCwgcHJvcGVydGllc1tpXSwgMyksXG4gICAgICAgICAgaW52UmVjdDogcmVjdFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghdGhpcy52aWV3RGF0YVtpXS5wcm9wLmspIHtcbiAgICAgICAgICB0aGlzLmRyYXdQYXRoKHByb3BlcnRpZXNbaV0sIHRoaXMudmlld0RhdGFbaV0ucHJvcC52LCB0aGlzLnZpZXdEYXRhW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubWFza0VsZW1lbnQgPSBjcmVhdGVOUyhtYXNrVHlwZSk7XG4gICAgbGVuID0gY3VycmVudE1hc2tzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy5tYXNrRWxlbWVudC5hcHBlbmRDaGlsZChjdXJyZW50TWFza3NbaV0pO1xuICAgIH1cblxuICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgIHRoaXMubWFza0VsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIGxheWVySWQpO1xuICAgICAgdGhpcy5lbGVtZW50Lm1hc2tlZEVsZW1lbnQuc2V0QXR0cmlidXRlKG1hc2tSZWYsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgbGF5ZXJJZCArICcpJyk7XG4gICAgICBkZWZzLmFwcGVuZENoaWxkKHRoaXMubWFza0VsZW1lbnQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnZpZXdEYXRhLmxlbmd0aCkge1xuICAgICAgdGhpcy5lbGVtZW50LmFkZFJlbmRlcmFibGVDb21wb25lbnQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgTWFza0VsZW1lbnQucHJvdG90eXBlLmdldE1hc2tQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3RGF0YVtwb3NdLnByb3A7XG4gIH07XG5cbiAgTWFza0VsZW1lbnQucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGlzRmlyc3RGcmFtZSkge1xuICAgIHZhciBmaW5hbE1hdCA9IHRoaXMuZWxlbWVudC5maW5hbFRyYW5zZm9ybS5tYXQ7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubWFza3NQcm9wZXJ0aWVzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMudmlld0RhdGFbaV0ucHJvcC5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICB0aGlzLmRyYXdQYXRoKHRoaXMubWFza3NQcm9wZXJ0aWVzW2ldLCB0aGlzLnZpZXdEYXRhW2ldLnByb3AudiwgdGhpcy52aWV3RGF0YVtpXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnZpZXdEYXRhW2ldLm9wLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIHRoaXMudmlld0RhdGFbaV0uZWxlbS5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIHRoaXMudmlld0RhdGFbaV0ub3Audik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1hc2tzUHJvcGVydGllc1tpXS5tb2RlICE9PSAnbicpIHtcbiAgICAgICAgaWYgKHRoaXMudmlld0RhdGFbaV0uaW52UmVjdCAmJiAodGhpcy5lbGVtZW50LmZpbmFsVHJhbnNmb3JtLm1Qcm9wLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSkge1xuICAgICAgICAgIHRoaXMudmlld0RhdGFbaV0uaW52UmVjdC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIGZpbmFsTWF0LmdldEludmVyc2VNYXRyaXgoKS50bzJkQ1NTKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RvcmVkRGF0YVtpXS54ICYmICh0aGlzLnN0b3JlZERhdGFbaV0ueC5fbWRmIHx8IGlzRmlyc3RGcmFtZSkpIHtcbiAgICAgICAgICB2YXIgZmVNb3JwaCA9IHRoaXMuc3RvcmVkRGF0YVtpXS5leHBhbjtcblxuICAgICAgICAgIGlmICh0aGlzLnN0b3JlZERhdGFbaV0ueC52IDwgMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcmVkRGF0YVtpXS5sYXN0T3BlcmF0b3IgIT09ICdlcm9kZScpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdG9yZWREYXRhW2ldLmxhc3RPcGVyYXRvciA9ICdlcm9kZSc7XG4gICAgICAgICAgICAgIHRoaXMuc3RvcmVkRGF0YVtpXS5lbGVtLnNldEF0dHJpYnV0ZSgnZmlsdGVyJywgJ3VybCgnICsgZ2V0TG9jYXRpb25IcmVmKCkgKyAnIycgKyB0aGlzLnN0b3JlZERhdGFbaV0uZmlsdGVySWQgKyAnKScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmZU1vcnBoLnNldEF0dHJpYnV0ZSgncmFkaXVzJywgLXRoaXMuc3RvcmVkRGF0YVtpXS54LnYpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9yZWREYXRhW2ldLmxhc3RPcGVyYXRvciAhPT0gJ2RpbGF0ZScpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdG9yZWREYXRhW2ldLmxhc3RPcGVyYXRvciA9ICdkaWxhdGUnO1xuICAgICAgICAgICAgICB0aGlzLnN0b3JlZERhdGFbaV0uZWxlbS5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsIG51bGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN0b3JlZERhdGFbaV0uZWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIHRoaXMuc3RvcmVkRGF0YVtpXS54LnYgKiAyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgTWFza0VsZW1lbnQucHJvdG90eXBlLmdldE1hc2tlbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1hc2tFbGVtZW50O1xuICB9O1xuXG4gIE1hc2tFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVMYXllclNvbGlkUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGF0aCA9ICdNMCwwICc7XG4gICAgcGF0aCArPSAnIGgnICsgdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLnc7XG4gICAgcGF0aCArPSAnIHYnICsgdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmg7XG4gICAgcGF0aCArPSAnIGgtJyArIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53O1xuICAgIHBhdGggKz0gJyB2LScgKyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaCArICcgJztcbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcblxuICBNYXNrRWxlbWVudC5wcm90b3R5cGUuZHJhd1BhdGggPSBmdW5jdGlvbiAocGF0aERhdGEsIHBhdGhOb2Rlcywgdmlld0RhdGEpIHtcbiAgICB2YXIgcGF0aFN0cmluZyA9ICcgTScgKyBwYXRoTm9kZXMudlswXVswXSArICcsJyArIHBhdGhOb2Rlcy52WzBdWzFdO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgbGVuID0gcGF0aE5vZGVzLl9sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIC8vIHBhdGhTdHJpbmcgKz0gXCIgQ1wiK3BhdGhOb2Rlcy5vW2ktMV1bMF0rJywnK3BhdGhOb2Rlcy5vW2ktMV1bMV0gKyBcIiBcIitwYXRoTm9kZXMuaVtpXVswXSsnLCcrcGF0aE5vZGVzLmlbaV1bMV0gKyBcIiBcIitwYXRoTm9kZXMudltpXVswXSsnLCcrcGF0aE5vZGVzLnZbaV1bMV07XG4gICAgICBwYXRoU3RyaW5nICs9ICcgQycgKyBwYXRoTm9kZXMub1tpIC0gMV1bMF0gKyAnLCcgKyBwYXRoTm9kZXMub1tpIC0gMV1bMV0gKyAnICcgKyBwYXRoTm9kZXMuaVtpXVswXSArICcsJyArIHBhdGhOb2Rlcy5pW2ldWzFdICsgJyAnICsgcGF0aE5vZGVzLnZbaV1bMF0gKyAnLCcgKyBwYXRoTm9kZXMudltpXVsxXTtcbiAgICB9IC8vIHBhdGhTdHJpbmcgKz0gXCIgQ1wiK3BhdGhOb2Rlcy5vW2ktMV1bMF0rJywnK3BhdGhOb2Rlcy5vW2ktMV1bMV0gKyBcIiBcIitwYXRoTm9kZXMuaVswXVswXSsnLCcrcGF0aE5vZGVzLmlbMF1bMV0gKyBcIiBcIitwYXRoTm9kZXMudlswXVswXSsnLCcrcGF0aE5vZGVzLnZbMF1bMV07XG5cblxuICAgIGlmIChwYXRoTm9kZXMuYyAmJiBsZW4gPiAxKSB7XG4gICAgICBwYXRoU3RyaW5nICs9ICcgQycgKyBwYXRoTm9kZXMub1tpIC0gMV1bMF0gKyAnLCcgKyBwYXRoTm9kZXMub1tpIC0gMV1bMV0gKyAnICcgKyBwYXRoTm9kZXMuaVswXVswXSArICcsJyArIHBhdGhOb2Rlcy5pWzBdWzFdICsgJyAnICsgcGF0aE5vZGVzLnZbMF1bMF0gKyAnLCcgKyBwYXRoTm9kZXMudlswXVsxXTtcbiAgICB9IC8vIHBhdGhOb2Rlcy5fX3JlbmRlcmVkU3RyaW5nID0gcGF0aFN0cmluZztcblxuXG4gICAgaWYgKHZpZXdEYXRhLmxhc3RQYXRoICE9PSBwYXRoU3RyaW5nKSB7XG4gICAgICB2YXIgcGF0aFNoYXBlVmFsdWUgPSAnJztcblxuICAgICAgaWYgKHZpZXdEYXRhLmVsZW0pIHtcbiAgICAgICAgaWYgKHBhdGhOb2Rlcy5jKSB7XG4gICAgICAgICAgcGF0aFNoYXBlVmFsdWUgPSBwYXRoRGF0YS5pbnYgPyB0aGlzLnNvbGlkUGF0aCArIHBhdGhTdHJpbmcgOiBwYXRoU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmlld0RhdGEuZWxlbS5zZXRBdHRyaWJ1dGUoJ2QnLCBwYXRoU2hhcGVWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHZpZXdEYXRhLmxhc3RQYXRoID0gcGF0aFN0cmluZztcbiAgICB9XG4gIH07XG5cbiAgTWFza0VsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmdsb2JhbERhdGEgPSBudWxsO1xuICAgIHRoaXMubWFza0VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy5tYXNrc1Byb3BlcnRpZXMgPSBudWxsO1xuICB9O1xuXG4gIHZhciBmaWx0ZXJzRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2IgPSB7fTtcbiAgICBvYi5jcmVhdGVGaWx0ZXIgPSBjcmVhdGVGaWx0ZXI7XG4gICAgb2IuY3JlYXRlQWxwaGFUb0x1bWluYW5jZUZpbHRlciA9IGNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXI7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWx0ZXIoZmlsSWQsIHNraXBDb29yZGluYXRlcykge1xuICAgICAgdmFyIGZpbCA9IGNyZWF0ZU5TKCdmaWx0ZXInKTtcbiAgICAgIGZpbC5zZXRBdHRyaWJ1dGUoJ2lkJywgZmlsSWQpO1xuXG4gICAgICBpZiAoc2tpcENvb3JkaW5hdGVzICE9PSB0cnVlKSB7XG4gICAgICAgIGZpbC5zZXRBdHRyaWJ1dGUoJ2ZpbHRlclVuaXRzJywgJ29iamVjdEJvdW5kaW5nQm94Jyk7XG4gICAgICAgIGZpbC5zZXRBdHRyaWJ1dGUoJ3gnLCAnMCUnKTtcbiAgICAgICAgZmlsLnNldEF0dHJpYnV0ZSgneScsICcwJScpO1xuICAgICAgICBmaWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcxMDAlJyk7XG4gICAgICAgIGZpbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcxMDAlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQWxwaGFUb0x1bWluYW5jZUZpbHRlcigpIHtcbiAgICAgIHZhciBmZUNvbG9yTWF0cml4ID0gY3JlYXRlTlMoJ2ZlQ29sb3JNYXRyaXgnKTtcbiAgICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd0eXBlJywgJ21hdHJpeCcpO1xuICAgICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdzUkdCJyk7XG4gICAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndmFsdWVzJywgJzAgMCAwIDEgMCAgMCAwIDAgMSAwICAwIDAgMCAxIDAgIDAgMCAwIDEgMScpO1xuICAgICAgcmV0dXJuIGZlQ29sb3JNYXRyaXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iO1xuICB9KCk7XG5cbiAgdmFyIGZlYXR1cmVTdXBwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYiA9IHtcbiAgICAgIG1hc2tUeXBlOiB0cnVlLFxuICAgICAgc3ZnTHVtYUhpZGRlbjogdHJ1ZSxcbiAgICAgIG9mZnNjcmVlbkNhbnZhczogdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICB9O1xuXG4gICAgaWYgKC9NU0lFIDEwL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSB8fCAvTVNJRSA5L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSB8fCAvcnY6MTEuMC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgL0VkZ2VcXC9cXGQuL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgb2IubWFza1R5cGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoL2ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICBvYi5zdmdMdW1hSGlkZGVuID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iO1xuICB9KCk7XG5cbiAgdmFyIHJlZ2lzdGVyZWRFZmZlY3RzJDEgPSB7fTtcbiAgdmFyIGlkUHJlZml4ID0gJ2ZpbHRlcl9yZXN1bHRfJztcblxuICBmdW5jdGlvbiBTVkdFZmZlY3RzKGVsZW0pIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgc291cmNlID0gJ1NvdXJjZUdyYXBoaWMnO1xuICAgIHZhciBsZW4gPSBlbGVtLmRhdGEuZWYgPyBlbGVtLmRhdGEuZWYubGVuZ3RoIDogMDtcbiAgICB2YXIgZmlsSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICB2YXIgZmlsID0gZmlsdGVyc0ZhY3RvcnkuY3JlYXRlRmlsdGVyKGZpbElkLCB0cnVlKTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHRoaXMuZmlsdGVycyA9IFtdO1xuICAgIHZhciBmaWx0ZXJNYW5hZ2VyO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBmaWx0ZXJNYW5hZ2VyID0gbnVsbDtcbiAgICAgIHZhciB0eXBlID0gZWxlbS5kYXRhLmVmW2ldLnR5O1xuXG4gICAgICBpZiAocmVnaXN0ZXJlZEVmZmVjdHMkMVt0eXBlXSkge1xuICAgICAgICB2YXIgRWZmZWN0ID0gcmVnaXN0ZXJlZEVmZmVjdHMkMVt0eXBlXS5lZmZlY3Q7XG4gICAgICAgIGZpbHRlck1hbmFnZXIgPSBuZXcgRWZmZWN0KGZpbCwgZWxlbS5lZmZlY3RzTWFuYWdlci5lZmZlY3RFbGVtZW50c1tpXSwgZWxlbSwgaWRQcmVmaXggKyBjb3VudCwgc291cmNlKTtcbiAgICAgICAgc291cmNlID0gaWRQcmVmaXggKyBjb3VudDtcblxuICAgICAgICBpZiAocmVnaXN0ZXJlZEVmZmVjdHMkMVt0eXBlXS5jb3VudHNBc0VmZmVjdCkge1xuICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbHRlck1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJzLnB1c2goZmlsdGVyTWFuYWdlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBlbGVtLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChmaWwpO1xuICAgICAgZWxlbS5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmaWx0ZXInLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGZpbElkICsgJyknKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgZWxlbS5hZGRSZW5kZXJhYmxlQ29tcG9uZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIFNWR0VmZmVjdHMucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKF9pc0ZpcnN0RnJhbWUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5maWx0ZXJzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy5maWx0ZXJzW2ldLnJlbmRlckZyYW1lKF9pc0ZpcnN0RnJhbWUpO1xuICAgIH1cbiAgfTtcblxuICBTVkdFZmZlY3RzLnByb3RvdHlwZS5nZXRFZmZlY3RzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5maWx0ZXJzLmxlbmd0aDtcbiAgICB2YXIgZWZmZWN0cyA9IFtdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5maWx0ZXJzW2ldLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgZWZmZWN0cy5wdXNoKHRoaXMuZmlsdGVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVmZmVjdHM7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJFZmZlY3QkMShpZCwgZWZmZWN0LCBjb3VudHNBc0VmZmVjdCkge1xuICAgIHJlZ2lzdGVyZWRFZmZlY3RzJDFbaWRdID0ge1xuICAgICAgZWZmZWN0OiBlZmZlY3QsXG4gICAgICBjb3VudHNBc0VmZmVjdDogY291bnRzQXNFZmZlY3RcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gU1ZHQmFzZUVsZW1lbnQoKSB7fVxuXG4gIFNWR0Jhc2VFbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgICBpbml0UmVuZGVyZXJFbGVtZW50OiBmdW5jdGlvbiBpbml0UmVuZGVyZXJFbGVtZW50KCkge1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQgPSBjcmVhdGVOUygnZycpO1xuICAgIH0sXG4gICAgY3JlYXRlQ29udGFpbmVyRWxlbWVudHM6IGZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzKCkge1xuICAgICAgdGhpcy5tYXR0ZUVsZW1lbnQgPSBjcmVhdGVOUygnZycpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPSB0aGlzLmxheWVyRWxlbWVudDtcbiAgICAgIHRoaXMubWFza2VkRWxlbWVudCA9IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgICAgdGhpcy5fc2l6ZUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciBsYXllckVsZW1lbnRQYXJlbnQgPSBudWxsOyAvLyBJZiB0aGlzIGxheWVyIGFjdHMgYXMgYSBtYXNrIGZvciB0aGUgZm9sbG93aW5nIGxheWVyXG5cbiAgICAgIGlmICh0aGlzLmRhdGEudGQpIHtcbiAgICAgICAgdGhpcy5tYXR0ZU1hc2tzID0ge307XG4gICAgICAgIHZhciBnZyA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICAgIGdnLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmxheWVySWQpO1xuICAgICAgICBnZy5hcHBlbmRDaGlsZCh0aGlzLmxheWVyRWxlbWVudCk7XG4gICAgICAgIGxheWVyRWxlbWVudFBhcmVudCA9IGdnO1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChnZyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS50dCkge1xuICAgICAgICB0aGlzLm1hdHRlRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmxheWVyRWxlbWVudCk7XG4gICAgICAgIGxheWVyRWxlbWVudFBhcmVudCA9IHRoaXMubWF0dGVFbGVtZW50O1xuICAgICAgICB0aGlzLmJhc2VFbGVtZW50ID0gdGhpcy5tYXR0ZUVsZW1lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJhc2VFbGVtZW50ID0gdGhpcy5sYXllckVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRhdGEubG4pIHtcbiAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuZGF0YS5sbik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRhdGEuY2wpIHtcbiAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIHRoaXMuZGF0YS5jbCk7XG4gICAgICB9IC8vIENsaXBwaW5nIGNvbXBvc2l0aW9ucyB0byBoaWRlIGNvbnRlbnQgdGhhdCBleGNlZWRzIGJvdW5kYXJpZXMuIElmIGNvbGxhcHNlZCB0cmFuc2Zvcm1hdGlvbnMgaXMgb24sIGNvbXBvbmVudCBzaG91bGQgbm90IGJlIGNsaXBwZWRcblxuXG4gICAgICBpZiAodGhpcy5kYXRhLnR5ID09PSAwICYmICF0aGlzLmRhdGEuaGQpIHtcbiAgICAgICAgdmFyIGNwID0gY3JlYXRlTlMoJ2NsaXBQYXRoJyk7XG4gICAgICAgIHZhciBwdCA9IGNyZWF0ZU5TKCdwYXRoJyk7XG4gICAgICAgIHB0LnNldEF0dHJpYnV0ZSgnZCcsICdNMCwwIEwnICsgdGhpcy5kYXRhLncgKyAnLDAgTCcgKyB0aGlzLmRhdGEudyArICcsJyArIHRoaXMuZGF0YS5oICsgJyBMMCwnICsgdGhpcy5kYXRhLmggKyAneicpO1xuICAgICAgICB2YXIgY2xpcElkID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgICAgIGNwLnNldEF0dHJpYnV0ZSgnaWQnLCBjbGlwSWQpO1xuICAgICAgICBjcC5hcHBlbmRDaGlsZChwdCk7XG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKGNwKTtcblxuICAgICAgICBpZiAodGhpcy5jaGVja01hc2tzKCkpIHtcbiAgICAgICAgICB2YXIgY3BHcm91cCA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICAgICAgY3BHcm91cC5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgY2xpcElkICsgJyknKTtcbiAgICAgICAgICBjcEdyb3VwLmFwcGVuZENoaWxkKHRoaXMubGF5ZXJFbGVtZW50KTtcbiAgICAgICAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudCA9IGNwR3JvdXA7XG5cbiAgICAgICAgICBpZiAobGF5ZXJFbGVtZW50UGFyZW50KSB7XG4gICAgICAgICAgICBsYXllckVsZW1lbnRQYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhc2VFbGVtZW50ID0gdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xpcC1wYXRoJywgJ3VybCgnICsgZ2V0TG9jYXRpb25IcmVmKCkgKyAnIycgKyBjbGlwSWQgKyAnKScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRhdGEuYm0gIT09IDApIHtcbiAgICAgICAgdGhpcy5zZXRCbGVuZE1vZGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlckVsZW1lbnQ6IGZ1bmN0aW9uIHJlbmRlckVsZW1lbnQoKSB7XG4gICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fbG9jYWxNYXRNZGYpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCB0aGlzLmZpbmFsVHJhbnNmb3JtLmxvY2FsTWF0LnRvMmRDU1MoKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmZpbmFsVHJhbnNmb3JtLl9vcE1kZikge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCB0aGlzLmZpbmFsVHJhbnNmb3JtLmxvY2FsT3BhY2l0eSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZXN0cm95QmFzZUVsZW1lbnQ6IGZ1bmN0aW9uIGRlc3Ryb3lCYXNlRWxlbWVudCgpIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMubWF0dGVFbGVtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMubWFza01hbmFnZXIuZGVzdHJveSgpO1xuICAgIH0sXG4gICAgZ2V0QmFzZUVsZW1lbnQ6IGZ1bmN0aW9uIGdldEJhc2VFbGVtZW50KCkge1xuICAgICAgaWYgKHRoaXMuZGF0YS5oZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuYmFzZUVsZW1lbnQ7XG4gICAgfSxcbiAgICBjcmVhdGVSZW5kZXJhYmxlQ29tcG9uZW50czogZnVuY3Rpb24gY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHMoKSB7XG4gICAgICB0aGlzLm1hc2tNYW5hZ2VyID0gbmV3IE1hc2tFbGVtZW50KHRoaXMuZGF0YSwgdGhpcywgdGhpcy5nbG9iYWxEYXRhKTtcbiAgICAgIHRoaXMucmVuZGVyYWJsZUVmZmVjdHNNYW5hZ2VyID0gbmV3IFNWR0VmZmVjdHModGhpcyk7XG4gICAgICB0aGlzLnNlYXJjaEVmZmVjdFRyYW5zZm9ybXMoKTtcbiAgICB9LFxuICAgIGdldE1hdHRlOiBmdW5jdGlvbiBnZXRNYXR0ZShtYXR0ZVR5cGUpIHtcbiAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBiZSBhIGNvbW1vbiBjYXNlLiBCdXQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHdlJ2xsIGNyZWF0ZSB0aGUgbWF0dGUgb2JqZWN0LlxuICAgICAgLy8gSXQgc29sdmVzIGFuaW1hdGlvbnMgdGhhdCBoYXZlIHR3byBjb25zZWN1dGl2ZSBsYXllcnMgbWFya2VkIGFzIG1hdHRlIG1hc2tzLlxuICAgICAgLy8gV2hpY2ggaXMgYW4gdW5kZWZpbmVkIGJlaGF2aW9yIGluIEFFLlxuICAgICAgaWYgKCF0aGlzLm1hdHRlTWFza3MpIHtcbiAgICAgICAgdGhpcy5tYXR0ZU1hc2tzID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5tYXR0ZU1hc2tzW21hdHRlVHlwZV0pIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5sYXllcklkICsgJ18nICsgbWF0dGVUeXBlO1xuICAgICAgICB2YXIgZmlsSWQ7XG4gICAgICAgIHZhciBmaWw7XG4gICAgICAgIHZhciB1c2VFbGVtZW50O1xuICAgICAgICB2YXIgZ2c7XG5cbiAgICAgICAgaWYgKG1hdHRlVHlwZSA9PT0gMSB8fCBtYXR0ZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICB2YXIgbWFza2VyID0gY3JlYXRlTlMoJ21hc2snKTtcbiAgICAgICAgICBtYXNrZXIuc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgICBtYXNrZXIuc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCBtYXR0ZVR5cGUgPT09IDMgPyAnbHVtaW5hbmNlJyA6ICdhbHBoYScpO1xuICAgICAgICAgIHVzZUVsZW1lbnQgPSBjcmVhdGVOUygndXNlJyk7XG4gICAgICAgICAgdXNlRWxlbWVudC5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsICdocmVmJywgJyMnICsgdGhpcy5sYXllcklkKTtcbiAgICAgICAgICBtYXNrZXIuYXBwZW5kQ2hpbGQodXNlRWxlbWVudCk7XG4gICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQobWFza2VyKTtcblxuICAgICAgICAgIGlmICghZmVhdHVyZVN1cHBvcnQubWFza1R5cGUgJiYgbWF0dGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICBtYXNrZXIuc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCAnbHVtaW5hbmNlJyk7XG4gICAgICAgICAgICBmaWxJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgICAgICAgZmlsID0gZmlsdGVyc0ZhY3RvcnkuY3JlYXRlRmlsdGVyKGZpbElkKTtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKGZpbCk7XG4gICAgICAgICAgICBmaWwuYXBwZW5kQ2hpbGQoZmlsdGVyc0ZhY3RvcnkuY3JlYXRlQWxwaGFUb0x1bWluYW5jZUZpbHRlcigpKTtcbiAgICAgICAgICAgIGdnID0gY3JlYXRlTlMoJ2cnKTtcbiAgICAgICAgICAgIGdnLmFwcGVuZENoaWxkKHVzZUVsZW1lbnQpO1xuICAgICAgICAgICAgbWFza2VyLmFwcGVuZENoaWxkKGdnKTtcbiAgICAgICAgICAgIGdnLnNldEF0dHJpYnV0ZSgnZmlsdGVyJywgJ3VybCgnICsgZ2V0TG9jYXRpb25IcmVmKCkgKyAnIycgKyBmaWxJZCArICcpJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1hdHRlVHlwZSA9PT0gMikge1xuICAgICAgICAgIHZhciBtYXNrR3JvdXAgPSBjcmVhdGVOUygnbWFzaycpO1xuICAgICAgICAgIG1hc2tHcm91cC5zZXRBdHRyaWJ1dGUoJ2lkJywgaWQpO1xuICAgICAgICAgIG1hc2tHcm91cC5zZXRBdHRyaWJ1dGUoJ21hc2stdHlwZScsICdhbHBoYScpO1xuICAgICAgICAgIHZhciBtYXNrR3JvdXBlciA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICAgICAgbWFza0dyb3VwLmFwcGVuZENoaWxkKG1hc2tHcm91cGVyKTtcbiAgICAgICAgICBmaWxJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgICAgIGZpbCA9IGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUZpbHRlcihmaWxJZCk7IC8vLyAvXG5cbiAgICAgICAgICB2YXIgZmVDVHIgPSBjcmVhdGVOUygnZmVDb21wb25lbnRUcmFuc2ZlcicpO1xuICAgICAgICAgIGZlQ1RyLnNldEF0dHJpYnV0ZSgnaW4nLCAnU291cmNlR3JhcGhpYycpO1xuICAgICAgICAgIGZpbC5hcHBlbmRDaGlsZChmZUNUcik7XG4gICAgICAgICAgdmFyIGZlRnVuYyA9IGNyZWF0ZU5TKCdmZUZ1bmNBJyk7XG4gICAgICAgICAgZmVGdW5jLnNldEF0dHJpYnV0ZSgndHlwZScsICd0YWJsZScpO1xuICAgICAgICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgJzEuMCAwLjAnKTtcbiAgICAgICAgICBmZUNUci5hcHBlbmRDaGlsZChmZUZ1bmMpOyAvLy8gL1xuXG4gICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoZmlsKTtcbiAgICAgICAgICB2YXIgYWxwaGFSZWN0ID0gY3JlYXRlTlMoJ3JlY3QnKTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuY29tcC5kYXRhLncpO1xuICAgICAgICAgIGFscGhhUmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuY29tcC5kYXRhLmgpO1xuICAgICAgICAgIGFscGhhUmVjdC5zZXRBdHRyaWJ1dGUoJ3gnLCAnMCcpO1xuICAgICAgICAgIGFscGhhUmVjdC5zZXRBdHRyaWJ1dGUoJ3knLCAnMCcpO1xuICAgICAgICAgIGFscGhhUmVjdC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnI2ZmZmZmZicpO1xuICAgICAgICAgIGFscGhhUmVjdC5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCAnMCcpO1xuICAgICAgICAgIG1hc2tHcm91cGVyLnNldEF0dHJpYnV0ZSgnZmlsdGVyJywgJ3VybCgnICsgZ2V0TG9jYXRpb25IcmVmKCkgKyAnIycgKyBmaWxJZCArICcpJyk7XG4gICAgICAgICAgbWFza0dyb3VwZXIuYXBwZW5kQ2hpbGQoYWxwaGFSZWN0KTtcbiAgICAgICAgICB1c2VFbGVtZW50ID0gY3JlYXRlTlMoJ3VzZScpO1xuICAgICAgICAgIHVzZUVsZW1lbnQuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicsICcjJyArIHRoaXMubGF5ZXJJZCk7XG4gICAgICAgICAgbWFza0dyb3VwZXIuYXBwZW5kQ2hpbGQodXNlRWxlbWVudCk7XG5cbiAgICAgICAgICBpZiAoIWZlYXR1cmVTdXBwb3J0Lm1hc2tUeXBlKSB7XG4gICAgICAgICAgICBtYXNrR3JvdXAuc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCAnbHVtaW5hbmNlJyk7XG4gICAgICAgICAgICBmaWwuYXBwZW5kQ2hpbGQoZmlsdGVyc0ZhY3RvcnkuY3JlYXRlQWxwaGFUb0x1bWluYW5jZUZpbHRlcigpKTtcbiAgICAgICAgICAgIGdnID0gY3JlYXRlTlMoJ2cnKTtcbiAgICAgICAgICAgIG1hc2tHcm91cGVyLmFwcGVuZENoaWxkKGFscGhhUmVjdCk7XG4gICAgICAgICAgICBnZy5hcHBlbmRDaGlsZCh0aGlzLmxheWVyRWxlbWVudCk7XG4gICAgICAgICAgICBtYXNrR3JvdXBlci5hcHBlbmRDaGlsZChnZyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQobWFza0dyb3VwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWF0dGVNYXNrc1ttYXR0ZVR5cGVdID0gaWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm1hdHRlTWFza3NbbWF0dGVUeXBlXTtcbiAgICB9LFxuICAgIHNldE1hdHRlOiBmdW5jdGlvbiBzZXRNYXR0ZShpZCkge1xuICAgICAgaWYgKCF0aGlzLm1hdHRlRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWF0dGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWFzaycsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgaWQgKyAnKScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcclxuICAgKiBAZmlsZVxyXG4gICAqIEhhbmRsZXMgQUUncyBsYXllciBwYXJlbnRpbmcgcHJvcGVydHkuXHJcbiAgICpcclxuICAgKi9cbiAgZnVuY3Rpb24gSGllcmFyY2h5RWxlbWVudCgpIHt9XG5cbiAgSGllcmFyY2h5RWxlbWVudC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKiBJbml0aWFsaXplcyBoaWVyYXJjaHkgcHJvcGVydGllc1xyXG4gICAgICAgKlxyXG4gICAgICAgKi9cbiAgICBpbml0SGllcmFyY2h5OiBmdW5jdGlvbiBpbml0SGllcmFyY2h5KCkge1xuICAgICAgLy8gZWxlbWVudCdzIHBhcmVudCBsaXN0XG4gICAgICB0aGlzLmhpZXJhcmNoeSA9IFtdOyAvLyBpZiBlbGVtZW50IGlzIHBhcmVudCBvZiBhbm90aGVyIGxheWVyIF9pc1BhcmVudCB3aWxsIGJlIHRydWVcblxuICAgICAgdGhpcy5faXNQYXJlbnQgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2hlY2tQYXJlbnRpbmcoKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKiBTZXRzIGxheWVyJ3MgaGllcmFyY2h5LlxyXG4gICAgICAgKiBAcGFyYW0ge2FycmF5fSBoaWVyYXJjaFxyXG4gICAgICAgKiBsYXllcidzIHBhcmVudCBsaXN0XHJcbiAgICAgICAqXHJcbiAgICAgICAqL1xuICAgIHNldEhpZXJhcmNoeTogZnVuY3Rpb24gc2V0SGllcmFyY2h5KGhpZXJhcmNoeSkge1xuICAgICAgdGhpcy5oaWVyYXJjaHkgPSBoaWVyYXJjaHk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogU2V0cyBsYXllciBhcyBwYXJlbnQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqL1xuICAgIHNldEFzUGFyZW50OiBmdW5jdGlvbiBzZXRBc1BhcmVudCgpIHtcbiAgICAgIHRoaXMuX2lzUGFyZW50ID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKiBTZWFyY2hlcyBsYXllcidzIHBhcmVudGluZyBjaGFpblxyXG4gICAgICAgKlxyXG4gICAgICAgKi9cbiAgICBjaGVja1BhcmVudGluZzogZnVuY3Rpb24gY2hlY2tQYXJlbnRpbmcoKSB7XG4gICAgICBpZiAodGhpcy5kYXRhLnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuY29tcC5idWlsZEVsZW1lbnRQYXJlbnRpbmcodGhpcywgdGhpcy5kYXRhLnBhcmVudCwgW10pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBSZW5kZXJhYmxlRE9NRWxlbWVudCgpIHt9XG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3Byb3RvdHlwZSA9IHtcbiAgICAgIGluaXRFbGVtZW50OiBmdW5jdGlvbiBpbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgICAgIHRoaXMuaW5pdEZyYW1lKCk7XG4gICAgICAgIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgICAgICB0aGlzLmluaXRUcmFuc2Zvcm0oZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgICAgIHRoaXMuaW5pdEhpZXJhcmNoeSgpO1xuICAgICAgICB0aGlzLmluaXRSZW5kZXJhYmxlKCk7XG4gICAgICAgIHRoaXMuaW5pdFJlbmRlcmVyRWxlbWVudCgpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHMoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb250ZW50KCk7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfSxcbiAgICAgIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdISURFJywgdGhpcyk7XG4gICAgICAgIGlmICghdGhpcy5oaWRkZW4gJiYgKCF0aGlzLmlzSW5SYW5nZSB8fCB0aGlzLmlzVHJhbnNwYXJlbnQpKSB7XG4gICAgICAgICAgdmFyIGVsZW0gPSB0aGlzLmJhc2VFbGVtZW50IHx8IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICB0aGlzLmhpZGRlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnU0hPVycsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5pc0luUmFuZ2UgJiYgIXRoaXMuaXNUcmFuc3BhcmVudCkge1xuICAgICAgICAgIGlmICghdGhpcy5kYXRhLmhkKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXMuYmFzZUVsZW1lbnQgfHwgdGhpcy5sYXllckVsZW1lbnQ7XG4gICAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlbmRlckZyYW1lOiBmdW5jdGlvbiByZW5kZXJGcmFtZSgpIHtcbiAgICAgICAgLy8gSWYgaXQgaXMgZXhwb3J0ZWQgYXMgaGlkZGVuIChkYXRhLmhkID09PSB0cnVlKSBubyBuZWVkIHRvIHJlbmRlclxuICAgICAgICAvLyBJZiBpdCBpcyBub3QgdmlzaWJsZSBubyBuZWVkIHRvIHJlbmRlclxuICAgICAgICBpZiAodGhpcy5kYXRhLmhkIHx8IHRoaXMuaGlkZGVuKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW5kZXJUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy5yZW5kZXJSZW5kZXJhYmxlKCk7XG4gICAgICAgIHRoaXMucmVuZGVyTG9jYWxUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy5yZW5kZXJFbGVtZW50KCk7XG4gICAgICAgIHRoaXMucmVuZGVySW5uZXJDb250ZW50KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVuZGVySW5uZXJDb250ZW50OiBmdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQoKSB7fSxcbiAgICAgIHByZXBhcmVGcmFtZTogZnVuY3Rpb24gcHJlcGFyZUZyYW1lKG51bSkge1xuICAgICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmVwYXJlUmVuZGVyYWJsZUZyYW1lKG51bSk7XG4gICAgICAgIHRoaXMucHJlcGFyZVByb3BlcnRpZXMobnVtLCB0aGlzLmlzSW5SYW5nZSk7XG4gICAgICAgIHRoaXMuY2hlY2tUcmFuc3BhcmVuY3koKTtcbiAgICAgIH0sXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmlubmVyRWxlbSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVzdHJveUJhc2VFbGVtZW50KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHRlbmRQcm90b3R5cGUoW1JlbmRlcmFibGVFbGVtZW50LCBjcmVhdGVQcm94eUZ1bmN0aW9uKF9wcm90b3R5cGUpXSwgUmVuZGVyYWJsZURPTUVsZW1lbnQpO1xuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIElJbWFnZUVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMuYXNzZXREYXRhID0gZ2xvYmFsRGF0YS5nZXRBc3NldERhdGEoZGF0YS5yZWZJZCk7XG5cbiAgICBpZiAodGhpcy5hc3NldERhdGEgJiYgdGhpcy5hc3NldERhdGEuc2lkKSB7XG4gICAgICB0aGlzLmFzc2V0RGF0YSA9IGdsb2JhbERhdGEuc2xvdE1hbmFnZXIuZ2V0UHJvcCh0aGlzLmFzc2V0RGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICB0aGlzLnNvdXJjZVJlY3QgPSB7XG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgd2lkdGg6IHRoaXMuYXNzZXREYXRhLncsXG4gICAgICBoZWlnaHQ6IHRoaXMuYXNzZXREYXRhLmhcbiAgICB9O1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgU1ZHQmFzZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZURPTUVsZW1lbnRdLCBJSW1hZ2VFbGVtZW50KTtcblxuICBJSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhc3NldFBhdGggPSB0aGlzLmdsb2JhbERhdGEuZ2V0QXNzZXRzUGF0aCh0aGlzLmFzc2V0RGF0YSk7XG4gICAgdGhpcy5pbm5lckVsZW0gPSBjcmVhdGVOUygnaW1hZ2UnKTtcbiAgICB0aGlzLmlubmVyRWxlbS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5hc3NldERhdGEudyArICdweCcpO1xuICAgIHRoaXMuaW5uZXJFbGVtLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5hc3NldERhdGEuaCArICdweCcpO1xuICAgIHRoaXMuaW5uZXJFbGVtLnNldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsIHRoaXMuYXNzZXREYXRhLnByIHx8IHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJDb25maWcuaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvKTtcbiAgICB0aGlzLmlubmVyRWxlbS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsICdocmVmJywgYXNzZXRQYXRoKTtcbiAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmlubmVyRWxlbSk7XG4gIH07XG5cbiAgSUltYWdlRWxlbWVudC5wcm90b3R5cGUuc291cmNlUmVjdEF0VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2VSZWN0O1xuICB9O1xuXG4gIGZ1bmN0aW9uIFByb2Nlc3NlZEVsZW1lbnQoZWxlbWVudCwgcG9zaXRpb24pIHtcbiAgICB0aGlzLmVsZW0gPSBlbGVtZW50O1xuICAgIHRoaXMucG9zID0gcG9zaXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBJU2hhcGVFbGVtZW50KCkge31cblxuICBJU2hhcGVFbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgICBhZGRTaGFwZVRvTW9kaWZpZXJzOiBmdW5jdGlvbiBhZGRTaGFwZVRvTW9kaWZpZXJzKGRhdGEpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuc2hhcGVNb2RpZmllcnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5zaGFwZU1vZGlmaWVyc1tpXS5hZGRTaGFwZShkYXRhKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzU2hhcGVJbkFuaW1hdGVkTW9kaWZpZXJzOiBmdW5jdGlvbiBpc1NoYXBlSW5BbmltYXRlZE1vZGlmaWVycyhkYXRhKSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gdGhpcy5zaGFwZU1vZGlmaWVycy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGlmICh0aGlzLnNoYXBlTW9kaWZpZXJzW2ldLmlzQW5pbWF0ZWRXaXRoU2hhcGUoZGF0YSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICByZW5kZXJNb2RpZmllcnM6IGZ1bmN0aW9uIHJlbmRlck1vZGlmaWVycygpIHtcbiAgICAgIGlmICghdGhpcy5zaGFwZU1vZGlmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLnNoYXBlcy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB0aGlzLnNoYXBlc1tpXS5zaC5yZXNldCgpO1xuICAgICAgfVxuXG4gICAgICBsZW4gPSB0aGlzLnNoYXBlTW9kaWZpZXJzLmxlbmd0aDtcbiAgICAgIHZhciBzaG91bGRCcmVha1Byb2Nlc3M7XG5cbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHNob3VsZEJyZWFrUHJvY2VzcyA9IHRoaXMuc2hhcGVNb2RpZmllcnNbaV0ucHJvY2Vzc1NoYXBlcyh0aGlzLl9pc0ZpcnN0RnJhbWUpOyAvLyB3b3JrYXJvdW5kIHRvIGZpeCBjYXNlcyB3aGVyZSBhIHJlcGVhdGVyIHJlc2V0cyB0aGUgc2hhcGUgc28gdGhlIGZvbGxvd2luZyBwcm9jZXNzZXMgZ2V0IGNhbGxlZCB0d2ljZVxuICAgICAgICAvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIHNvbHV0aW9uIGZvciB0aGlzXG5cbiAgICAgICAgaWYgKHNob3VsZEJyZWFrUHJvY2Vzcykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzZWFyY2hQcm9jZXNzZWRFbGVtZW50OiBmdW5jdGlvbiBzZWFyY2hQcm9jZXNzZWRFbGVtZW50KGVsZW0pIHtcbiAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMucHJvY2Vzc2VkRWxlbWVudHM7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAoZWxlbWVudHNbaV0uZWxlbSA9PT0gZWxlbSkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50c1tpXS5wb3M7XG4gICAgICAgIH1cblxuICAgICAgICBpICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgYWRkUHJvY2Vzc2VkRWxlbWVudDogZnVuY3Rpb24gYWRkUHJvY2Vzc2VkRWxlbWVudChlbGVtLCBwb3MpIHtcbiAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMucHJvY2Vzc2VkRWxlbWVudHM7XG4gICAgICB2YXIgaSA9IGVsZW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGkpIHtcbiAgICAgICAgaSAtPSAxO1xuXG4gICAgICAgIGlmIChlbGVtZW50c1tpXS5lbGVtID09PSBlbGVtKSB7XG4gICAgICAgICAgZWxlbWVudHNbaV0ucG9zID0gcG9zO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbGVtZW50cy5wdXNoKG5ldyBQcm9jZXNzZWRFbGVtZW50KGVsZW0sIHBvcykpO1xuICAgIH0sXG4gICAgcHJlcGFyZUZyYW1lOiBmdW5jdGlvbiBwcmVwYXJlRnJhbWUobnVtKSB7XG4gICAgICB0aGlzLnByZXBhcmVSZW5kZXJhYmxlRnJhbWUobnVtKTtcbiAgICAgIHRoaXMucHJlcGFyZVByb3BlcnRpZXMobnVtLCB0aGlzLmlzSW5SYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBsaW5lQ2FwRW51bSA9IHtcbiAgICAxOiAnYnV0dCcsXG4gICAgMjogJ3JvdW5kJyxcbiAgICAzOiAnc3F1YXJlJ1xuICB9O1xuICB2YXIgbGluZUpvaW5FbnVtID0ge1xuICAgIDE6ICdtaXRlcicsXG4gICAgMjogJ3JvdW5kJyxcbiAgICAzOiAnYmV2ZWwnXG4gIH07XG5cbiAgZnVuY3Rpb24gU1ZHU2hhcGVEYXRhKHRyYW5zZm9ybWVycywgbGV2ZWwsIHNoYXBlKSB7XG4gICAgdGhpcy5jYWNoZXMgPSBbXTtcbiAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgIHRoaXMudHJhbnNmb3JtZXJzID0gdHJhbnNmb3JtZXJzO1xuICAgIHRoaXMubFN0ciA9ICcnO1xuICAgIHRoaXMuc2ggPSBzaGFwZTtcbiAgICB0aGlzLmx2bCA9IGxldmVsOyAvLyBUT0RPIGZpbmQgaWYgdGhlcmUgYXJlIHNvbWUgY2FzZXMgd2hlcmUgX2lzQW5pbWF0ZWQgY2FuIGJlIGZhbHNlLlxuICAgIC8vIEZvciBub3csIHNpbmNlIHNoYXBlcyBhZGQgdXAgd2l0aCBvdGhlciBzaGFwZXMuIFRoZXkgaGF2ZSB0byBiZSBjYWxjdWxhdGVkIGV2ZXJ5IHRpbWUuXG4gICAgLy8gT25lIHdheSBvZiBmaW5kaW5nIG91dCBpcyBjaGVja2luZyBpZiBhbGwgc3R5bGVzIGFzc29jaWF0ZWQgdG8gdGhpcyBzaGFwZSBkZXBlbmQgb25seSBvZiB0aGlzIHNoYXBlXG5cbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gISFzaGFwZS5rOyAvLyBUT0RPOiBjb21tZW50aW5nIHRoaXMgZm9yIG5vdyBzaW5jZSBhbGwgc2hhcGVzIGFyZSBhbmltYXRlZFxuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1lcnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGlmICh0cmFuc2Zvcm1lcnNbaV0ubVByb3BzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9pc0FuaW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMTtcbiAgICB9XG4gIH1cblxuICBTVkdTaGFwZURhdGEucHJvdG90eXBlLnNldEFzQW5pbWF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faXNBbmltYXRlZCA9IHRydWU7XG4gIH07XG5cbiAgZnVuY3Rpb24gU1ZHU3R5bGVEYXRhKGRhdGEsIGxldmVsKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnR5cGUgPSBkYXRhLnR5O1xuICAgIHRoaXMuZCA9ICcnO1xuICAgIHRoaXMubHZsID0gbGV2ZWw7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgdGhpcy5jbG9zZWQgPSBkYXRhLmhkID09PSB0cnVlO1xuICAgIHRoaXMucEVsZW0gPSBjcmVhdGVOUygncGF0aCcpO1xuICAgIHRoaXMubXNFbGVtID0gbnVsbDtcbiAgfVxuXG4gIFNWR1N0eWxlRGF0YS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kID0gJyc7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gIH07XG5cbiAgZnVuY3Rpb24gRGFzaFByb3BlcnR5KGVsZW0sIGRhdGEsIHJlbmRlcmVyLCBjb250YWluZXIpIHtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xuICAgIHRoaXMuZGF0YVByb3BzID0gY3JlYXRlU2l6ZWRBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMuayA9IGZhbHNlO1xuICAgIHRoaXMuZGFzaFN0ciA9ICcnO1xuICAgIHRoaXMuZGFzaEFycmF5ID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGRhdGEubGVuZ3RoID8gZGF0YS5sZW5ndGggLSAxIDogMCk7XG4gICAgdGhpcy5kYXNob2Zmc2V0ID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIDEpO1xuICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBkYXRhLmxlbmd0aCB8fCAwO1xuICAgIHZhciBwcm9wO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBwcm9wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YVtpXS52LCAwLCAwLCB0aGlzKTtcbiAgICAgIHRoaXMuayA9IHByb3AuayB8fCB0aGlzLms7XG4gICAgICB0aGlzLmRhdGFQcm9wc1tpXSA9IHtcbiAgICAgICAgbjogZGF0YVtpXS5uLFxuICAgICAgICBwOiBwcm9wXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghdGhpcy5rKSB7XG4gICAgICB0aGlzLmdldFZhbHVlKHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSB0aGlzLms7XG4gIH1cblxuICBEYXNoUHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgaWYgKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCAmJiAhZm9yY2VSZW5kZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xuICAgIHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5fbWRmID0gdGhpcy5fbWRmIHx8IGZvcmNlUmVuZGVyO1xuXG4gICAgaWYgKHRoaXMuX21kZikge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZGF0YVByb3BzLmxlbmd0aDtcblxuICAgICAgaWYgKHRoaXMucmVuZGVyZXIgPT09ICdzdmcnKSB7XG4gICAgICAgIHRoaXMuZGFzaFN0ciA9ICcnO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVByb3BzW2ldLm4gIT09ICdvJykge1xuICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVyID09PSAnc3ZnJykge1xuICAgICAgICAgICAgdGhpcy5kYXNoU3RyICs9ICcgJyArIHRoaXMuZGF0YVByb3BzW2ldLnAudjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXNoQXJyYXlbaV0gPSB0aGlzLmRhdGFQcm9wc1tpXS5wLnY7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGFzaG9mZnNldFswXSA9IHRoaXMuZGF0YVByb3BzW2ldLnAudjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIERhc2hQcm9wZXJ0eSk7XG5cbiAgZnVuY3Rpb24gU1ZHU3Ryb2tlU3R5bGVEYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpIHtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzO1xuICAgIHRoaXMubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubywgMCwgMC4wMSwgdGhpcyk7XG4gICAgdGhpcy53ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS53LCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLmQgPSBuZXcgRGFzaFByb3BlcnR5KGVsZW0sIGRhdGEuZCB8fCB7fSwgJ3N2ZycsIHRoaXMpO1xuICAgIHRoaXMuYyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuYywgMSwgMjU1LCB0aGlzKTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGVPYjtcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLl9pc0FuaW1hdGVkO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBTVkdTdHJva2VTdHlsZURhdGEpO1xuXG4gIGZ1bmN0aW9uIFNWR0ZpbGxTdHlsZURhdGEoZWxlbSwgZGF0YSwgc3R5bGVPYikge1xuICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcbiAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXM7XG4gICAgdGhpcy5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5vLCAwLCAwLjAxLCB0aGlzKTtcbiAgICB0aGlzLmMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmMsIDEsIDI1NSwgdGhpcyk7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlT2I7XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFNWR0ZpbGxTdHlsZURhdGEpO1xuXG4gIGZ1bmN0aW9uIFNWR05vU3R5bGVEYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpIHtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzO1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZU9iO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBTVkdOb1N0eWxlRGF0YSk7XG5cbiAgZnVuY3Rpb24gR3JhZGllbnRQcm9wZXJ0eShlbGVtLCBkYXRhLCBjb250YWluZXIpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuYyA9IGNyZWF0ZVR5cGVkQXJyYXkoJ3VpbnQ4YycsIGRhdGEucCAqIDQpO1xuICAgIHZhciBjTGVuZ3RoID0gZGF0YS5rLmtbMF0ucyA/IGRhdGEuay5rWzBdLnMubGVuZ3RoIC0gZGF0YS5wICogNCA6IGRhdGEuay5rLmxlbmd0aCAtIGRhdGEucCAqIDQ7XG4gICAgdGhpcy5vID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGNMZW5ndGgpO1xuICAgIHRoaXMuX2NtZGYgPSBmYWxzZTtcbiAgICB0aGlzLl9vbWRmID0gZmFsc2U7XG4gICAgdGhpcy5fY29sbGFwc2FibGUgPSB0aGlzLmNoZWNrQ29sbGFwc2FibGUoKTtcbiAgICB0aGlzLl9oYXNPcGFjaXR5ID0gY0xlbmd0aDtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoY29udGFpbmVyKTtcbiAgICB0aGlzLnByb3AgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmssIDEsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMuayA9IHRoaXMucHJvcC5rO1xuICAgIHRoaXMuZ2V0VmFsdWUodHJ1ZSk7XG4gIH1cblxuICBHcmFkaWVudFByb3BlcnR5LnByb3RvdHlwZS5jb21wYXJlUG9pbnRzID0gZnVuY3Rpb24gKHZhbHVlcywgcG9pbnRzKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0aGlzLm8ubGVuZ3RoIC8gMjtcbiAgICB2YXIgZGlmZjtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBkaWZmID0gTWF0aC5hYnModmFsdWVzW2kgKiA0XSAtIHZhbHVlc1twb2ludHMgKiA0ICsgaSAqIDJdKTtcblxuICAgICAgaWYgKGRpZmYgPiAwLjAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIEdyYWRpZW50UHJvcGVydHkucHJvdG90eXBlLmNoZWNrQ29sbGFwc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuby5sZW5ndGggLyAyICE9PSB0aGlzLmMubGVuZ3RoIC8gNCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRhdGEuay5rWzBdLnMpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmRhdGEuay5rLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBhcmVQb2ludHModGhpcy5kYXRhLmsua1tpXS5zLCB0aGlzLmRhdGEucCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpICs9IDE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdGhpcy5jb21wYXJlUG9pbnRzKHRoaXMuZGF0YS5rLmssIHRoaXMuZGF0YS5wKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIEdyYWRpZW50UHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgdGhpcy5wcm9wLmdldFZhbHVlKCk7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgdGhpcy5fY21kZiA9IGZhbHNlO1xuICAgIHRoaXMuX29tZGYgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnByb3AuX21kZiB8fCBmb3JjZVJlbmRlcikge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gdGhpcy5kYXRhLnAgKiA0O1xuICAgICAgdmFyIG11bHQ7XG4gICAgICB2YXIgdmFsO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgbXVsdCA9IGkgJSA0ID09PSAwID8gMTAwIDogMjU1O1xuICAgICAgICB2YWwgPSBNYXRoLnJvdW5kKHRoaXMucHJvcC52W2ldICogbXVsdCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY1tpXSAhPT0gdmFsKSB7XG4gICAgICAgICAgdGhpcy5jW2ldID0gdmFsO1xuICAgICAgICAgIHRoaXMuX2NtZGYgPSAhZm9yY2VSZW5kZXI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuby5sZW5ndGgpIHtcbiAgICAgICAgbGVuID0gdGhpcy5wcm9wLnYubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IHRoaXMuZGF0YS5wICogNDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgbXVsdCA9IGkgJSAyID09PSAwID8gMTAwIDogMTtcbiAgICAgICAgICB2YWwgPSBpICUgMiA9PT0gMCA/IE1hdGgucm91bmQodGhpcy5wcm9wLnZbaV0gKiAxMDApIDogdGhpcy5wcm9wLnZbaV07XG5cbiAgICAgICAgICBpZiAodGhpcy5vW2kgLSB0aGlzLmRhdGEucCAqIDRdICE9PSB2YWwpIHtcbiAgICAgICAgICAgIHRoaXMub1tpIC0gdGhpcy5kYXRhLnAgKiA0XSA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMuX29tZGYgPSAhZm9yY2VSZW5kZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21kZiA9ICFmb3JjZVJlbmRlcjtcbiAgICB9XG4gIH07XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBHcmFkaWVudFByb3BlcnR5KTtcblxuICBmdW5jdGlvbiBTVkdHcmFkaWVudEZpbGxTdHlsZURhdGEoZWxlbSwgZGF0YSwgc3R5bGVPYikge1xuICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcbiAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXM7XG4gICAgdGhpcy5pbml0R3JhZGllbnREYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpO1xuICB9XG5cbiAgU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhLnByb3RvdHlwZS5pbml0R3JhZGllbnREYXRhID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEsIHN0eWxlT2IpIHtcbiAgICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm8sIDAsIDAuMDEsIHRoaXMpO1xuICAgIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucywgMSwgbnVsbCwgdGhpcyk7XG4gICAgdGhpcy5lID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5lLCAxLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLmggPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmggfHwge1xuICAgICAgazogMFxuICAgIH0sIDAsIDAuMDEsIHRoaXMpO1xuICAgIHRoaXMuYSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuYSB8fCB7XG4gICAgICBrOiAwXG4gICAgfSwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcbiAgICB0aGlzLmcgPSBuZXcgR3JhZGllbnRQcm9wZXJ0eShlbGVtLCBkYXRhLmcsIHRoaXMpO1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZU9iO1xuICAgIHRoaXMuc3RvcHMgPSBbXTtcbiAgICB0aGlzLnNldEdyYWRpZW50RGF0YShzdHlsZU9iLnBFbGVtLCBkYXRhKTtcbiAgICB0aGlzLnNldEdyYWRpZW50T3BhY2l0eShkYXRhLCBzdHlsZU9iKTtcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLl9pc0FuaW1hdGVkO1xuICB9O1xuXG4gIFNWR0dyYWRpZW50RmlsbFN0eWxlRGF0YS5wcm90b3R5cGUuc2V0R3JhZGllbnREYXRhID0gZnVuY3Rpb24gKHBhdGhFbGVtZW50LCBkYXRhKSB7XG4gICAgdmFyIGdyYWRpZW50SWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICB2YXIgZ2ZpbGwgPSBjcmVhdGVOUyhkYXRhLnQgPT09IDEgPyAnbGluZWFyR3JhZGllbnQnIDogJ3JhZGlhbEdyYWRpZW50Jyk7XG4gICAgZ2ZpbGwuc2V0QXR0cmlidXRlKCdpZCcsIGdyYWRpZW50SWQpO1xuICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgnc3ByZWFkTWV0aG9kJywgJ3BhZCcpO1xuICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgnZ3JhZGllbnRVbml0cycsICd1c2VyU3BhY2VPblVzZScpO1xuICAgIHZhciBzdG9wcyA9IFtdO1xuICAgIHZhciBzdG9wO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIGpMZW4gPSBkYXRhLmcucCAqIDQ7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSA0KSB7XG4gICAgICBzdG9wID0gY3JlYXRlTlMoJ3N0b3AnKTtcbiAgICAgIGdmaWxsLmFwcGVuZENoaWxkKHN0b3ApO1xuICAgICAgc3RvcHMucHVzaChzdG9wKTtcbiAgICB9XG5cbiAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoZGF0YS50eSA9PT0gJ2dmJyA/ICdmaWxsJyA6ICdzdHJva2UnLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGdyYWRpZW50SWQgKyAnKScpO1xuICAgIHRoaXMuZ2YgPSBnZmlsbDtcbiAgICB0aGlzLmNzdCA9IHN0b3BzO1xuICB9O1xuXG4gIFNWR0dyYWRpZW50RmlsbFN0eWxlRGF0YS5wcm90b3R5cGUuc2V0R3JhZGllbnRPcGFjaXR5ID0gZnVuY3Rpb24gKGRhdGEsIHN0eWxlT2IpIHtcbiAgICBpZiAodGhpcy5nLl9oYXNPcGFjaXR5ICYmICF0aGlzLmcuX2NvbGxhcHNhYmxlKSB7XG4gICAgICB2YXIgc3RvcDtcbiAgICAgIHZhciBqO1xuICAgICAgdmFyIGpMZW47XG4gICAgICB2YXIgbWFzayA9IGNyZWF0ZU5TKCdtYXNrJyk7XG4gICAgICB2YXIgbWFza0VsZW1lbnQgPSBjcmVhdGVOUygncGF0aCcpO1xuICAgICAgbWFzay5hcHBlbmRDaGlsZChtYXNrRWxlbWVudCk7XG4gICAgICB2YXIgb3BhY2l0eUlkID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgICB2YXIgbWFza0lkID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgICBtYXNrLnNldEF0dHJpYnV0ZSgnaWQnLCBtYXNrSWQpO1xuICAgICAgdmFyIG9wRmlsbCA9IGNyZWF0ZU5TKGRhdGEudCA9PT0gMSA/ICdsaW5lYXJHcmFkaWVudCcgOiAncmFkaWFsR3JhZGllbnQnKTtcbiAgICAgIG9wRmlsbC5zZXRBdHRyaWJ1dGUoJ2lkJywgb3BhY2l0eUlkKTtcbiAgICAgIG9wRmlsbC5zZXRBdHRyaWJ1dGUoJ3NwcmVhZE1ldGhvZCcsICdwYWQnKTtcbiAgICAgIG9wRmlsbC5zZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKTtcbiAgICAgIGpMZW4gPSBkYXRhLmcuay5rWzBdLnMgPyBkYXRhLmcuay5rWzBdLnMubGVuZ3RoIDogZGF0YS5nLmsuay5sZW5ndGg7XG4gICAgICB2YXIgc3RvcHMgPSB0aGlzLnN0b3BzO1xuXG4gICAgICBmb3IgKGogPSBkYXRhLmcucCAqIDQ7IGogPCBqTGVuOyBqICs9IDIpIHtcbiAgICAgICAgc3RvcCA9IGNyZWF0ZU5TKCdzdG9wJyk7XG4gICAgICAgIHN0b3Auc2V0QXR0cmlidXRlKCdzdG9wLWNvbG9yJywgJ3JnYigyNTUsMjU1LDI1NSknKTtcbiAgICAgICAgb3BGaWxsLmFwcGVuZENoaWxkKHN0b3ApO1xuICAgICAgICBzdG9wcy5wdXNoKHN0b3ApO1xuICAgICAgfVxuXG4gICAgICBtYXNrRWxlbWVudC5zZXRBdHRyaWJ1dGUoZGF0YS50eSA9PT0gJ2dmJyA/ICdmaWxsJyA6ICdzdHJva2UnLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIG9wYWNpdHlJZCArICcpJyk7XG5cbiAgICAgIGlmIChkYXRhLnR5ID09PSAnZ3MnKSB7XG4gICAgICAgIG1hc2tFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCBsaW5lQ2FwRW51bVtkYXRhLmxjIHx8IDJdKTtcbiAgICAgICAgbWFza0VsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCBsaW5lSm9pbkVudW1bZGF0YS5saiB8fCAyXSk7XG5cbiAgICAgICAgaWYgKGRhdGEubGogPT09IDEpIHtcbiAgICAgICAgICBtYXNrRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1taXRlcmxpbWl0JywgZGF0YS5tbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5vZiA9IG9wRmlsbDtcbiAgICAgIHRoaXMubXMgPSBtYXNrO1xuICAgICAgdGhpcy5vc3QgPSBzdG9wcztcbiAgICAgIHRoaXMubWFza0lkID0gbWFza0lkO1xuICAgICAgc3R5bGVPYi5tc0VsZW0gPSBtYXNrRWxlbWVudDtcbiAgICB9XG4gIH07XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBTVkdHcmFkaWVudEZpbGxTdHlsZURhdGEpO1xuXG4gIGZ1bmN0aW9uIFNWR0dyYWRpZW50U3Ryb2tlU3R5bGVEYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpIHtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzO1xuICAgIHRoaXMudyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudywgMCwgbnVsbCwgdGhpcyk7XG4gICAgdGhpcy5kID0gbmV3IERhc2hQcm9wZXJ0eShlbGVtLCBkYXRhLmQgfHwge30sICdzdmcnLCB0aGlzKTtcbiAgICB0aGlzLmluaXRHcmFkaWVudERhdGEoZWxlbSwgZGF0YSwgc3R5bGVPYik7XG4gICAgdGhpcy5faXNBbmltYXRlZCA9ICEhdGhpcy5faXNBbmltYXRlZDtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhLCBEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBTVkdHcmFkaWVudFN0cm9rZVN0eWxlRGF0YSk7XG5cbiAgZnVuY3Rpb24gU2hhcGVHcm91cERhdGEoKSB7XG4gICAgdGhpcy5pdCA9IFtdO1xuICAgIHRoaXMucHJldlZpZXdEYXRhID0gW107XG4gICAgdGhpcy5nciA9IGNyZWF0ZU5TKCdnJyk7XG4gIH1cblxuICBmdW5jdGlvbiBTVkdUcmFuc2Zvcm1EYXRhKG1Qcm9wcywgb3AsIGNvbnRhaW5lcikge1xuICAgIHRoaXMudHJhbnNmb3JtID0ge1xuICAgICAgbVByb3BzOiBtUHJvcHMsXG4gICAgICBvcDogb3AsXG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lclxuICAgIH07XG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSB0aGlzLnRyYW5zZm9ybS5tUHJvcHMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoIHx8IHRoaXMudHJhbnNmb3JtLm9wLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGg7XG4gIH1cblxuICB2YXIgYnVpbGRTaGFwZVN0cmluZyA9IGZ1bmN0aW9uIGJ1aWxkU2hhcGVTdHJpbmcocGF0aE5vZGVzLCBsZW5ndGgsIGNsb3NlZCwgbWF0KSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHZhciBfbyA9IHBhdGhOb2Rlcy5vO1xuICAgIHZhciBfaSA9IHBhdGhOb2Rlcy5pO1xuICAgIHZhciBfdiA9IHBhdGhOb2Rlcy52O1xuICAgIHZhciBpO1xuICAgIHZhciBzaGFwZVN0cmluZyA9ICcgTScgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX3ZbMF1bMF0sIF92WzBdWzFdKTtcblxuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgc2hhcGVTdHJpbmcgKz0gJyBDJyArIG1hdC5hcHBseVRvUG9pbnRTdHJpbmdpZmllZChfb1tpIC0gMV1bMF0sIF9vW2kgLSAxXVsxXSkgKyAnICcgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX2lbaV1bMF0sIF9pW2ldWzFdKSArICcgJyArIG1hdC5hcHBseVRvUG9pbnRTdHJpbmdpZmllZChfdltpXVswXSwgX3ZbaV1bMV0pO1xuICAgIH1cblxuICAgIGlmIChjbG9zZWQgJiYgbGVuZ3RoKSB7XG4gICAgICBzaGFwZVN0cmluZyArPSAnIEMnICsgbWF0LmFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKF9vW2kgLSAxXVswXSwgX29baSAtIDFdWzFdKSArICcgJyArIG1hdC5hcHBseVRvUG9pbnRTdHJpbmdpZmllZChfaVswXVswXSwgX2lbMF1bMV0pICsgJyAnICsgbWF0LmFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKF92WzBdWzBdLCBfdlswXVsxXSk7XG4gICAgICBzaGFwZVN0cmluZyArPSAneic7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYXBlU3RyaW5nO1xuICB9O1xuXG4gIHZhciBTVkdFbGVtZW50c1JlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfaWRlbnRpdHlNYXRyaXggPSBuZXcgTWF0cml4KCk7XG5cbiAgICB2YXIgX21hdHJpeEhlbHBlciA9IG5ldyBNYXRyaXgoKTtcblxuICAgIHZhciBvYiA9IHtcbiAgICAgIGNyZWF0ZVJlbmRlckZ1bmN0aW9uOiBjcmVhdGVSZW5kZXJGdW5jdGlvblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVSZW5kZXJGdW5jdGlvbihkYXRhKSB7XG4gICAgICBzd2l0Y2ggKGRhdGEudHkpIHtcbiAgICAgICAgY2FzZSAnZmwnOlxuICAgICAgICAgIHJldHVybiByZW5kZXJGaWxsO1xuXG4gICAgICAgIGNhc2UgJ2dmJzpcbiAgICAgICAgICByZXR1cm4gcmVuZGVyR3JhZGllbnQ7XG5cbiAgICAgICAgY2FzZSAnZ3MnOlxuICAgICAgICAgIHJldHVybiByZW5kZXJHcmFkaWVudFN0cm9rZTtcblxuICAgICAgICBjYXNlICdzdCc6XG4gICAgICAgICAgcmV0dXJuIHJlbmRlclN0cm9rZTtcblxuICAgICAgICBjYXNlICdzaCc6XG4gICAgICAgIGNhc2UgJ2VsJzpcbiAgICAgICAgY2FzZSAncmMnOlxuICAgICAgICBjYXNlICdzcic6XG4gICAgICAgICAgcmV0dXJuIHJlbmRlclBhdGg7XG5cbiAgICAgICAgY2FzZSAndHInOlxuICAgICAgICAgIHJldHVybiByZW5kZXJDb250ZW50VHJhbnNmb3JtO1xuXG4gICAgICAgIGNhc2UgJ25vJzpcbiAgICAgICAgICByZXR1cm4gcmVuZGVyTm9vcDtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlckNvbnRlbnRUcmFuc2Zvcm0oc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICBpZiAoaXNGaXJzdEZyYW1lIHx8IGl0ZW1EYXRhLnRyYW5zZm9ybS5vcC5fbWRmKSB7XG4gICAgICAgIGl0ZW1EYXRhLnRyYW5zZm9ybS5jb250YWluZXIuc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgaXRlbURhdGEudHJhbnNmb3JtLm9wLnYpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGaXJzdEZyYW1lIHx8IGl0ZW1EYXRhLnRyYW5zZm9ybS5tUHJvcHMuX21kZikge1xuICAgICAgICBpdGVtRGF0YS50cmFuc2Zvcm0uY29udGFpbmVyLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgaXRlbURhdGEudHJhbnNmb3JtLm1Qcm9wcy52LnRvMmRDU1MoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyTm9vcCgpIHt9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJQYXRoKHN0eWxlRGF0YSwgaXRlbURhdGEsIGlzRmlyc3RGcmFtZSkge1xuICAgICAgdmFyIGo7XG4gICAgICB2YXIgakxlbjtcbiAgICAgIHZhciBwYXRoU3RyaW5nVHJhbnNmb3JtZWQ7XG4gICAgICB2YXIgcmVkcmF3O1xuICAgICAgdmFyIHBhdGhOb2RlcztcbiAgICAgIHZhciBsO1xuICAgICAgdmFyIGxMZW4gPSBpdGVtRGF0YS5zdHlsZXMubGVuZ3RoO1xuICAgICAgdmFyIGx2bCA9IGl0ZW1EYXRhLmx2bDtcbiAgICAgIHZhciBwYXRocztcbiAgICAgIHZhciBtYXQ7XG4gICAgICB2YXIgaXRlcmF0aW9ucztcbiAgICAgIHZhciBrO1xuXG4gICAgICBmb3IgKGwgPSAwOyBsIDwgbExlbjsgbCArPSAxKSB7XG4gICAgICAgIHJlZHJhdyA9IGl0ZW1EYXRhLnNoLl9tZGYgfHwgaXNGaXJzdEZyYW1lO1xuXG4gICAgICAgIGlmIChpdGVtRGF0YS5zdHlsZXNbbF0ubHZsIDwgbHZsKSB7XG4gICAgICAgICAgbWF0ID0gX21hdHJpeEhlbHBlci5yZXNldCgpO1xuICAgICAgICAgIGl0ZXJhdGlvbnMgPSBsdmwgLSBpdGVtRGF0YS5zdHlsZXNbbF0ubHZsO1xuICAgICAgICAgIGsgPSBpdGVtRGF0YS50cmFuc2Zvcm1lcnMubGVuZ3RoIC0gMTtcblxuICAgICAgICAgIHdoaWxlICghcmVkcmF3ICYmIGl0ZXJhdGlvbnMgPiAwKSB7XG4gICAgICAgICAgICByZWRyYXcgPSBpdGVtRGF0YS50cmFuc2Zvcm1lcnNba10ubVByb3BzLl9tZGYgfHwgcmVkcmF3O1xuICAgICAgICAgICAgaXRlcmF0aW9ucyAtPSAxO1xuICAgICAgICAgICAgayAtPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZWRyYXcpIHtcbiAgICAgICAgICAgIGl0ZXJhdGlvbnMgPSBsdmwgLSBpdGVtRGF0YS5zdHlsZXNbbF0ubHZsO1xuICAgICAgICAgICAgayA9IGl0ZW1EYXRhLnRyYW5zZm9ybWVycy5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICB3aGlsZSAoaXRlcmF0aW9ucyA+IDApIHtcbiAgICAgICAgICAgICAgbWF0Lm11bHRpcGx5KGl0ZW1EYXRhLnRyYW5zZm9ybWVyc1trXS5tUHJvcHMudik7XG4gICAgICAgICAgICAgIGl0ZXJhdGlvbnMgLT0gMTtcbiAgICAgICAgICAgICAgayAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXQgPSBfaWRlbnRpdHlNYXRyaXg7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRocyA9IGl0ZW1EYXRhLnNoLnBhdGhzO1xuICAgICAgICBqTGVuID0gcGF0aHMuX2xlbmd0aDtcblxuICAgICAgICBpZiAocmVkcmF3KSB7XG4gICAgICAgICAgcGF0aFN0cmluZ1RyYW5zZm9ybWVkID0gJyc7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBwYXRoTm9kZXMgPSBwYXRocy5zaGFwZXNbal07XG5cbiAgICAgICAgICAgIGlmIChwYXRoTm9kZXMgJiYgcGF0aE5vZGVzLl9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcGF0aFN0cmluZ1RyYW5zZm9ybWVkICs9IGJ1aWxkU2hhcGVTdHJpbmcocGF0aE5vZGVzLCBwYXRoTm9kZXMuX2xlbmd0aCwgcGF0aE5vZGVzLmMsIG1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXRlbURhdGEuY2FjaGVzW2xdID0gcGF0aFN0cmluZ1RyYW5zZm9ybWVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGhTdHJpbmdUcmFuc2Zvcm1lZCA9IGl0ZW1EYXRhLmNhY2hlc1tsXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW1EYXRhLnN0eWxlc1tsXS5kICs9IHN0eWxlRGF0YS5oZCA9PT0gdHJ1ZSA/ICcnIDogcGF0aFN0cmluZ1RyYW5zZm9ybWVkO1xuICAgICAgICBpdGVtRGF0YS5zdHlsZXNbbF0uX21kZiA9IHJlZHJhdyB8fCBpdGVtRGF0YS5zdHlsZXNbbF0uX21kZjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJGaWxsKHN0eWxlRGF0YSwgaXRlbURhdGEsIGlzRmlyc3RGcmFtZSkge1xuICAgICAgdmFyIHN0eWxlRWxlbSA9IGl0ZW1EYXRhLnN0eWxlO1xuXG4gICAgICBpZiAoaXRlbURhdGEuYy5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICBzdHlsZUVsZW0ucEVsZW0uc2V0QXR0cmlidXRlKCdmaWxsJywgJ3JnYignICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMF0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMV0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMl0pICsgJyknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1EYXRhLm8uX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnZmlsbC1vcGFjaXR5JywgaXRlbURhdGEuby52KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJHcmFkaWVudFN0cm9rZShzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHJlbmRlckdyYWRpZW50KHN0eWxlRGF0YSwgaXRlbURhdGEsIGlzRmlyc3RGcmFtZSk7XG4gICAgICByZW5kZXJTdHJva2Uoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJHcmFkaWVudChzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBnZmlsbCA9IGl0ZW1EYXRhLmdmO1xuICAgICAgdmFyIGhhc09wYWNpdHkgPSBpdGVtRGF0YS5nLl9oYXNPcGFjaXR5O1xuICAgICAgdmFyIHB0MSA9IGl0ZW1EYXRhLnMudjtcbiAgICAgIHZhciBwdDIgPSBpdGVtRGF0YS5lLnY7XG5cbiAgICAgIGlmIChpdGVtRGF0YS5vLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIHZhciBhdHRyID0gc3R5bGVEYXRhLnR5ID09PSAnZ2YnID8gJ2ZpbGwtb3BhY2l0eScgOiAnc3Ryb2tlLW9wYWNpdHknO1xuICAgICAgICBpdGVtRGF0YS5zdHlsZS5wRWxlbS5zZXRBdHRyaWJ1dGUoYXR0ciwgaXRlbURhdGEuby52KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1EYXRhLnMuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgdmFyIGF0dHIxID0gc3R5bGVEYXRhLnQgPT09IDEgPyAneDEnIDogJ2N4JztcbiAgICAgICAgdmFyIGF0dHIyID0gYXR0cjEgPT09ICd4MScgPyAneTEnIDogJ2N5JztcbiAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKGF0dHIxLCBwdDFbMF0pO1xuICAgICAgICBnZmlsbC5zZXRBdHRyaWJ1dGUoYXR0cjIsIHB0MVsxXSk7XG5cbiAgICAgICAgaWYgKGhhc09wYWNpdHkgJiYgIWl0ZW1EYXRhLmcuX2NvbGxhcHNhYmxlKSB7XG4gICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKGF0dHIxLCBwdDFbMF0pO1xuICAgICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZShhdHRyMiwgcHQxWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3RvcHM7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW47XG4gICAgICB2YXIgc3RvcDtcblxuICAgICAgaWYgKGl0ZW1EYXRhLmcuX2NtZGYgfHwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIHN0b3BzID0gaXRlbURhdGEuY3N0O1xuICAgICAgICB2YXIgY1ZhbHVlcyA9IGl0ZW1EYXRhLmcuYztcbiAgICAgICAgbGVuID0gc3RvcHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHN0b3AgPSBzdG9wc1tpXTtcbiAgICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZSgnb2Zmc2V0JywgY1ZhbHVlc1tpICogNF0gKyAnJScpO1xuICAgICAgICAgIHN0b3Auc2V0QXR0cmlidXRlKCdzdG9wLWNvbG9yJywgJ3JnYignICsgY1ZhbHVlc1tpICogNCArIDFdICsgJywnICsgY1ZhbHVlc1tpICogNCArIDJdICsgJywnICsgY1ZhbHVlc1tpICogNCArIDNdICsgJyknKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGFzT3BhY2l0eSAmJiAoaXRlbURhdGEuZy5fb21kZiB8fCBpc0ZpcnN0RnJhbWUpKSB7XG4gICAgICAgIHZhciBvVmFsdWVzID0gaXRlbURhdGEuZy5vO1xuXG4gICAgICAgIGlmIChpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xuICAgICAgICAgIHN0b3BzID0gaXRlbURhdGEuY3N0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0b3BzID0gaXRlbURhdGEub3N0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuID0gc3RvcHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHN0b3AgPSBzdG9wc1tpXTtcblxuICAgICAgICAgIGlmICghaXRlbURhdGEuZy5fY29sbGFwc2FibGUpIHtcbiAgICAgICAgICAgIHN0b3Auc2V0QXR0cmlidXRlKCdvZmZzZXQnLCBvVmFsdWVzW2kgKiAyXSArICclJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGUoJ3N0b3Atb3BhY2l0eScsIG9WYWx1ZXNbaSAqIDIgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0eWxlRGF0YS50ID09PSAxKSB7XG4gICAgICAgIGlmIChpdGVtRGF0YS5lLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKCd4MicsIHB0MlswXSk7XG4gICAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKCd5MicsIHB0MlsxXSk7XG5cbiAgICAgICAgICBpZiAoaGFzT3BhY2l0eSAmJiAhaXRlbURhdGEuZy5fY29sbGFwc2FibGUpIHtcbiAgICAgICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZSgneDInLCBwdDJbMF0pO1xuICAgICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKCd5MicsIHB0MlsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmFkO1xuXG4gICAgICAgIGlmIChpdGVtRGF0YS5zLl9tZGYgfHwgaXRlbURhdGEuZS5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICAgIHJhZCA9IE1hdGguc3FydChNYXRoLnBvdyhwdDFbMF0gLSBwdDJbMF0sIDIpICsgTWF0aC5wb3cocHQxWzFdIC0gcHQyWzFdLCAyKSk7XG4gICAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKCdyJywgcmFkKTtcblxuICAgICAgICAgIGlmIChoYXNPcGFjaXR5ICYmICFpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xuICAgICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKCdyJywgcmFkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbURhdGEuZS5fbWRmIHx8IGl0ZW1EYXRhLmguX21kZiB8fCBpdGVtRGF0YS5hLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgICAgaWYgKCFyYWQpIHtcbiAgICAgICAgICAgIHJhZCA9IE1hdGguc3FydChNYXRoLnBvdyhwdDFbMF0gLSBwdDJbMF0sIDIpICsgTWF0aC5wb3cocHQxWzFdIC0gcHQyWzFdLCAyKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGFuZyA9IE1hdGguYXRhbjIocHQyWzFdIC0gcHQxWzFdLCBwdDJbMF0gLSBwdDFbMF0pO1xuICAgICAgICAgIHZhciBwZXJjZW50ID0gaXRlbURhdGEuaC52O1xuXG4gICAgICAgICAgaWYgKHBlcmNlbnQgPj0gMSkge1xuICAgICAgICAgICAgcGVyY2VudCA9IDAuOTk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwZXJjZW50IDw9IC0xKSB7XG4gICAgICAgICAgICBwZXJjZW50ID0gLTAuOTk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRpc3QgPSByYWQgKiBwZXJjZW50O1xuICAgICAgICAgIHZhciB4ID0gTWF0aC5jb3MoYW5nICsgaXRlbURhdGEuYS52KSAqIGRpc3QgKyBwdDFbMF07XG4gICAgICAgICAgdmFyIHkgPSBNYXRoLnNpbihhbmcgKyBpdGVtRGF0YS5hLnYpICogZGlzdCArIHB0MVsxXTtcbiAgICAgICAgICBnZmlsbC5zZXRBdHRyaWJ1dGUoJ2Z4JywgeCk7XG4gICAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKCdmeScsIHkpO1xuXG4gICAgICAgICAgaWYgKGhhc09wYWNpdHkgJiYgIWl0ZW1EYXRhLmcuX2NvbGxhcHNhYmxlKSB7XG4gICAgICAgICAgICBpdGVtRGF0YS5vZi5zZXRBdHRyaWJ1dGUoJ2Z4JywgeCk7XG4gICAgICAgICAgICBpdGVtRGF0YS5vZi5zZXRBdHRyaWJ1dGUoJ2Z5JywgeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGdmaWxsLnNldEF0dHJpYnV0ZSgnZnknLCcyMDAnKTtcblxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlclN0cm9rZShzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBzdHlsZUVsZW0gPSBpdGVtRGF0YS5zdHlsZTtcbiAgICAgIHZhciBkID0gaXRlbURhdGEuZDtcblxuICAgICAgaWYgKGQgJiYgKGQuX21kZiB8fCBpc0ZpcnN0RnJhbWUpICYmIGQuZGFzaFN0cikge1xuICAgICAgICBzdHlsZUVsZW0ucEVsZW0uc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5JywgZC5kYXNoU3RyKTtcbiAgICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnLCBkLmRhc2hvZmZzZXRbMF0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbURhdGEuYyAmJiAoaXRlbURhdGEuYy5fbWRmIHx8IGlzRmlyc3RGcmFtZSkpIHtcbiAgICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ3JnYignICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMF0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMV0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMl0pICsgJyknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1EYXRhLm8uX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW9wYWNpdHknLCBpdGVtRGF0YS5vLnYpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbURhdGEudy5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICBzdHlsZUVsZW0ucEVsZW0uc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBpdGVtRGF0YS53LnYpO1xuXG4gICAgICAgIGlmIChzdHlsZUVsZW0ubXNFbGVtKSB7XG4gICAgICAgICAgc3R5bGVFbGVtLm1zRWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIGl0ZW1EYXRhLncudik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2I7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBTVkdTaGFwZUVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIC8vIExpc3Qgb2YgZHJhd2FibGUgZWxlbWVudHNcbiAgICB0aGlzLnNoYXBlcyA9IFtdOyAvLyBGdWxsIHNoYXBlIGRhdGFcblxuICAgIHRoaXMuc2hhcGVzRGF0YSA9IGRhdGEuc2hhcGVzOyAvLyBMaXN0IG9mIHN0eWxlcyB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBzaGFwZXNcblxuICAgIHRoaXMuc3R5bGVzTGlzdCA9IFtdOyAvLyBMaXN0IG9mIG1vZGlmaWVycyB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBzaGFwZXNcblxuICAgIHRoaXMuc2hhcGVNb2RpZmllcnMgPSBbXTsgLy8gTGlzdCBvZiBpdGVtcyBpbiBzaGFwZSB0cmVlXG5cbiAgICB0aGlzLml0ZW1zRGF0YSA9IFtdOyAvLyBMaXN0IG9mIGl0ZW1zIGluIHByZXZpb3VzIHNoYXBlIHRyZWVcblxuICAgIHRoaXMucHJvY2Vzc2VkRWxlbWVudHMgPSBbXTsgLy8gTGlzdCBvZiBhbmltYXRlZCBjb21wb25lbnRzXG5cbiAgICB0aGlzLmFuaW1hdGVkQ29udGVudHMgPSBbXTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApOyAvLyBNb3ZpbmcgYW55IHByb3BlcnR5IHRoYXQgZG9lc24ndCBnZXQgdG9vIG11Y2ggYWNjZXNzIGFmdGVyIGluaXRpYWxpemF0aW9uIGJlY2F1c2Ugb2Ygdjggd2F5IG9mIGhhbmRsaW5nIG1vcmUgdGhhbiAxMCBwcm9wZXJ0aWVzLlxuICAgIC8vIExpc3Qgb2YgZWxlbWVudHMgdGhhdCBoYXZlIGJlZW4gY3JlYXRlZFxuXG4gICAgdGhpcy5wcmV2Vmlld0RhdGEgPSBbXTsgLy8gTW92aW5nIGFueSBwcm9wZXJ0eSB0aGF0IGRvZXNuJ3QgZ2V0IHRvbyBtdWNoIGFjY2VzcyBhZnRlciBpbml0aWFsaXphdGlvbiBiZWNhdXNlIG9mIHY4IHdheSBvZiBoYW5kbGluZyBtb3JlIHRoYW4gMTAgcHJvcGVydGllcy5cbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIFNWR0Jhc2VFbGVtZW50LCBJU2hhcGVFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50XSwgU1ZHU2hhcGVFbGVtZW50KTtcblxuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmluaXRTZWNvbmRhcnlFbGVtZW50ID0gZnVuY3Rpb24gKCkge307XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5pZGVudGl0eU1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcblxuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmJ1aWxkRXhwcmVzc2lvbkludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNlYXJjaFNoYXBlcyh0aGlzLnNoYXBlc0RhdGEsIHRoaXMuaXRlbXNEYXRhLCB0aGlzLnByZXZWaWV3RGF0YSwgdGhpcy5sYXllckVsZW1lbnQsIDAsIFtdLCB0cnVlKTtcbiAgICB0aGlzLmZpbHRlclVuaXF1ZVNoYXBlcygpO1xuICB9O1xuICAvKlxyXG4gIFRoaXMgbWV0aG9kIHNlYXJjaGVzIGZvciBtdWx0aXBsZSBzaGFwZXMgdGhhdCBhZmZlY3QgYSBzaW5nbGUgZWxlbWVudCBhbmQgb25lIG9mIHRoZW0gaXMgYW5pbWF0ZWRcclxuICAqL1xuXG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5maWx0ZXJVbmlxdWVTaGFwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc2hhcGVzLmxlbmd0aDtcbiAgICB2YXIgc2hhcGU7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW4gPSB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoO1xuICAgIHZhciBzdHlsZTtcbiAgICB2YXIgdGVtcFNoYXBlcyA9IFtdO1xuICAgIHZhciBhcmVBbmltYXRlZCA9IGZhbHNlO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgc3R5bGUgPSB0aGlzLnN0eWxlc0xpc3Rbal07XG4gICAgICBhcmVBbmltYXRlZCA9IGZhbHNlO1xuICAgICAgdGVtcFNoYXBlcy5sZW5ndGggPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgc2hhcGUgPSB0aGlzLnNoYXBlc1tpXTtcblxuICAgICAgICBpZiAoc2hhcGUuc3R5bGVzLmluZGV4T2Yoc3R5bGUpICE9PSAtMSkge1xuICAgICAgICAgIHRlbXBTaGFwZXMucHVzaChzaGFwZSk7XG4gICAgICAgICAgYXJlQW5pbWF0ZWQgPSBzaGFwZS5faXNBbmltYXRlZCB8fCBhcmVBbmltYXRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGVtcFNoYXBlcy5sZW5ndGggPiAxICYmIGFyZUFuaW1hdGVkKSB7XG4gICAgICAgIHRoaXMuc2V0U2hhcGVzQXNBbmltYXRlZCh0ZW1wU2hhcGVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5zZXRTaGFwZXNBc0FuaW1hdGVkID0gZnVuY3Rpb24gKHNoYXBlcykge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBzaGFwZXMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBzaGFwZXNbaV0uc2V0QXNBbmltYXRlZCgpO1xuICAgIH1cbiAgfTtcblxuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVN0eWxlRWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhLCBsZXZlbCkge1xuICAgIC8vIFRPRE86IHByZXZlbnQgZHJhd2luZyBvZiBoaWRkZW4gc3R5bGVzXG4gICAgdmFyIGVsZW1lbnREYXRhO1xuICAgIHZhciBzdHlsZU9iID0gbmV3IFNWR1N0eWxlRGF0YShkYXRhLCBsZXZlbCk7XG4gICAgdmFyIHBhdGhFbGVtZW50ID0gc3R5bGVPYi5wRWxlbTtcblxuICAgIGlmIChkYXRhLnR5ID09PSAnc3QnKSB7XG4gICAgICBlbGVtZW50RGF0YSA9IG5ldyBTVkdTdHJva2VTdHlsZURhdGEodGhpcywgZGF0YSwgc3R5bGVPYik7XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5ID09PSAnZmwnKSB7XG4gICAgICBlbGVtZW50RGF0YSA9IG5ldyBTVkdGaWxsU3R5bGVEYXRhKHRoaXMsIGRhdGEsIHN0eWxlT2IpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS50eSA9PT0gJ2dmJyB8fCBkYXRhLnR5ID09PSAnZ3MnKSB7XG4gICAgICB2YXIgR3JhZGllbnRDb25zdHJ1Y3RvciA9IGRhdGEudHkgPT09ICdnZicgPyBTVkdHcmFkaWVudEZpbGxTdHlsZURhdGEgOiBTVkdHcmFkaWVudFN0cm9rZVN0eWxlRGF0YTtcbiAgICAgIGVsZW1lbnREYXRhID0gbmV3IEdyYWRpZW50Q29uc3RydWN0b3IodGhpcywgZGF0YSwgc3R5bGVPYik7XG4gICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChlbGVtZW50RGF0YS5nZik7XG5cbiAgICAgIGlmIChlbGVtZW50RGF0YS5tYXNrSWQpIHtcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoZWxlbWVudERhdGEubXMpO1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChlbGVtZW50RGF0YS5vZik7XG4gICAgICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWFzaycsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgZWxlbWVudERhdGEubWFza0lkICsgJyknKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdubycpIHtcbiAgICAgIGVsZW1lbnREYXRhID0gbmV3IFNWR05vU3R5bGVEYXRhKHRoaXMsIGRhdGEsIHN0eWxlT2IpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLnR5ID09PSAnc3QnIHx8IGRhdGEudHkgPT09ICdncycpIHtcbiAgICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCBsaW5lQ2FwRW51bVtkYXRhLmxjIHx8IDJdKTtcbiAgICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgbGluZUpvaW5FbnVtW2RhdGEubGogfHwgMl0pO1xuICAgICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCAnMCcpO1xuXG4gICAgICBpZiAoZGF0YS5saiA9PT0gMSkge1xuICAgICAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1taXRlcmxpbWl0JywgZGF0YS5tbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuciA9PT0gMikge1xuICAgICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdmaWxsLXJ1bGUnLCAnZXZlbm9kZCcpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxuKSB7XG4gICAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgZGF0YS5sbik7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuY2wpIHtcbiAgICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBkYXRhLmNsKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5ibSkge1xuICAgICAgcGF0aEVsZW1lbnQuc3R5bGVbJ21peC1ibGVuZC1tb2RlJ10gPSBnZXRCbGVuZE1vZGUoZGF0YS5ibSk7XG4gICAgfVxuXG4gICAgdGhpcy5zdHlsZXNMaXN0LnB1c2goc3R5bGVPYik7XG4gICAgdGhpcy5hZGRUb0FuaW1hdGVkQ29udGVudHMoZGF0YSwgZWxlbWVudERhdGEpO1xuICAgIHJldHVybiBlbGVtZW50RGF0YTtcbiAgfTtcblxuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUdyb3VwRWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGVsZW1lbnREYXRhID0gbmV3IFNoYXBlR3JvdXBEYXRhKCk7XG5cbiAgICBpZiAoZGF0YS5sbikge1xuICAgICAgZWxlbWVudERhdGEuZ3Iuc2V0QXR0cmlidXRlKCdpZCcsIGRhdGEubG4pO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmNsKSB7XG4gICAgICBlbGVtZW50RGF0YS5nci5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgZGF0YS5jbCk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuYm0pIHtcbiAgICAgIGVsZW1lbnREYXRhLmdyLnN0eWxlWydtaXgtYmxlbmQtbW9kZSddID0gZ2V0QmxlbmRNb2RlKGRhdGEuYm0pO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50RGF0YTtcbiAgfTtcblxuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVRyYW5zZm9ybUVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSwgY29udGFpbmVyKSB7XG4gICAgdmFyIHRyYW5zZm9ybVByb3BlcnR5ID0gVHJhbnNmb3JtUHJvcGVydHlGYWN0b3J5LmdldFRyYW5zZm9ybVByb3BlcnR5KHRoaXMsIGRhdGEsIHRoaXMpO1xuICAgIHZhciBlbGVtZW50RGF0YSA9IG5ldyBTVkdUcmFuc2Zvcm1EYXRhKHRyYW5zZm9ybVByb3BlcnR5LCB0cmFuc2Zvcm1Qcm9wZXJ0eS5vLCBjb250YWluZXIpO1xuICAgIHRoaXMuYWRkVG9BbmltYXRlZENvbnRlbnRzKGRhdGEsIGVsZW1lbnREYXRhKTtcbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTaGFwZUVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSwgb3duVHJhbnNmb3JtZXJzLCBsZXZlbCkge1xuICAgIHZhciB0eSA9IDQ7XG5cbiAgICBpZiAoZGF0YS50eSA9PT0gJ3JjJykge1xuICAgICAgdHkgPSA1O1xuICAgIH0gZWxzZSBpZiAoZGF0YS50eSA9PT0gJ2VsJykge1xuICAgICAgdHkgPSA2O1xuICAgIH0gZWxzZSBpZiAoZGF0YS50eSA9PT0gJ3NyJykge1xuICAgICAgdHkgPSA3O1xuICAgIH1cblxuICAgIHZhciBzaGFwZVByb3BlcnR5ID0gU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0U2hhcGVQcm9wKHRoaXMsIGRhdGEsIHR5LCB0aGlzKTtcbiAgICB2YXIgZWxlbWVudERhdGEgPSBuZXcgU1ZHU2hhcGVEYXRhKG93blRyYW5zZm9ybWVycywgbGV2ZWwsIHNoYXBlUHJvcGVydHkpO1xuICAgIHRoaXMuc2hhcGVzLnB1c2goZWxlbWVudERhdGEpO1xuICAgIHRoaXMuYWRkU2hhcGVUb01vZGlmaWVycyhlbGVtZW50RGF0YSk7XG4gICAgdGhpcy5hZGRUb0FuaW1hdGVkQ29udGVudHMoZGF0YSwgZWxlbWVudERhdGEpO1xuICAgIHJldHVybiBlbGVtZW50RGF0YTtcbiAgfTtcblxuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmFkZFRvQW5pbWF0ZWRDb250ZW50cyA9IGZ1bmN0aW9uIChkYXRhLCBlbGVtZW50KSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0aGlzLmFuaW1hdGVkQ29udGVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGlmICh0aGlzLmFuaW1hdGVkQ29udGVudHNbaV0uZWxlbWVudCA9PT0gZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGVkQ29udGVudHMucHVzaCh7XG4gICAgICBmbjogU1ZHRWxlbWVudHNSZW5kZXJlci5jcmVhdGVSZW5kZXJGdW5jdGlvbihkYXRhKSxcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH07XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5zZXRFbGVtZW50U3R5bGVzID0gZnVuY3Rpb24gKGVsZW1lbnREYXRhKSB7XG4gICAgdmFyIGFyciA9IGVsZW1lbnREYXRhLnN0eWxlcztcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbiA9IHRoaXMuc3R5bGVzTGlzdC5sZW5ndGg7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzTGlzdFtqXS5jbG9zZWQpIHtcbiAgICAgICAgYXJyLnB1c2godGhpcy5zdHlsZXNMaXN0W2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZWxvYWRTaGFwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5pdGVtc0RhdGEubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICB0aGlzLnByZXZWaWV3RGF0YVtpXSA9IHRoaXMuaXRlbXNEYXRhW2ldO1xuICAgIH1cblxuICAgIHRoaXMuc2VhcmNoU2hhcGVzKHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRoaXMucHJldlZpZXdEYXRhLCB0aGlzLmxheWVyRWxlbWVudCwgMCwgW10sIHRydWUpO1xuICAgIHRoaXMuZmlsdGVyVW5pcXVlU2hhcGVzKCk7XG4gICAgbGVuID0gdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV0uZ2V0VmFsdWUoKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlck1vZGlmaWVycygpO1xuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuc2VhcmNoU2hhcGVzID0gZnVuY3Rpb24gKGFyciwgaXRlbXNEYXRhLCBwcmV2Vmlld0RhdGEsIGNvbnRhaW5lciwgbGV2ZWwsIHRyYW5zZm9ybWVycywgcmVuZGVyKSB7XG4gICAgdmFyIG93blRyYW5zZm9ybWVycyA9IFtdLmNvbmNhdCh0cmFuc2Zvcm1lcnMpO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoIC0gMTtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgb3duU3R5bGVzID0gW107XG4gICAgdmFyIG93bk1vZGlmaWVycyA9IFtdO1xuICAgIHZhciBjdXJyZW50VHJhbnNmb3JtO1xuICAgIHZhciBtb2RpZmllcjtcbiAgICB2YXIgcHJvY2Vzc2VkUG9zO1xuXG4gICAgZm9yIChpID0gbGVuOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgcHJvY2Vzc2VkUG9zID0gdGhpcy5zZWFyY2hQcm9jZXNzZWRFbGVtZW50KGFycltpXSk7XG5cbiAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgIGFycltpXS5fcmVuZGVyID0gcmVuZGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbXNEYXRhW2ldID0gcHJldlZpZXdEYXRhW3Byb2Nlc3NlZFBvcyAtIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJyW2ldLnR5ID09PSAnZmwnIHx8IGFycltpXS50eSA9PT0gJ3N0JyB8fCBhcnJbaV0udHkgPT09ICdnZicgfHwgYXJyW2ldLnR5ID09PSAnZ3MnIHx8IGFycltpXS50eSA9PT0gJ25vJykge1xuICAgICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICAgIGl0ZW1zRGF0YVtpXSA9IHRoaXMuY3JlYXRlU3R5bGVFbGVtZW50KGFycltpXSwgbGV2ZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1zRGF0YVtpXS5zdHlsZS5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcnJbaV0uX3JlbmRlcikge1xuICAgICAgICAgIGlmIChpdGVtc0RhdGFbaV0uc3R5bGUucEVsZW0ucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaXRlbXNEYXRhW2ldLnN0eWxlLnBFbGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvd25TdHlsZXMucHVzaChpdGVtc0RhdGFbaV0uc3R5bGUpO1xuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdncicpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSB0aGlzLmNyZWF0ZUdyb3VwRWxlbWVudChhcnJbaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGpMZW4gPSBpdGVtc0RhdGFbaV0uaXQubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgaXRlbXNEYXRhW2ldLnByZXZWaWV3RGF0YVtqXSA9IGl0ZW1zRGF0YVtpXS5pdFtqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlYXJjaFNoYXBlcyhhcnJbaV0uaXQsIGl0ZW1zRGF0YVtpXS5pdCwgaXRlbXNEYXRhW2ldLnByZXZWaWV3RGF0YSwgaXRlbXNEYXRhW2ldLmdyLCBsZXZlbCArIDEsIG93blRyYW5zZm9ybWVycywgcmVuZGVyKTtcblxuICAgICAgICBpZiAoYXJyW2ldLl9yZW5kZXIpIHtcbiAgICAgICAgICBpZiAoaXRlbXNEYXRhW2ldLmdyLnBhcmVudE5vZGUgIT09IGNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGl0ZW1zRGF0YVtpXS5ncik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ3RyJykge1xuICAgICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICAgIGl0ZW1zRGF0YVtpXSA9IHRoaXMuY3JlYXRlVHJhbnNmb3JtRWxlbWVudChhcnJbaV0sIGNvbnRhaW5lcik7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50VHJhbnNmb3JtID0gaXRlbXNEYXRhW2ldLnRyYW5zZm9ybTtcbiAgICAgICAgb3duVHJhbnNmb3JtZXJzLnB1c2goY3VycmVudFRyYW5zZm9ybSk7XG4gICAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ3NoJyB8fCBhcnJbaV0udHkgPT09ICdyYycgfHwgYXJyW2ldLnR5ID09PSAnZWwnIHx8IGFycltpXS50eSA9PT0gJ3NyJykge1xuICAgICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICAgIGl0ZW1zRGF0YVtpXSA9IHRoaXMuY3JlYXRlU2hhcGVFbGVtZW50KGFycltpXSwgb3duVHJhbnNmb3JtZXJzLCBsZXZlbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEVsZW1lbnRTdHlsZXMoaXRlbXNEYXRhW2ldKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAndG0nIHx8IGFycltpXS50eSA9PT0gJ3JkJyB8fCBhcnJbaV0udHkgPT09ICdtcycgfHwgYXJyW2ldLnR5ID09PSAncGInIHx8IGFycltpXS50eSA9PT0gJ3p6JyB8fCBhcnJbaV0udHkgPT09ICdvcCcpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBtb2RpZmllciA9IFNoYXBlTW9kaWZpZXJzLmdldE1vZGlmaWVyKGFycltpXS50eSk7XG4gICAgICAgICAgbW9kaWZpZXIuaW5pdCh0aGlzLCBhcnJbaV0pO1xuICAgICAgICAgIGl0ZW1zRGF0YVtpXSA9IG1vZGlmaWVyO1xuICAgICAgICAgIHRoaXMuc2hhcGVNb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kaWZpZXIgPSBpdGVtc0RhdGFbaV07XG4gICAgICAgICAgbW9kaWZpZXIuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBvd25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ3JwJykge1xuICAgICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICAgIG1vZGlmaWVyID0gU2hhcGVNb2RpZmllcnMuZ2V0TW9kaWZpZXIoYXJyW2ldLnR5KTtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSBtb2RpZmllcjtcbiAgICAgICAgICBtb2RpZmllci5pbml0KHRoaXMsIGFyciwgaSwgaXRlbXNEYXRhKTtcbiAgICAgICAgICB0aGlzLnNoYXBlTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICAgIHJlbmRlciA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGlmaWVyID0gaXRlbXNEYXRhW2ldO1xuICAgICAgICAgIG1vZGlmaWVyLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBvd25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWRkUHJvY2Vzc2VkRWxlbWVudChhcnJbaV0sIGkgKyAxKTtcbiAgICB9XG5cbiAgICBsZW4gPSBvd25TdHlsZXMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBvd25TdHlsZXNbaV0uY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZW4gPSBvd25Nb2RpZmllcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBvd25Nb2RpZmllcnNbaV0uY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZW5kZXJNb2RpZmllcnMoKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy5zdHlsZXNMaXN0W2ldLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJTaGFwZSgpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5zdHlsZXNMaXN0W2ldLl9tZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlc0xpc3RbaV0ubXNFbGVtKSB7XG4gICAgICAgICAgdGhpcy5zdHlsZXNMaXN0W2ldLm1zRWxlbS5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLnN0eWxlc0xpc3RbaV0uZCk7IC8vIEFkZGluZyBNMCAwIGZpeGVzIHNhbWUgbWFzayBidWcgb24gYWxsIGJyb3dzZXJzXG5cbiAgICAgICAgICB0aGlzLnN0eWxlc0xpc3RbaV0uZCA9ICdNMCAwJyArIHRoaXMuc3R5bGVzTGlzdFtpXS5kO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdHlsZXNMaXN0W2ldLnBFbGVtLnNldEF0dHJpYnV0ZSgnZCcsIHRoaXMuc3R5bGVzTGlzdFtpXS5kIHx8ICdNMCAwJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyU2hhcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuYW5pbWF0ZWRDb250ZW50cy5sZW5ndGg7XG4gICAgdmFyIGFuaW1hdGVkQ29udGVudDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgYW5pbWF0ZWRDb250ZW50ID0gdGhpcy5hbmltYXRlZENvbnRlbnRzW2ldO1xuXG4gICAgICBpZiAoKHRoaXMuX2lzRmlyc3RGcmFtZSB8fCBhbmltYXRlZENvbnRlbnQuZWxlbWVudC5faXNBbmltYXRlZCkgJiYgYW5pbWF0ZWRDb250ZW50LmRhdGEgIT09IHRydWUpIHtcbiAgICAgICAgYW5pbWF0ZWRDb250ZW50LmZuKGFuaW1hdGVkQ29udGVudC5kYXRhLCBhbmltYXRlZENvbnRlbnQuZWxlbWVudCwgdGhpcy5faXNGaXJzdEZyYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVzdHJveUJhc2VFbGVtZW50KCk7XG4gICAgdGhpcy5zaGFwZXNEYXRhID0gbnVsbDtcbiAgICB0aGlzLml0ZW1zRGF0YSA9IG51bGw7XG4gIH07XG5cbiAgZnVuY3Rpb24gTGV0dGVyUHJvcHMobywgc3csIHNjLCBmYywgbSwgcCkge1xuICAgIHRoaXMubyA9IG87XG4gICAgdGhpcy5zdyA9IHN3O1xuICAgIHRoaXMuc2MgPSBzYztcbiAgICB0aGlzLmZjID0gZmM7XG4gICAgdGhpcy5tID0gbTtcbiAgICB0aGlzLnAgPSBwO1xuICAgIHRoaXMuX21kZiA9IHtcbiAgICAgIG86IHRydWUsXG4gICAgICBzdzogISFzdyxcbiAgICAgIHNjOiAhIXNjLFxuICAgICAgZmM6ICEhZmMsXG4gICAgICBtOiB0cnVlLFxuICAgICAgcDogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBMZXR0ZXJQcm9wcy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG8sIHN3LCBzYywgZmMsIG0sIHApIHtcbiAgICB0aGlzLl9tZGYubyA9IGZhbHNlO1xuICAgIHRoaXMuX21kZi5zdyA9IGZhbHNlO1xuICAgIHRoaXMuX21kZi5zYyA9IGZhbHNlO1xuICAgIHRoaXMuX21kZi5mYyA9IGZhbHNlO1xuICAgIHRoaXMuX21kZi5tID0gZmFsc2U7XG4gICAgdGhpcy5fbWRmLnAgPSBmYWxzZTtcbiAgICB2YXIgdXBkYXRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMubyAhPT0gbykge1xuICAgICAgdGhpcy5vID0gbztcbiAgICAgIHRoaXMuX21kZi5vID0gdHJ1ZTtcbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN3ICE9PSBzdykge1xuICAgICAgdGhpcy5zdyA9IHN3O1xuICAgICAgdGhpcy5fbWRmLnN3ID0gdHJ1ZTtcbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNjICE9PSBzYykge1xuICAgICAgdGhpcy5zYyA9IHNjO1xuICAgICAgdGhpcy5fbWRmLnNjID0gdHJ1ZTtcbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZjICE9PSBmYykge1xuICAgICAgdGhpcy5mYyA9IGZjO1xuICAgICAgdGhpcy5fbWRmLmZjID0gdHJ1ZTtcbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm0gIT09IG0pIHtcbiAgICAgIHRoaXMubSA9IG07XG4gICAgICB0aGlzLl9tZGYubSA9IHRydWU7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocC5sZW5ndGggJiYgKHRoaXMucFswXSAhPT0gcFswXSB8fCB0aGlzLnBbMV0gIT09IHBbMV0gfHwgdGhpcy5wWzRdICE9PSBwWzRdIHx8IHRoaXMucFs1XSAhPT0gcFs1XSB8fCB0aGlzLnBbMTJdICE9PSBwWzEyXSB8fCB0aGlzLnBbMTNdICE9PSBwWzEzXSkpIHtcbiAgICAgIHRoaXMucCA9IHA7XG4gICAgICB0aGlzLl9tZGYucCA9IHRydWU7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfTtcblxuICBmdW5jdGlvbiBUZXh0UHJvcGVydHkoZWxlbSwgZGF0YSkge1xuICAgIHRoaXMuX2ZyYW1lSWQgPSBpbml0aWFsRGVmYXVsdEZyYW1lO1xuICAgIHRoaXMucHYgPSAnJztcbiAgICB0aGlzLnYgPSAnJztcbiAgICB0aGlzLmtmID0gZmFsc2U7XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcblxuICAgIGlmIChkYXRhLmQgJiYgZGF0YS5kLnNpZCkge1xuICAgICAgZGF0YS5kID0gZWxlbS5nbG9iYWxEYXRhLnNsb3RNYW5hZ2VyLmdldFByb3AoZGF0YS5kKTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgdGhpcy5jb21wID0gdGhpcy5lbGVtLmNvbXA7XG4gICAgdGhpcy5rZXlzSW5kZXggPSAwO1xuICAgIHRoaXMuY2FuUmVzaXplID0gZmFsc2U7XG4gICAgdGhpcy5taW5pbXVtRm9udFNpemUgPSAxO1xuICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlID0gW107XG4gICAgdGhpcy5jdXJyZW50RGF0YSA9IHtcbiAgICAgIGFzY2VudDogMCxcbiAgICAgIGJveFdpZHRoOiB0aGlzLmRlZmF1bHRCb3hXaWR0aCxcbiAgICAgIGY6ICcnLFxuICAgICAgZlN0eWxlOiAnJyxcbiAgICAgIGZXZWlnaHQ6ICcnLFxuICAgICAgZmM6ICcnLFxuICAgICAgajogJycsXG4gICAgICBqdXN0aWZ5T2Zmc2V0OiAnJyxcbiAgICAgIGw6IFtdLFxuICAgICAgbGg6IDAsXG4gICAgICBsaW5lV2lkdGhzOiBbXSxcbiAgICAgIGxzOiAnJyxcbiAgICAgIG9mOiAnJyxcbiAgICAgIHM6ICcnLFxuICAgICAgc2M6ICcnLFxuICAgICAgc3c6IDAsXG4gICAgICB0OiAwLFxuICAgICAgdHI6IDAsXG4gICAgICBzejogMCxcbiAgICAgIHBzOiBudWxsLFxuICAgICAgZmlsbENvbG9yQW5pbTogZmFsc2UsXG4gICAgICBzdHJva2VDb2xvckFuaW06IGZhbHNlLFxuICAgICAgc3Ryb2tlV2lkdGhBbmltOiBmYWxzZSxcbiAgICAgIHlPZmZzZXQ6IDAsXG4gICAgICBmaW5hbFNpemU6IDAsXG4gICAgICBmaW5hbFRleHQ6IFtdLFxuICAgICAgZmluYWxMaW5lSGVpZ2h0OiAwLFxuICAgICAgX19jb21wbGV0ZTogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuY29weURhdGEodGhpcy5jdXJyZW50RGF0YSwgdGhpcy5kYXRhLmQua1swXS5zKTtcblxuICAgIGlmICghdGhpcy5zZWFyY2hQcm9wZXJ0eSgpKSB7XG4gICAgICB0aGlzLmNvbXBsZXRlVGV4dERhdGEodGhpcy5jdXJyZW50RGF0YSk7XG4gICAgfVxuICB9XG5cbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5kZWZhdWx0Qm94V2lkdGggPSBbMCwgMF07XG5cbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5jb3B5RGF0YSA9IGZ1bmN0aW9uIChvYmosIGRhdGEpIHtcbiAgICBmb3IgKHZhciBzIGluIGRhdGEpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgcykpIHtcbiAgICAgICAgb2JqW3NdID0gZGF0YVtzXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuc2V0Q3VycmVudERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICghZGF0YS5fX2NvbXBsZXRlKSB7XG4gICAgICB0aGlzLmNvbXBsZXRlVGV4dERhdGEoZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50RGF0YSA9IGRhdGE7XG4gICAgdGhpcy5jdXJyZW50RGF0YS5ib3hXaWR0aCA9IHRoaXMuY3VycmVudERhdGEuYm94V2lkdGggfHwgdGhpcy5kZWZhdWx0Qm94V2lkdGg7XG4gICAgdGhpcy5fbWRmID0gdHJ1ZTtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLnNlYXJjaFByb3BlcnR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnNlYXJjaEtleWZyYW1lcygpO1xuICB9O1xuXG4gIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuc2VhcmNoS2V5ZnJhbWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMua2YgPSB0aGlzLmRhdGEuZC5rLmxlbmd0aCA+IDE7XG5cbiAgICBpZiAodGhpcy5rZikge1xuICAgICAgdGhpcy5hZGRFZmZlY3QodGhpcy5nZXRLZXlmcmFtZVZhbHVlLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmtmO1xuICB9O1xuXG4gIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuYWRkRWZmZWN0ID0gZnVuY3Rpb24gKGVmZmVjdEZ1bmN0aW9uKSB7XG4gICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UucHVzaChlZmZlY3RGdW5jdGlvbik7XG4gICAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKF9maW5hbFZhbHVlKSB7XG4gICAgaWYgKCh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQgfHwgIXRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkgJiYgIV9maW5hbFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50RGF0YS50ID0gdGhpcy5kYXRhLmQua1t0aGlzLmtleXNJbmRleF0ucy50O1xuICAgIHZhciBjdXJyZW50VmFsdWUgPSB0aGlzLmN1cnJlbnREYXRhO1xuICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLmtleXNJbmRleDtcblxuICAgIGlmICh0aGlzLmxvY2spIHtcbiAgICAgIHRoaXMuc2V0Q3VycmVudERhdGEodGhpcy5jdXJyZW50RGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sb2NrID0gdHJ1ZTtcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoO1xuICAgIHZhciBmaW5hbFZhbHVlID0gX2ZpbmFsVmFsdWUgfHwgdGhpcy5kYXRhLmQua1t0aGlzLmtleXNJbmRleF0ucztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgLy8gQ2hlY2tpbmcgaWYgaW5kZXggY2hhbmdlZCB0byBwcmV2ZW50IGNyZWF0aW5nIGEgbmV3IG9iamVjdCBldmVyeSB0aW1lIHRoZSBleHByZXNzaW9uIHVwZGF0ZXMuXG4gICAgICBpZiAoY3VycmVudEluZGV4ICE9PSB0aGlzLmtleXNJbmRleCkge1xuICAgICAgICBmaW5hbFZhbHVlID0gdGhpcy5lZmZlY3RzU2VxdWVuY2VbaV0oZmluYWxWYWx1ZSwgZmluYWxWYWx1ZS50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmFsVmFsdWUgPSB0aGlzLmVmZmVjdHNTZXF1ZW5jZVtpXSh0aGlzLmN1cnJlbnREYXRhLCBmaW5hbFZhbHVlLnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyZW50VmFsdWUgIT09IGZpbmFsVmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0Q3VycmVudERhdGEoZmluYWxWYWx1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy52ID0gdGhpcy5jdXJyZW50RGF0YTtcbiAgICB0aGlzLnB2ID0gdGhpcy52O1xuICAgIHRoaXMubG9jayA9IGZhbHNlO1xuICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gIH07XG5cbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5nZXRLZXlmcmFtZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZXh0S2V5cyA9IHRoaXMuZGF0YS5kLms7XG4gICAgdmFyIGZyYW1lTnVtID0gdGhpcy5lbGVtLmNvbXAucmVuZGVyZWRGcmFtZTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHRleHRLZXlzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDw9IGxlbiAtIDEpIHtcbiAgICAgIGlmIChpID09PSBsZW4gLSAxIHx8IHRleHRLZXlzW2kgKyAxXS50ID4gZnJhbWVOdW0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5rZXlzSW5kZXggIT09IGkpIHtcbiAgICAgIHRoaXMua2V5c0luZGV4ID0gaTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhLmQua1t0aGlzLmtleXNJbmRleF0ucztcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLmJ1aWxkRmluYWxUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICB2YXIgY2hhcmFjdGVyc0FycmF5ID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICB2YXIgY2hhckNvZGU7XG4gICAgdmFyIHNlY29uZENoYXJDb2RlO1xuICAgIHZhciBzaG91bGRDb21iaW5lID0gZmFsc2U7XG4gICAgdmFyIHNob3VsZENvbWJpbmVOZXh0ID0gZmFsc2U7XG4gICAgdmFyIGN1cnJlbnRDaGFycyA9ICcnO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIHNob3VsZENvbWJpbmUgPSBzaG91bGRDb21iaW5lTmV4dDtcbiAgICAgIHNob3VsZENvbWJpbmVOZXh0ID0gZmFsc2U7XG4gICAgICBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgIGN1cnJlbnRDaGFycyA9IHRleHQuY2hhckF0KGkpO1xuXG4gICAgICBpZiAoRm9udE1hbmFnZXIuaXNDb21iaW5lZENoYXJhY3RlcihjaGFyQ29kZSkpIHtcbiAgICAgICAgc2hvdWxkQ29tYmluZSA9IHRydWU7IC8vIEl0J3MgYSBwb3RlbnRpYWwgc3Vycm9nYXRlIHBhaXIgKHRoaXMgaXMgdGhlIEhpZ2ggc3Vycm9nYXRlKVxuICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICAgIGlmIChGb250TWFuYWdlci5pc1JlZ2lvbmFsRmxhZyh0ZXh0LCBpKSkge1xuICAgICAgICAgIGN1cnJlbnRDaGFycyA9IHRleHQuc3Vic3RyKGksIDE0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWNvbmRDaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpICsgMSk7IC8vIEl0J3MgYSBzdXJyb2dhdGUgcGFpciAodGhpcyBpcyB0aGUgTG93IHN1cnJvZ2F0ZSlcblxuICAgICAgICAgIGlmIChzZWNvbmRDaGFyQ29kZSA+PSAweERDMDAgJiYgc2Vjb25kQ2hhckNvZGUgPD0gMHhERkZGKSB7XG4gICAgICAgICAgICBpZiAoRm9udE1hbmFnZXIuaXNNb2RpZmllcihjaGFyQ29kZSwgc2Vjb25kQ2hhckNvZGUpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRDaGFycyA9IHRleHQuc3Vic3RyKGksIDIpO1xuICAgICAgICAgICAgICBzaG91bGRDb21iaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoRm9udE1hbmFnZXIuaXNGbGFnRW1vamkodGV4dC5zdWJzdHIoaSwgNCkpKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRDaGFycyA9IHRleHQuc3Vic3RyKGksIDQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3VycmVudENoYXJzID0gdGV4dC5zdWJzdHIoaSwgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID4gMHhEQkZGKSB7XG4gICAgICAgIHNlY29uZENoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGkgKyAxKTtcblxuICAgICAgICBpZiAoRm9udE1hbmFnZXIuaXNWYXJpYXRpb25TZWxlY3RvcihjaGFyQ29kZSkpIHtcbiAgICAgICAgICBzaG91bGRDb21iaW5lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChGb250TWFuYWdlci5pc1plcm9XaWR0aEpvaW5lcihjaGFyQ29kZSkpIHtcbiAgICAgICAgc2hvdWxkQ29tYmluZSA9IHRydWU7XG4gICAgICAgIHNob3VsZENvbWJpbmVOZXh0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZENvbWJpbmUpIHtcbiAgICAgICAgY2hhcmFjdGVyc0FycmF5W2NoYXJhY3RlcnNBcnJheS5sZW5ndGggLSAxXSArPSBjdXJyZW50Q2hhcnM7XG4gICAgICAgIHNob3VsZENvbWJpbmUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYXJhY3RlcnNBcnJheS5wdXNoKGN1cnJlbnRDaGFycyk7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gY3VycmVudENoYXJzLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhcmFjdGVyc0FycmF5O1xuICB9O1xuXG4gIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuY29tcGxldGVUZXh0RGF0YSA9IGZ1bmN0aW9uIChkb2N1bWVudERhdGEpIHtcbiAgICBkb2N1bWVudERhdGEuX19jb21wbGV0ZSA9IHRydWU7XG4gICAgdmFyIGZvbnRNYW5hZ2VyID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZm9udE1hbmFnZXI7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIGxldHRlcnMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuICAgIHZhciBuZXdMaW5lRmxhZztcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciB2YWw7XG4gICAgdmFyIGFuY2hvckdyb3VwaW5nID0gZGF0YS5tLmc7XG4gICAgdmFyIGN1cnJlbnRTaXplID0gMDtcbiAgICB2YXIgY3VycmVudFBvcyA9IDA7XG4gICAgdmFyIGN1cnJlbnRMaW5lID0gMDtcbiAgICB2YXIgbGluZVdpZHRocyA9IFtdO1xuICAgIHZhciBsaW5lV2lkdGggPSAwO1xuICAgIHZhciBtYXhMaW5lV2lkdGggPSAwO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBmb250RGF0YSA9IGZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpO1xuICAgIHZhciBjaGFyRGF0YTtcbiAgICB2YXIgY0xlbmd0aCA9IDA7XG4gICAgdmFyIGZvbnRQcm9wcyA9IGdldEZvbnRQcm9wZXJ0aWVzKGZvbnREYXRhKTtcbiAgICBkb2N1bWVudERhdGEuZldlaWdodCA9IGZvbnRQcm9wcy53ZWlnaHQ7XG4gICAgZG9jdW1lbnREYXRhLmZTdHlsZSA9IGZvbnRQcm9wcy5zdHlsZTtcbiAgICBkb2N1bWVudERhdGEuZmluYWxTaXplID0gZG9jdW1lbnREYXRhLnM7XG4gICAgZG9jdW1lbnREYXRhLmZpbmFsVGV4dCA9IHRoaXMuYnVpbGRGaW5hbFRleHQoZG9jdW1lbnREYXRhLnQpO1xuICAgIGxlbiA9IGRvY3VtZW50RGF0YS5maW5hbFRleHQubGVuZ3RoO1xuICAgIGRvY3VtZW50RGF0YS5maW5hbExpbmVIZWlnaHQgPSBkb2N1bWVudERhdGEubGg7XG4gICAgdmFyIHRyYWNraW5nT2Zmc2V0ID0gZG9jdW1lbnREYXRhLnRyIC8gMTAwMCAqIGRvY3VtZW50RGF0YS5maW5hbFNpemU7XG4gICAgdmFyIGNoYXJDb2RlO1xuXG4gICAgaWYgKGRvY3VtZW50RGF0YS5zeikge1xuICAgICAgdmFyIGZsYWcgPSB0cnVlO1xuICAgICAgdmFyIGJveFdpZHRoID0gZG9jdW1lbnREYXRhLnN6WzBdO1xuICAgICAgdmFyIGJveEhlaWdodCA9IGRvY3VtZW50RGF0YS5zelsxXTtcbiAgICAgIHZhciBjdXJyZW50SGVpZ2h0O1xuICAgICAgdmFyIGZpbmFsVGV4dDtcblxuICAgICAgd2hpbGUgKGZsYWcpIHtcbiAgICAgICAgZmluYWxUZXh0ID0gdGhpcy5idWlsZEZpbmFsVGV4dChkb2N1bWVudERhdGEudCk7XG4gICAgICAgIGN1cnJlbnRIZWlnaHQgPSAwO1xuICAgICAgICBsaW5lV2lkdGggPSAwO1xuICAgICAgICBsZW4gPSBmaW5hbFRleHQubGVuZ3RoO1xuICAgICAgICB0cmFja2luZ09mZnNldCA9IGRvY3VtZW50RGF0YS50ciAvIDEwMDAgKiBkb2N1bWVudERhdGEuZmluYWxTaXplO1xuICAgICAgICB2YXIgbGFzdFNwYWNlSW5kZXggPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBjaGFyQ29kZSA9IGZpbmFsVGV4dFtpXS5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIG5ld0xpbmVGbGFnID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoZmluYWxUZXh0W2ldID09PSAnICcpIHtcbiAgICAgICAgICAgIGxhc3RTcGFjZUluZGV4ID0gaTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09PSAxMyB8fCBjaGFyQ29kZSA9PT0gMykge1xuICAgICAgICAgICAgbGluZVdpZHRoID0gMDtcbiAgICAgICAgICAgIG5ld0xpbmVGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIGN1cnJlbnRIZWlnaHQgKz0gZG9jdW1lbnREYXRhLmZpbmFsTGluZUhlaWdodCB8fCBkb2N1bWVudERhdGEuZmluYWxTaXplICogMS4yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmb250TWFuYWdlci5jaGFycykge1xuICAgICAgICAgICAgY2hhckRhdGEgPSBmb250TWFuYWdlci5nZXRDaGFyRGF0YShmaW5hbFRleHRbaV0sIGZvbnREYXRhLmZTdHlsZSwgZm9udERhdGEuZkZhbWlseSk7XG4gICAgICAgICAgICBjTGVuZ3RoID0gbmV3TGluZUZsYWcgPyAwIDogY2hhckRhdGEudyAqIGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRDYW52YXNIZWxwZXIuZm9udCA9IGRvY3VtZW50RGF0YS5zICsgJ3B4ICcrIGZvbnREYXRhLmZGYW1pbHk7XG4gICAgICAgICAgICBjTGVuZ3RoID0gZm9udE1hbmFnZXIubWVhc3VyZVRleHQoZmluYWxUZXh0W2ldLCBkb2N1bWVudERhdGEuZiwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxpbmVXaWR0aCArIGNMZW5ndGggPiBib3hXaWR0aCAmJiBmaW5hbFRleHRbaV0gIT09ICcgJykge1xuICAgICAgICAgICAgaWYgKGxhc3RTcGFjZUluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICBsZW4gKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGkgPSBsYXN0U3BhY2VJbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudEhlaWdodCArPSBkb2N1bWVudERhdGEuZmluYWxMaW5lSGVpZ2h0IHx8IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKiAxLjI7XG4gICAgICAgICAgICBmaW5hbFRleHQuc3BsaWNlKGksIGxhc3RTcGFjZUluZGV4ID09PSBpID8gMSA6IDAsICdcXHInKTsgLy8gZmluYWxUZXh0ID0gZmluYWxUZXh0LnN1YnN0cigwLGkpICsgXCJcXHJcIiArIGZpbmFsVGV4dC5zdWJzdHIoaSA9PT0gbGFzdFNwYWNlSW5kZXggPyBpICsgMSA6IGkpO1xuXG4gICAgICAgICAgICBsYXN0U3BhY2VJbmRleCA9IC0xO1xuICAgICAgICAgICAgbGluZVdpZHRoID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZVdpZHRoICs9IGNMZW5ndGg7XG4gICAgICAgICAgICBsaW5lV2lkdGggKz0gdHJhY2tpbmdPZmZzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudEhlaWdodCArPSBmb250RGF0YS5hc2NlbnQgKiBkb2N1bWVudERhdGEuZmluYWxTaXplIC8gMTAwO1xuXG4gICAgICAgIGlmICh0aGlzLmNhblJlc2l6ZSAmJiBkb2N1bWVudERhdGEuZmluYWxTaXplID4gdGhpcy5taW5pbXVtRm9udFNpemUgJiYgYm94SGVpZ2h0IDwgY3VycmVudEhlaWdodCkge1xuICAgICAgICAgIGRvY3VtZW50RGF0YS5maW5hbFNpemUgLT0gMTtcbiAgICAgICAgICBkb2N1bWVudERhdGEuZmluYWxMaW5lSGVpZ2h0ID0gZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAqIGRvY3VtZW50RGF0YS5saCAvIGRvY3VtZW50RGF0YS5zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvY3VtZW50RGF0YS5maW5hbFRleHQgPSBmaW5hbFRleHQ7XG4gICAgICAgICAgbGVuID0gZG9jdW1lbnREYXRhLmZpbmFsVGV4dC5sZW5ndGg7XG4gICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGluZVdpZHRoID0gLXRyYWNraW5nT2Zmc2V0O1xuICAgIGNMZW5ndGggPSAwO1xuICAgIHZhciB1bmNvbGxhcHNlZFNwYWNlcyA9IDA7XG4gICAgdmFyIGN1cnJlbnRDaGFyO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBuZXdMaW5lRmxhZyA9IGZhbHNlO1xuICAgICAgY3VycmVudENoYXIgPSBkb2N1bWVudERhdGEuZmluYWxUZXh0W2ldO1xuICAgICAgY2hhckNvZGUgPSBjdXJyZW50Q2hhci5jaGFyQ29kZUF0KDApO1xuXG4gICAgICBpZiAoY2hhckNvZGUgPT09IDEzIHx8IGNoYXJDb2RlID09PSAzKSB7XG4gICAgICAgIHVuY29sbGFwc2VkU3BhY2VzID0gMDtcbiAgICAgICAgbGluZVdpZHRocy5wdXNoKGxpbmVXaWR0aCk7XG4gICAgICAgIG1heExpbmVXaWR0aCA9IGxpbmVXaWR0aCA+IG1heExpbmVXaWR0aCA/IGxpbmVXaWR0aCA6IG1heExpbmVXaWR0aDtcbiAgICAgICAgbGluZVdpZHRoID0gLTIgKiB0cmFja2luZ09mZnNldDtcbiAgICAgICAgdmFsID0gJyc7XG4gICAgICAgIG5ld0xpbmVGbGFnID0gdHJ1ZTtcbiAgICAgICAgY3VycmVudExpbmUgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IGN1cnJlbnRDaGFyO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9udE1hbmFnZXIuY2hhcnMpIHtcbiAgICAgICAgY2hhckRhdGEgPSBmb250TWFuYWdlci5nZXRDaGFyRGF0YShjdXJyZW50Q2hhciwgZm9udERhdGEuZlN0eWxlLCBmb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5KTtcbiAgICAgICAgY0xlbmd0aCA9IG5ld0xpbmVGbGFnID8gMCA6IGNoYXJEYXRhLncgKiBkb2N1bWVudERhdGEuZmluYWxTaXplIC8gMTAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdmFyIGNoYXJXaWR0aCA9IGZvbnRNYW5hZ2VyLm1lYXN1cmVUZXh0KHZhbCwgZG9jdW1lbnREYXRhLmYsIGRvY3VtZW50RGF0YS5maW5hbFNpemUpO1xuICAgICAgICAvLyB0Q2FudmFzSGVscGVyLmZvbnQgPSBkb2N1bWVudERhdGEuZmluYWxTaXplICsgJ3B4ICcrIGZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpLmZGYW1pbHk7XG4gICAgICAgIGNMZW5ndGggPSBmb250TWFuYWdlci5tZWFzdXJlVGV4dCh2YWwsIGRvY3VtZW50RGF0YS5mLCBkb2N1bWVudERhdGEuZmluYWxTaXplKTtcbiAgICAgIH0gLy9cblxuXG4gICAgICBpZiAoY3VycmVudENoYXIgPT09ICcgJykge1xuICAgICAgICB1bmNvbGxhcHNlZFNwYWNlcyArPSBjTGVuZ3RoICsgdHJhY2tpbmdPZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lV2lkdGggKz0gY0xlbmd0aCArIHRyYWNraW5nT2Zmc2V0ICsgdW5jb2xsYXBzZWRTcGFjZXM7XG4gICAgICAgIHVuY29sbGFwc2VkU3BhY2VzID0gMDtcbiAgICAgIH1cblxuICAgICAgbGV0dGVycy5wdXNoKHtcbiAgICAgICAgbDogY0xlbmd0aCxcbiAgICAgICAgYW46IGNMZW5ndGgsXG4gICAgICAgIGFkZDogY3VycmVudFNpemUsXG4gICAgICAgIG46IG5ld0xpbmVGbGFnLFxuICAgICAgICBhbkluZGV4ZXM6IFtdLFxuICAgICAgICB2YWw6IHZhbCxcbiAgICAgICAgbGluZTogY3VycmVudExpbmUsXG4gICAgICAgIGFuaW1hdG9ySnVzdGlmeU9mZnNldDogMFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChhbmNob3JHcm91cGluZyA9PSAyKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICAgIGN1cnJlbnRTaXplICs9IGNMZW5ndGg7XG5cbiAgICAgICAgaWYgKHZhbCA9PT0gJycgfHwgdmFsID09PSAnICcgfHwgaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICAgIGlmICh2YWwgPT09ICcnIHx8IHZhbCA9PT0gJyAnKSB7XG4gICAgICAgICAgICBjdXJyZW50U2l6ZSAtPSBjTGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdoaWxlIChjdXJyZW50UG9zIDw9IGkpIHtcbiAgICAgICAgICAgIGxldHRlcnNbY3VycmVudFBvc10uYW4gPSBjdXJyZW50U2l6ZTtcbiAgICAgICAgICAgIGxldHRlcnNbY3VycmVudFBvc10uaW5kID0gaW5kZXg7XG4gICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmV4dHJhID0gY0xlbmd0aDtcbiAgICAgICAgICAgIGN1cnJlbnRQb3MgKz0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgIGN1cnJlbnRTaXplID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhbmNob3JHcm91cGluZyA9PSAzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICAgIGN1cnJlbnRTaXplICs9IGNMZW5ndGg7XG5cbiAgICAgICAgaWYgKHZhbCA9PT0gJycgfHwgaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICAgIGlmICh2YWwgPT09ICcnKSB7XG4gICAgICAgICAgICBjdXJyZW50U2l6ZSAtPSBjTGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdoaWxlIChjdXJyZW50UG9zIDw9IGkpIHtcbiAgICAgICAgICAgIGxldHRlcnNbY3VycmVudFBvc10uYW4gPSBjdXJyZW50U2l6ZTtcbiAgICAgICAgICAgIGxldHRlcnNbY3VycmVudFBvc10uaW5kID0gaW5kZXg7XG4gICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmV4dHJhID0gY0xlbmd0aDtcbiAgICAgICAgICAgIGN1cnJlbnRQb3MgKz0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50U2l6ZSA9IDA7XG4gICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0dGVyc1tpbmRleF0uaW5kID0gaW5kZXg7XG4gICAgICAgIGxldHRlcnNbaW5kZXhdLmV4dHJhID0gMDtcbiAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkb2N1bWVudERhdGEubCA9IGxldHRlcnM7XG4gICAgbWF4TGluZVdpZHRoID0gbGluZVdpZHRoID4gbWF4TGluZVdpZHRoID8gbGluZVdpZHRoIDogbWF4TGluZVdpZHRoO1xuICAgIGxpbmVXaWR0aHMucHVzaChsaW5lV2lkdGgpO1xuXG4gICAgaWYgKGRvY3VtZW50RGF0YS5zeikge1xuICAgICAgZG9jdW1lbnREYXRhLmJveFdpZHRoID0gZG9jdW1lbnREYXRhLnN6WzBdO1xuICAgICAgZG9jdW1lbnREYXRhLmp1c3RpZnlPZmZzZXQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudERhdGEuYm94V2lkdGggPSBtYXhMaW5lV2lkdGg7XG5cbiAgICAgIHN3aXRjaCAoZG9jdW1lbnREYXRhLmopIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ID0gLWRvY3VtZW50RGF0YS5ib3hXaWR0aDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgZG9jdW1lbnREYXRhLmp1c3RpZnlPZmZzZXQgPSAtZG9jdW1lbnREYXRhLmJveFdpZHRoIC8gMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkb2N1bWVudERhdGEubGluZVdpZHRocyA9IGxpbmVXaWR0aHM7XG4gICAgdmFyIGFuaW1hdG9ycyA9IGRhdGEuYTtcbiAgICB2YXIgYW5pbWF0b3JEYXRhO1xuICAgIHZhciBsZXR0ZXJEYXRhO1xuICAgIGpMZW4gPSBhbmltYXRvcnMubGVuZ3RoO1xuICAgIHZhciBiYXNlZDtcbiAgICB2YXIgaW5kO1xuICAgIHZhciBpbmRleGVzID0gW107XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICBhbmltYXRvckRhdGEgPSBhbmltYXRvcnNbal07XG5cbiAgICAgIGlmIChhbmltYXRvckRhdGEuYS5zYykge1xuICAgICAgICBkb2N1bWVudERhdGEuc3Ryb2tlQ29sb3JBbmltID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFuaW1hdG9yRGF0YS5hLnN3KSB7XG4gICAgICAgIGRvY3VtZW50RGF0YS5zdHJva2VXaWR0aEFuaW0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYW5pbWF0b3JEYXRhLmEuZmMgfHwgYW5pbWF0b3JEYXRhLmEuZmggfHwgYW5pbWF0b3JEYXRhLmEuZnMgfHwgYW5pbWF0b3JEYXRhLmEuZmIpIHtcbiAgICAgICAgZG9jdW1lbnREYXRhLmZpbGxDb2xvckFuaW0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpbmQgPSAwO1xuICAgICAgYmFzZWQgPSBhbmltYXRvckRhdGEucy5iO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgbGV0dGVyRGF0YSA9IGxldHRlcnNbaV07XG4gICAgICAgIGxldHRlckRhdGEuYW5JbmRleGVzW2pdID0gaW5kO1xuXG4gICAgICAgIGlmIChiYXNlZCA9PSAxICYmIGxldHRlckRhdGEudmFsICE9PSAnJyB8fCBiYXNlZCA9PSAyICYmIGxldHRlckRhdGEudmFsICE9PSAnJyAmJiBsZXR0ZXJEYXRhLnZhbCAhPT0gJyAnIHx8IGJhc2VkID09IDMgJiYgKGxldHRlckRhdGEubiB8fCBsZXR0ZXJEYXRhLnZhbCA9PSAnICcgfHwgaSA9PSBsZW4gLSAxKSB8fCBiYXNlZCA9PSA0ICYmIChsZXR0ZXJEYXRhLm4gfHwgaSA9PSBsZW4gLSAxKSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICAgICAgaWYgKGFuaW1hdG9yRGF0YS5zLnJuID09PSAxKSB7XG4gICAgICAgICAgICBpbmRleGVzLnB1c2goaW5kKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbmQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkYXRhLmFbal0ucy50b3RhbENoYXJzID0gaW5kO1xuICAgICAgdmFyIGN1cnJlbnRJbmQgPSAtMTtcbiAgICAgIHZhciBuZXdJbmQ7XG5cbiAgICAgIGlmIChhbmltYXRvckRhdGEucy5ybiA9PT0gMSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBsZXR0ZXJEYXRhID0gbGV0dGVyc1tpXTtcblxuICAgICAgICAgIGlmIChjdXJyZW50SW5kICE9IGxldHRlckRhdGEuYW5JbmRleGVzW2pdKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgICAgICAgY3VycmVudEluZCA9IGxldHRlckRhdGEuYW5JbmRleGVzW2pdO1xuICAgICAgICAgICAgbmV3SW5kID0gaW5kZXhlcy5zcGxpY2UoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogaW5kZXhlcy5sZW5ndGgpLCAxKVswXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXR0ZXJEYXRhLmFuSW5kZXhlc1tqXSA9IG5ld0luZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGRvY3VtZW50RGF0YS55T2Zmc2V0ID0gZG9jdW1lbnREYXRhLmZpbmFsTGluZUhlaWdodCB8fCBkb2N1bWVudERhdGEuZmluYWxTaXplICogMS4yO1xuICAgIGRvY3VtZW50RGF0YS5scyA9IGRvY3VtZW50RGF0YS5scyB8fCAwO1xuICAgIGRvY3VtZW50RGF0YS5hc2NlbnQgPSBmb250RGF0YS5hc2NlbnQgKiBkb2N1bWVudERhdGEuZmluYWxTaXplIC8gMTAwO1xuICB9O1xuXG4gIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUudXBkYXRlRG9jdW1lbnREYXRhID0gZnVuY3Rpb24gKG5ld0RhdGEsIGluZGV4KSB7XG4gICAgaW5kZXggPSBpbmRleCA9PT0gdW5kZWZpbmVkID8gdGhpcy5rZXlzSW5kZXggOiBpbmRleDtcbiAgICB2YXIgZERhdGEgPSB0aGlzLmNvcHlEYXRhKHt9LCB0aGlzLmRhdGEuZC5rW2luZGV4XS5zKTtcbiAgICBkRGF0YSA9IHRoaXMuY29weURhdGEoZERhdGEsIG5ld0RhdGEpO1xuICAgIHRoaXMuZGF0YS5kLmtbaW5kZXhdLnMgPSBkRGF0YTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlKGluZGV4KTtcbiAgICB0aGlzLnNldEN1cnJlbnREYXRhKGREYXRhKTtcbiAgICB0aGlzLmVsZW0uYWRkRHluYW1pY1Byb3BlcnR5KHRoaXMpO1xuICB9O1xuXG4gIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUucmVjYWxjdWxhdGUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgZERhdGEgPSB0aGlzLmRhdGEuZC5rW2luZGV4XS5zO1xuICAgIGREYXRhLl9fY29tcGxldGUgPSBmYWxzZTtcbiAgICB0aGlzLmtleXNJbmRleCA9IDA7XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICB0aGlzLmdldFZhbHVlKGREYXRhKTtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLmNhblJlc2l6ZUZvbnQgPSBmdW5jdGlvbiAoX2NhblJlc2l6ZSkge1xuICAgIHRoaXMuY2FuUmVzaXplID0gX2NhblJlc2l6ZTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlKHRoaXMua2V5c0luZGV4KTtcbiAgICB0aGlzLmVsZW0uYWRkRHluYW1pY1Byb3BlcnR5KHRoaXMpO1xuICB9O1xuXG4gIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuc2V0TWluaW11bUZvbnRTaXplID0gZnVuY3Rpb24gKF9mb250VmFsdWUpIHtcbiAgICB0aGlzLm1pbmltdW1Gb250U2l6ZSA9IE1hdGguZmxvb3IoX2ZvbnRWYWx1ZSkgfHwgMTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlKHRoaXMua2V5c0luZGV4KTtcbiAgICB0aGlzLmVsZW0uYWRkRHluYW1pY1Byb3BlcnR5KHRoaXMpO1xuICB9O1xuXG4gIHZhciBUZXh0U2VsZWN0b3JQcm9wID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtYXggPSBNYXRoLm1heDtcbiAgICB2YXIgbWluID0gTWF0aC5taW47XG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxuICAgIGZ1bmN0aW9uIFRleHRTZWxlY3RvclByb3BGYWN0b3J5KGVsZW0sIGRhdGEpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRUZXh0TGVuZ3RoID0gLTE7XG4gICAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xuICAgICAgdGhpcy5maW5hbFMgPSAwO1xuICAgICAgdGhpcy5maW5hbEUgPSAwO1xuICAgICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICAgICAgdGhpcy5zID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5zIHx8IHtcbiAgICAgICAgazogMFxuICAgICAgfSwgMCwgMCwgdGhpcyk7XG5cbiAgICAgIGlmICgnZScgaW4gZGF0YSkge1xuICAgICAgICB0aGlzLmUgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmUsIDAsIDAsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lID0ge1xuICAgICAgICAgIHY6IDEwMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm8gfHwge1xuICAgICAgICBrOiAwXG4gICAgICB9LCAwLCAwLCB0aGlzKTtcbiAgICAgIHRoaXMueGUgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnhlIHx8IHtcbiAgICAgICAgazogMFxuICAgICAgfSwgMCwgMCwgdGhpcyk7XG4gICAgICB0aGlzLm5lID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5uZSB8fCB7XG4gICAgICAgIGs6IDBcbiAgICAgIH0sIDAsIDAsIHRoaXMpO1xuICAgICAgdGhpcy5zbSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuc20gfHwge1xuICAgICAgICBrOiAxMDBcbiAgICAgIH0sIDAsIDAsIHRoaXMpO1xuICAgICAgdGhpcy5hID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5hLCAwLCAwLjAxLCB0aGlzKTtcblxuICAgICAgaWYgKCF0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmdldFZhbHVlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgVGV4dFNlbGVjdG9yUHJvcEZhY3RvcnkucHJvdG90eXBlID0ge1xuICAgICAgZ2V0TXVsdDogZnVuY3Rpb24gZ2V0TXVsdChpbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUZXh0TGVuZ3RoICE9PSB0aGlzLmVsZW0udGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLmwubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHgxID0gMDtcbiAgICAgICAgdmFyIHkxID0gMDtcbiAgICAgICAgdmFyIHgyID0gMTtcbiAgICAgICAgdmFyIHkyID0gMTtcblxuICAgICAgICBpZiAodGhpcy5uZS52ID4gMCkge1xuICAgICAgICAgIHgxID0gdGhpcy5uZS52IC8gMTAwLjA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeTEgPSAtdGhpcy5uZS52IC8gMTAwLjA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy54ZS52ID4gMCkge1xuICAgICAgICAgIHgyID0gMS4wIC0gdGhpcy54ZS52IC8gMTAwLjA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeTIgPSAxLjAgKyB0aGlzLnhlLnYgLyAxMDAuMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlYXNlciA9IEJlemllckZhY3RvcnkuZ2V0QmV6aWVyRWFzaW5nKHgxLCB5MSwgeDIsIHkyKS5nZXQ7XG4gICAgICAgIHZhciBtdWx0ID0gMDtcbiAgICAgICAgdmFyIHMgPSB0aGlzLmZpbmFsUztcbiAgICAgICAgdmFyIGUgPSB0aGlzLmZpbmFsRTtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmRhdGEuc2g7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IDIpIHtcbiAgICAgICAgICBpZiAoZSA9PT0gcykge1xuICAgICAgICAgICAgbXVsdCA9IGluZCA+PSBlID8gMSA6IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG11bHQgPSBtYXgoMCwgbWluKDAuNSAvIChlIC0gcykgKyAoaW5kIC0gcykgLyAoZSAtIHMpLCAxKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbXVsdCA9IGVhc2VyKG11bHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDMpIHtcbiAgICAgICAgICBpZiAoZSA9PT0gcykge1xuICAgICAgICAgICAgbXVsdCA9IGluZCA+PSBlID8gMCA6IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG11bHQgPSAxIC0gbWF4KDAsIG1pbigwLjUgLyAoZSAtIHMpICsgKGluZCAtIHMpIC8gKGUgLSBzKSwgMSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG11bHQgPSBlYXNlcihtdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA0KSB7XG4gICAgICAgICAgaWYgKGUgPT09IHMpIHtcbiAgICAgICAgICAgIG11bHQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtdWx0ID0gbWF4KDAsIG1pbigwLjUgLyAoZSAtIHMpICsgKGluZCAtIHMpIC8gKGUgLSBzKSwgMSkpO1xuXG4gICAgICAgICAgICBpZiAobXVsdCA8IDAuNSkge1xuICAgICAgICAgICAgICBtdWx0ICo9IDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtdWx0ID0gMSAtIDIgKiAobXVsdCAtIDAuNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbXVsdCA9IGVhc2VyKG11bHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDUpIHtcbiAgICAgICAgICBpZiAoZSA9PT0gcykge1xuICAgICAgICAgICAgbXVsdCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0b3QgPSBlIC0gcztcbiAgICAgICAgICAgIC8qIGluZCArPSAwLjU7XHJcbiAgICAgICAgICAgICAgICAgICAgICBtdWx0ID0gLTQvKHRvdCp0b3QpKihpbmQqaW5kKSsoNC90b3QpKmluZDsgKi9cblxuICAgICAgICAgICAgaW5kID0gbWluKG1heCgwLCBpbmQgKyAwLjUgLSBzKSwgZSAtIHMpO1xuICAgICAgICAgICAgdmFyIHggPSAtdG90IC8gMiArIGluZDtcbiAgICAgICAgICAgIHZhciBhID0gdG90IC8gMjtcbiAgICAgICAgICAgIG11bHQgPSBNYXRoLnNxcnQoMSAtIHggKiB4IC8gKGEgKiBhKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbXVsdCA9IGVhc2VyKG11bHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDYpIHtcbiAgICAgICAgICBpZiAoZSA9PT0gcykge1xuICAgICAgICAgICAgbXVsdCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZCA9IG1pbihtYXgoMCwgaW5kICsgMC41IC0gcyksIGUgLSBzKTtcbiAgICAgICAgICAgIG11bHQgPSAoMSArIE1hdGguY29zKE1hdGguUEkgKyBNYXRoLlBJICogMiAqIGluZCAvIChlIC0gcykpKSAvIDI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtdWx0ID0gZWFzZXIobXVsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGluZCA+PSBmbG9vcihzKSkge1xuICAgICAgICAgICAgaWYgKGluZCAtIHMgPCAwKSB7XG4gICAgICAgICAgICAgIG11bHQgPSBtYXgoMCwgbWluKG1pbihlLCAxKSAtIChzIC0gaW5kKSwgMSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbXVsdCA9IG1heCgwLCBtaW4oZSAtIGluZCwgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG11bHQgPSBlYXNlcihtdWx0KTtcbiAgICAgICAgfSAvLyBTbW9vdGhuZXNzIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAvLyBUaGUgc21vb3RobmVzcyByZXByZXNlbnRzIGEgcmVkdWNlZCByYW5nZSBvZiB0aGUgb3JpZ2luYWwgWzA7IDFdIHJhbmdlLlxuICAgICAgICAvLyBpZiBzbW9vdGhuZXNzIGlzIDI1JSwgdGhlIG5ldyByYW5nZSB3aWxsIGJlIFswLjM3NTsgMC42MjVdXG4gICAgICAgIC8vIFN0ZXBzIGFyZTpcbiAgICAgICAgLy8gLSBmaW5kIHRoZSBsb3dlciB2YWx1ZSBvZiB0aGUgbmV3IHJhbmdlICh0aHJlc2hvbGQpXG4gICAgICAgIC8vIC0gaWYgbXVsdGlwbGllciBpcyBzbWFsbGVyIHRoYW4gdGhhdCB2YWx1ZSwgZmxvb3IgaXQgdG8gMFxuICAgICAgICAvLyAtIGlmIGl0IGlzIGxhcmdlcixcbiAgICAgICAgLy8gICAgIC0gc3VidHJhY3QgdGhlIHRocmVzaG9sZFxuICAgICAgICAvLyAgICAgLSBkaXZpZGUgaXQgYnkgdGhlIHNtb290aG5lc3MgKHRoaXMgd2lsbCByZXR1cm4gdGhlIHJhbmdlIHRvIFswOyAxXSlcbiAgICAgICAgLy8gTm90ZTogSWYgaXQgZG9lc24ndCB3b3JrIG9uIHNvbWUgc2NlbmFyaW9zLCBjb25zaWRlciBhcHBseWluZyBpdCBiZWZvcmUgdGhlIGVhc2VyLlxuXG5cbiAgICAgICAgaWYgKHRoaXMuc20udiAhPT0gMTAwKSB7XG4gICAgICAgICAgdmFyIHNtb290aG5lc3MgPSB0aGlzLnNtLnYgKiAwLjAxO1xuXG4gICAgICAgICAgaWYgKHNtb290aG5lc3MgPT09IDApIHtcbiAgICAgICAgICAgIHNtb290aG5lc3MgPSAwLjAwMDAwMDAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0aHJlc2hvbGQgPSAwLjUgLSBzbW9vdGhuZXNzICogMC41O1xuXG4gICAgICAgICAgaWYgKG11bHQgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIG11bHQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtdWx0ID0gKG11bHQgLSB0aHJlc2hvbGQpIC8gc21vb3RobmVzcztcblxuICAgICAgICAgICAgaWYgKG11bHQgPiAxKSB7XG4gICAgICAgICAgICAgIG11bHQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtdWx0ICogdGhpcy5hLnY7XG4gICAgICB9LFxuICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKG5ld0NoYXJzRmxhZykge1xuICAgICAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xuICAgICAgICB0aGlzLl9tZGYgPSBuZXdDaGFyc0ZsYWcgfHwgdGhpcy5fbWRmO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGV4dExlbmd0aCA9IHRoaXMuZWxlbS50ZXh0UHJvcGVydHkuY3VycmVudERhdGEubC5sZW5ndGggfHwgMDtcblxuICAgICAgICBpZiAobmV3Q2hhcnNGbGFnICYmIHRoaXMuZGF0YS5yID09PSAyKSB7XG4gICAgICAgICAgdGhpcy5lLnYgPSB0aGlzLl9jdXJyZW50VGV4dExlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaXZpc29yID0gdGhpcy5kYXRhLnIgPT09IDIgPyAxIDogMTAwIC8gdGhpcy5kYXRhLnRvdGFsQ2hhcnM7XG4gICAgICAgIHZhciBvID0gdGhpcy5vLnYgLyBkaXZpc29yO1xuICAgICAgICB2YXIgcyA9IHRoaXMucy52IC8gZGl2aXNvciArIG87XG4gICAgICAgIHZhciBlID0gdGhpcy5lLnYgLyBkaXZpc29yICsgbztcblxuICAgICAgICBpZiAocyA+IGUpIHtcbiAgICAgICAgICB2YXIgX3MgPSBzO1xuICAgICAgICAgIHMgPSBlO1xuICAgICAgICAgIGUgPSBfcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmluYWxTID0gcztcbiAgICAgICAgdGhpcy5maW5hbEUgPSBlO1xuICAgICAgfVxuICAgIH07XG4gICAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBUZXh0U2VsZWN0b3JQcm9wRmFjdG9yeSk7XG5cbiAgICBmdW5jdGlvbiBnZXRUZXh0U2VsZWN0b3JQcm9wKGVsZW0sIGRhdGEsIGFycikge1xuICAgICAgcmV0dXJuIG5ldyBUZXh0U2VsZWN0b3JQcm9wRmFjdG9yeShlbGVtLCBkYXRhLCBhcnIpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBnZXRUZXh0U2VsZWN0b3JQcm9wOiBnZXRUZXh0U2VsZWN0b3JQcm9wXG4gICAgfTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIFRleHRBbmltYXRvckRhdGFQcm9wZXJ0eShlbGVtLCBhbmltYXRvclByb3BzLCBjb250YWluZXIpIHtcbiAgICB2YXIgZGVmYXVsdERhdGEgPSB7XG4gICAgICBwcm9wVHlwZTogZmFsc2VcbiAgICB9O1xuICAgIHZhciBnZXRQcm9wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3A7XG4gICAgdmFyIHRleHRBbmltYXRvckFuaW1hdGFibGVzID0gYW5pbWF0b3JQcm9wcy5hO1xuICAgIHRoaXMuYSA9IHtcbiAgICAgIHI6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnIgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLnIsIDAsIGRlZ1RvUmFkcywgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgcng6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnJ4ID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5yeCwgMCwgZGVnVG9SYWRzLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICByeTogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucnkgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLnJ5LCAwLCBkZWdUb1JhZHMsIGNvbnRhaW5lcikgOiBkZWZhdWx0RGF0YSxcbiAgICAgIHNrOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zayA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuc2ssIDAsIGRlZ1RvUmFkcywgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgc2E6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnNhID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zYSwgMCwgZGVnVG9SYWRzLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBzOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zLCAxLCAwLjAxLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBhOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5hID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5hLCAxLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBvOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5vID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5vLCAwLCAwLjAxLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBwOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5wID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5wLCAxLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBzdzogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuc3cgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLnN3LCAwLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBzYzogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuc2MgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLnNjLCAxLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBmYzogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuZmMgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZjLCAxLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBmaDogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuZmggPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZoLCAwLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBmczogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuZnMgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZzLCAwLCAwLjAxLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBmYjogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuZmIgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZiLCAwLCAwLjAxLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICB0OiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy50ID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy50LCAwLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGFcbiAgICB9O1xuICAgIHRoaXMucyA9IFRleHRTZWxlY3RvclByb3AuZ2V0VGV4dFNlbGVjdG9yUHJvcChlbGVtLCBhbmltYXRvclByb3BzLnMsIGNvbnRhaW5lcik7XG4gICAgdGhpcy5zLnQgPSBhbmltYXRvclByb3BzLnMudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFRleHRBbmltYXRvclByb3BlcnR5KHRleHREYXRhLCByZW5kZXJUeXBlLCBlbGVtKSB7XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICB0aGlzLl9oYXNNYXNrZWRQYXRoID0gZmFsc2U7XG4gICAgdGhpcy5fZnJhbWVJZCA9IC0xO1xuICAgIHRoaXMuX3RleHREYXRhID0gdGV4dERhdGE7XG4gICAgdGhpcy5fcmVuZGVyVHlwZSA9IHJlbmRlclR5cGU7XG4gICAgdGhpcy5fZWxlbSA9IGVsZW07XG4gICAgdGhpcy5fYW5pbWF0b3JzRGF0YSA9IGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fdGV4dERhdGEuYS5sZW5ndGgpO1xuICAgIHRoaXMuX3BhdGhEYXRhID0ge307XG4gICAgdGhpcy5fbW9yZU9wdGlvbnMgPSB7XG4gICAgICBhbGlnbm1lbnQ6IHt9XG4gICAgfTtcbiAgICB0aGlzLnJlbmRlcmVkTGV0dGVycyA9IFtdO1xuICAgIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnID0gZmFsc2U7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICB9XG5cbiAgVGV4dEFuaW1hdG9yUHJvcGVydHkucHJvdG90eXBlLnNlYXJjaFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuX3RleHREYXRhLmEubGVuZ3RoO1xuICAgIHZhciBhbmltYXRvclByb3BzO1xuICAgIHZhciBnZXRQcm9wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3A7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGFuaW1hdG9yUHJvcHMgPSB0aGlzLl90ZXh0RGF0YS5hW2ldO1xuICAgICAgdGhpcy5fYW5pbWF0b3JzRGF0YVtpXSA9IG5ldyBUZXh0QW5pbWF0b3JEYXRhUHJvcGVydHkodGhpcy5fZWxlbSwgYW5pbWF0b3JQcm9wcywgdGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3RleHREYXRhLnAgJiYgJ20nIGluIHRoaXMuX3RleHREYXRhLnApIHtcbiAgICAgIHRoaXMuX3BhdGhEYXRhID0ge1xuICAgICAgICBhOiBnZXRQcm9wKHRoaXMuX2VsZW0sIHRoaXMuX3RleHREYXRhLnAuYSwgMCwgMCwgdGhpcyksXG4gICAgICAgIGY6IGdldFByb3AodGhpcy5fZWxlbSwgdGhpcy5fdGV4dERhdGEucC5mLCAwLCAwLCB0aGlzKSxcbiAgICAgICAgbDogZ2V0UHJvcCh0aGlzLl9lbGVtLCB0aGlzLl90ZXh0RGF0YS5wLmwsIDAsIDAsIHRoaXMpLFxuICAgICAgICByOiBnZXRQcm9wKHRoaXMuX2VsZW0sIHRoaXMuX3RleHREYXRhLnAuciwgMCwgMCwgdGhpcyksXG4gICAgICAgIHA6IGdldFByb3AodGhpcy5fZWxlbSwgdGhpcy5fdGV4dERhdGEucC5wLCAwLCAwLCB0aGlzKSxcbiAgICAgICAgbTogdGhpcy5fZWxlbS5tYXNrTWFuYWdlci5nZXRNYXNrUHJvcGVydHkodGhpcy5fdGV4dERhdGEucC5tKVxuICAgICAgfTtcbiAgICAgIHRoaXMuX2hhc01hc2tlZFBhdGggPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oYXNNYXNrZWRQYXRoID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fbW9yZU9wdGlvbnMuYWxpZ25tZW50ID0gZ2V0UHJvcCh0aGlzLl9lbGVtLCB0aGlzLl90ZXh0RGF0YS5tLmEsIDEsIDAsIHRoaXMpO1xuICB9O1xuXG4gIFRleHRBbmltYXRvclByb3BlcnR5LnByb3RvdHlwZS5nZXRNZWFzdXJlcyA9IGZ1bmN0aW9uIChkb2N1bWVudERhdGEsIGxldHRlcnNDaGFuZ2VkRmxhZykge1xuICAgIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnID0gbGV0dGVyc0NoYW5nZWRGbGFnO1xuXG4gICAgaWYgKCF0aGlzLl9tZGYgJiYgIXRoaXMuX2lzRmlyc3RGcmFtZSAmJiAhbGV0dGVyc0NoYW5nZWRGbGFnICYmICghdGhpcy5faGFzTWFza2VkUGF0aCB8fCAhdGhpcy5fcGF0aERhdGEubS5fbWRmKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IGZhbHNlO1xuICAgIHZhciBhbGlnbm1lbnQgPSB0aGlzLl9tb3JlT3B0aW9ucy5hbGlnbm1lbnQudjtcbiAgICB2YXIgYW5pbWF0b3JzID0gdGhpcy5fYW5pbWF0b3JzRGF0YTtcbiAgICB2YXIgdGV4dERhdGEgPSB0aGlzLl90ZXh0RGF0YTtcbiAgICB2YXIgbWF0cml4SGVscGVyID0gdGhpcy5tSGVscGVyO1xuICAgIHZhciByZW5kZXJUeXBlID0gdGhpcy5fcmVuZGVyVHlwZTtcbiAgICB2YXIgcmVuZGVyZWRMZXR0ZXJzQ291bnQgPSB0aGlzLnJlbmRlcmVkTGV0dGVycy5sZW5ndGg7XG4gICAgdmFyIHhQb3M7XG4gICAgdmFyIHlQb3M7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcbiAgICB2YXIgbGV0dGVycyA9IGRvY3VtZW50RGF0YS5sO1xuICAgIHZhciBwYXRoSW5mbztcbiAgICB2YXIgY3VycmVudExlbmd0aDtcbiAgICB2YXIgY3VycmVudFBvaW50O1xuICAgIHZhciBzZWdtZW50TGVuZ3RoO1xuICAgIHZhciBmbGFnO1xuICAgIHZhciBwb2ludEluZDtcbiAgICB2YXIgc2VnbWVudEluZDtcbiAgICB2YXIgcHJldlBvaW50O1xuICAgIHZhciBwb2ludHM7XG4gICAgdmFyIHNlZ21lbnRzO1xuICAgIHZhciBwYXJ0aWFsTGVuZ3RoO1xuICAgIHZhciB0b3RhbExlbmd0aDtcbiAgICB2YXIgcGVyYztcbiAgICB2YXIgdGFuQW5nbGU7XG4gICAgdmFyIG1hc2s7XG5cbiAgICBpZiAodGhpcy5faGFzTWFza2VkUGF0aCkge1xuICAgICAgbWFzayA9IHRoaXMuX3BhdGhEYXRhLm07XG5cbiAgICAgIGlmICghdGhpcy5fcGF0aERhdGEubiB8fCB0aGlzLl9wYXRoRGF0YS5fbWRmKSB7XG4gICAgICAgIHZhciBwYXRocyA9IG1hc2sudjtcblxuICAgICAgICBpZiAodGhpcy5fcGF0aERhdGEuci52KSB7XG4gICAgICAgICAgcGF0aHMgPSBwYXRocy5yZXZlcnNlKCk7XG4gICAgICAgIH0gLy8gVE9ETzogcmVsZWFzZSBiZXppZXIgZGF0YSBjYWNoZWQgZnJvbSBwcmV2aW91cyBwYXRoSW5mbzogdGhpcy5fcGF0aERhdGEucGlcblxuXG4gICAgICAgIHBhdGhJbmZvID0ge1xuICAgICAgICAgIHRMZW5ndGg6IDAsXG4gICAgICAgICAgc2VnbWVudHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGxlbiA9IHBhdGhzLl9sZW5ndGggLSAxO1xuICAgICAgICB2YXIgYmV6aWVyRGF0YTtcbiAgICAgICAgdG90YWxMZW5ndGggPSAwO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGJlemllckRhdGEgPSBiZXouYnVpbGRCZXppZXJEYXRhKHBhdGhzLnZbaV0sIHBhdGhzLnZbaSArIDFdLCBbcGF0aHMub1tpXVswXSAtIHBhdGhzLnZbaV1bMF0sIHBhdGhzLm9baV1bMV0gLSBwYXRocy52W2ldWzFdXSwgW3BhdGhzLmlbaSArIDFdWzBdIC0gcGF0aHMudltpICsgMV1bMF0sIHBhdGhzLmlbaSArIDFdWzFdIC0gcGF0aHMudltpICsgMV1bMV1dKTtcbiAgICAgICAgICBwYXRoSW5mby50TGVuZ3RoICs9IGJlemllckRhdGEuc2VnbWVudExlbmd0aDtcbiAgICAgICAgICBwYXRoSW5mby5zZWdtZW50cy5wdXNoKGJlemllckRhdGEpO1xuICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IGJlemllckRhdGEuc2VnbWVudExlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgPSBsZW47XG5cbiAgICAgICAgaWYgKG1hc2sudi5jKSB7XG4gICAgICAgICAgYmV6aWVyRGF0YSA9IGJlei5idWlsZEJlemllckRhdGEocGF0aHMudltpXSwgcGF0aHMudlswXSwgW3BhdGhzLm9baV1bMF0gLSBwYXRocy52W2ldWzBdLCBwYXRocy5vW2ldWzFdIC0gcGF0aHMudltpXVsxXV0sIFtwYXRocy5pWzBdWzBdIC0gcGF0aHMudlswXVswXSwgcGF0aHMuaVswXVsxXSAtIHBhdGhzLnZbMF1bMV1dKTtcbiAgICAgICAgICBwYXRoSW5mby50TGVuZ3RoICs9IGJlemllckRhdGEuc2VnbWVudExlbmd0aDtcbiAgICAgICAgICBwYXRoSW5mby5zZWdtZW50cy5wdXNoKGJlemllckRhdGEpO1xuICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IGJlemllckRhdGEuc2VnbWVudExlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BhdGhEYXRhLnBpID0gcGF0aEluZm87XG4gICAgICB9XG5cbiAgICAgIHBhdGhJbmZvID0gdGhpcy5fcGF0aERhdGEucGk7XG4gICAgICBjdXJyZW50TGVuZ3RoID0gdGhpcy5fcGF0aERhdGEuZi52O1xuICAgICAgc2VnbWVudEluZCA9IDA7XG4gICAgICBwb2ludEluZCA9IDE7XG4gICAgICBzZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgc2VnbWVudHMgPSBwYXRoSW5mby5zZWdtZW50cztcblxuICAgICAgaWYgKGN1cnJlbnRMZW5ndGggPCAwICYmIG1hc2sudi5jKSB7XG4gICAgICAgIGlmIChwYXRoSW5mby50TGVuZ3RoIDwgTWF0aC5hYnMoY3VycmVudExlbmd0aCkpIHtcbiAgICAgICAgICBjdXJyZW50TGVuZ3RoID0gLU1hdGguYWJzKGN1cnJlbnRMZW5ndGgpICUgcGF0aEluZm8udExlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlZ21lbnRJbmQgPSBzZWdtZW50cy5sZW5ndGggLSAxO1xuICAgICAgICBwb2ludHMgPSBzZWdtZW50c1tzZWdtZW50SW5kXS5wb2ludHM7XG4gICAgICAgIHBvaW50SW5kID0gcG9pbnRzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKGN1cnJlbnRMZW5ndGggPCAwKSB7XG4gICAgICAgICAgY3VycmVudExlbmd0aCArPSBwb2ludHNbcG9pbnRJbmRdLnBhcnRpYWxMZW5ndGg7XG4gICAgICAgICAgcG9pbnRJbmQgLT0gMTtcblxuICAgICAgICAgIGlmIChwb2ludEluZCA8IDApIHtcbiAgICAgICAgICAgIHNlZ21lbnRJbmQgLT0gMTtcbiAgICAgICAgICAgIHBvaW50cyA9IHNlZ21lbnRzW3NlZ21lbnRJbmRdLnBvaW50cztcbiAgICAgICAgICAgIHBvaW50SW5kID0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBvaW50cyA9IHNlZ21lbnRzW3NlZ21lbnRJbmRdLnBvaW50cztcbiAgICAgIHByZXZQb2ludCA9IHBvaW50c1twb2ludEluZCAtIDFdO1xuICAgICAgY3VycmVudFBvaW50ID0gcG9pbnRzW3BvaW50SW5kXTtcbiAgICAgIHBhcnRpYWxMZW5ndGggPSBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcbiAgICB9XG5cbiAgICBsZW4gPSBsZXR0ZXJzLmxlbmd0aDtcbiAgICB4UG9zID0gMDtcbiAgICB5UG9zID0gMDtcbiAgICB2YXIgeU9mZiA9IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKiAxLjIgKiAwLjcxNDtcbiAgICB2YXIgZmlyc3RMaW5lID0gdHJ1ZTtcbiAgICB2YXIgYW5pbWF0b3JQcm9wcztcbiAgICB2YXIgYW5pbWF0b3JTZWxlY3RvcjtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgbGV0dGVyVmFsdWU7XG4gICAgakxlbiA9IGFuaW1hdG9ycy5sZW5ndGg7XG4gICAgdmFyIG11bHQ7XG4gICAgdmFyIGluZCA9IC0xO1xuICAgIHZhciBvZmZmO1xuICAgIHZhciB4UGF0aFBvcztcbiAgICB2YXIgeVBhdGhQb3M7XG4gICAgdmFyIGluaXRQYXRoUG9zID0gY3VycmVudExlbmd0aDtcbiAgICB2YXIgaW5pdFNlZ21lbnRJbmQgPSBzZWdtZW50SW5kO1xuICAgIHZhciBpbml0UG9pbnRJbmQgPSBwb2ludEluZDtcbiAgICB2YXIgY3VycmVudExpbmUgPSAtMTtcbiAgICB2YXIgZWxlbU9wYWNpdHk7XG4gICAgdmFyIHNjO1xuICAgIHZhciBzdztcbiAgICB2YXIgZmM7XG4gICAgdmFyIGs7XG4gICAgdmFyIGxldHRlclN3O1xuICAgIHZhciBsZXR0ZXJTYztcbiAgICB2YXIgbGV0dGVyRmM7XG4gICAgdmFyIGxldHRlck0gPSAnJztcbiAgICB2YXIgbGV0dGVyUCA9IHRoaXMuZGVmYXVsdFByb3BzQXJyYXk7XG4gICAgdmFyIGxldHRlck87IC8vXG5cbiAgICBpZiAoZG9jdW1lbnREYXRhLmogPT09IDIgfHwgZG9jdW1lbnREYXRhLmogPT09IDEpIHtcbiAgICAgIHZhciBhbmltYXRvckp1c3RpZnlPZmZzZXQgPSAwO1xuICAgICAgdmFyIGFuaW1hdG9yRmlyc3RDaGFyT2Zmc2V0ID0gMDtcbiAgICAgIHZhciBqdXN0aWZ5T2Zmc2V0TXVsdCA9IGRvY3VtZW50RGF0YS5qID09PSAyID8gLTAuNSA6IC0xO1xuICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgaXNOZXdMaW5lID0gdHJ1ZTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmIChsZXR0ZXJzW2ldLm4pIHtcbiAgICAgICAgICBpZiAoYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0KSB7XG4gICAgICAgICAgICBhbmltYXRvckp1c3RpZnlPZmZzZXQgKz0gYW5pbWF0b3JGaXJzdENoYXJPZmZzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2hpbGUgKGxhc3RJbmRleCA8IGkpIHtcbiAgICAgICAgICAgIGxldHRlcnNbbGFzdEluZGV4XS5hbmltYXRvckp1c3RpZnlPZmZzZXQgPSBhbmltYXRvckp1c3RpZnlPZmZzZXQ7XG4gICAgICAgICAgICBsYXN0SW5kZXggKz0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhbmltYXRvckp1c3RpZnlPZmZzZXQgPSAwO1xuICAgICAgICAgIGlzTmV3TGluZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgYW5pbWF0b3JQcm9wcyA9IGFuaW1hdG9yc1tqXS5hO1xuXG4gICAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy50LnByb3BUeXBlKSB7XG4gICAgICAgICAgICAgIGlmIChpc05ld0xpbmUgJiYgZG9jdW1lbnREYXRhLmogPT09IDIpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRvckZpcnN0Q2hhck9mZnNldCArPSBhbmltYXRvclByb3BzLnQudiAqIGp1c3RpZnlPZmZzZXRNdWx0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYW5pbWF0b3JTZWxlY3RvciA9IGFuaW1hdG9yc1tqXS5zO1xuICAgICAgICAgICAgICBtdWx0ID0gYW5pbWF0b3JTZWxlY3Rvci5nZXRNdWx0KGxldHRlcnNbaV0uYW5JbmRleGVzW2pdLCB0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XG5cbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ICs9IGFuaW1hdG9yUHJvcHMudC52ICogbXVsdFswXSAqIGp1c3RpZnlPZmZzZXRNdWx0O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9ySnVzdGlmeU9mZnNldCArPSBhbmltYXRvclByb3BzLnQudiAqIG11bHQgKiBqdXN0aWZ5T2Zmc2V0TXVsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlzTmV3TGluZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmltYXRvckp1c3RpZnlPZmZzZXQpIHtcbiAgICAgICAgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ICs9IGFuaW1hdG9yRmlyc3RDaGFyT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobGFzdEluZGV4IDwgaSkge1xuICAgICAgICBsZXR0ZXJzW2xhc3RJbmRleF0uYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ID0gYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0O1xuICAgICAgICBsYXN0SW5kZXggKz0gMTtcbiAgICAgIH1cbiAgICB9IC8vXG5cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgbWF0cml4SGVscGVyLnJlc2V0KCk7XG4gICAgICBlbGVtT3BhY2l0eSA9IDE7XG5cbiAgICAgIGlmIChsZXR0ZXJzW2ldLm4pIHtcbiAgICAgICAgeFBvcyA9IDA7XG4gICAgICAgIHlQb3MgKz0gZG9jdW1lbnREYXRhLnlPZmZzZXQ7XG4gICAgICAgIHlQb3MgKz0gZmlyc3RMaW5lID8gMSA6IDA7XG4gICAgICAgIGN1cnJlbnRMZW5ndGggPSBpbml0UGF0aFBvcztcbiAgICAgICAgZmlyc3RMaW5lID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcbiAgICAgICAgICBzZWdtZW50SW5kID0gaW5pdFNlZ21lbnRJbmQ7XG4gICAgICAgICAgcG9pbnRJbmQgPSBpbml0UG9pbnRJbmQ7XG4gICAgICAgICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0ucG9pbnRzO1xuICAgICAgICAgIHByZXZQb2ludCA9IHBvaW50c1twb2ludEluZCAtIDFdO1xuICAgICAgICAgIGN1cnJlbnRQb2ludCA9IHBvaW50c1twb2ludEluZF07XG4gICAgICAgICAgcGFydGlhbExlbmd0aCA9IGN1cnJlbnRQb2ludC5wYXJ0aWFsTGVuZ3RoO1xuICAgICAgICAgIHNlZ21lbnRMZW5ndGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0dGVyTSA9ICcnO1xuICAgICAgICBsZXR0ZXJGYyA9ICcnO1xuICAgICAgICBsZXR0ZXJTdyA9ICcnO1xuICAgICAgICBsZXR0ZXJPID0gJyc7XG4gICAgICAgIGxldHRlclAgPSB0aGlzLmRlZmF1bHRQcm9wc0FycmF5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcbiAgICAgICAgICBpZiAoY3VycmVudExpbmUgIT09IGxldHRlcnNbaV0ubGluZSkge1xuICAgICAgICAgICAgc3dpdGNoIChkb2N1bWVudERhdGEuaikge1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSB0b3RhbExlbmd0aCAtIGRvY3VtZW50RGF0YS5saW5lV2lkdGhzW2xldHRlcnNbaV0ubGluZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gKHRvdGFsTGVuZ3RoIC0gZG9jdW1lbnREYXRhLmxpbmVXaWR0aHNbbGV0dGVyc1tpXS5saW5lXSkgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRMaW5lID0gbGV0dGVyc1tpXS5saW5lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbmQgIT09IGxldHRlcnNbaV0uaW5kKSB7XG4gICAgICAgICAgICBpZiAobGV0dGVyc1tpbmRdKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gbGV0dGVyc1tpbmRdLmV4dHJhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IGxldHRlcnNbaV0uYW4gLyAyO1xuICAgICAgICAgICAgaW5kID0gbGV0dGVyc1tpXS5pbmQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudExlbmd0aCArPSBhbGlnbm1lbnRbMF0gKiBsZXR0ZXJzW2ldLmFuICogMC4wMDU7XG4gICAgICAgICAgdmFyIGFuaW1hdG9yT2Zmc2V0ID0gMDtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcblxuICAgICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMucC5wcm9wVHlwZSkge1xuICAgICAgICAgICAgICBhbmltYXRvclNlbGVjdG9yID0gYW5pbWF0b3JzW2pdLnM7XG4gICAgICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcblxuICAgICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRvck9mZnNldCArPSBhbmltYXRvclByb3BzLnAudlswXSAqIG11bHRbMF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3JPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy5wLnZbMF0gKiBtdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLmEucHJvcFR5cGUpIHtcbiAgICAgICAgICAgICAgYW5pbWF0b3JTZWxlY3RvciA9IGFuaW1hdG9yc1tqXS5zO1xuICAgICAgICAgICAgICBtdWx0ID0gYW5pbWF0b3JTZWxlY3Rvci5nZXRNdWx0KGxldHRlcnNbaV0uYW5JbmRleGVzW2pdLCB0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XG5cbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3JPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy5hLnZbMF0gKiBtdWx0WzBdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yT2Zmc2V0ICs9IGFuaW1hdG9yUHJvcHMuYS52WzBdICogbXVsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZsYWcgPSB0cnVlOyAvLyBGb3JjZSBhbGlnbm1lbnQgb25seSB3b3JrcyB3aXRoIGEgc2luZ2xlIGxpbmUgZm9yIG5vd1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3BhdGhEYXRhLmEudikge1xuICAgICAgICAgICAgY3VycmVudExlbmd0aCA9IGxldHRlcnNbMF0uYW4gKiAwLjUgKyAodG90YWxMZW5ndGggLSB0aGlzLl9wYXRoRGF0YS5mLnYgLSBsZXR0ZXJzWzBdLmFuICogMC41IC0gbGV0dGVyc1tsZXR0ZXJzLmxlbmd0aCAtIDFdLmFuICogMC41KSAqIGluZCAvIChsZW4gLSAxKTtcbiAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gdGhpcy5fcGF0aERhdGEuZi52O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdoaWxlIChmbGFnKSB7XG4gICAgICAgICAgICBpZiAoc2VnbWVudExlbmd0aCArIHBhcnRpYWxMZW5ndGggPj0gY3VycmVudExlbmd0aCArIGFuaW1hdG9yT2Zmc2V0IHx8ICFwb2ludHMpIHtcbiAgICAgICAgICAgICAgcGVyYyA9IChjdXJyZW50TGVuZ3RoICsgYW5pbWF0b3JPZmZzZXQgLSBzZWdtZW50TGVuZ3RoKSAvIGN1cnJlbnRQb2ludC5wYXJ0aWFsTGVuZ3RoO1xuICAgICAgICAgICAgICB4UGF0aFBvcyA9IHByZXZQb2ludC5wb2ludFswXSArIChjdXJyZW50UG9pbnQucG9pbnRbMF0gLSBwcmV2UG9pbnQucG9pbnRbMF0pICogcGVyYztcbiAgICAgICAgICAgICAgeVBhdGhQb3MgPSBwcmV2UG9pbnQucG9pbnRbMV0gKyAoY3VycmVudFBvaW50LnBvaW50WzFdIC0gcHJldlBvaW50LnBvaW50WzFdKSAqIHBlcmM7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoLWFsaWdubWVudFswXSAqIGxldHRlcnNbaV0uYW4gKiAwLjAwNSwgLShhbGlnbm1lbnRbMV0gKiB5T2ZmKSAqIDAuMDEpO1xuICAgICAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvaW50cykge1xuICAgICAgICAgICAgICBzZWdtZW50TGVuZ3RoICs9IGN1cnJlbnRQb2ludC5wYXJ0aWFsTGVuZ3RoO1xuICAgICAgICAgICAgICBwb2ludEluZCArPSAxO1xuXG4gICAgICAgICAgICAgIGlmIChwb2ludEluZCA+PSBwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRJbmQgPSAwO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRJbmQgKz0gMTtcblxuICAgICAgICAgICAgICAgIGlmICghc2VnbWVudHNbc2VnbWVudEluZF0pIHtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXNrLnYuYykge1xuICAgICAgICAgICAgICAgICAgICBwb2ludEluZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRJbmQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSBzZWdtZW50c1tzZWdtZW50SW5kXS5wb2ludHM7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50TGVuZ3RoIC09IGN1cnJlbnRQb2ludC5wYXJ0aWFsTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwb2ludHMgPSBzZWdtZW50c1tzZWdtZW50SW5kXS5wb2ludHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHBvaW50cykge1xuICAgICAgICAgICAgICAgIHByZXZQb2ludCA9IGN1cnJlbnRQb2ludDtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnQgPSBwb2ludHNbcG9pbnRJbmRdO1xuICAgICAgICAgICAgICAgIHBhcnRpYWxMZW5ndGggPSBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG9mZmYgPSBsZXR0ZXJzW2ldLmFuIC8gMiAtIGxldHRlcnNbaV0uYWRkO1xuICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoLW9mZmYsIDAsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZmYgPSBsZXR0ZXJzW2ldLmFuIC8gMiAtIGxldHRlcnNbaV0uYWRkO1xuICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoLW9mZmYsIDAsIDApOyAvLyBHcm91cGluZyBhbGlnbm1lbnRcblxuICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoLWFsaWdubWVudFswXSAqIGxldHRlcnNbaV0uYW4gKiAwLjAwNSwgLWFsaWdubWVudFsxXSAqIHlPZmYgKiAwLjAxLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICBhbmltYXRvclByb3BzID0gYW5pbWF0b3JzW2pdLmE7XG5cbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy50LnByb3BUeXBlKSB7XG4gICAgICAgICAgICBhbmltYXRvclNlbGVjdG9yID0gYW5pbWF0b3JzW2pdLnM7XG4gICAgICAgICAgICBtdWx0ID0gYW5pbWF0b3JTZWxlY3Rvci5nZXRNdWx0KGxldHRlcnNbaV0uYW5JbmRleGVzW2pdLCB0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7IC8vIFRoaXMgY29uZGl0aW9uIGlzIHRvIHByZXZlbnQgYXBwbHlpbmcgdHJhY2tpbmcgdG8gZmlyc3QgY2hhcmFjdGVyIGluIGVhY2ggbGluZS4gTWlnaHQgYmUgYmV0dGVyIHRvIHVzZSBhIGJvb2xlYW4gXCJpc05ld0xpbmVcIlxuXG4gICAgICAgICAgICBpZiAoeFBvcyAhPT0gMCB8fCBkb2N1bWVudERhdGEuaiAhPT0gMCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5faGFzTWFza2VkUGF0aCkge1xuICAgICAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSBhbmltYXRvclByb3BzLnQudiAqIG11bHRbMF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBtdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHhQb3MgKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBtdWx0WzBdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHhQb3MgKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBtdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5zdHJva2VXaWR0aEFuaW0pIHtcbiAgICAgICAgICBzdyA9IGRvY3VtZW50RGF0YS5zdyB8fCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5zdHJva2VDb2xvckFuaW0pIHtcbiAgICAgICAgICBpZiAoZG9jdW1lbnREYXRhLnNjKSB7XG4gICAgICAgICAgICBzYyA9IFtkb2N1bWVudERhdGEuc2NbMF0sIGRvY3VtZW50RGF0YS5zY1sxXSwgZG9jdW1lbnREYXRhLnNjWzJdXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2MgPSBbMCwgMCwgMF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5maWxsQ29sb3JBbmltICYmIGRvY3VtZW50RGF0YS5mYykge1xuICAgICAgICAgIGZjID0gW2RvY3VtZW50RGF0YS5mY1swXSwgZG9jdW1lbnREYXRhLmZjWzFdLCBkb2N1bWVudERhdGEuZmNbMl1dO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcblxuICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLmEucHJvcFR5cGUpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcbiAgICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcblxuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoLWFuaW1hdG9yUHJvcHMuYS52WzBdICogbXVsdFswXSwgLWFuaW1hdG9yUHJvcHMuYS52WzFdICogbXVsdFsxXSwgYW5pbWF0b3JQcm9wcy5hLnZbMl0gKiBtdWx0WzJdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoLWFuaW1hdG9yUHJvcHMuYS52WzBdICogbXVsdCwgLWFuaW1hdG9yUHJvcHMuYS52WzFdICogbXVsdCwgYW5pbWF0b3JQcm9wcy5hLnZbMl0gKiBtdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgYW5pbWF0b3JQcm9wcyA9IGFuaW1hdG9yc1tqXS5hO1xuXG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMucy5wcm9wVHlwZSkge1xuICAgICAgICAgICAgYW5pbWF0b3JTZWxlY3RvciA9IGFuaW1hdG9yc1tqXS5zO1xuICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSwgdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpO1xuXG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnNjYWxlKDEgKyAoYW5pbWF0b3JQcm9wcy5zLnZbMF0gLSAxKSAqIG11bHRbMF0sIDEgKyAoYW5pbWF0b3JQcm9wcy5zLnZbMV0gLSAxKSAqIG11bHRbMV0sIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnNjYWxlKDEgKyAoYW5pbWF0b3JQcm9wcy5zLnZbMF0gLSAxKSAqIG11bHQsIDEgKyAoYW5pbWF0b3JQcm9wcy5zLnZbMV0gLSAxKSAqIG11bHQsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICBhbmltYXRvclByb3BzID0gYW5pbWF0b3JzW2pdLmE7XG4gICAgICAgICAgYW5pbWF0b3JTZWxlY3RvciA9IGFuaW1hdG9yc1tqXS5zO1xuICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcblxuICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLnNrLnByb3BUeXBlKSB7XG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnNrZXdGcm9tQXhpcygtYW5pbWF0b3JQcm9wcy5zay52ICogbXVsdFswXSwgYW5pbWF0b3JQcm9wcy5zYS52ICogbXVsdFsxXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIuc2tld0Zyb21BeGlzKC1hbmltYXRvclByb3BzLnNrLnYgKiBtdWx0LCBhbmltYXRvclByb3BzLnNhLnYgKiBtdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5yLnByb3BUeXBlKSB7XG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZVooLWFuaW1hdG9yUHJvcHMuci52ICogbXVsdFsyXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlWigtYW5pbWF0b3JQcm9wcy5yLnYgKiBtdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5yeS5wcm9wVHlwZSkge1xuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5yb3RhdGVZKGFuaW1hdG9yUHJvcHMucnkudiAqIG11bHRbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZVkoYW5pbWF0b3JQcm9wcy5yeS52ICogbXVsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMucngucHJvcFR5cGUpIHtcbiAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlWChhbmltYXRvclByb3BzLnJ4LnYgKiBtdWx0WzBdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5yb3RhdGVYKGFuaW1hdG9yUHJvcHMucngudiAqIG11bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLm8ucHJvcFR5cGUpIHtcbiAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBlbGVtT3BhY2l0eSArPSAoYW5pbWF0b3JQcm9wcy5vLnYgKiBtdWx0WzBdIC0gZWxlbU9wYWNpdHkpICogbXVsdFswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW1PcGFjaXR5ICs9IChhbmltYXRvclByb3BzLm8udiAqIG11bHQgLSBlbGVtT3BhY2l0eSkgKiBtdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkb2N1bWVudERhdGEuc3Ryb2tlV2lkdGhBbmltICYmIGFuaW1hdG9yUHJvcHMuc3cucHJvcFR5cGUpIHtcbiAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBzdyArPSBhbmltYXRvclByb3BzLnN3LnYgKiBtdWx0WzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3cgKz0gYW5pbWF0b3JQcm9wcy5zdy52ICogbXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZG9jdW1lbnREYXRhLnN0cm9rZUNvbG9yQW5pbSAmJiBhbmltYXRvclByb3BzLnNjLnByb3BUeXBlKSB7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgMzsgayArPSAxKSB7XG4gICAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNjW2tdICs9IChhbmltYXRvclByb3BzLnNjLnZba10gLSBzY1trXSkgKiBtdWx0WzBdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjW2tdICs9IChhbmltYXRvclByb3BzLnNjLnZba10gLSBzY1trXSkgKiBtdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5maWxsQ29sb3JBbmltICYmIGRvY3VtZW50RGF0YS5mYykge1xuICAgICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuZmMucHJvcFR5cGUpIHtcbiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IDM7IGsgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgZmNba10gKz0gKGFuaW1hdG9yUHJvcHMuZmMudltrXSAtIGZjW2tdKSAqIG11bHRbMF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGZjW2tdICs9IChhbmltYXRvclByb3BzLmZjLnZba10gLSBmY1trXSkgKiBtdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5maC5wcm9wVHlwZSkge1xuICAgICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmYyA9IGFkZEh1ZVRvUkdCKGZjLCBhbmltYXRvclByb3BzLmZoLnYgKiBtdWx0WzBdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYyA9IGFkZEh1ZVRvUkdCKGZjLCBhbmltYXRvclByb3BzLmZoLnYgKiBtdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5mcy5wcm9wVHlwZSkge1xuICAgICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmYyA9IGFkZFNhdHVyYXRpb25Ub1JHQihmYywgYW5pbWF0b3JQcm9wcy5mcy52ICogbXVsdFswXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmMgPSBhZGRTYXR1cmF0aW9uVG9SR0IoZmMsIGFuaW1hdG9yUHJvcHMuZnMudiAqIG11bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLmZiLnByb3BUeXBlKSB7XG4gICAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZjID0gYWRkQnJpZ2h0bmVzc1RvUkdCKGZjLCBhbmltYXRvclByb3BzLmZiLnYgKiBtdWx0WzBdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYyA9IGFkZEJyaWdodG5lc3NUb1JHQihmYywgYW5pbWF0b3JQcm9wcy5mYi52ICogbXVsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgYW5pbWF0b3JQcm9wcyA9IGFuaW1hdG9yc1tqXS5hO1xuXG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMucC5wcm9wVHlwZSkge1xuICAgICAgICAgICAgYW5pbWF0b3JTZWxlY3RvciA9IGFuaW1hdG9yc1tqXS5zO1xuICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSwgdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5faGFzTWFza2VkUGF0aCkge1xuICAgICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKDAsIGFuaW1hdG9yUHJvcHMucC52WzFdICogbXVsdFswXSwgLWFuaW1hdG9yUHJvcHMucC52WzJdICogbXVsdFsxXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgwLCBhbmltYXRvclByb3BzLnAudlsxXSAqIG11bHQsIC1hbmltYXRvclByb3BzLnAudlsyXSAqIG11bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoYW5pbWF0b3JQcm9wcy5wLnZbMF0gKiBtdWx0WzBdLCBhbmltYXRvclByb3BzLnAudlsxXSAqIG11bHRbMV0sIC1hbmltYXRvclByb3BzLnAudlsyXSAqIG11bHRbMl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShhbmltYXRvclByb3BzLnAudlswXSAqIG11bHQsIGFuaW1hdG9yUHJvcHMucC52WzFdICogbXVsdCwgLWFuaW1hdG9yUHJvcHMucC52WzJdICogbXVsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5zdHJva2VXaWR0aEFuaW0pIHtcbiAgICAgICAgICBsZXR0ZXJTdyA9IHN3IDwgMCA/IDAgOiBzdztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2N1bWVudERhdGEuc3Ryb2tlQ29sb3JBbmltKSB7XG4gICAgICAgICAgbGV0dGVyU2MgPSAncmdiKCcgKyBNYXRoLnJvdW5kKHNjWzBdICogMjU1KSArICcsJyArIE1hdGgucm91bmQoc2NbMV0gKiAyNTUpICsgJywnICsgTWF0aC5yb3VuZChzY1syXSAqIDI1NSkgKyAnKSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9jdW1lbnREYXRhLmZpbGxDb2xvckFuaW0gJiYgZG9jdW1lbnREYXRhLmZjKSB7XG4gICAgICAgICAgbGV0dGVyRmMgPSAncmdiKCcgKyBNYXRoLnJvdW5kKGZjWzBdICogMjU1KSArICcsJyArIE1hdGgucm91bmQoZmNbMV0gKiAyNTUpICsgJywnICsgTWF0aC5yb3VuZChmY1syXSAqIDI1NSkgKyAnKSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faGFzTWFza2VkUGF0aCkge1xuICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgLWRvY3VtZW50RGF0YS5scyk7XG4gICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgwLCBhbGlnbm1lbnRbMV0gKiB5T2ZmICogMC4wMSArIHlQb3MsIDApO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3BhdGhEYXRhLnAudikge1xuICAgICAgICAgICAgdGFuQW5nbGUgPSAoY3VycmVudFBvaW50LnBvaW50WzFdIC0gcHJldlBvaW50LnBvaW50WzFdKSAvIChjdXJyZW50UG9pbnQucG9pbnRbMF0gLSBwcmV2UG9pbnQucG9pbnRbMF0pO1xuICAgICAgICAgICAgdmFyIHJvdCA9IE1hdGguYXRhbih0YW5BbmdsZSkgKiAxODAgLyBNYXRoLlBJO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFBvaW50LnBvaW50WzBdIDwgcHJldlBvaW50LnBvaW50WzBdKSB7XG4gICAgICAgICAgICAgIHJvdCArPSAxODA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hdHJpeEhlbHBlci5yb3RhdGUoLXJvdCAqIE1hdGguUEkgLyAxODApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoeFBhdGhQb3MsIHlQYXRoUG9zLCAwKTtcbiAgICAgICAgICBjdXJyZW50TGVuZ3RoIC09IGFsaWdubWVudFswXSAqIGxldHRlcnNbaV0uYW4gKiAwLjAwNTtcblxuICAgICAgICAgIGlmIChsZXR0ZXJzW2kgKyAxXSAmJiBpbmQgIT09IGxldHRlcnNbaSArIDFdLmluZCkge1xuICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSBsZXR0ZXJzW2ldLmFuIC8gMjtcbiAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gZG9jdW1lbnREYXRhLnRyICogMC4wMDEgKiBkb2N1bWVudERhdGEuZmluYWxTaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKHhQb3MsIHlQb3MsIDApO1xuXG4gICAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5wcykge1xuICAgICAgICAgICAgLy8gbWF0cml4SGVscGVyLnRyYW5zbGF0ZShkb2N1bWVudERhdGEucHNbMF0sZG9jdW1lbnREYXRhLnBzWzFdLDApO1xuICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShkb2N1bWVudERhdGEucHNbMF0sIGRvY3VtZW50RGF0YS5wc1sxXSArIGRvY3VtZW50RGF0YS5hc2NlbnQsIDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXRjaCAoZG9jdW1lbnREYXRhLmopIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShsZXR0ZXJzW2ldLmFuaW1hdG9ySnVzdGlmeU9mZnNldCArIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ICsgKGRvY3VtZW50RGF0YS5ib3hXaWR0aCAtIGRvY3VtZW50RGF0YS5saW5lV2lkdGhzW2xldHRlcnNbaV0ubGluZV0pLCAwLCAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShsZXR0ZXJzW2ldLmFuaW1hdG9ySnVzdGlmeU9mZnNldCArIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ICsgKGRvY3VtZW50RGF0YS5ib3hXaWR0aCAtIGRvY3VtZW50RGF0YS5saW5lV2lkdGhzW2xldHRlcnNbaV0ubGluZV0pIC8gMiwgMCwgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKDAsIC1kb2N1bWVudERhdGEubHMpO1xuICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUob2ZmZiwgMCwgMCk7XG4gICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShhbGlnbm1lbnRbMF0gKiBsZXR0ZXJzW2ldLmFuICogMC4wMDUsIGFsaWdubWVudFsxXSAqIHlPZmYgKiAwLjAxLCAwKTtcbiAgICAgICAgICB4UG9zICs9IGxldHRlcnNbaV0ubCArIGRvY3VtZW50RGF0YS50ciAqIDAuMDAxICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJUeXBlID09PSAnaHRtbCcpIHtcbiAgICAgICAgICBsZXR0ZXJNID0gbWF0cml4SGVscGVyLnRvQ1NTKCk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVuZGVyVHlwZSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICBsZXR0ZXJNID0gbWF0cml4SGVscGVyLnRvMmRDU1MoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXR0ZXJQID0gW21hdHJpeEhlbHBlci5wcm9wc1swXSwgbWF0cml4SGVscGVyLnByb3BzWzFdLCBtYXRyaXhIZWxwZXIucHJvcHNbMl0sIG1hdHJpeEhlbHBlci5wcm9wc1szXSwgbWF0cml4SGVscGVyLnByb3BzWzRdLCBtYXRyaXhIZWxwZXIucHJvcHNbNV0sIG1hdHJpeEhlbHBlci5wcm9wc1s2XSwgbWF0cml4SGVscGVyLnByb3BzWzddLCBtYXRyaXhIZWxwZXIucHJvcHNbOF0sIG1hdHJpeEhlbHBlci5wcm9wc1s5XSwgbWF0cml4SGVscGVyLnByb3BzWzEwXSwgbWF0cml4SGVscGVyLnByb3BzWzExXSwgbWF0cml4SGVscGVyLnByb3BzWzEyXSwgbWF0cml4SGVscGVyLnByb3BzWzEzXSwgbWF0cml4SGVscGVyLnByb3BzWzE0XSwgbWF0cml4SGVscGVyLnByb3BzWzE1XV07XG4gICAgICAgIH1cblxuICAgICAgICBsZXR0ZXJPID0gZWxlbU9wYWNpdHk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW5kZXJlZExldHRlcnNDb3VudCA8PSBpKSB7XG4gICAgICAgIGxldHRlclZhbHVlID0gbmV3IExldHRlclByb3BzKGxldHRlck8sIGxldHRlclN3LCBsZXR0ZXJTYywgbGV0dGVyRmMsIGxldHRlck0sIGxldHRlclApO1xuICAgICAgICB0aGlzLnJlbmRlcmVkTGV0dGVycy5wdXNoKGxldHRlclZhbHVlKTtcbiAgICAgICAgcmVuZGVyZWRMZXR0ZXJzQ291bnQgKz0gMTtcbiAgICAgICAgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0dGVyVmFsdWUgPSB0aGlzLnJlbmRlcmVkTGV0dGVyc1tpXTtcbiAgICAgICAgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgPSBsZXR0ZXJWYWx1ZS51cGRhdGUobGV0dGVyTywgbGV0dGVyU3csIGxldHRlclNjLCBsZXR0ZXJGYywgbGV0dGVyTSwgbGV0dGVyUCkgfHwgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWc7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFRleHRBbmltYXRvclByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuX2ZyYW1lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9mcmFtZUlkID0gdGhpcy5fZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcbiAgfTtcblxuICBUZXh0QW5pbWF0b3JQcm9wZXJ0eS5wcm90b3R5cGUubUhlbHBlciA9IG5ldyBNYXRyaXgoKTtcbiAgVGV4dEFuaW1hdG9yUHJvcGVydHkucHJvdG90eXBlLmRlZmF1bHRQcm9wc0FycmF5ID0gW107XG4gIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgVGV4dEFuaW1hdG9yUHJvcGVydHkpO1xuXG4gIGZ1bmN0aW9uIElUZXh0RWxlbWVudCgpIHt9XG5cbiAgSVRleHRFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgPSB0cnVlO1xuICAgIHRoaXMuaW5pdEZyYW1lKCk7XG4gICAgdGhpcy5pbml0QmFzZURhdGEoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy50ZXh0UHJvcGVydHkgPSBuZXcgVGV4dFByb3BlcnR5KHRoaXMsIGRhdGEudCwgdGhpcy5keW5hbWljUHJvcGVydGllcyk7XG4gICAgdGhpcy50ZXh0QW5pbWF0b3IgPSBuZXcgVGV4dEFuaW1hdG9yUHJvcGVydHkoZGF0YS50LCB0aGlzLnJlbmRlclR5cGUsIHRoaXMpO1xuICAgIHRoaXMuaW5pdFRyYW5zZm9ybShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICB0aGlzLmluaXRIaWVyYXJjaHkoKTtcbiAgICB0aGlzLmluaXRSZW5kZXJhYmxlKCk7XG4gICAgdGhpcy5pbml0UmVuZGVyZXJFbGVtZW50KCk7XG4gICAgdGhpcy5jcmVhdGVDb250YWluZXJFbGVtZW50cygpO1xuICAgIHRoaXMuY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHMoKTtcbiAgICB0aGlzLmNyZWF0ZUNvbnRlbnQoKTtcbiAgICB0aGlzLmhpZGUoKTtcbiAgICB0aGlzLnRleHRBbmltYXRvci5zZWFyY2hQcm9wZXJ0aWVzKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMpO1xuICB9O1xuXG4gIElUZXh0RWxlbWVudC5wcm90b3R5cGUucHJlcGFyZUZyYW1lID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIHRoaXMucHJlcGFyZVJlbmRlcmFibGVGcmFtZShudW0pO1xuICAgIHRoaXMucHJlcGFyZVByb3BlcnRpZXMobnVtLCB0aGlzLmlzSW5SYW5nZSk7XG4gIH07XG5cbiAgSVRleHRFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVQYXRoU2hhcGUgPSBmdW5jdGlvbiAobWF0cml4SGVscGVyLCBzaGFwZXMpIHtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbiA9IHNoYXBlcy5sZW5ndGg7XG4gICAgdmFyIHBhdGhOb2RlcztcbiAgICB2YXIgc2hhcGVTdHIgPSAnJztcblxuICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgIGlmIChzaGFwZXNbal0udHkgPT09ICdzaCcpIHtcbiAgICAgICAgcGF0aE5vZGVzID0gc2hhcGVzW2pdLmtzLms7XG4gICAgICAgIHNoYXBlU3RyICs9IGJ1aWxkU2hhcGVTdHJpbmcocGF0aE5vZGVzLCBwYXRoTm9kZXMuaS5sZW5ndGgsIHRydWUsIG1hdHJpeEhlbHBlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYXBlU3RyO1xuICB9O1xuXG4gIElUZXh0RWxlbWVudC5wcm90b3R5cGUudXBkYXRlRG9jdW1lbnREYXRhID0gZnVuY3Rpb24gKG5ld0RhdGEsIGluZGV4KSB7XG4gICAgdGhpcy50ZXh0UHJvcGVydHkudXBkYXRlRG9jdW1lbnREYXRhKG5ld0RhdGEsIGluZGV4KTtcbiAgfTtcblxuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLmNhblJlc2l6ZUZvbnQgPSBmdW5jdGlvbiAoX2NhblJlc2l6ZSkge1xuICAgIHRoaXMudGV4dFByb3BlcnR5LmNhblJlc2l6ZUZvbnQoX2NhblJlc2l6ZSk7XG4gIH07XG5cbiAgSVRleHRFbGVtZW50LnByb3RvdHlwZS5zZXRNaW5pbXVtRm9udFNpemUgPSBmdW5jdGlvbiAoX2ZvbnRTaXplKSB7XG4gICAgdGhpcy50ZXh0UHJvcGVydHkuc2V0TWluaW11bUZvbnRTaXplKF9mb250U2l6ZSk7XG4gIH07XG5cbiAgSVRleHRFbGVtZW50LnByb3RvdHlwZS5hcHBseVRleHRQcm9wZXJ0aWVzVG9NYXRyaXggPSBmdW5jdGlvbiAoZG9jdW1lbnREYXRhLCBtYXRyaXhIZWxwZXIsIGxpbmVOdW1iZXIsIHhQb3MsIHlQb3MpIHtcbiAgICBpZiAoZG9jdW1lbnREYXRhLnBzKSB7XG4gICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKGRvY3VtZW50RGF0YS5wc1swXSwgZG9jdW1lbnREYXRhLnBzWzFdICsgZG9jdW1lbnREYXRhLmFzY2VudCwgMCk7XG4gICAgfVxuXG4gICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgwLCAtZG9jdW1lbnREYXRhLmxzLCAwKTtcblxuICAgIHN3aXRjaCAoZG9jdW1lbnREYXRhLmopIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCArIChkb2N1bWVudERhdGEuYm94V2lkdGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsaW5lTnVtYmVyXSksIDAsIDApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOlxuICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ICsgKGRvY3VtZW50RGF0YS5ib3hXaWR0aCAtIGRvY3VtZW50RGF0YS5saW5lV2lkdGhzW2xpbmVOdW1iZXJdKSAvIDIsIDAsIDApO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSh4UG9zLCB5UG9zLCAwKTtcbiAgfTtcblxuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLmJ1aWxkQ29sb3IgPSBmdW5jdGlvbiAoY29sb3JEYXRhKSB7XG4gICAgcmV0dXJuICdyZ2IoJyArIE1hdGgucm91bmQoY29sb3JEYXRhWzBdICogMjU1KSArICcsJyArIE1hdGgucm91bmQoY29sb3JEYXRhWzFdICogMjU1KSArICcsJyArIE1hdGgucm91bmQoY29sb3JEYXRhWzJdICogMjU1KSArICcpJztcbiAgfTtcblxuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLmVtcHR5UHJvcCA9IG5ldyBMZXR0ZXJQcm9wcygpO1xuXG4gIElUZXh0RWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIElUZXh0RWxlbWVudC5wcm90b3R5cGUudmFsaWRhdGVUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRleHRQcm9wZXJ0eS5fbWRmIHx8IHRoaXMudGV4dFByb3BlcnR5Ll9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHRoaXMuYnVpbGROZXdUZXh0KCk7XG4gICAgICB0aGlzLnRleHRQcm9wZXJ0eS5faXNGaXJzdEZyYW1lID0gZmFsc2U7XG4gICAgICB0aGlzLnRleHRQcm9wZXJ0eS5fbWRmID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHZhciBlbXB0eVNoYXBlRGF0YSA9IHtcbiAgICBzaGFwZXM6IFtdXG4gIH07XG5cbiAgZnVuY3Rpb24gU1ZHVGV4dExvdHRpZUVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMudGV4dFNwYW5zID0gW107XG4gICAgdGhpcy5yZW5kZXJUeXBlID0gJ3N2Zyc7XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIFNWR0Jhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50LCBJVGV4dEVsZW1lbnRdLCBTVkdUZXh0TG90dGllRWxlbWVudCk7XG5cbiAgU1ZHVGV4dExvdHRpZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZGF0YS5zaW5nbGVTaGFwZSAmJiAhdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmNoYXJzKSB7XG4gICAgICB0aGlzLnRleHRDb250YWluZXIgPSBjcmVhdGVOUygndGV4dCcpO1xuICAgIH1cbiAgfTtcblxuICBTVkdUZXh0TG90dGllRWxlbWVudC5wcm90b3R5cGUuYnVpbGRUZXh0Q29udGVudHMgPSBmdW5jdGlvbiAodGV4dEFycmF5KSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0ZXh0QXJyYXkubGVuZ3RoO1xuICAgIHZhciB0ZXh0Q29udGVudHMgPSBbXTtcbiAgICB2YXIgY3VycmVudFRleHRDb250ZW50ID0gJyc7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgaWYgKHRleHRBcnJheVtpXSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMykgfHwgdGV4dEFycmF5W2ldID09PSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMpKSB7XG4gICAgICAgIHRleHRDb250ZW50cy5wdXNoKGN1cnJlbnRUZXh0Q29udGVudCk7XG4gICAgICAgIGN1cnJlbnRUZXh0Q29udGVudCA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFRleHRDb250ZW50ICs9IHRleHRBcnJheVtpXTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHRleHRDb250ZW50cy5wdXNoKGN1cnJlbnRUZXh0Q29udGVudCk7XG4gICAgcmV0dXJuIHRleHRDb250ZW50cztcbiAgfTtcblxuICBTVkdUZXh0TG90dGllRWxlbWVudC5wcm90b3R5cGUuYnVpbGRTaGFwZURhdGEgPSBmdW5jdGlvbiAoZGF0YSwgc2NhbGUpIHtcbiAgICAvLyBkYXRhIHNob3VsZCBwcm9iYWJseSBiZSBjbG9uZWQgdG8gYXBwbHkgc2NhbGUgc2VwYXJhdGVseSB0byBlYWNoIGluc3RhbmNlIG9mIGEgdGV4dCBvbiBkaWZmZXJlbnQgbGF5ZXJzXG4gICAgLy8gYnV0IHNpbmNlIHRleHQgaW50ZXJuYWwgY29udGVudCBnZXRzIG9ubHkgcmVuZGVyZWQgb25jZSBhbmQgdGhlbiBpdCdzIG5ldmVyIHJlcmVuZGVyZWQsXG4gICAgLy8gaXQncyBwcm9iYWJseSBzYWZlIG5vdCB0byBjbG9uZSBkYXRhIGFuZCByZXVzZSBhbHdheXMgdGhlIHNhbWUgaW5zdGFuY2UgZXZlbiBpZiB0aGUgb2JqZWN0IGlzIG11dGF0ZWQuXG4gICAgLy8gQXZvaWRpbmcgY2xvbmluZyBpcyBwcmVmZXJyZWQgc2luY2UgY2xvbmluZyBlYWNoIGNoYXJhY3RlciBzaGFwZSBkYXRhIGlzIGV4cGVuc2l2ZVxuICAgIGlmIChkYXRhLnNoYXBlcyAmJiBkYXRhLnNoYXBlcy5sZW5ndGgpIHtcbiAgICAgIHZhciBzaGFwZSA9IGRhdGEuc2hhcGVzWzBdO1xuXG4gICAgICBpZiAoc2hhcGUuaXQpIHtcbiAgICAgICAgdmFyIHNoYXBlSXRlbSA9IHNoYXBlLml0W3NoYXBlLml0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChzaGFwZUl0ZW0ucykge1xuICAgICAgICAgIHNoYXBlSXRlbS5zLmtbMF0gPSBzY2FsZTtcbiAgICAgICAgICBzaGFwZUl0ZW0ucy5rWzFdID0gc2NhbGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICBTVkdUZXh0TG90dGllRWxlbWVudC5wcm90b3R5cGUuYnVpbGROZXdUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWRkRHluYW1pY1Byb3BlcnR5KHRoaXMpO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgdmFyIGRvY3VtZW50RGF0YSA9IHRoaXMudGV4dFByb3BlcnR5LmN1cnJlbnREYXRhO1xuICAgIHRoaXMucmVuZGVyZWRMZXR0ZXJzID0gY3JlYXRlU2l6ZWRBcnJheShkb2N1bWVudERhdGEgPyBkb2N1bWVudERhdGEubC5sZW5ndGggOiAwKTtcblxuICAgIGlmIChkb2N1bWVudERhdGEuZmMpIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsbCcsIHRoaXMuYnVpbGRDb2xvcihkb2N1bWVudERhdGEuZmMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmaWxsJywgJ3JnYmEoMCwwLDAsMCknKTtcbiAgICB9XG5cbiAgICBpZiAoZG9jdW1lbnREYXRhLnNjKSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIHRoaXMuYnVpbGRDb2xvcihkb2N1bWVudERhdGEuc2MpKTtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgZG9jdW1lbnREYXRhLnN3KTtcbiAgICB9XG5cbiAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZvbnQtc2l6ZScsIGRvY3VtZW50RGF0YS5maW5hbFNpemUpO1xuICAgIHZhciBmb250RGF0YSA9IHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKTtcblxuICAgIGlmIChmb250RGF0YS5mQ2xhc3MpIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBmb250RGF0YS5mQ2xhc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZvbnQtZmFtaWx5JywgZm9udERhdGEuZkZhbWlseSk7XG4gICAgICB2YXIgZldlaWdodCA9IGRvY3VtZW50RGF0YS5mV2VpZ2h0O1xuICAgICAgdmFyIGZTdHlsZSA9IGRvY3VtZW50RGF0YS5mU3R5bGU7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZvbnQtc3R5bGUnLCBmU3R5bGUpO1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmb250LXdlaWdodCcsIGZXZWlnaHQpO1xuICAgIH1cblxuICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGRvY3VtZW50RGF0YS50KTtcbiAgICB2YXIgbGV0dGVycyA9IGRvY3VtZW50RGF0YS5sIHx8IFtdO1xuICAgIHZhciB1c2VzR2x5cGhzID0gISF0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuY2hhcnM7XG4gICAgbGVuID0gbGV0dGVycy5sZW5ndGg7XG4gICAgdmFyIHRTcGFuO1xuICAgIHZhciBtYXRyaXhIZWxwZXIgPSB0aGlzLm1IZWxwZXI7XG4gICAgdmFyIHNoYXBlU3RyID0gJyc7XG4gICAgdmFyIHNpbmdsZVNoYXBlID0gdGhpcy5kYXRhLnNpbmdsZVNoYXBlO1xuICAgIHZhciB4UG9zID0gMDtcbiAgICB2YXIgeVBvcyA9IDA7XG4gICAgdmFyIGZpcnN0TGluZSA9IHRydWU7XG4gICAgdmFyIHRyYWNraW5nT2Zmc2V0ID0gZG9jdW1lbnREYXRhLnRyICogMC4wMDEgKiBkb2N1bWVudERhdGEuZmluYWxTaXplO1xuXG4gICAgaWYgKHNpbmdsZVNoYXBlICYmICF1c2VzR2x5cGhzICYmICFkb2N1bWVudERhdGEuc3opIHtcbiAgICAgIHZhciB0RWxlbWVudCA9IHRoaXMudGV4dENvbnRhaW5lcjtcbiAgICAgIHZhciBqdXN0aWZ5ID0gJ3N0YXJ0JztcblxuICAgICAgc3dpdGNoIChkb2N1bWVudERhdGEuaikge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAganVzdGlmeSA9ICdlbmQnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBqdXN0aWZ5ID0gJ21pZGRsZSc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBqdXN0aWZ5ID0gJ3N0YXJ0JztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdEVsZW1lbnQuc2V0QXR0cmlidXRlKCd0ZXh0LWFuY2hvcicsIGp1c3RpZnkpO1xuICAgICAgdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdsZXR0ZXItc3BhY2luZycsIHRyYWNraW5nT2Zmc2V0KTtcbiAgICAgIHZhciB0ZXh0Q29udGVudCA9IHRoaXMuYnVpbGRUZXh0Q29udGVudHMoZG9jdW1lbnREYXRhLmZpbmFsVGV4dCk7XG4gICAgICBsZW4gPSB0ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICB5UG9zID0gZG9jdW1lbnREYXRhLnBzID8gZG9jdW1lbnREYXRhLnBzWzFdICsgZG9jdW1lbnREYXRhLmFzY2VudCA6IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB0U3BhbiA9IHRoaXMudGV4dFNwYW5zW2ldLnNwYW4gfHwgY3JlYXRlTlMoJ3RzcGFuJyk7XG4gICAgICAgIHRTcGFuLnRleHRDb250ZW50ID0gdGV4dENvbnRlbnRbaV07XG4gICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgneCcsIDApO1xuICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3knLCB5UG9zKTtcbiAgICAgICAgdFNwYW4uc3R5bGUuZGlzcGxheSA9ICdpbmhlcml0JztcbiAgICAgICAgdEVsZW1lbnQuYXBwZW5kQ2hpbGQodFNwYW4pO1xuXG4gICAgICAgIGlmICghdGhpcy50ZXh0U3BhbnNbaV0pIHtcbiAgICAgICAgICB0aGlzLnRleHRTcGFuc1tpXSA9IHtcbiAgICAgICAgICAgIHNwYW46IG51bGwsXG4gICAgICAgICAgICBnbHlwaDogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRleHRTcGFuc1tpXS5zcGFuID0gdFNwYW47XG4gICAgICAgIHlQb3MgKz0gZG9jdW1lbnREYXRhLmZpbmFsTGluZUhlaWdodDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQodEVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2FjaGVkU3BhbnNMZW5ndGggPSB0aGlzLnRleHRTcGFucy5sZW5ndGg7XG4gICAgICB2YXIgY2hhckRhdGE7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoIXRoaXMudGV4dFNwYW5zW2ldKSB7XG4gICAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0gPSB7XG4gICAgICAgICAgICBzcGFuOiBudWxsLFxuICAgICAgICAgICAgY2hpbGRTcGFuOiBudWxsLFxuICAgICAgICAgICAgZ2x5cGg6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1c2VzR2x5cGhzIHx8ICFzaW5nbGVTaGFwZSB8fCBpID09PSAwKSB7XG4gICAgICAgICAgdFNwYW4gPSBjYWNoZWRTcGFuc0xlbmd0aCA+IGkgPyB0aGlzLnRleHRTcGFuc1tpXS5zcGFuIDogY3JlYXRlTlModXNlc0dseXBocyA/ICdnJyA6ICd0ZXh0Jyk7XG5cbiAgICAgICAgICBpZiAoY2FjaGVkU3BhbnNMZW5ndGggPD0gaSkge1xuICAgICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsICdidXR0Jyk7XG4gICAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsICdyb3VuZCcpO1xuICAgICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCdzdHJva2UtbWl0ZXJsaW1pdCcsICc0Jyk7XG4gICAgICAgICAgICB0aGlzLnRleHRTcGFuc1tpXS5zcGFuID0gdFNwYW47XG5cbiAgICAgICAgICAgIGlmICh1c2VzR2x5cGhzKSB7XG4gICAgICAgICAgICAgIHZhciBjaGlsZFNwYW4gPSBjcmVhdGVOUygnZycpO1xuICAgICAgICAgICAgICB0U3Bhbi5hcHBlbmRDaGlsZChjaGlsZFNwYW4pO1xuICAgICAgICAgICAgICB0aGlzLnRleHRTcGFuc1tpXS5jaGlsZFNwYW4gPSBjaGlsZFNwYW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudGV4dFNwYW5zW2ldLnNwYW4gPSB0U3BhbjtcbiAgICAgICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHRTcGFuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0U3Bhbi5zdHlsZS5kaXNwbGF5ID0gJ2luaGVyaXQnO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF0cml4SGVscGVyLnJlc2V0KCk7XG5cbiAgICAgICAgaWYgKHNpbmdsZVNoYXBlKSB7XG4gICAgICAgICAgaWYgKGxldHRlcnNbaV0ubikge1xuICAgICAgICAgICAgeFBvcyA9IC10cmFja2luZ09mZnNldDtcbiAgICAgICAgICAgIHlQb3MgKz0gZG9jdW1lbnREYXRhLnlPZmZzZXQ7XG4gICAgICAgICAgICB5UG9zICs9IGZpcnN0TGluZSA/IDEgOiAwO1xuICAgICAgICAgICAgZmlyc3RMaW5lID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5hcHBseVRleHRQcm9wZXJ0aWVzVG9NYXRyaXgoZG9jdW1lbnREYXRhLCBtYXRyaXhIZWxwZXIsIGxldHRlcnNbaV0ubGluZSwgeFBvcywgeVBvcyk7XG4gICAgICAgICAgeFBvcyArPSBsZXR0ZXJzW2ldLmwgfHwgMDsgLy8geFBvcyArPSBsZXR0ZXJzW2ldLnZhbCA9PT0gJyAnID8gMCA6IHRyYWNraW5nT2Zmc2V0O1xuXG4gICAgICAgICAgeFBvcyArPSB0cmFja2luZ09mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1c2VzR2x5cGhzKSB7XG4gICAgICAgICAgY2hhckRhdGEgPSB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Q2hhckRhdGEoZG9jdW1lbnREYXRhLmZpbmFsVGV4dFtpXSwgZm9udERhdGEuZlN0eWxlLCB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZikuZkZhbWlseSk7XG4gICAgICAgICAgdmFyIGdseXBoRWxlbWVudDsgLy8gdCA9PT0gMSBtZWFucyB0aGUgY2hhcmFjdGVyIGhhcyBiZWVuIHJlcGxhY2VkIHdpdGggYW4gYW5pbWF0ZWQgc2hhcGVkXG5cbiAgICAgICAgICBpZiAoY2hhckRhdGEudCA9PT0gMSkge1xuICAgICAgICAgICAgZ2x5cGhFbGVtZW50ID0gbmV3IFNWR0NvbXBFbGVtZW50KGNoYXJEYXRhLmRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZW1wdHlTaGFwZURhdGE7XG5cbiAgICAgICAgICAgIGlmIChjaGFyRGF0YS5kYXRhICYmIGNoYXJEYXRhLmRhdGEuc2hhcGVzKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmJ1aWxkU2hhcGVEYXRhKGNoYXJEYXRhLmRhdGEsIGRvY3VtZW50RGF0YS5maW5hbFNpemUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbHlwaEVsZW1lbnQgPSBuZXcgU1ZHU2hhcGVFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMudGV4dFNwYW5zW2ldLmdseXBoKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGggPSB0aGlzLnRleHRTcGFuc1tpXS5nbHlwaDtcbiAgICAgICAgICAgIHRoaXMudGV4dFNwYW5zW2ldLmNoaWxkU3Bhbi5yZW1vdmVDaGlsZChnbHlwaC5sYXllckVsZW1lbnQpO1xuICAgICAgICAgICAgZ2x5cGguZGVzdHJveSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudGV4dFNwYW5zW2ldLmdseXBoID0gZ2x5cGhFbGVtZW50O1xuICAgICAgICAgIGdseXBoRWxlbWVudC5fZGVidWcgPSB0cnVlO1xuICAgICAgICAgIGdseXBoRWxlbWVudC5wcmVwYXJlRnJhbWUoMCk7XG4gICAgICAgICAgZ2x5cGhFbGVtZW50LnJlbmRlckZyYW1lKCk7XG4gICAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0uY2hpbGRTcGFuLmFwcGVuZENoaWxkKGdseXBoRWxlbWVudC5sYXllckVsZW1lbnQpOyAvLyB3aGVuIHVzaW5nIGFuaW1hdGVkIHNoYXBlcywgdGhlIGxheWVyIHdpbGwgYmUgc2NhbGVkIGluc3RlYWQgb2YgcmVwbGFjaW5nIHRoZSBpbnRlcm5hbCBzY2FsZVxuICAgICAgICAgIC8vIHRoaXMgbWlnaHQgaGF2ZSBpc3N1ZXMgd2l0aCBzdHJva2VzIGFuZCBtaWdodCBuZWVkIGEgZGlmZmVyZW50IHNvbHV0aW9uXG5cbiAgICAgICAgICBpZiAoY2hhckRhdGEudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0uY2hpbGRTcGFuLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgJ3NjYWxlKCcgKyBkb2N1bWVudERhdGEuZmluYWxTaXplIC8gMTAwICsgJywnICsgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMCArICcpJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzaW5nbGVTaGFwZSkge1xuICAgICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXRyaXhIZWxwZXIucHJvcHNbMTJdICsgJywnICsgbWF0cml4SGVscGVyLnByb3BzWzEzXSArICcpJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdFNwYW4udGV4dENvbnRlbnQgPSBsZXR0ZXJzW2ldLnZhbDtcbiAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJywgJ3htbDpzcGFjZScsICdwcmVzZXJ2ZScpO1xuICAgICAgICB9IC8vXG5cbiAgICAgIH1cblxuICAgICAgaWYgKHNpbmdsZVNoYXBlICYmIHRTcGFuKSB7XG4gICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnZCcsIHNoYXBlU3RyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IHRoaXMudGV4dFNwYW5zLmxlbmd0aCkge1xuICAgICAgdGhpcy50ZXh0U3BhbnNbaV0uc3Bhbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcbiAgfTtcblxuICBTVkdUZXh0TG90dGllRWxlbWVudC5wcm90b3R5cGUuc291cmNlUmVjdEF0VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnByZXBhcmVGcmFtZSh0aGlzLmNvbXAucmVuZGVyZWRGcmFtZSAtIHRoaXMuZGF0YS5zdCk7XG4gICAgdGhpcy5yZW5kZXJJbm5lckNvbnRlbnQoKTtcblxuICAgIGlmICh0aGlzLl9zaXplQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fc2l6ZUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciB0ZXh0Qm94ID0gdGhpcy5sYXllckVsZW1lbnQuZ2V0QkJveCgpO1xuICAgICAgdGhpcy5iYm94ID0ge1xuICAgICAgICB0b3A6IHRleHRCb3gueSxcbiAgICAgICAgbGVmdDogdGV4dEJveC54LFxuICAgICAgICB3aWR0aDogdGV4dEJveC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0ZXh0Qm94LmhlaWdodFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5iYm94O1xuICB9O1xuXG4gIFNWR1RleHRMb3R0aWVFbGVtZW50LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy50ZXh0U3BhbnMubGVuZ3RoO1xuICAgIHZhciBnbHlwaEVsZW1lbnQ7XG4gICAgdGhpcy5yZW5kZXJlZEZyYW1lID0gdGhpcy5jb21wLnJlbmRlcmVkRnJhbWU7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGdseXBoRWxlbWVudCA9IHRoaXMudGV4dFNwYW5zW2ldLmdseXBoO1xuXG4gICAgICBpZiAoZ2x5cGhFbGVtZW50KSB7XG4gICAgICAgIGdseXBoRWxlbWVudC5wcmVwYXJlRnJhbWUodGhpcy5jb21wLnJlbmRlcmVkRnJhbWUgLSB0aGlzLmRhdGEuc3QpO1xuXG4gICAgICAgIGlmIChnbHlwaEVsZW1lbnQuX21kZikge1xuICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU1ZHVGV4dExvdHRpZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnZhbGlkYXRlVGV4dCgpO1xuXG4gICAgaWYgKCF0aGlzLmRhdGEuc2luZ2xlU2hhcGUgfHwgdGhpcy5fbWRmKSB7XG4gICAgICB0aGlzLnRleHRBbmltYXRvci5nZXRNZWFzdXJlcyh0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YSwgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcpO1xuXG4gICAgICBpZiAodGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgfHwgdGhpcy50ZXh0QW5pbWF0b3IubGV0dGVyc0NoYW5nZWRGbGFnKSB7XG4gICAgICAgIHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW47XG4gICAgICAgIHZhciByZW5kZXJlZExldHRlcnMgPSB0aGlzLnRleHRBbmltYXRvci5yZW5kZXJlZExldHRlcnM7XG4gICAgICAgIHZhciBsZXR0ZXJzID0gdGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEubDtcbiAgICAgICAgbGVuID0gbGV0dGVycy5sZW5ndGg7XG4gICAgICAgIHZhciByZW5kZXJlZExldHRlcjtcbiAgICAgICAgdmFyIHRleHRTcGFuO1xuICAgICAgICB2YXIgZ2x5cGhFbGVtZW50O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGlmICghbGV0dGVyc1tpXS5uKSB7XG4gICAgICAgICAgICByZW5kZXJlZExldHRlciA9IHJlbmRlcmVkTGV0dGVyc1tpXTtcbiAgICAgICAgICAgIHRleHRTcGFuID0gdGhpcy50ZXh0U3BhbnNbaV0uc3BhbjtcbiAgICAgICAgICAgIGdseXBoRWxlbWVudCA9IHRoaXMudGV4dFNwYW5zW2ldLmdseXBoO1xuXG4gICAgICAgICAgICBpZiAoZ2x5cGhFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGdseXBoRWxlbWVudC5yZW5kZXJGcmFtZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuX21kZi5tKSB7XG4gICAgICAgICAgICAgIHRleHRTcGFuLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgcmVuZGVyZWRMZXR0ZXIubSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZW5kZXJlZExldHRlci5fbWRmLm8pIHtcbiAgICAgICAgICAgICAgdGV4dFNwYW4uc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgcmVuZGVyZWRMZXR0ZXIubyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZW5kZXJlZExldHRlci5fbWRmLnN3KSB7XG4gICAgICAgICAgICAgIHRleHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgcmVuZGVyZWRMZXR0ZXIuc3cpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuX21kZi5zYykge1xuICAgICAgICAgICAgICB0ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIHJlbmRlcmVkTGV0dGVyLnNjKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLl9tZGYuZmMpIHtcbiAgICAgICAgICAgICAgdGV4dFNwYW4uc2V0QXR0cmlidXRlKCdmaWxsJywgcmVuZGVyZWRMZXR0ZXIuZmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBJU29saWRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtJSW1hZ2VFbGVtZW50XSwgSVNvbGlkRWxlbWVudCk7XG5cbiAgSVNvbGlkRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdCA9IGNyZWF0ZU5TKCdyZWN0Jyk7IC8vLyAvcmVjdC5zdHlsZS53aWR0aCA9IHRoaXMuZGF0YS5zdztcbiAgICAvLy8gL3JlY3Quc3R5bGUuaGVpZ2h0ID0gdGhpcy5kYXRhLnNoO1xuICAgIC8vLyAvcmVjdC5zdHlsZS5maWxsID0gdGhpcy5kYXRhLnNjO1xuXG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5kYXRhLnN3KTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5kYXRhLnNoKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsIHRoaXMuZGF0YS5zYyk7XG4gICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQocmVjdCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gTnVsbEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMuaW5pdEZyYW1lKCk7XG4gICAgdGhpcy5pbml0QmFzZURhdGEoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy5pbml0RnJhbWUoKTtcbiAgICB0aGlzLmluaXRUcmFuc2Zvcm0oZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy5pbml0SGllcmFyY2h5KCk7XG4gIH1cblxuICBOdWxsRWxlbWVudC5wcm90b3R5cGUucHJlcGFyZUZyYW1lID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHRoaXMucHJlcGFyZVByb3BlcnRpZXMobnVtLCB0cnVlKTtcbiAgfTtcblxuICBOdWxsRWxlbWVudC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBOdWxsRWxlbWVudC5wcm90b3R5cGUuZ2V0QmFzZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgTnVsbEVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBOdWxsRWxlbWVudC5wcm90b3R5cGUuc291cmNlUmVjdEF0VGltZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIE51bGxFbGVtZW50LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge307XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50XSwgTnVsbEVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFNWR1JlbmRlcmVyQmFzZSgpIHt9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlUmVuZGVyZXJdLCBTVkdSZW5kZXJlckJhc2UpO1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlTnVsbCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBOdWxsRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlU2hhcGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgU1ZHU2hhcGVFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVUZXh0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFNWR1RleHRMb3R0aWVFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVJbWFnZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBJSW1hZ2VFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVTb2xpZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBJU29saWRFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jb25maWdBbmltYXRpb24gPSBmdW5jdGlvbiAoYW5pbURhdGEpIHtcbiAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd4bWxucycsICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycpO1xuICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3htbG5zOnhsaW5rJywgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnKTtcblxuICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy52aWV3Qm94U2l6ZSkge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIHRoaXMucmVuZGVyQ29uZmlnLnZpZXdCb3hTaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsICcwIDAgJyArIGFuaW1EYXRhLncgKyAnICcgKyBhbmltRGF0YS5oKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucmVuZGVyQ29uZmlnLnZpZXdCb3hPbmx5KSB7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGFuaW1EYXRhLncpO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYW5pbURhdGEuaCk7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgwLDAsMCknO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnN0eWxlLmNvbnRlbnRWaXNpYmlsaXR5ID0gdGhpcy5yZW5kZXJDb25maWcuY29udGVudFZpc2liaWxpdHk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLndpZHRoKSB7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMucmVuZGVyQ29uZmlnLndpZHRoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuaGVpZ2h0KSB7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLnJlbmRlckNvbmZpZy5oZWlnaHQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5jbGFzc05hbWUpIHtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuaWQpIHtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5yZW5kZXJDb25maWcuaWQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5mb2N1c2FibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnZm9jdXNhYmxlJywgdGhpcy5yZW5kZXJDb25maWcuZm9jdXNhYmxlKTtcbiAgICB9XG5cbiAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgdGhpcy5yZW5kZXJDb25maWcucHJlc2VydmVBc3BlY3RSYXRpbyk7IC8vIHRoaXMubGF5ZXJFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgwLDAsMCknO1xuICAgIC8vIHRoaXMubGF5ZXJFbGVtZW50LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IHRoaXMubGF5ZXJFbGVtZW50LnN0eWxlLm1velRyYW5zZm9ybU9yaWdpbiA9IHRoaXMubGF5ZXJFbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9IHRoaXMubGF5ZXJFbGVtZW50LnN0eWxlWyctd2Via2l0LXRyYW5zZm9ybSddID0gXCIwcHggMHB4IDBweFwiO1xuXG4gICAgdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5zdmdFbGVtZW50KTsgLy8gTWFzayBhbmltYXRpb25cblxuICAgIHZhciBkZWZzID0gdGhpcy5nbG9iYWxEYXRhLmRlZnM7XG4gICAgdGhpcy5zZXR1cEdsb2JhbERhdGEoYW5pbURhdGEsIGRlZnMpO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5wcm9ncmVzc2l2ZUxvYWQgPSB0aGlzLnJlbmRlckNvbmZpZy5wcm9ncmVzc2l2ZUxvYWQ7XG4gICAgdGhpcy5kYXRhID0gYW5pbURhdGE7XG4gICAgdmFyIG1hc2tFbGVtZW50ID0gY3JlYXRlTlMoJ2NsaXBQYXRoJyk7XG4gICAgdmFyIHJlY3QgPSBjcmVhdGVOUygncmVjdCcpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsIGFuaW1EYXRhLncpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBhbmltRGF0YS5oKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgneCcsIDApO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlKCd5JywgMCk7XG4gICAgdmFyIG1hc2tJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgIG1hc2tFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBtYXNrSWQpO1xuICAgIG1hc2tFbGVtZW50LmFwcGVuZENoaWxkKHJlY3QpO1xuICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xpcC1wYXRoJywgJ3VybCgnICsgZ2V0TG9jYXRpb25IcmVmKCkgKyAnIycgKyBtYXNrSWQgKyAnKScpO1xuICAgIGRlZnMuYXBwZW5kQ2hpbGQobWFza0VsZW1lbnQpO1xuICAgIHRoaXMubGF5ZXJzID0gYW5pbURhdGEubGF5ZXJzO1xuICAgIHRoaXMuZWxlbWVudHMgPSBjcmVhdGVTaXplZEFycmF5KGFuaW1EYXRhLmxheWVycy5sZW5ndGgpO1xuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLmlubmVyVGV4dCA9ICcnO1xuICAgIH1cblxuICAgIHRoaXMubGF5ZXJFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmdsb2JhbERhdGEuZGVmcyA9IG51bGw7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzID8gdGhpcy5sYXllcnMubGVuZ3RoIDogMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0gJiYgdGhpcy5lbGVtZW50c1tpXS5kZXN0cm95KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbaV0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5hbmltYXRpb25JdGVtID0gbnVsbDtcbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLnVwZGF0ZUNvbnRhaW5lclNpemUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmZpbmRJbmRleEJ5SW5kID0gZnVuY3Rpb24gKGluZCkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5sYXllcnNbaV0uaW5kID09PSBpbmQpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuYnVpbGRJdGVtID0gZnVuY3Rpb24gKHBvcykge1xuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICBpZiAoZWxlbWVudHNbcG9zXSB8fCB0aGlzLmxheWVyc1twb3NdLnR5ID09PSA5OSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnRzW3Bvc10gPSB0cnVlO1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5jcmVhdGVJdGVtKHRoaXMubGF5ZXJzW3Bvc10pO1xuICAgIGVsZW1lbnRzW3Bvc10gPSBlbGVtZW50O1xuXG4gICAgaWYgKGdldEV4cHJlc3Npb25zUGx1Z2luKCkpIHtcbiAgICAgIGlmICh0aGlzLmxheWVyc1twb3NdLnR5ID09PSAwKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5wcm9qZWN0SW50ZXJmYWNlLnJlZ2lzdGVyQ29tcG9zaXRpb24oZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuaW5pdEV4cHJlc3Npb25zKCk7XG4gICAgfVxuXG4gICAgdGhpcy5hcHBlbmRFbGVtZW50SW5Qb3MoZWxlbWVudCwgcG9zKTtcblxuICAgIGlmICh0aGlzLmxheWVyc1twb3NdLnR0KSB7XG4gICAgICB2YXIgZWxlbWVudEluZGV4ID0gJ3RwJyBpbiB0aGlzLmxheWVyc1twb3NdID8gdGhpcy5maW5kSW5kZXhCeUluZCh0aGlzLmxheWVyc1twb3NdLnRwKSA6IHBvcyAtIDE7XG5cbiAgICAgIGlmIChlbGVtZW50SW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmVsZW1lbnRzW2VsZW1lbnRJbmRleF0gfHwgdGhpcy5lbGVtZW50c1tlbGVtZW50SW5kZXhdID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYnVpbGRJdGVtKGVsZW1lbnRJbmRleCk7XG4gICAgICAgIHRoaXMuYWRkUGVuZGluZ0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWF0dGVFbGVtZW50ID0gZWxlbWVudHNbZWxlbWVudEluZGV4XTtcbiAgICAgICAgdmFyIG1hdHRlTWFzayA9IG1hdHRlRWxlbWVudC5nZXRNYXR0ZSh0aGlzLmxheWVyc1twb3NdLnR0KTtcbiAgICAgICAgZWxlbWVudC5zZXRNYXR0ZShtYXR0ZU1hc2spO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmNoZWNrUGVuZGluZ0VsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHdoaWxlICh0aGlzLnBlbmRpbmdFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wZW5kaW5nRWxlbWVudHMucG9wKCk7XG4gICAgICBlbGVtZW50LmNoZWNrUGFyZW50aW5nKCk7XG5cbiAgICAgIGlmIChlbGVtZW50LmRhdGEudHQpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICBpZiAodGhpcy5lbGVtZW50c1tpXSA9PT0gZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRJbmRleCA9ICd0cCcgaW4gZWxlbWVudC5kYXRhID8gdGhpcy5maW5kSW5kZXhCeUluZChlbGVtZW50LmRhdGEudHApIDogaSAtIDE7XG4gICAgICAgICAgICB2YXIgbWF0dGVFbGVtZW50ID0gdGhpcy5lbGVtZW50c1tlbGVtZW50SW5kZXhdO1xuICAgICAgICAgICAgdmFyIG1hdHRlTWFzayA9IG1hdHRlRWxlbWVudC5nZXRNYXR0ZSh0aGlzLmxheWVyc1tpXS50dCk7XG4gICAgICAgICAgICBlbGVtZW50LnNldE1hdHRlKG1hdHRlTWFzayk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlZEZyYW1lID09PSBudW0gfHwgdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobnVtID09PSBudWxsKSB7XG4gICAgICBudW0gPSB0aGlzLnJlbmRlcmVkRnJhbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZWRGcmFtZSA9IG51bTtcbiAgICB9IC8vIGNvbnNvbGUubG9nKCctLS0tLS0tJyk7XG4gICAgLy8gY29uc29sZS5sb2coJ0ZSQU1FICcsbnVtKTtcblxuXG4gICAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lTnVtID0gbnVtO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZUlkICs9IDE7XG4gICAgdGhpcy5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UuY3VycmVudEZyYW1lID0gbnVtO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5fbWRmID0gZmFsc2U7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcblxuICAgIGlmICghdGhpcy5jb21wbGV0ZUxheWVycykge1xuICAgICAgdGhpcy5jaGVja0xheWVycyhudW0pO1xuICAgIH1cblxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICBpZiAodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbaV0ucHJlcGFyZUZyYW1lKG51bSAtIHRoaXMubGF5ZXJzW2ldLnN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5nbG9iYWxEYXRhLl9tZGYpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5yZW5kZXJGcmFtZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuYXBwZW5kRWxlbWVudEluUG9zID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBvcykge1xuICAgIHZhciBuZXdFbGVtZW50ID0gZWxlbWVudC5nZXRCYXNlRWxlbWVudCgpO1xuXG4gICAgaWYgKCFuZXdFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBuZXh0RWxlbWVudDtcblxuICAgIHdoaWxlIChpIDwgcG9zKSB7XG4gICAgICBpZiAodGhpcy5lbGVtZW50c1tpXSAmJiB0aGlzLmVsZW1lbnRzW2ldICE9PSB0cnVlICYmIHRoaXMuZWxlbWVudHNbaV0uZ2V0QmFzZUVsZW1lbnQoKSkge1xuICAgICAgICBuZXh0RWxlbWVudCA9IHRoaXMuZWxlbWVudHNbaV0uZ2V0QmFzZUVsZW1lbnQoKTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIGlmIChuZXh0RWxlbWVudCkge1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuaW5zZXJ0QmVmb3JlKG5ld0VsZW1lbnQsIG5leHRFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQobmV3RWxlbWVudCk7XG4gICAgfVxuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgfTtcblxuICBmdW5jdGlvbiBJQ29tcEVsZW1lbnQoKSB7fVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZURPTUVsZW1lbnRdLCBJQ29tcEVsZW1lbnQpO1xuXG4gIElDb21wRWxlbWVudC5wcm90b3R5cGUuaW5pdEVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMuaW5pdEZyYW1lKCk7XG4gICAgdGhpcy5pbml0QmFzZURhdGEoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy5pbml0VHJhbnNmb3JtKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMuaW5pdFJlbmRlcmFibGUoKTtcbiAgICB0aGlzLmluaXRIaWVyYXJjaHkoKTtcbiAgICB0aGlzLmluaXRSZW5kZXJlckVsZW1lbnQoKTtcbiAgICB0aGlzLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzKCk7XG4gICAgdGhpcy5jcmVhdGVSZW5kZXJhYmxlQ29tcG9uZW50cygpO1xuXG4gICAgaWYgKHRoaXMuZGF0YS54dCB8fCAhZ2xvYmFsRGF0YS5wcm9ncmVzc2l2ZUxvYWQpIHtcbiAgICAgIHRoaXMuYnVpbGRBbGxJdGVtcygpO1xuICAgIH1cblxuICAgIHRoaXMuaGlkZSgpO1xuICB9O1xuICAvKiBJQ29tcEVsZW1lbnQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpe1xyXG4gICAgICBpZighdGhpcy5oaWRkZW4pe1xyXG4gICAgICAgICAgdGhpcy5oaWRlRWxlbWVudCgpO1xyXG4gICAgICAgICAgdmFyIGksbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgICBmb3IoIGkgPSAwOyBpIDwgbGVuOyBpKz0xICl7XHJcbiAgICAgICAgICAgICAgaWYodGhpcy5lbGVtZW50c1tpXSl7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbaV0uaGlkZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gIH07ICovXG5cblxuICBJQ29tcEVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB0aGlzLnByZXBhcmVSZW5kZXJhYmxlRnJhbWUobnVtKTtcbiAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdGhpcy5pc0luUmFuZ2UpO1xuXG4gICAgaWYgKCF0aGlzLmlzSW5SYW5nZSAmJiAhdGhpcy5kYXRhLnh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnRtLl9wbGFjZWhvbGRlcikge1xuICAgICAgdmFyIHRpbWVSZW1hcHBlZCA9IHRoaXMudG0udjtcblxuICAgICAgaWYgKHRpbWVSZW1hcHBlZCA9PT0gdGhpcy5kYXRhLm9wKSB7XG4gICAgICAgIHRpbWVSZW1hcHBlZCA9IHRoaXMuZGF0YS5vcCAtIDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyZWRGcmFtZSA9IHRpbWVSZW1hcHBlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW5kZXJlZEZyYW1lID0gbnVtIC8gdGhpcy5kYXRhLnNyO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcblxuICAgIGlmICghdGhpcy5jb21wbGV0ZUxheWVycykge1xuICAgICAgdGhpcy5jaGVja0xheWVycyh0aGlzLnJlbmRlcmVkRnJhbWUpO1xuICAgIH0gLy8gVGhpcyBpdGVyYXRpb24gbmVlZHMgdG8gYmUgYmFja3dhcmRzIGJlY2F1c2Ugb2YgaG93IGV4cHJlc3Npb25zIGNvbm5lY3QgYmV0d2VlbiBlYWNoIG90aGVyXG5cblxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICBpZiAodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbaV0ucHJlcGFyZUZyYW1lKHRoaXMucmVuZGVyZWRGcmFtZSAtIHRoaXMubGF5ZXJzW2ldLnN0KTtcblxuICAgICAgICBpZiAodGhpcy5lbGVtZW50c1tpXS5fbWRmKSB7XG4gICAgICAgICAgdGhpcy5fbWRmID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBJQ29tcEVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbaV0ucmVuZGVyRnJhbWUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSUNvbXBFbGVtZW50LnByb3RvdHlwZS5zZXRFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVtcykge1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtcztcbiAgfTtcblxuICBJQ29tcEVsZW1lbnQucHJvdG90eXBlLmdldEVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzO1xuICB9O1xuXG4gIElDb21wRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveUVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbaV0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBJQ29tcEVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZXN0cm95RWxlbWVudHMoKTtcbiAgICB0aGlzLmRlc3Ryb3lCYXNlRWxlbWVudCgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR0NvbXBFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmxheWVycyA9IGRhdGEubGF5ZXJzO1xuICAgIHRoaXMuc3VwcG9ydHMzZCA9IHRydWU7XG4gICAgdGhpcy5jb21wbGV0ZUxheWVycyA9IGZhbHNlO1xuICAgIHRoaXMucGVuZGluZ0VsZW1lbnRzID0gW107XG4gICAgdGhpcy5lbGVtZW50cyA9IHRoaXMubGF5ZXJzID8gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLmxheWVycy5sZW5ndGgpIDogW107XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICB0aGlzLnRtID0gZGF0YS50bSA/IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEudG0sIDAsIGdsb2JhbERhdGEuZnJhbWVSYXRlLCB0aGlzKSA6IHtcbiAgICAgIF9wbGFjZWhvbGRlcjogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW1NWR1JlbmRlcmVyQmFzZSwgSUNvbXBFbGVtZW50LCBTVkdCYXNlRWxlbWVudF0sIFNWR0NvbXBFbGVtZW50KTtcblxuICBTVkdDb21wRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29tcCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBTVkdDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR1JlbmRlcmVyKGFuaW1hdGlvbkl0ZW0sIGNvbmZpZykge1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbSA9IGFuaW1hdGlvbkl0ZW07XG4gICAgdGhpcy5sYXllcnMgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyZWRGcmFtZSA9IC0xO1xuICAgIHRoaXMuc3ZnRWxlbWVudCA9IGNyZWF0ZU5TKCdzdmcnKTtcbiAgICB2YXIgYXJpYUxhYmVsID0gJyc7XG5cbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy50aXRsZSkge1xuICAgICAgdmFyIHRpdGxlRWxlbWVudCA9IGNyZWF0ZU5TKCd0aXRsZScpO1xuICAgICAgdmFyIHRpdGxlSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICAgIHRpdGxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGl0bGVJZCk7XG4gICAgICB0aXRsZUVsZW1lbnQudGV4dENvbnRlbnQgPSBjb25maWcudGl0bGU7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQodGl0bGVFbGVtZW50KTtcbiAgICAgIGFyaWFMYWJlbCArPSB0aXRsZUlkO1xuICAgIH1cblxuICAgIGlmIChjb25maWcgJiYgY29uZmlnLmRlc2NyaXB0aW9uKSB7XG4gICAgICB2YXIgZGVzY0VsZW1lbnQgPSBjcmVhdGVOUygnZGVzYycpO1xuICAgICAgdmFyIGRlc2NJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgZGVzY0VsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIGRlc2NJZCk7XG4gICAgICBkZXNjRWxlbWVudC50ZXh0Q29udGVudCA9IGNvbmZpZy5kZXNjcmlwdGlvbjtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5hcHBlbmRDaGlsZChkZXNjRWxlbWVudCk7XG4gICAgICBhcmlhTGFiZWwgKz0gJyAnICsgZGVzY0lkO1xuICAgIH1cblxuICAgIGlmIChhcmlhTGFiZWwpIHtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWxsZWRieScsIGFyaWFMYWJlbCk7XG4gICAgfVxuXG4gICAgdmFyIGRlZnMgPSBjcmVhdGVOUygnZGVmcycpO1xuICAgIHRoaXMuc3ZnRWxlbWVudC5hcHBlbmRDaGlsZChkZWZzKTtcbiAgICB2YXIgbWFza0VsZW1lbnQgPSBjcmVhdGVOUygnZycpO1xuICAgIHRoaXMuc3ZnRWxlbWVudC5hcHBlbmRDaGlsZChtYXNrRWxlbWVudCk7XG4gICAgdGhpcy5sYXllckVsZW1lbnQgPSBtYXNrRWxlbWVudDtcbiAgICB0aGlzLnJlbmRlckNvbmZpZyA9IHtcbiAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IGNvbmZpZyAmJiBjb25maWcucHJlc2VydmVBc3BlY3RSYXRpbyB8fCAneE1pZFlNaWQgbWVldCcsXG4gICAgICBpbWFnZVByZXNlcnZlQXNwZWN0UmF0aW86IGNvbmZpZyAmJiBjb25maWcuaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvIHx8ICd4TWlkWU1pZCBzbGljZScsXG4gICAgICBjb250ZW50VmlzaWJpbGl0eTogY29uZmlnICYmIGNvbmZpZy5jb250ZW50VmlzaWJpbGl0eSB8fCAndmlzaWJsZScsXG4gICAgICBwcm9ncmVzc2l2ZUxvYWQ6IGNvbmZpZyAmJiBjb25maWcucHJvZ3Jlc3NpdmVMb2FkIHx8IGZhbHNlLFxuICAgICAgaGlkZU9uVHJhbnNwYXJlbnQ6ICEoY29uZmlnICYmIGNvbmZpZy5oaWRlT25UcmFuc3BhcmVudCA9PT0gZmFsc2UpLFxuICAgICAgdmlld0JveE9ubHk6IGNvbmZpZyAmJiBjb25maWcudmlld0JveE9ubHkgfHwgZmFsc2UsXG4gICAgICB2aWV3Qm94U2l6ZTogY29uZmlnICYmIGNvbmZpZy52aWV3Qm94U2l6ZSB8fCBmYWxzZSxcbiAgICAgIGNsYXNzTmFtZTogY29uZmlnICYmIGNvbmZpZy5jbGFzc05hbWUgfHwgJycsXG4gICAgICBpZDogY29uZmlnICYmIGNvbmZpZy5pZCB8fCAnJyxcbiAgICAgIGZvY3VzYWJsZTogY29uZmlnICYmIGNvbmZpZy5mb2N1c2FibGUsXG4gICAgICBmaWx0ZXJTaXplOiB7XG4gICAgICAgIHdpZHRoOiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUud2lkdGggfHwgJzEwMCUnLFxuICAgICAgICBoZWlnaHQ6IGNvbmZpZyAmJiBjb25maWcuZmlsdGVyU2l6ZSAmJiBjb25maWcuZmlsdGVyU2l6ZS5oZWlnaHQgfHwgJzEwMCUnLFxuICAgICAgICB4OiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUueCB8fCAnMCUnLFxuICAgICAgICB5OiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUueSB8fCAnMCUnXG4gICAgICB9LFxuICAgICAgd2lkdGg6IGNvbmZpZyAmJiBjb25maWcud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNvbmZpZyAmJiBjb25maWcuaGVpZ2h0LFxuICAgICAgcnVuRXhwcmVzc2lvbnM6ICFjb25maWcgfHwgY29uZmlnLnJ1bkV4cHJlc3Npb25zID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnJ1bkV4cHJlc3Npb25zXG4gICAgfTtcbiAgICB0aGlzLmdsb2JhbERhdGEgPSB7XG4gICAgICBfbWRmOiBmYWxzZSxcbiAgICAgIGZyYW1lTnVtOiAtMSxcbiAgICAgIGRlZnM6IGRlZnMsXG4gICAgICByZW5kZXJDb25maWc6IHRoaXMucmVuZGVyQ29uZmlnXG4gICAgfTtcbiAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgdGhpcy5wZW5kaW5nRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyZXJUeXBlID0gJ3N2Zyc7XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW1NWR1JlbmRlcmVyQmFzZV0sIFNWR1JlbmRlcmVyKTtcblxuICBTVkdSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQ29tcCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBTVkdDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFNoYXBlVHJhbnNmb3JtTWFuYWdlcigpIHtcbiAgICB0aGlzLnNlcXVlbmNlcyA9IHt9O1xuICAgIHRoaXMuc2VxdWVuY2VMaXN0ID0gW107XG4gICAgdGhpcy50cmFuc2Zvcm1fa2V5X2NvdW50ID0gMDtcbiAgfVxuXG4gIFNoYXBlVHJhbnNmb3JtTWFuYWdlci5wcm90b3R5cGUgPSB7XG4gICAgYWRkVHJhbnNmb3JtU2VxdWVuY2U6IGZ1bmN0aW9uIGFkZFRyYW5zZm9ybVNlcXVlbmNlKHRyYW5zZm9ybXMpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgdmFyIGtleSA9ICdfJztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGtleSArPSB0cmFuc2Zvcm1zW2ldLnRyYW5zZm9ybS5rZXkgKyAnXyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZXF1ZW5jZSA9IHRoaXMuc2VxdWVuY2VzW2tleV07XG5cbiAgICAgIGlmICghc2VxdWVuY2UpIHtcbiAgICAgICAgc2VxdWVuY2UgPSB7XG4gICAgICAgICAgdHJhbnNmb3JtczogW10uY29uY2F0KHRyYW5zZm9ybXMpLFxuICAgICAgICAgIGZpbmFsVHJhbnNmb3JtOiBuZXcgTWF0cml4KCksXG4gICAgICAgICAgX21kZjogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXF1ZW5jZXNba2V5XSA9IHNlcXVlbmNlO1xuICAgICAgICB0aGlzLnNlcXVlbmNlTGlzdC5wdXNoKHNlcXVlbmNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlcXVlbmNlO1xuICAgIH0sXG4gICAgcHJvY2Vzc1NlcXVlbmNlOiBmdW5jdGlvbiBwcm9jZXNzU2VxdWVuY2Uoc2VxdWVuY2UsIGlzRmlyc3RGcmFtZSkge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IHNlcXVlbmNlLnRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgdmFyIF9tZGYgPSBpc0ZpcnN0RnJhbWU7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuICYmICFpc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgaWYgKHNlcXVlbmNlLnRyYW5zZm9ybXNbaV0udHJhbnNmb3JtLm1Qcm9wcy5fbWRmKSB7XG4gICAgICAgICAgX21kZiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpICs9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChfbWRmKSB7XG4gICAgICAgIHNlcXVlbmNlLmZpbmFsVHJhbnNmb3JtLnJlc2V0KCk7XG5cbiAgICAgICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICBzZXF1ZW5jZS5maW5hbFRyYW5zZm9ybS5tdWx0aXBseShzZXF1ZW5jZS50cmFuc2Zvcm1zW2ldLnRyYW5zZm9ybS5tUHJvcHMudik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VxdWVuY2UuX21kZiA9IF9tZGY7XG4gICAgfSxcbiAgICBwcm9jZXNzU2VxdWVuY2VzOiBmdW5jdGlvbiBwcm9jZXNzU2VxdWVuY2VzKGlzRmlyc3RGcmFtZSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gdGhpcy5zZXF1ZW5jZUxpc3QubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzU2VxdWVuY2UodGhpcy5zZXF1ZW5jZUxpc3RbaV0sIGlzRmlyc3RGcmFtZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXROZXdLZXk6IGZ1bmN0aW9uIGdldE5ld0tleSgpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtX2tleV9jb3VudCArPSAxO1xuICAgICAgcmV0dXJuICdfJyArIHRoaXMudHJhbnNmb3JtX2tleV9jb3VudDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGx1bWFMb2FkZXIgPSBmdW5jdGlvbiBsdW1hTG9hZGVyKCkge1xuICAgIHZhciBpZCA9ICdfX2xvdHRpZV9lbGVtZW50X2x1bWFfYnVmZmVyJztcbiAgICB2YXIgbHVtYUJ1ZmZlciA9IG51bGw7XG4gICAgdmFyIGx1bWFCdWZmZXJDdHggPSBudWxsO1xuICAgIHZhciBzdmcgPSBudWxsOyAvLyBUaGlzIGFsdGVybmF0ZSBzb2x1dGlvbiBoYXMgYSBzbGlnaHQgZGVsYXkgYmVmb3JlIHRoZSBmaWx0ZXIgaXMgYXBwbGllZCwgcmVzdWx0aW5nIGluIGEgZmxpY2tlciBvbiB0aGUgZmlyc3QgZnJhbWUuXG4gICAgLy8gS2VlcGluZyB0aGlzIGhlcmUgZm9yIHJlZmVyZW5jZSwgYW5kIGluIHRoZSBmdXR1cmUsIGlmIG9mZnNjcmVlbiBjYW52YXMgc3VwcG9ydHMgdXJsIGZpbHRlcnMsIHRoaXMgY2FuIGJlIHVzZWQuXG4gICAgLy8gRm9yIG5vdywgbmVpdGhlciBvZiB0aGVtIHdvcmsgZm9yIG9mZnNjcmVlbiBjYW52YXMsIHNvIGNhbnZhcyB3b3JrZXJzIGNhbid0IHN1cHBvcnQgdGhlIGx1bWEgdHJhY2sgbWF0dGUgbWFzay5cbiAgICAvLyBOYW1pbmcgaXQgc29sdXRpb24gMiB0byBtYXJrIHRoZSBleHRyYSBjb21tZW50IGxpbmVzLlxuXG4gICAgLypcclxuICAgIHZhciBzdmdTdHJpbmcgPSBbXHJcbiAgICAgICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj4nLFxyXG4gICAgICAnPGZpbHRlciBpZD1cIicgKyBpZCArICdcIj4nLFxyXG4gICAgICAnPGZlQ29sb3JNYXRyaXggdHlwZT1cIm1hdHJpeFwiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz1cInNSR0JcIiB2YWx1ZXM9XCInLFxyXG4gICAgICAnMC4zLCAwLjMsIDAuMywgMCwgMCwgJyxcclxuICAgICAgJzAuMywgMC4zLCAwLjMsIDAsIDAsICcsXHJcbiAgICAgICcwLjMsIDAuMywgMC4zLCAwLCAwLCAnLFxyXG4gICAgICAnMC4zLCAwLjMsIDAuMywgMCwgMCcsXHJcbiAgICAgICdcIi8+JyxcclxuICAgICAgJzwvZmlsdGVyPicsXHJcbiAgICAgICc8L3N2Zz4nLFxyXG4gICAgXS5qb2luKCcnKTtcclxuICAgIHZhciBibG9iID0gbmV3IEJsb2IoW3N2Z1N0cmluZ10sIHsgdHlwZTogJ2ltYWdlL3N2Zyt4bWwnIH0pO1xyXG4gICAgdmFyIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlTHVtYVN2Z0ZpbHRlcigpIHtcbiAgICAgIHZhciBfc3ZnID0gY3JlYXRlTlMoJ3N2ZycpO1xuXG4gICAgICB2YXIgZmlsID0gY3JlYXRlTlMoJ2ZpbHRlcicpO1xuICAgICAgdmFyIG1hdHJpeCA9IGNyZWF0ZU5TKCdmZUNvbG9yTWF0cml4Jyk7XG4gICAgICBmaWwuc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgIG1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnbWF0cml4Jyk7XG4gICAgICBtYXRyaXguc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnc1JHQicpO1xuICAgICAgbWF0cml4LnNldEF0dHJpYnV0ZSgndmFsdWVzJywgJzAuMywgMC4zLCAwLjMsIDAsIDAsIDAuMywgMC4zLCAwLjMsIDAsIDAsIDAuMywgMC4zLCAwLjMsIDAsIDAsIDAuMywgMC4zLCAwLjMsIDAsIDAnKTtcbiAgICAgIGZpbC5hcHBlbmRDaGlsZChtYXRyaXgpO1xuXG4gICAgICBfc3ZnLmFwcGVuZENoaWxkKGZpbCk7XG5cbiAgICAgIF9zdmcuc2V0QXR0cmlidXRlKCdpZCcsIGlkICsgJ19zdmcnKTtcblxuICAgICAgaWYgKGZlYXR1cmVTdXBwb3J0LnN2Z0x1bWFIaWRkZW4pIHtcbiAgICAgICAgX3N2Zy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3N2ZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTHVtYSgpIHtcbiAgICAgIGlmICghbHVtYUJ1ZmZlcikge1xuICAgICAgICBzdmcgPSBjcmVhdGVMdW1hU3ZnRmlsdGVyKCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgICAgICAgbHVtYUJ1ZmZlciA9IGNyZWF0ZVRhZygnY2FudmFzJyk7XG4gICAgICAgIGx1bWFCdWZmZXJDdHggPSBsdW1hQnVmZmVyLmdldENvbnRleHQoJzJkJyk7IC8vIGx1bWFCdWZmZXJDdHguZmlsdGVyID0gYHVybCgnJHt1cmx9I19fbG90dGllX2VsZW1lbnRfbHVtYV9idWZmZXInKWA7IC8vIHBhcnQgb2Ygc29sdXRpb24gMlxuXG4gICAgICAgIGx1bWFCdWZmZXJDdHguZmlsdGVyID0gJ3VybCgjJyArIGlkICsgJyknO1xuICAgICAgICBsdW1hQnVmZmVyQ3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgbHVtYUJ1ZmZlckN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRMdW1hKGNhbnZhcykge1xuICAgICAgaWYgKCFsdW1hQnVmZmVyKSB7XG4gICAgICAgIGxvYWRMdW1hKCk7XG4gICAgICB9XG5cbiAgICAgIGx1bWFCdWZmZXIud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICBsdW1hQnVmZmVyLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7IC8vIGx1bWFCdWZmZXJDdHguZmlsdGVyID0gYHVybCgnJHt1cmx9I19fbG90dGllX2VsZW1lbnRfbHVtYV9idWZmZXInKWA7IC8vIHBhcnQgb2Ygc29sdXRpb24gMlxuXG4gICAgICBsdW1hQnVmZmVyQ3R4LmZpbHRlciA9ICd1cmwoIycgKyBpZCArICcpJztcbiAgICAgIHJldHVybiBsdW1hQnVmZmVyO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsb2FkOiBsb2FkTHVtYSxcbiAgICAgIGdldDogZ2V0THVtYVxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoZmVhdHVyZVN1cHBvcnQub2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgICByZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICB2YXIgY2FudmFzID0gY3JlYXRlVGFnKCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBjYW52YXM7XG4gIH1cblxuICB2YXIgYXNzZXRMb2FkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvYWRMdW1hQ2FudmFzOiBsdW1hTG9hZGVyLmxvYWQsXG4gICAgICBnZXRMdW1hQ2FudmFzOiBsdW1hTG9hZGVyLmdldCxcbiAgICAgIGNyZWF0ZUNhbnZhczogY3JlYXRlQ2FudmFzXG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciByZWdpc3RlcmVkRWZmZWN0cyA9IHt9O1xuXG4gIGZ1bmN0aW9uIENWRWZmZWN0cyhlbGVtKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGVsZW0uZGF0YS5lZiA/IGVsZW0uZGF0YS5lZi5sZW5ndGggOiAwO1xuICAgIHRoaXMuZmlsdGVycyA9IFtdO1xuICAgIHZhciBmaWx0ZXJNYW5hZ2VyO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBmaWx0ZXJNYW5hZ2VyID0gbnVsbDtcbiAgICAgIHZhciB0eXBlID0gZWxlbS5kYXRhLmVmW2ldLnR5O1xuXG4gICAgICBpZiAocmVnaXN0ZXJlZEVmZmVjdHNbdHlwZV0pIHtcbiAgICAgICAgdmFyIEVmZmVjdCA9IHJlZ2lzdGVyZWRFZmZlY3RzW3R5cGVdLmVmZmVjdDtcbiAgICAgICAgZmlsdGVyTWFuYWdlciA9IG5ldyBFZmZlY3QoZWxlbS5lZmZlY3RzTWFuYWdlci5lZmZlY3RFbGVtZW50c1tpXSwgZWxlbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWx0ZXJNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuZmlsdGVycy5wdXNoKGZpbHRlck1hbmFnZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICBlbGVtLmFkZFJlbmRlcmFibGVDb21wb25lbnQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgQ1ZFZmZlY3RzLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuZmlsdGVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuZmlsdGVyc1tpXS5yZW5kZXJGcmFtZShfaXNGaXJzdEZyYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgQ1ZFZmZlY3RzLnByb3RvdHlwZS5nZXRFZmZlY3RzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5maWx0ZXJzLmxlbmd0aDtcbiAgICB2YXIgZWZmZWN0cyA9IFtdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5maWx0ZXJzW2ldLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgZWZmZWN0cy5wdXNoKHRoaXMuZmlsdGVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVmZmVjdHM7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJFZmZlY3QoaWQsIGVmZmVjdCkge1xuICAgIHJlZ2lzdGVyZWRFZmZlY3RzW2lkXSA9IHtcbiAgICAgIGVmZmVjdDogZWZmZWN0XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIENWTWFza0VsZW1lbnQoZGF0YSwgZWxlbWVudCkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLm1hc2tzUHJvcGVydGllcyA9IHRoaXMuZGF0YS5tYXNrc1Byb3BlcnRpZXMgfHwgW107XG4gICAgdGhpcy52aWV3RGF0YSA9IGNyZWF0ZVNpemVkQXJyYXkodGhpcy5tYXNrc1Byb3BlcnRpZXMubGVuZ3RoKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5tYXNrc1Byb3BlcnRpZXMubGVuZ3RoO1xuICAgIHZhciBoYXNNYXNrcyA9IGZhbHNlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5tYXNrc1Byb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ24nKSB7XG4gICAgICAgIGhhc01hc2tzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy52aWV3RGF0YVtpXSA9IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcCh0aGlzLmVsZW1lbnQsIHRoaXMubWFza3NQcm9wZXJ0aWVzW2ldLCAzKTtcbiAgICB9XG5cbiAgICB0aGlzLmhhc01hc2tzID0gaGFzTWFza3M7XG5cbiAgICBpZiAoaGFzTWFza3MpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRSZW5kZXJhYmxlQ29tcG9uZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIENWTWFza0VsZW1lbnQucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5oYXNNYXNrcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLmVsZW1lbnQuZmluYWxUcmFuc2Zvcm0ubWF0O1xuICAgIHZhciBjdHggPSB0aGlzLmVsZW1lbnQuY2FudmFzQ29udGV4dDtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5tYXNrc1Byb3BlcnRpZXMubGVuZ3RoO1xuICAgIHZhciBwdDtcbiAgICB2YXIgcHRzO1xuICAgIHZhciBkYXRhO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMubWFza3NQcm9wZXJ0aWVzW2ldLm1vZGUgIT09ICduJykge1xuICAgICAgICBpZiAodGhpcy5tYXNrc1Byb3BlcnRpZXNbaV0uaW52KSB7XG4gICAgICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgICBjdHgubGluZVRvKHRoaXMuZWxlbWVudC5nbG9iYWxEYXRhLmNvbXBTaXplLncsIDApO1xuICAgICAgICAgIGN0eC5saW5lVG8odGhpcy5lbGVtZW50Lmdsb2JhbERhdGEuY29tcFNpemUudywgdGhpcy5lbGVtZW50Lmdsb2JhbERhdGEuY29tcFNpemUuaCk7XG4gICAgICAgICAgY3R4LmxpbmVUbygwLCB0aGlzLmVsZW1lbnQuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oKTtcbiAgICAgICAgICBjdHgubGluZVRvKDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YSA9IHRoaXMudmlld0RhdGFbaV0udjtcbiAgICAgICAgcHQgPSB0cmFuc2Zvcm0uYXBwbHlUb1BvaW50QXJyYXkoZGF0YS52WzBdWzBdLCBkYXRhLnZbMF1bMV0sIDApO1xuICAgICAgICBjdHgubW92ZVRvKHB0WzBdLCBwdFsxXSk7XG4gICAgICAgIHZhciBqO1xuICAgICAgICB2YXIgakxlbiA9IGRhdGEuX2xlbmd0aDtcblxuICAgICAgICBmb3IgKGogPSAxOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgcHRzID0gdHJhbnNmb3JtLmFwcGx5VG9UcmlwbGVQb2ludHMoZGF0YS5vW2ogLSAxXSwgZGF0YS5pW2pdLCBkYXRhLnZbal0pO1xuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHB0c1swXSwgcHRzWzFdLCBwdHNbMl0sIHB0c1szXSwgcHRzWzRdLCBwdHNbNV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcHRzID0gdHJhbnNmb3JtLmFwcGx5VG9UcmlwbGVQb2ludHMoZGF0YS5vW2ogLSAxXSwgZGF0YS5pWzBdLCBkYXRhLnZbMF0pO1xuICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhwdHNbMF0sIHB0c1sxXSwgcHRzWzJdLCBwdHNbM10sIHB0c1s0XSwgcHRzWzVdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQuZ2xvYmFsRGF0YS5yZW5kZXJlci5zYXZlKHRydWUpO1xuICAgIGN0eC5jbGlwKCk7XG4gIH07XG5cbiAgQ1ZNYXNrRWxlbWVudC5wcm90b3R5cGUuZ2V0TWFza1Byb3BlcnR5ID0gTWFza0VsZW1lbnQucHJvdG90eXBlLmdldE1hc2tQcm9wZXJ0eTtcblxuICBDVk1hc2tFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gIH07XG5cbiAgZnVuY3Rpb24gQ1ZCYXNlRWxlbWVudCgpIHt9XG5cbiAgdmFyIG9wZXJhdGlvbnNNYXAgPSB7XG4gICAgMTogJ3NvdXJjZS1pbicsXG4gICAgMjogJ3NvdXJjZS1vdXQnLFxuICAgIDM6ICdzb3VyY2UtaW4nLFxuICAgIDQ6ICdzb3VyY2Utb3V0J1xuICB9O1xuICBDVkJhc2VFbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgICBjcmVhdGVFbGVtZW50czogZnVuY3Rpb24gY3JlYXRlRWxlbWVudHMoKSB7fSxcbiAgICBpbml0UmVuZGVyZXJFbGVtZW50OiBmdW5jdGlvbiBpbml0UmVuZGVyZXJFbGVtZW50KCkge30sXG4gICAgY3JlYXRlQ29udGFpbmVyRWxlbWVudHM6IGZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzKCkge1xuICAgICAgLy8gSWYgdGhlIGxheWVyIGlzIG1hc2tlZCB3ZSB3aWxsIHVzZSB0d28gYnVmZmVycyB0byBzdG9yZSBlYWNoIGRpZmZlcmVudCBzdGF0ZXMgb2YgdGhlIGRyYXdpbmdcbiAgICAgIC8vIFRoaXMgc29sdXRpb24gaXMgbm90IGlkZWFsIGZvciBzZXZlcmFsIHJlYXNvbi4gQnV0IHVuZm9ydHVuYXRlbHksIGJlY2F1c2Ugb2YgdGhlIHJlY3Vyc2l2ZVxuICAgICAgLy8gbmF0dXJlIG9mIHRoZSByZW5kZXIgdHJlZSwgaXQncyB0aGUgb25seSBzaW1wbGUgd2F5IHRvIG1ha2Ugc3VyZSBvbmUgaW5uZXIgbWFzayBkb2Vzbid0IG92ZXJyaWRlIGFuIG91dGVyIG1hc2suXG4gICAgICAvLyBUT0RPOiB0cnkgdG8gcmVkdWNlIHRoZSBzaXplIG9mIHRoZXNlIGJ1ZmZlcnMgdG8gdGhlIHNpemUgb2YgdGhlIGNvbXBvc2l0aW9uIGNvbnRhbmluZyB0aGUgbGF5ZXJcbiAgICAgIC8vIEl0IG1pZ2h0IGJlIGNoYWxsZW5naW5nIGJlY2F1c2UgdGhlIGxheWVyIG1vc3QgbGlrZWx5IGlzIHRyYW5zZm9ybWVkIGluIHNvbWUgd2F5XG4gICAgICBpZiAodGhpcy5kYXRhLnR0ID49IDEpIHtcbiAgICAgICAgdGhpcy5idWZmZXJzID0gW107XG4gICAgICAgIHZhciBjYW52YXNDb250ZXh0ID0gdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQ7XG4gICAgICAgIHZhciBidWZmZXJDYW52YXMgPSBhc3NldExvYWRlci5jcmVhdGVDYW52YXMoY2FudmFzQ29udGV4dC5jYW52YXMud2lkdGgsIGNhbnZhc0NvbnRleHQuY2FudmFzLmhlaWdodCk7XG4gICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGJ1ZmZlckNhbnZhcyk7XG4gICAgICAgIHZhciBidWZmZXJDYW52YXMyID0gYXNzZXRMb2FkZXIuY3JlYXRlQ2FudmFzKGNhbnZhc0NvbnRleHQuY2FudmFzLndpZHRoLCBjYW52YXNDb250ZXh0LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChidWZmZXJDYW52YXMyKTtcblxuICAgICAgICBpZiAodGhpcy5kYXRhLnR0ID49IDMgJiYgIWRvY3VtZW50Ll9pc1Byb3h5KSB7XG4gICAgICAgICAgYXNzZXRMb2FkZXIubG9hZEx1bWFDYW52YXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQgPSB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dDtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzID0gdGhpcy5nbG9iYWxEYXRhLnRyYW5zZm9ybUNhbnZhcztcbiAgICAgIHRoaXMucmVuZGVyYWJsZUVmZmVjdHNNYW5hZ2VyID0gbmV3IENWRWZmZWN0cyh0aGlzKTtcbiAgICAgIHRoaXMuc2VhcmNoRWZmZWN0VHJhbnNmb3JtcygpO1xuICAgIH0sXG4gICAgY3JlYXRlQ29udGVudDogZnVuY3Rpb24gY3JlYXRlQ29udGVudCgpIHt9LFxuICAgIHNldEJsZW5kTW9kZTogZnVuY3Rpb24gc2V0QmxlbmRNb2RlKCkge1xuICAgICAgdmFyIGdsb2JhbERhdGEgPSB0aGlzLmdsb2JhbERhdGE7XG5cbiAgICAgIGlmIChnbG9iYWxEYXRhLmJsZW5kTW9kZSAhPT0gdGhpcy5kYXRhLmJtKSB7XG4gICAgICAgIGdsb2JhbERhdGEuYmxlbmRNb2RlID0gdGhpcy5kYXRhLmJtO1xuICAgICAgICB2YXIgYmxlbmRNb2RlVmFsdWUgPSBnZXRCbGVuZE1vZGUodGhpcy5kYXRhLmJtKTtcbiAgICAgICAgZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGJsZW5kTW9kZVZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHM6IGZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzKCkge1xuICAgICAgdGhpcy5tYXNrTWFuYWdlciA9IG5ldyBDVk1hc2tFbGVtZW50KHRoaXMuZGF0YSwgdGhpcyk7XG4gICAgICB0aGlzLnRyYW5zZm9ybUVmZmVjdHMgPSB0aGlzLnJlbmRlcmFibGVFZmZlY3RzTWFuYWdlci5nZXRFZmZlY3RzKGVmZmVjdFR5cGVzLlRSQU5TRk9STV9FRkZFQ1QpO1xuICAgIH0sXG4gICAgaGlkZUVsZW1lbnQ6IGZ1bmN0aW9uIGhpZGVFbGVtZW50KCkge1xuICAgICAgaWYgKCF0aGlzLmhpZGRlbiAmJiAoIXRoaXMuaXNJblJhbmdlIHx8IHRoaXMuaXNUcmFuc3BhcmVudCkpIHtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2hvd0VsZW1lbnQ6IGZ1bmN0aW9uIHNob3dFbGVtZW50KCkge1xuICAgICAgaWYgKHRoaXMuaXNJblJhbmdlICYmICF0aGlzLmlzVHJhbnNwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYXNrTWFuYWdlci5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsZWFyQ2FudmFzOiBmdW5jdGlvbiBjbGVhckNhbnZhcyhjYW52YXNDb250ZXh0KSB7XG4gICAgICBjYW52YXNDb250ZXh0LmNsZWFyUmVjdCh0aGlzLnRyYW5zZm9ybUNhbnZhcy50eCwgdGhpcy50cmFuc2Zvcm1DYW52YXMudHksIHRoaXMudHJhbnNmb3JtQ2FudmFzLncgKiB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeCwgdGhpcy50cmFuc2Zvcm1DYW52YXMuaCAqIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN5KTtcbiAgICB9LFxuICAgIHByZXBhcmVMYXllcjogZnVuY3Rpb24gcHJlcGFyZUxheWVyKCkge1xuICAgICAgaWYgKHRoaXMuZGF0YS50dCA+PSAxKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcnNbMF07XG4gICAgICAgIHZhciBidWZmZXJDdHggPSBidWZmZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdGhpcy5jbGVhckNhbnZhcyhidWZmZXJDdHgpOyAvLyBvbiB0aGUgZmlyc3QgYnVmZmVyIHdlIHN0b3JlIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBnbG9iYWwgZHJhd2luZ1xuXG4gICAgICAgIGJ1ZmZlckN0eC5kcmF3SW1hZ2UodGhpcy5jYW52YXNDb250ZXh0LmNhbnZhcywgMCwgMCk7IC8vIFRoZSBuZXh0IGZvdXIgbGluZXMgYXJlIHRvIGNsZWFyIHRoZSBjYW52YXNcbiAgICAgICAgLy8gVE9ETzogQ2hlY2sgaWYgdGhlcmUgaXMgYSB3YXkgdG8gY2xlYXIgdGhlIGNhbnZhcyB3aXRob3V0IHJlc2V0dGluZyB0aGUgdHJhbnNmb3JtXG5cbiAgICAgICAgdGhpcy5jdXJyZW50VHJhbnNmb3JtID0gdGhpcy5jYW52YXNDb250ZXh0LmdldFRyYW5zZm9ybSgpO1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICB0aGlzLmNsZWFyQ2FudmFzKHRoaXMuY2FudmFzQ29udGV4dCk7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5zZXRUcmFuc2Zvcm0odGhpcy5jdXJyZW50VHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4aXRMYXllcjogZnVuY3Rpb24gZXhpdExheWVyKCkge1xuICAgICAgaWYgKHRoaXMuZGF0YS50dCA+PSAxKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcnNbMV07IC8vIE9uIHRoZSBzZWNvbmQgYnVmZmVyIHdlIHN0b3JlIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBnbG9iYWwgZHJhd2luZ1xuICAgICAgICAvLyB0aGF0IG9ubHkgY29udGFpbnMgdGhlIGNvbnRlbnQgb2YgdGhpcyBsYXllclxuICAgICAgICAvLyAoaWYgaXQgaXMgYSBjb21wb3NpdGlvbiwgaXQgYWxzbyBpbmNsdWRlcyB0aGUgbmVzdGVkIGxheWVycylcblxuICAgICAgICB2YXIgYnVmZmVyQ3R4ID0gYnVmZmVyLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRoaXMuY2xlYXJDYW52YXMoYnVmZmVyQ3R4KTtcbiAgICAgICAgYnVmZmVyQ3R4LmRyYXdJbWFnZSh0aGlzLmNhbnZhc0NvbnRleHQuY2FudmFzLCAwLCAwKTsgLy8gV2UgY2xlYXIgdGhlIGNhbnZhcyBhZ2FpblxuXG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIHRoaXMuY2xlYXJDYW52YXModGhpcy5jYW52YXNDb250ZXh0KTtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnNldFRyYW5zZm9ybSh0aGlzLmN1cnJlbnRUcmFuc2Zvcm0pOyAvLyBXZSBkcmF3IHRoZSBtYXNrXG5cbiAgICAgICAgdmFyIG1hc2sgPSB0aGlzLmNvbXAuZ2V0RWxlbWVudEJ5SWQoJ3RwJyBpbiB0aGlzLmRhdGEgPyB0aGlzLmRhdGEudHAgOiB0aGlzLmRhdGEuaW5kIC0gMSk7XG4gICAgICAgIG1hc2sucmVuZGVyRnJhbWUodHJ1ZSk7IC8vIFdlIGRyYXcgdGhlIHNlY29uZCBidWZmZXIgKHRoYXQgY29udGFpbnMgdGhlIGNvbnRlbnQgb2YgdGhpcyBsYXllcilcblxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApOyAvLyBJZiB0aGUgbWFzayBpcyBhIEx1bWEgbWF0dGUsIHdlIG5lZWQgdG8gZG8gdHdvIGV4dHJhIHBhaW50aW5nIG9wZXJhdGlvbnNcbiAgICAgICAgLy8gdGhlIF9pc1Byb3h5IGNoZWNrIGlzIHRvIGF2b2lkIGRyYXdpbmcgYSBmYWtlIGNhbnZhcyBpbiB3b3JrZXJzIHRoYXQgd2lsbCB0aHJvdyBhbiBlcnJvclxuXG4gICAgICAgIGlmICh0aGlzLmRhdGEudHQgPj0gMyAmJiAhZG9jdW1lbnQuX2lzUHJveHkpIHtcbiAgICAgICAgICAvLyBXZSBjb3B5IHRoZSBwYWludGVkIG1hc2sgdG8gYSBidWZmZXIgdGhhdCBoYXMgYSBjb2xvciBtYXRyaXggZmlsdGVyIGFwcGxpZWQgdG8gaXRcbiAgICAgICAgICAvLyB0aGF0IGFwcGxpZXMgdGhlIHJnYiB2YWx1ZXMgdG8gdGhlIGFscGhhIGNoYW5uZWxcbiAgICAgICAgICB2YXIgbHVtYUJ1ZmZlciA9IGFzc2V0TG9hZGVyLmdldEx1bWFDYW52YXModGhpcy5jYW52YXNDb250ZXh0LmNhbnZhcyk7XG4gICAgICAgICAgdmFyIGx1bWFCdWZmZXJDdHggPSBsdW1hQnVmZmVyLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgbHVtYUJ1ZmZlckN0eC5kcmF3SW1hZ2UodGhpcy5jYW52YXNDb250ZXh0LmNhbnZhcywgMCwgMCk7XG4gICAgICAgICAgdGhpcy5jbGVhckNhbnZhcyh0aGlzLmNhbnZhc0NvbnRleHQpOyAvLyB3ZSByZXBhaW50IHRoZSBjb250ZXh0IHdpdGggdGhlIG1hc2sgYXBwbGllZCB0byBpdFxuXG4gICAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmRyYXdJbWFnZShsdW1hQnVmZmVyLCAwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBvcGVyYXRpb25zTWFwW3RoaXMuZGF0YS50dF07XG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5kcmF3SW1hZ2UoYnVmZmVyLCAwLCAwKTsgLy8gV2UgZmluYWxseSBkcmF3IHRoZSBmaXJzdCBidWZmZXIgKHRoYXQgY29udGFpbnMgdGhlIGNvbnRlbnQgb2YgdGhlIGdsb2JhbCBkcmF3aW5nKVxuICAgICAgICAvLyBXZSB1c2UgZGVzdGluYXRpb24tb3ZlciB0byBkcmF3IHRoZSBnbG9iYWwgZHJhd2luZyBiZWxvdyB0aGUgY3VycmVudCBsYXllclxuXG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3Zlcic7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5kcmF3SW1hZ2UodGhpcy5idWZmZXJzWzBdLCAwLCAwKTtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnNldFRyYW5zZm9ybSh0aGlzLmN1cnJlbnRUcmFuc2Zvcm0pOyAvLyBXZSByZXNldCB0aGUgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIHRvIHNvdXJjZS1vdmVyLCB0aGUgc3RhbmRhcmQgdHlwZSBvZiBvcGVyYXRpb25cblxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlckZyYW1lOiBmdW5jdGlvbiByZW5kZXJGcmFtZShmb3JjZVJlbmRlcikge1xuICAgICAgaWYgKHRoaXMuaGlkZGVuIHx8IHRoaXMuZGF0YS5oZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRhdGEudGQgPT09IDEgJiYgIWZvcmNlUmVuZGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJUcmFuc2Zvcm0oKTtcbiAgICAgIHRoaXMucmVuZGVyUmVuZGVyYWJsZSgpO1xuICAgICAgdGhpcy5yZW5kZXJMb2NhbFRyYW5zZm9ybSgpO1xuICAgICAgdGhpcy5zZXRCbGVuZE1vZGUoKTtcbiAgICAgIHZhciBmb3JjZVJlYWxTdGFjayA9IHRoaXMuZGF0YS50eSA9PT0gMDtcbiAgICAgIHRoaXMucHJlcGFyZUxheWVyKCk7XG4gICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuc2F2ZShmb3JjZVJlYWxTdGFjayk7XG4gICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuY3R4VHJhbnNmb3JtKHRoaXMuZmluYWxUcmFuc2Zvcm0ubG9jYWxNYXQucHJvcHMpO1xuICAgICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eE9wYWNpdHkodGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE9wYWNpdHkpO1xuICAgICAgdGhpcy5yZW5kZXJJbm5lckNvbnRlbnQoKTtcbiAgICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5yZXN0b3JlKGZvcmNlUmVhbFN0YWNrKTtcbiAgICAgIHRoaXMuZXhpdExheWVyKCk7XG5cbiAgICAgIGlmICh0aGlzLm1hc2tNYW5hZ2VyLmhhc01hc2tzKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5yZXN0b3JlKHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgICAgdGhpcy5nbG9iYWxEYXRhID0gbnVsbDtcbiAgICAgIHRoaXMubWFza01hbmFnZXIuZGVzdHJveSgpO1xuICAgIH0sXG4gICAgbUhlbHBlcjogbmV3IE1hdHJpeCgpXG4gIH07XG4gIENWQmFzZUVsZW1lbnQucHJvdG90eXBlLmhpZGUgPSBDVkJhc2VFbGVtZW50LnByb3RvdHlwZS5oaWRlRWxlbWVudDtcbiAgQ1ZCYXNlRWxlbWVudC5wcm90b3R5cGUuc2hvdyA9IENWQmFzZUVsZW1lbnQucHJvdG90eXBlLnNob3dFbGVtZW50O1xuXG4gIGZ1bmN0aW9uIENWU2hhcGVEYXRhKGVsZW1lbnQsIGRhdGEsIHN0eWxlcywgdHJhbnNmb3Jtc01hbmFnZXIpIHtcbiAgICB0aGlzLnN0eWxlZFNoYXBlcyA9IFtdO1xuICAgIHRoaXMudHIgPSBbMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgdmFyIHR5ID0gNDtcblxuICAgIGlmIChkYXRhLnR5ID09PSAncmMnKSB7XG4gICAgICB0eSA9IDU7XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5ID09PSAnZWwnKSB7XG4gICAgICB0eSA9IDY7XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5ID09PSAnc3InKSB7XG4gICAgICB0eSA9IDc7XG4gICAgfVxuXG4gICAgdGhpcy5zaCA9IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcChlbGVtZW50LCBkYXRhLCB0eSwgZWxlbWVudCk7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHN0eWxlcy5sZW5ndGg7XG4gICAgdmFyIHN0eWxlZFNoYXBlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAoIXN0eWxlc1tpXS5jbG9zZWQpIHtcbiAgICAgICAgc3R5bGVkU2hhcGUgPSB7XG4gICAgICAgICAgdHJhbnNmb3JtczogdHJhbnNmb3Jtc01hbmFnZXIuYWRkVHJhbnNmb3JtU2VxdWVuY2Uoc3R5bGVzW2ldLnRyYW5zZm9ybXMpLFxuICAgICAgICAgIHRyTm9kZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3R5bGVkU2hhcGVzLnB1c2goc3R5bGVkU2hhcGUpO1xuICAgICAgICBzdHlsZXNbaV0uZWxlbWVudHMucHVzaChzdHlsZWRTaGFwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgQ1ZTaGFwZURhdGEucHJvdG90eXBlLnNldEFzQW5pbWF0ZWQgPSBTVkdTaGFwZURhdGEucHJvdG90eXBlLnNldEFzQW5pbWF0ZWQ7XG5cbiAgZnVuY3Rpb24gQ1ZTaGFwZUVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMuc2hhcGVzID0gW107XG4gICAgdGhpcy5zaGFwZXNEYXRhID0gZGF0YS5zaGFwZXM7XG4gICAgdGhpcy5zdHlsZXNMaXN0ID0gW107XG4gICAgdGhpcy5pdGVtc0RhdGEgPSBbXTtcbiAgICB0aGlzLnByZXZWaWV3RGF0YSA9IFtdO1xuICAgIHRoaXMuc2hhcGVNb2RpZmllcnMgPSBbXTtcbiAgICB0aGlzLnByb2Nlc3NlZEVsZW1lbnRzID0gW107XG4gICAgdGhpcy50cmFuc2Zvcm1zTWFuYWdlciA9IG5ldyBTaGFwZVRyYW5zZm9ybU1hbmFnZXIoKTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgQ1ZCYXNlRWxlbWVudCwgSVNoYXBlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRWxlbWVudF0sIENWU2hhcGVFbGVtZW50KTtcbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmluaXRFbGVtZW50ID0gUmVuZGVyYWJsZURPTUVsZW1lbnQucHJvdG90eXBlLmluaXRFbGVtZW50O1xuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUudHJhbnNmb3JtSGVscGVyID0ge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgX29wTWRmOiBmYWxzZVxuICB9O1xuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuZGFzaFJlc2V0dGVyID0gW107XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZWFyY2hTaGFwZXModGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdGhpcy5wcmV2Vmlld0RhdGEsIHRydWUsIFtdKTtcbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlU3R5bGVFbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEsIHRyYW5zZm9ybXMpIHtcbiAgICB2YXIgc3R5bGVFbGVtID0ge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIHR5cGU6IGRhdGEudHksXG4gICAgICBwcmVUcmFuc2Zvcm1zOiB0aGlzLnRyYW5zZm9ybXNNYW5hZ2VyLmFkZFRyYW5zZm9ybVNlcXVlbmNlKHRyYW5zZm9ybXMpLFxuICAgICAgdHJhbnNmb3JtczogW10sXG4gICAgICBlbGVtZW50czogW10sXG4gICAgICBjbG9zZWQ6IGRhdGEuaGQgPT09IHRydWVcbiAgICB9O1xuICAgIHZhciBlbGVtZW50RGF0YSA9IHt9O1xuXG4gICAgaWYgKGRhdGEudHkgPT09ICdmbCcgfHwgZGF0YS50eSA9PT0gJ3N0Jykge1xuICAgICAgZWxlbWVudERhdGEuYyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEuYywgMSwgMjU1LCB0aGlzKTtcblxuICAgICAgaWYgKCFlbGVtZW50RGF0YS5jLmspIHtcbiAgICAgICAgc3R5bGVFbGVtLmNvID0gJ3JnYignICsgYm1GbG9vcihlbGVtZW50RGF0YS5jLnZbMF0pICsgJywnICsgYm1GbG9vcihlbGVtZW50RGF0YS5jLnZbMV0pICsgJywnICsgYm1GbG9vcihlbGVtZW50RGF0YS5jLnZbMl0pICsgJyknO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGF0YS50eSA9PT0gJ2dmJyB8fCBkYXRhLnR5ID09PSAnZ3MnKSB7XG4gICAgICBlbGVtZW50RGF0YS5zID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS5zLCAxLCBudWxsLCB0aGlzKTtcbiAgICAgIGVsZW1lbnREYXRhLmUgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLmUsIDEsIG51bGwsIHRoaXMpO1xuICAgICAgZWxlbWVudERhdGEuaCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEuaCB8fCB7XG4gICAgICAgIGs6IDBcbiAgICAgIH0sIDAsIDAuMDEsIHRoaXMpO1xuICAgICAgZWxlbWVudERhdGEuYSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEuYSB8fCB7XG4gICAgICAgIGs6IDBcbiAgICAgIH0sIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgICBlbGVtZW50RGF0YS5nID0gbmV3IEdyYWRpZW50UHJvcGVydHkodGhpcywgZGF0YS5nLCB0aGlzKTtcbiAgICB9XG5cbiAgICBlbGVtZW50RGF0YS5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS5vLCAwLCAwLjAxLCB0aGlzKTtcblxuICAgIGlmIChkYXRhLnR5ID09PSAnc3QnIHx8IGRhdGEudHkgPT09ICdncycpIHtcbiAgICAgIHN0eWxlRWxlbS5sYyA9IGxpbmVDYXBFbnVtW2RhdGEubGMgfHwgMl07XG4gICAgICBzdHlsZUVsZW0ubGogPSBsaW5lSm9pbkVudW1bZGF0YS5saiB8fCAyXTtcblxuICAgICAgaWYgKGRhdGEubGogPT0gMSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgICBzdHlsZUVsZW0ubWwgPSBkYXRhLm1sO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50RGF0YS53ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS53LCAwLCBudWxsLCB0aGlzKTtcblxuICAgICAgaWYgKCFlbGVtZW50RGF0YS53LmspIHtcbiAgICAgICAgc3R5bGVFbGVtLndpID0gZWxlbWVudERhdGEudy52O1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5kKSB7XG4gICAgICAgIHZhciBkID0gbmV3IERhc2hQcm9wZXJ0eSh0aGlzLCBkYXRhLmQsICdjYW52YXMnLCB0aGlzKTtcbiAgICAgICAgZWxlbWVudERhdGEuZCA9IGQ7XG5cbiAgICAgICAgaWYgKCFlbGVtZW50RGF0YS5kLmspIHtcbiAgICAgICAgICBzdHlsZUVsZW0uZGEgPSBlbGVtZW50RGF0YS5kLmRhc2hBcnJheTtcbiAgICAgICAgICBzdHlsZUVsZW1bXCJkb1wiXSA9IGVsZW1lbnREYXRhLmQuZGFzaG9mZnNldFswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZUVsZW0uciA9IGRhdGEuciA9PT0gMiA/ICdldmVub2RkJyA6ICdub256ZXJvJztcbiAgICB9XG5cbiAgICB0aGlzLnN0eWxlc0xpc3QucHVzaChzdHlsZUVsZW0pO1xuICAgIGVsZW1lbnREYXRhLnN0eWxlID0gc3R5bGVFbGVtO1xuICAgIHJldHVybiBlbGVtZW50RGF0YTtcbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlR3JvdXBFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGVtZW50RGF0YSA9IHtcbiAgICAgIGl0OiBbXSxcbiAgICAgIHByZXZWaWV3RGF0YTogW11cbiAgICB9O1xuICAgIHJldHVybiBlbGVtZW50RGF0YTtcbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlVHJhbnNmb3JtRWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGVsZW1lbnREYXRhID0ge1xuICAgICAgdHJhbnNmb3JtOiB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIF9vcE1kZjogZmFsc2UsXG4gICAgICAgIGtleTogdGhpcy50cmFuc2Zvcm1zTWFuYWdlci5nZXROZXdLZXkoKSxcbiAgICAgICAgb3A6IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEubywgMCwgMC4wMSwgdGhpcyksXG4gICAgICAgIG1Qcm9wczogVHJhbnNmb3JtUHJvcGVydHlGYWN0b3J5LmdldFRyYW5zZm9ybVByb3BlcnR5KHRoaXMsIGRhdGEsIHRoaXMpXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVNoYXBlRWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGVsZW1lbnREYXRhID0gbmV3IENWU2hhcGVEYXRhKHRoaXMsIGRhdGEsIHRoaXMuc3R5bGVzTGlzdCwgdGhpcy50cmFuc2Zvcm1zTWFuYWdlcik7XG4gICAgdGhpcy5zaGFwZXMucHVzaChlbGVtZW50RGF0YSk7XG4gICAgdGhpcy5hZGRTaGFwZVRvTW9kaWZpZXJzKGVsZW1lbnREYXRhKTtcbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbG9hZFNoYXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLml0ZW1zRGF0YS5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMucHJldlZpZXdEYXRhW2ldID0gdGhpcy5pdGVtc0RhdGFbaV07XG4gICAgfVxuXG4gICAgdGhpcy5zZWFyY2hTaGFwZXModGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdGhpcy5wcmV2Vmlld0RhdGEsIHRydWUsIFtdKTtcbiAgICBsZW4gPSB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllc1tpXS5nZXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyTW9kaWZpZXJzKCk7XG4gICAgdGhpcy50cmFuc2Zvcm1zTWFuYWdlci5wcm9jZXNzU2VxdWVuY2VzKHRoaXMuX2lzRmlyc3RGcmFtZSk7XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmFkZFRyYW5zZm9ybVRvU3R5bGVMaXN0ID0gZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAoIXRoaXMuc3R5bGVzTGlzdFtpXS5jbG9zZWQpIHtcbiAgICAgICAgdGhpcy5zdHlsZXNMaXN0W2ldLnRyYW5zZm9ybXMucHVzaCh0cmFuc2Zvcm0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlVHJhbnNmb3JtRnJvbVN0eWxlTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlc0xpc3RbaV0uY2xvc2VkKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS50cmFuc2Zvcm1zLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuY2xvc2VTdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHN0eWxlcy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHN0eWxlc1tpXS5jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuc2VhcmNoU2hhcGVzID0gZnVuY3Rpb24gKGFyciwgaXRlbXNEYXRhLCBwcmV2Vmlld0RhdGEsIHNob3VsZFJlbmRlciwgdHJhbnNmb3Jtcykge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoIC0gMTtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgb3duU3R5bGVzID0gW107XG4gICAgdmFyIG93bk1vZGlmaWVycyA9IFtdO1xuICAgIHZhciBwcm9jZXNzZWRQb3M7XG4gICAgdmFyIG1vZGlmaWVyO1xuICAgIHZhciBjdXJyZW50VHJhbnNmb3JtO1xuICAgIHZhciBvd25UcmFuc2Zvcm1zID0gW10uY29uY2F0KHRyYW5zZm9ybXMpO1xuXG4gICAgZm9yIChpID0gbGVuOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgcHJvY2Vzc2VkUG9zID0gdGhpcy5zZWFyY2hQcm9jZXNzZWRFbGVtZW50KGFycltpXSk7XG5cbiAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgIGFycltpXS5fc2hvdWxkUmVuZGVyID0gc2hvdWxkUmVuZGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbXNEYXRhW2ldID0gcHJldlZpZXdEYXRhW3Byb2Nlc3NlZFBvcyAtIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJyW2ldLnR5ID09PSAnZmwnIHx8IGFycltpXS50eSA9PT0gJ3N0JyB8fCBhcnJbaV0udHkgPT09ICdnZicgfHwgYXJyW2ldLnR5ID09PSAnZ3MnKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVTdHlsZUVsZW1lbnQoYXJyW2ldLCBvd25UcmFuc2Zvcm1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0uc3R5bGUuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBvd25TdHlsZXMucHVzaChpdGVtc0RhdGFbaV0uc3R5bGUpO1xuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdncicpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSB0aGlzLmNyZWF0ZUdyb3VwRWxlbWVudChhcnJbaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGpMZW4gPSBpdGVtc0RhdGFbaV0uaXQubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgaXRlbXNEYXRhW2ldLnByZXZWaWV3RGF0YVtqXSA9IGl0ZW1zRGF0YVtpXS5pdFtqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlYXJjaFNoYXBlcyhhcnJbaV0uaXQsIGl0ZW1zRGF0YVtpXS5pdCwgaXRlbXNEYXRhW2ldLnByZXZWaWV3RGF0YSwgc2hvdWxkUmVuZGVyLCBvd25UcmFuc2Zvcm1zKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAndHInKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgY3VycmVudFRyYW5zZm9ybSA9IHRoaXMuY3JlYXRlVHJhbnNmb3JtRWxlbWVudChhcnJbaV0pO1xuICAgICAgICAgIGl0ZW1zRGF0YVtpXSA9IGN1cnJlbnRUcmFuc2Zvcm07XG4gICAgICAgIH1cblxuICAgICAgICBvd25UcmFuc2Zvcm1zLnB1c2goaXRlbXNEYXRhW2ldKTtcbiAgICAgICAgdGhpcy5hZGRUcmFuc2Zvcm1Ub1N0eWxlTGlzdChpdGVtc0RhdGFbaV0pO1xuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdzaCcgfHwgYXJyW2ldLnR5ID09PSAncmMnIHx8IGFycltpXS50eSA9PT0gJ2VsJyB8fCBhcnJbaV0udHkgPT09ICdzcicpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSB0aGlzLmNyZWF0ZVNoYXBlRWxlbWVudChhcnJbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ3RtJyB8fCBhcnJbaV0udHkgPT09ICdyZCcgfHwgYXJyW2ldLnR5ID09PSAncGInIHx8IGFycltpXS50eSA9PT0gJ3p6JyB8fCBhcnJbaV0udHkgPT09ICdvcCcpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBtb2RpZmllciA9IFNoYXBlTW9kaWZpZXJzLmdldE1vZGlmaWVyKGFycltpXS50eSk7XG4gICAgICAgICAgbW9kaWZpZXIuaW5pdCh0aGlzLCBhcnJbaV0pO1xuICAgICAgICAgIGl0ZW1zRGF0YVtpXSA9IG1vZGlmaWVyO1xuICAgICAgICAgIHRoaXMuc2hhcGVNb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kaWZpZXIgPSBpdGVtc0RhdGFbaV07XG4gICAgICAgICAgbW9kaWZpZXIuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBvd25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ3JwJykge1xuICAgICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICAgIG1vZGlmaWVyID0gU2hhcGVNb2RpZmllcnMuZ2V0TW9kaWZpZXIoYXJyW2ldLnR5KTtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSBtb2RpZmllcjtcbiAgICAgICAgICBtb2RpZmllci5pbml0KHRoaXMsIGFyciwgaSwgaXRlbXNEYXRhKTtcbiAgICAgICAgICB0aGlzLnNoYXBlTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICAgIHNob3VsZFJlbmRlciA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGlmaWVyID0gaXRlbXNEYXRhW2ldO1xuICAgICAgICAgIG1vZGlmaWVyLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBvd25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWRkUHJvY2Vzc2VkRWxlbWVudChhcnJbaV0sIGkgKyAxKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZVRyYW5zZm9ybUZyb21TdHlsZUxpc3QoKTtcbiAgICB0aGlzLmNsb3NlU3R5bGVzKG93blN0eWxlcyk7XG4gICAgbGVuID0gb3duTW9kaWZpZXJzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgb3duTW9kaWZpZXJzW2ldLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmFuc2Zvcm1IZWxwZXIub3BhY2l0eSA9IDE7XG4gICAgdGhpcy50cmFuc2Zvcm1IZWxwZXIuX29wTWRmID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJNb2RpZmllcnMoKTtcbiAgICB0aGlzLnRyYW5zZm9ybXNNYW5hZ2VyLnByb2Nlc3NTZXF1ZW5jZXModGhpcy5faXNGaXJzdEZyYW1lKTtcbiAgICB0aGlzLnJlbmRlclNoYXBlKHRoaXMudHJhbnNmb3JtSGVscGVyLCB0aGlzLnNoYXBlc0RhdGEsIHRoaXMuaXRlbXNEYXRhLCB0cnVlKTtcbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyU2hhcGVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAocGFyZW50VHJhbnNmb3JtLCBncm91cFRyYW5zZm9ybSkge1xuICAgIGlmIChwYXJlbnRUcmFuc2Zvcm0uX29wTWRmIHx8IGdyb3VwVHJhbnNmb3JtLm9wLl9tZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKSB7XG4gICAgICBncm91cFRyYW5zZm9ybS5vcGFjaXR5ID0gcGFyZW50VHJhbnNmb3JtLm9wYWNpdHk7XG4gICAgICBncm91cFRyYW5zZm9ybS5vcGFjaXR5ICo9IGdyb3VwVHJhbnNmb3JtLm9wLnY7XG4gICAgICBncm91cFRyYW5zZm9ybS5fb3BNZGYgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuZHJhd0xheWVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBrO1xuICAgIHZhciBrTGVuO1xuICAgIHZhciBlbGVtcztcbiAgICB2YXIgbm9kZXM7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyO1xuICAgIHZhciBjdHggPSB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dDtcbiAgICB2YXIgdHlwZTtcbiAgICB2YXIgY3VycmVudFN0eWxlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjdXJyZW50U3R5bGUgPSB0aGlzLnN0eWxlc0xpc3RbaV07XG4gICAgICB0eXBlID0gY3VycmVudFN0eWxlLnR5cGU7IC8vIFNraXBwaW5nIHN0eWxlIHdoZW5cbiAgICAgIC8vIFN0cm9rZSB3aWR0aCBlcXVhbHMgMFxuICAgICAgLy8gc3R5bGUgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCAoZXh0cmEgdW51c2VkIHJlcGVhdGVycylcbiAgICAgIC8vIGN1cnJlbnQgb3BhY2l0eSBlcXVhbHMgMFxuICAgICAgLy8gZ2xvYmFsIG9wYWNpdHkgZXF1YWxzIDBcblxuICAgICAgaWYgKCEoKHR5cGUgPT09ICdzdCcgfHwgdHlwZSA9PT0gJ2dzJykgJiYgY3VycmVudFN0eWxlLndpID09PSAwIHx8ICFjdXJyZW50U3R5bGUuZGF0YS5fc2hvdWxkUmVuZGVyIHx8IGN1cnJlbnRTdHlsZS5jb09wID09PSAwIHx8IHRoaXMuZ2xvYmFsRGF0YS5jdXJyZW50R2xvYmFsQWxwaGEgPT09IDApKSB7XG4gICAgICAgIHJlbmRlcmVyLnNhdmUoKTtcbiAgICAgICAgZWxlbXMgPSBjdXJyZW50U3R5bGUuZWxlbWVudHM7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdCcgfHwgdHlwZSA9PT0gJ2dzJykge1xuICAgICAgICAgIHJlbmRlcmVyLmN0eFN0cm9rZVN0eWxlKHR5cGUgPT09ICdzdCcgPyBjdXJyZW50U3R5bGUuY28gOiBjdXJyZW50U3R5bGUuZ3JkKTsgLy8gY3R4LnN0cm9rZVN0eWxlID0gdHlwZSA9PT0gJ3N0JyA/IGN1cnJlbnRTdHlsZS5jbyA6IGN1cnJlbnRTdHlsZS5ncmQ7XG5cbiAgICAgICAgICByZW5kZXJlci5jdHhMaW5lV2lkdGgoY3VycmVudFN0eWxlLndpKTsgLy8gY3R4LmxpbmVXaWR0aCA9IGN1cnJlbnRTdHlsZS53aTtcblxuICAgICAgICAgIHJlbmRlcmVyLmN0eExpbmVDYXAoY3VycmVudFN0eWxlLmxjKTsgLy8gY3R4LmxpbmVDYXAgPSBjdXJyZW50U3R5bGUubGM7XG5cbiAgICAgICAgICByZW5kZXJlci5jdHhMaW5lSm9pbihjdXJyZW50U3R5bGUubGopOyAvLyBjdHgubGluZUpvaW4gPSBjdXJyZW50U3R5bGUubGo7XG5cbiAgICAgICAgICByZW5kZXJlci5jdHhNaXRlckxpbWl0KGN1cnJlbnRTdHlsZS5tbCB8fCAwKTsgLy8gY3R4Lm1pdGVyTGltaXQgPSBjdXJyZW50U3R5bGUubWwgfHwgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW5kZXJlci5jdHhGaWxsU3R5bGUodHlwZSA9PT0gJ2ZsJyA/IGN1cnJlbnRTdHlsZS5jbyA6IGN1cnJlbnRTdHlsZS5ncmQpOyAvLyBjdHguZmlsbFN0eWxlID0gdHlwZSA9PT0gJ2ZsJyA/IGN1cnJlbnRTdHlsZS5jbyA6IGN1cnJlbnRTdHlsZS5ncmQ7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlci5jdHhPcGFjaXR5KGN1cnJlbnRTdHlsZS5jb09wKTtcblxuICAgICAgICBpZiAodHlwZSAhPT0gJ3N0JyAmJiB0eXBlICE9PSAnZ3MnKSB7XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIuY3R4VHJhbnNmb3JtKGN1cnJlbnRTdHlsZS5wcmVUcmFuc2Zvcm1zLmZpbmFsVHJhbnNmb3JtLnByb3BzKTtcbiAgICAgICAgakxlbiA9IGVsZW1zLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdzdCcgfHwgdHlwZSA9PT0gJ2dzJykge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFN0eWxlLmRhKSB7XG4gICAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChjdXJyZW50U3R5bGUuZGEpO1xuICAgICAgICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBjdXJyZW50U3R5bGVbXCJkb1wiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub2RlcyA9IGVsZW1zW2pdLnRyTm9kZXM7XG4gICAgICAgICAga0xlbiA9IG5vZGVzLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBrTGVuOyBrICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChub2Rlc1trXS50ID09PSAnbScpIHtcbiAgICAgICAgICAgICAgY3R4Lm1vdmVUbyhub2Rlc1trXS5wWzBdLCBub2Rlc1trXS5wWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZXNba10udCA9PT0gJ2MnKSB7XG4gICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKG5vZGVzW2tdLnB0c1swXSwgbm9kZXNba10ucHRzWzFdLCBub2Rlc1trXS5wdHNbMl0sIG5vZGVzW2tdLnB0c1szXSwgbm9kZXNba10ucHRzWzRdLCBub2Rlc1trXS5wdHNbNV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlID09PSAnc3QnIHx8IHR5cGUgPT09ICdncycpIHtcbiAgICAgICAgICAgIC8vIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmN0eFN0cm9rZSgpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFN0eWxlLmRhKSB7XG4gICAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaCh0aGlzLmRhc2hSZXNldHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgIT09ICdzdCcgJiYgdHlwZSAhPT0gJ2dzJykge1xuICAgICAgICAgIC8vIGN0eC5maWxsKGN1cnJlbnRTdHlsZS5yKTtcbiAgICAgICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuY3R4RmlsbChjdXJyZW50U3R5bGUucik7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJlci5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJTaGFwZSA9IGZ1bmN0aW9uIChwYXJlbnRUcmFuc2Zvcm0sIGl0ZW1zLCBkYXRhLCBpc01haW4pIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgZ3JvdXBUcmFuc2Zvcm07XG4gICAgZ3JvdXBUcmFuc2Zvcm0gPSBwYXJlbnRUcmFuc2Zvcm07XG5cbiAgICBmb3IgKGkgPSBsZW47IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICBpZiAoaXRlbXNbaV0udHkgPT09ICd0cicpIHtcbiAgICAgICAgZ3JvdXBUcmFuc2Zvcm0gPSBkYXRhW2ldLnRyYW5zZm9ybTtcbiAgICAgICAgdGhpcy5yZW5kZXJTaGFwZVRyYW5zZm9ybShwYXJlbnRUcmFuc2Zvcm0sIGdyb3VwVHJhbnNmb3JtKTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbXNbaV0udHkgPT09ICdzaCcgfHwgaXRlbXNbaV0udHkgPT09ICdlbCcgfHwgaXRlbXNbaV0udHkgPT09ICdyYycgfHwgaXRlbXNbaV0udHkgPT09ICdzcicpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJQYXRoKGl0ZW1zW2ldLCBkYXRhW2ldKTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbXNbaV0udHkgPT09ICdmbCcpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJGaWxsKGl0ZW1zW2ldLCBkYXRhW2ldLCBncm91cFRyYW5zZm9ybSk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1zW2ldLnR5ID09PSAnc3QnKSB7XG4gICAgICAgIHRoaXMucmVuZGVyU3Ryb2tlKGl0ZW1zW2ldLCBkYXRhW2ldLCBncm91cFRyYW5zZm9ybSk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1zW2ldLnR5ID09PSAnZ2YnIHx8IGl0ZW1zW2ldLnR5ID09PSAnZ3MnKSB7XG4gICAgICAgIHRoaXMucmVuZGVyR3JhZGllbnRGaWxsKGl0ZW1zW2ldLCBkYXRhW2ldLCBncm91cFRyYW5zZm9ybSk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1zW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgIHRoaXMucmVuZGVyU2hhcGUoZ3JvdXBUcmFuc2Zvcm0sIGl0ZW1zW2ldLml0LCBkYXRhW2ldLml0KTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbXNbaV0udHkgPT09ICd0bScpIHsvL1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc01haW4pIHtcbiAgICAgIHRoaXMuZHJhd0xheWVyKCk7XG4gICAgfVxuICB9O1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJTdHlsZWRTaGFwZSA9IGZ1bmN0aW9uIChzdHlsZWRTaGFwZSwgc2hhcGUpIHtcbiAgICBpZiAodGhpcy5faXNGaXJzdEZyYW1lIHx8IHNoYXBlLl9tZGYgfHwgc3R5bGVkU2hhcGUudHJhbnNmb3Jtcy5fbWRmKSB7XG4gICAgICB2YXIgc2hhcGVOb2RlcyA9IHN0eWxlZFNoYXBlLnRyTm9kZXM7XG4gICAgICB2YXIgcGF0aHMgPSBzaGFwZS5wYXRocztcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbjtcbiAgICAgIHZhciBqO1xuICAgICAgdmFyIGpMZW4gPSBwYXRocy5fbGVuZ3RoO1xuICAgICAgc2hhcGVOb2Rlcy5sZW5ndGggPSAwO1xuICAgICAgdmFyIGdyb3VwVHJhbnNmb3JtTWF0ID0gc3R5bGVkU2hhcGUudHJhbnNmb3Jtcy5maW5hbFRyYW5zZm9ybTtcblxuICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICB2YXIgcGF0aE5vZGVzID0gcGF0aHMuc2hhcGVzW2pdO1xuXG4gICAgICAgIGlmIChwYXRoTm9kZXMgJiYgcGF0aE5vZGVzLnYpIHtcbiAgICAgICAgICBsZW4gPSBwYXRoTm9kZXMuX2xlbmd0aDtcblxuICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgICAgICAgc2hhcGVOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0OiAnbScsXG4gICAgICAgICAgICAgICAgcDogZ3JvdXBUcmFuc2Zvcm1NYXQuYXBwbHlUb1BvaW50QXJyYXkocGF0aE5vZGVzLnZbMF1bMF0sIHBhdGhOb2Rlcy52WzBdWzFdLCAwKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2hhcGVOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdDogJ2MnLFxuICAgICAgICAgICAgICBwdHM6IGdyb3VwVHJhbnNmb3JtTWF0LmFwcGx5VG9UcmlwbGVQb2ludHMocGF0aE5vZGVzLm9baSAtIDFdLCBwYXRoTm9kZXMuaVtpXSwgcGF0aE5vZGVzLnZbaV0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICAgICAgICBzaGFwZU5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICB0OiAnbScsXG4gICAgICAgICAgICAgIHA6IGdyb3VwVHJhbnNmb3JtTWF0LmFwcGx5VG9Qb2ludEFycmF5KHBhdGhOb2Rlcy52WzBdWzBdLCBwYXRoTm9kZXMudlswXVsxXSwgMClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXRoTm9kZXMuYyAmJiBsZW4pIHtcbiAgICAgICAgICAgIHNoYXBlTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgIHQ6ICdjJyxcbiAgICAgICAgICAgICAgcHRzOiBncm91cFRyYW5zZm9ybU1hdC5hcHBseVRvVHJpcGxlUG9pbnRzKHBhdGhOb2Rlcy5vW2kgLSAxXSwgcGF0aE5vZGVzLmlbMF0sIHBhdGhOb2Rlcy52WzBdKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzaGFwZU5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICB0OiAneidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdHlsZWRTaGFwZS50ck5vZGVzID0gc2hhcGVOb2RlcztcbiAgICB9XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlclBhdGggPSBmdW5jdGlvbiAocGF0aERhdGEsIGl0ZW1EYXRhKSB7XG4gICAgaWYgKHBhdGhEYXRhLmhkICE9PSB0cnVlICYmIHBhdGhEYXRhLl9zaG91bGRSZW5kZXIpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IGl0ZW1EYXRhLnN0eWxlZFNoYXBlcy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB0aGlzLnJlbmRlclN0eWxlZFNoYXBlKGl0ZW1EYXRhLnN0eWxlZFNoYXBlc1tpXSwgaXRlbURhdGEuc2gpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyRmlsbCA9IGZ1bmN0aW9uIChzdHlsZURhdGEsIGl0ZW1EYXRhLCBncm91cFRyYW5zZm9ybSkge1xuICAgIHZhciBzdHlsZUVsZW0gPSBpdGVtRGF0YS5zdHlsZTtcblxuICAgIGlmIChpdGVtRGF0YS5jLl9tZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKSB7XG4gICAgICBzdHlsZUVsZW0uY28gPSAncmdiKCcgKyBibUZsb29yKGl0ZW1EYXRhLmMudlswXSkgKyAnLCcgKyBibUZsb29yKGl0ZW1EYXRhLmMudlsxXSkgKyAnLCcgKyBibUZsb29yKGl0ZW1EYXRhLmMudlsyXSkgKyAnKSc7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW1EYXRhLm8uX21kZiB8fCBncm91cFRyYW5zZm9ybS5fb3BNZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKSB7XG4gICAgICBzdHlsZUVsZW0uY29PcCA9IGl0ZW1EYXRhLm8udiAqIGdyb3VwVHJhbnNmb3JtLm9wYWNpdHk7XG4gICAgfVxuICB9O1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJHcmFkaWVudEZpbGwgPSBmdW5jdGlvbiAoc3R5bGVEYXRhLCBpdGVtRGF0YSwgZ3JvdXBUcmFuc2Zvcm0pIHtcbiAgICB2YXIgc3R5bGVFbGVtID0gaXRlbURhdGEuc3R5bGU7XG4gICAgdmFyIGdyZDtcblxuICAgIGlmICghc3R5bGVFbGVtLmdyZCB8fCBpdGVtRGF0YS5nLl9tZGYgfHwgaXRlbURhdGEucy5fbWRmIHx8IGl0ZW1EYXRhLmUuX21kZiB8fCBzdHlsZURhdGEudCAhPT0gMSAmJiAoaXRlbURhdGEuaC5fbWRmIHx8IGl0ZW1EYXRhLmEuX21kZikpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dDtcbiAgICAgIHZhciBwdDEgPSBpdGVtRGF0YS5zLnY7XG4gICAgICB2YXIgcHQyID0gaXRlbURhdGEuZS52O1xuXG4gICAgICBpZiAoc3R5bGVEYXRhLnQgPT09IDEpIHtcbiAgICAgICAgZ3JkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHB0MVswXSwgcHQxWzFdLCBwdDJbMF0sIHB0MlsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmFkID0gTWF0aC5zcXJ0KE1hdGgucG93KHB0MVswXSAtIHB0MlswXSwgMikgKyBNYXRoLnBvdyhwdDFbMV0gLSBwdDJbMV0sIDIpKTtcbiAgICAgICAgdmFyIGFuZyA9IE1hdGguYXRhbjIocHQyWzFdIC0gcHQxWzFdLCBwdDJbMF0gLSBwdDFbMF0pO1xuICAgICAgICB2YXIgcGVyY2VudCA9IGl0ZW1EYXRhLmgudjtcblxuICAgICAgICBpZiAocGVyY2VudCA+PSAxKSB7XG4gICAgICAgICAgcGVyY2VudCA9IDAuOTk7XG4gICAgICAgIH0gZWxzZSBpZiAocGVyY2VudCA8PSAtMSkge1xuICAgICAgICAgIHBlcmNlbnQgPSAtMC45OTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaXN0ID0gcmFkICogcGVyY2VudDtcbiAgICAgICAgdmFyIHggPSBNYXRoLmNvcyhhbmcgKyBpdGVtRGF0YS5hLnYpICogZGlzdCArIHB0MVswXTtcbiAgICAgICAgdmFyIHkgPSBNYXRoLnNpbihhbmcgKyBpdGVtRGF0YS5hLnYpICogZGlzdCArIHB0MVsxXTtcbiAgICAgICAgZ3JkID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHgsIHksIDAsIHB0MVswXSwgcHQxWzFdLCByYWQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBzdHlsZURhdGEuZy5wO1xuICAgICAgdmFyIGNWYWx1ZXMgPSBpdGVtRGF0YS5nLmM7XG4gICAgICB2YXIgb3BhY2l0eSA9IDE7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoaXRlbURhdGEuZy5faGFzT3BhY2l0eSAmJiBpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xuICAgICAgICAgIG9wYWNpdHkgPSBpdGVtRGF0YS5nLm9baSAqIDIgKyAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyZC5hZGRDb2xvclN0b3AoY1ZhbHVlc1tpICogNF0gLyAxMDAsICdyZ2JhKCcgKyBjVmFsdWVzW2kgKiA0ICsgMV0gKyAnLCcgKyBjVmFsdWVzW2kgKiA0ICsgMl0gKyAnLCcgKyBjVmFsdWVzW2kgKiA0ICsgM10gKyAnLCcgKyBvcGFjaXR5ICsgJyknKTtcbiAgICAgIH1cblxuICAgICAgc3R5bGVFbGVtLmdyZCA9IGdyZDtcbiAgICB9XG5cbiAgICBzdHlsZUVsZW0uY29PcCA9IGl0ZW1EYXRhLm8udiAqIGdyb3VwVHJhbnNmb3JtLm9wYWNpdHk7XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlclN0cm9rZSA9IGZ1bmN0aW9uIChzdHlsZURhdGEsIGl0ZW1EYXRhLCBncm91cFRyYW5zZm9ybSkge1xuICAgIHZhciBzdHlsZUVsZW0gPSBpdGVtRGF0YS5zdHlsZTtcbiAgICB2YXIgZCA9IGl0ZW1EYXRhLmQ7XG5cbiAgICBpZiAoZCAmJiAoZC5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSkpIHtcbiAgICAgIHN0eWxlRWxlbS5kYSA9IGQuZGFzaEFycmF5O1xuICAgICAgc3R5bGVFbGVtW1wiZG9cIl0gPSBkLmRhc2hvZmZzZXRbMF07XG4gICAgfVxuXG4gICAgaWYgKGl0ZW1EYXRhLmMuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHN0eWxlRWxlbS5jbyA9ICdyZ2IoJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzBdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzFdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzJdKSArICcpJztcbiAgICB9XG5cbiAgICBpZiAoaXRlbURhdGEuby5fbWRmIHx8IGdyb3VwVHJhbnNmb3JtLl9vcE1kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHN0eWxlRWxlbS5jb09wID0gaXRlbURhdGEuby52ICogZ3JvdXBUcmFuc2Zvcm0ub3BhY2l0eTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbURhdGEudy5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgc3R5bGVFbGVtLndpID0gaXRlbURhdGEudy52O1xuICAgIH1cbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNoYXBlc0RhdGEgPSBudWxsO1xuICAgIHRoaXMuZ2xvYmFsRGF0YSA9IG51bGw7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoID0gMDtcbiAgICB0aGlzLml0ZW1zRGF0YS5sZW5ndGggPSAwO1xuICB9O1xuXG4gIGZ1bmN0aW9uIENWVGV4dEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMudGV4dFNwYW5zID0gW107XG4gICAgdGhpcy55T2Zmc2V0ID0gMDtcbiAgICB0aGlzLmZpbGxDb2xvckFuaW0gPSBmYWxzZTtcbiAgICB0aGlzLnN0cm9rZUNvbG9yQW5pbSA9IGZhbHNlO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGhBbmltID0gZmFsc2U7XG4gICAgdGhpcy5zdHJva2UgPSBmYWxzZTtcbiAgICB0aGlzLmZpbGwgPSBmYWxzZTtcbiAgICB0aGlzLmp1c3RpZnlPZmZzZXQgPSAwO1xuICAgIHRoaXMuY3VycmVudFJlbmRlciA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJUeXBlID0gJ2NhbnZhcyc7XG4gICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICBmaWxsOiAncmdiYSgwLDAsMCwwKScsXG4gICAgICBzdHJva2U6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICAgIHNXaWR0aDogMCxcbiAgICAgIGZWYWx1ZTogJydcbiAgICB9O1xuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBDVkJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVFbGVtZW50LCBJVGV4dEVsZW1lbnRdLCBDVlRleHRFbGVtZW50KTtcbiAgQ1ZUZXh0RWxlbWVudC5wcm90b3R5cGUudEhlbHBlciA9IGNyZWF0ZVRhZygnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKTtcblxuICBDVlRleHRFbGVtZW50LnByb3RvdHlwZS5idWlsZE5ld1RleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRvY3VtZW50RGF0YSA9IHRoaXMudGV4dFByb3BlcnR5LmN1cnJlbnREYXRhO1xuICAgIHRoaXMucmVuZGVyZWRMZXR0ZXJzID0gY3JlYXRlU2l6ZWRBcnJheShkb2N1bWVudERhdGEubCA/IGRvY3VtZW50RGF0YS5sLmxlbmd0aCA6IDApO1xuICAgIHZhciBoYXNGaWxsID0gZmFsc2U7XG5cbiAgICBpZiAoZG9jdW1lbnREYXRhLmZjKSB7XG4gICAgICBoYXNGaWxsID0gdHJ1ZTtcbiAgICAgIHRoaXMudmFsdWVzLmZpbGwgPSB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLmZjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWx1ZXMuZmlsbCA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICB9XG5cbiAgICB0aGlzLmZpbGwgPSBoYXNGaWxsO1xuICAgIHZhciBoYXNTdHJva2UgPSBmYWxzZTtcblxuICAgIGlmIChkb2N1bWVudERhdGEuc2MpIHtcbiAgICAgIGhhc1N0cm9rZSA9IHRydWU7XG4gICAgICB0aGlzLnZhbHVlcy5zdHJva2UgPSB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLnNjKTtcbiAgICAgIHRoaXMudmFsdWVzLnNXaWR0aCA9IGRvY3VtZW50RGF0YS5zdztcbiAgICB9XG5cbiAgICB2YXIgZm9udERhdGEgPSB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZik7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcbiAgICB2YXIgbGV0dGVycyA9IGRvY3VtZW50RGF0YS5sO1xuICAgIHZhciBtYXRyaXhIZWxwZXIgPSB0aGlzLm1IZWxwZXI7XG4gICAgdGhpcy5zdHJva2UgPSBoYXNTdHJva2U7XG4gICAgdGhpcy52YWx1ZXMuZlZhbHVlID0gZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSArICdweCAnICsgdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpLmZGYW1pbHk7XG4gICAgbGVuID0gZG9jdW1lbnREYXRhLmZpbmFsVGV4dC5sZW5ndGg7IC8vIHRoaXMudEhlbHBlci5mb250ID0gdGhpcy52YWx1ZXMuZlZhbHVlO1xuXG4gICAgdmFyIGNoYXJEYXRhO1xuICAgIHZhciBzaGFwZURhdGE7XG4gICAgdmFyIGs7XG4gICAgdmFyIGtMZW47XG4gICAgdmFyIHNoYXBlcztcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgcGF0aE5vZGVzO1xuICAgIHZhciBjb21tYW5kcztcbiAgICB2YXIgcGF0aEFycjtcbiAgICB2YXIgc2luZ2xlU2hhcGUgPSB0aGlzLmRhdGEuc2luZ2xlU2hhcGU7XG4gICAgdmFyIHRyYWNraW5nT2Zmc2V0ID0gZG9jdW1lbnREYXRhLnRyICogMC4wMDEgKiBkb2N1bWVudERhdGEuZmluYWxTaXplO1xuICAgIHZhciB4UG9zID0gMDtcbiAgICB2YXIgeVBvcyA9IDA7XG4gICAgdmFyIGZpcnN0TGluZSA9IHRydWU7XG4gICAgdmFyIGNudCA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGNoYXJEYXRhID0gdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldENoYXJEYXRhKGRvY3VtZW50RGF0YS5maW5hbFRleHRbaV0sIGZvbnREYXRhLmZTdHlsZSwgdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpLmZGYW1pbHkpO1xuICAgICAgc2hhcGVEYXRhID0gY2hhckRhdGEgJiYgY2hhckRhdGEuZGF0YSB8fCB7fTtcbiAgICAgIG1hdHJpeEhlbHBlci5yZXNldCgpO1xuXG4gICAgICBpZiAoc2luZ2xlU2hhcGUgJiYgbGV0dGVyc1tpXS5uKSB7XG4gICAgICAgIHhQb3MgPSAtdHJhY2tpbmdPZmZzZXQ7XG4gICAgICAgIHlQb3MgKz0gZG9jdW1lbnREYXRhLnlPZmZzZXQ7XG4gICAgICAgIHlQb3MgKz0gZmlyc3RMaW5lID8gMSA6IDA7XG4gICAgICAgIGZpcnN0TGluZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBzaGFwZXMgPSBzaGFwZURhdGEuc2hhcGVzID8gc2hhcGVEYXRhLnNoYXBlc1swXS5pdCA6IFtdO1xuICAgICAgakxlbiA9IHNoYXBlcy5sZW5ndGg7XG4gICAgICBtYXRyaXhIZWxwZXIuc2NhbGUoZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMCwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMCk7XG5cbiAgICAgIGlmIChzaW5nbGVTaGFwZSkge1xuICAgICAgICB0aGlzLmFwcGx5VGV4dFByb3BlcnRpZXNUb01hdHJpeChkb2N1bWVudERhdGEsIG1hdHJpeEhlbHBlciwgbGV0dGVyc1tpXS5saW5lLCB4UG9zLCB5UG9zKTtcbiAgICAgIH1cblxuICAgICAgY29tbWFuZHMgPSBjcmVhdGVTaXplZEFycmF5KGpMZW4gLSAxKTtcbiAgICAgIHZhciBjb21tYW5kc0NvdW50ZXIgPSAwO1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgIGlmIChzaGFwZXNbal0udHkgPT09ICdzaCcpIHtcbiAgICAgICAgICBrTGVuID0gc2hhcGVzW2pdLmtzLmsuaS5sZW5ndGg7XG4gICAgICAgICAgcGF0aE5vZGVzID0gc2hhcGVzW2pdLmtzLms7XG4gICAgICAgICAgcGF0aEFyciA9IFtdO1xuXG4gICAgICAgICAgZm9yIChrID0gMTsgayA8IGtMZW47IGsgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGsgPT09IDEpIHtcbiAgICAgICAgICAgICAgcGF0aEFyci5wdXNoKG1hdHJpeEhlbHBlci5hcHBseVRvWChwYXRoTm9kZXMudlswXVswXSwgcGF0aE5vZGVzLnZbMF1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLnZbMF1bMF0sIHBhdGhOb2Rlcy52WzBdWzFdLCAwKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhdGhBcnIucHVzaChtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLm9bayAtIDFdWzBdLCBwYXRoTm9kZXMub1trIC0gMV1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLm9bayAtIDFdWzBdLCBwYXRoTm9kZXMub1trIC0gMV1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLmlba11bMF0sIHBhdGhOb2Rlcy5pW2tdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy5pW2tdWzBdLCBwYXRoTm9kZXMuaVtrXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWChwYXRoTm9kZXMudltrXVswXSwgcGF0aE5vZGVzLnZba11bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLnZba11bMF0sIHBhdGhOb2Rlcy52W2tdWzFdLCAwKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aEFyci5wdXNoKG1hdHJpeEhlbHBlci5hcHBseVRvWChwYXRoTm9kZXMub1trIC0gMV1bMF0sIHBhdGhOb2Rlcy5vW2sgLSAxXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWShwYXRoTm9kZXMub1trIC0gMV1bMF0sIHBhdGhOb2Rlcy5vW2sgLSAxXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWChwYXRoTm9kZXMuaVswXVswXSwgcGF0aE5vZGVzLmlbMF1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLmlbMF1bMF0sIHBhdGhOb2Rlcy5pWzBdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9YKHBhdGhOb2Rlcy52WzBdWzBdLCBwYXRoTm9kZXMudlswXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWShwYXRoTm9kZXMudlswXVswXSwgcGF0aE5vZGVzLnZbMF1bMV0sIDApKTtcbiAgICAgICAgICBjb21tYW5kc1tjb21tYW5kc0NvdW50ZXJdID0gcGF0aEFycjtcbiAgICAgICAgICBjb21tYW5kc0NvdW50ZXIgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2luZ2xlU2hhcGUpIHtcbiAgICAgICAgeFBvcyArPSBsZXR0ZXJzW2ldLmw7XG4gICAgICAgIHhQb3MgKz0gdHJhY2tpbmdPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRleHRTcGFuc1tjbnRdKSB7XG4gICAgICAgIHRoaXMudGV4dFNwYW5zW2NudF0uZWxlbSA9IGNvbW1hbmRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50ZXh0U3BhbnNbY250XSA9IHtcbiAgICAgICAgICBlbGVtOiBjb21tYW5kc1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjbnQgKz0gMTtcbiAgICB9XG4gIH07XG5cbiAgQ1ZUZXh0RWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudmFsaWRhdGVUZXh0KCk7XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzQ29udGV4dDtcbiAgICBjdHguZm9udCA9IHRoaXMudmFsdWVzLmZWYWx1ZTtcbiAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuY3R4TGluZUNhcCgnYnV0dCcpOyAvLyBjdHgubGluZUNhcCA9ICdidXR0JztcblxuICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5jdHhMaW5lSm9pbignbWl0ZXInKTsgLy8gY3R4LmxpbmVKb2luID0gJ21pdGVyJztcblxuICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5jdHhNaXRlckxpbWl0KDQpOyAvLyBjdHgubWl0ZXJMaW1pdCA9IDQ7XG5cbiAgICBpZiAoIXRoaXMuZGF0YS5zaW5nbGVTaGFwZSkge1xuICAgICAgdGhpcy50ZXh0QW5pbWF0b3IuZ2V0TWVhc3VyZXModGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEsIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnKTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBrO1xuICAgIHZhciBrTGVuO1xuICAgIHZhciByZW5kZXJlZExldHRlcnMgPSB0aGlzLnRleHRBbmltYXRvci5yZW5kZXJlZExldHRlcnM7XG4gICAgdmFyIGxldHRlcnMgPSB0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YS5sO1xuICAgIGxlbiA9IGxldHRlcnMubGVuZ3RoO1xuICAgIHZhciByZW5kZXJlZExldHRlcjtcbiAgICB2YXIgbGFzdEZpbGwgPSBudWxsO1xuICAgIHZhciBsYXN0U3Ryb2tlID0gbnVsbDtcbiAgICB2YXIgbGFzdFN0cm9rZVcgPSBudWxsO1xuICAgIHZhciBjb21tYW5kcztcbiAgICB2YXIgcGF0aEFycjtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICghbGV0dGVyc1tpXS5uKSB7XG4gICAgICAgIHJlbmRlcmVkTGV0dGVyID0gcmVuZGVyZWRMZXR0ZXJzW2ldO1xuXG4gICAgICAgIGlmIChyZW5kZXJlZExldHRlcikge1xuICAgICAgICAgIHJlbmRlcmVyLnNhdmUoKTtcbiAgICAgICAgICByZW5kZXJlci5jdHhUcmFuc2Zvcm0ocmVuZGVyZWRMZXR0ZXIucCk7XG4gICAgICAgICAgcmVuZGVyZXIuY3R4T3BhY2l0eShyZW5kZXJlZExldHRlci5vKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZpbGwpIHtcbiAgICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIgJiYgcmVuZGVyZWRMZXR0ZXIuZmMpIHtcbiAgICAgICAgICAgIGlmIChsYXN0RmlsbCAhPT0gcmVuZGVyZWRMZXR0ZXIuZmMpIHtcbiAgICAgICAgICAgICAgcmVuZGVyZXIuY3R4RmlsbFN0eWxlKHJlbmRlcmVkTGV0dGVyLmZjKTtcbiAgICAgICAgICAgICAgbGFzdEZpbGwgPSByZW5kZXJlZExldHRlci5mYzsgLy8gY3R4LmZpbGxTdHlsZSA9IHJlbmRlcmVkTGV0dGVyLmZjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobGFzdEZpbGwgIT09IHRoaXMudmFsdWVzLmZpbGwpIHtcbiAgICAgICAgICAgIGxhc3RGaWxsID0gdGhpcy52YWx1ZXMuZmlsbDtcbiAgICAgICAgICAgIHJlbmRlcmVyLmN0eEZpbGxTdHlsZSh0aGlzLnZhbHVlcy5maWxsKTsgLy8gY3R4LmZpbGxTdHlsZSA9IHRoaXMudmFsdWVzLmZpbGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29tbWFuZHMgPSB0aGlzLnRleHRTcGFuc1tpXS5lbGVtO1xuICAgICAgICAgIGpMZW4gPSBjb21tYW5kcy5sZW5ndGg7XG4gICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBwYXRoQXJyID0gY29tbWFuZHNbal07XG4gICAgICAgICAgICBrTGVuID0gcGF0aEFyci5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5tb3ZlVG8ocGF0aEFyclswXSwgcGF0aEFyclsxXSk7XG5cbiAgICAgICAgICAgIGZvciAoayA9IDI7IGsgPCBrTGVuOyBrICs9IDYpIHtcbiAgICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQuYmV6aWVyQ3VydmVUbyhwYXRoQXJyW2tdLCBwYXRoQXJyW2sgKyAxXSwgcGF0aEFycltrICsgMl0sIHBhdGhBcnJbayArIDNdLCBwYXRoQXJyW2sgKyA0XSwgcGF0aEFycltrICsgNV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgIHJlbmRlcmVyLmN0eEZpbGwoKTsgLy8gdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQuZmlsbCgpO1xuICAgICAgICAgIC8vLyBjdHguZmlsbFRleHQodGhpcy50ZXh0U3BhbnNbaV0udmFsLDAsMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdHJva2UpIHtcbiAgICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIgJiYgcmVuZGVyZWRMZXR0ZXIuc3cpIHtcbiAgICAgICAgICAgIGlmIChsYXN0U3Ryb2tlVyAhPT0gcmVuZGVyZWRMZXR0ZXIuc3cpIHtcbiAgICAgICAgICAgICAgbGFzdFN0cm9rZVcgPSByZW5kZXJlZExldHRlci5zdztcbiAgICAgICAgICAgICAgcmVuZGVyZXIuY3R4TGluZVdpZHRoKHJlbmRlcmVkTGV0dGVyLnN3KTsgLy8gY3R4LmxpbmVXaWR0aCA9IHJlbmRlcmVkTGV0dGVyLnN3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobGFzdFN0cm9rZVcgIT09IHRoaXMudmFsdWVzLnNXaWR0aCkge1xuICAgICAgICAgICAgbGFzdFN0cm9rZVcgPSB0aGlzLnZhbHVlcy5zV2lkdGg7XG4gICAgICAgICAgICByZW5kZXJlci5jdHhMaW5lV2lkdGgodGhpcy52YWx1ZXMuc1dpZHRoKTsgLy8gY3R4LmxpbmVXaWR0aCA9IHRoaXMudmFsdWVzLnNXaWR0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIgJiYgcmVuZGVyZWRMZXR0ZXIuc2MpIHtcbiAgICAgICAgICAgIGlmIChsYXN0U3Ryb2tlICE9PSByZW5kZXJlZExldHRlci5zYykge1xuICAgICAgICAgICAgICBsYXN0U3Ryb2tlID0gcmVuZGVyZWRMZXR0ZXIuc2M7XG4gICAgICAgICAgICAgIHJlbmRlcmVyLmN0eFN0cm9rZVN0eWxlKHJlbmRlcmVkTGV0dGVyLnNjKTsgLy8gY3R4LnN0cm9rZVN0eWxlID0gcmVuZGVyZWRMZXR0ZXIuc2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChsYXN0U3Ryb2tlICE9PSB0aGlzLnZhbHVlcy5zdHJva2UpIHtcbiAgICAgICAgICAgIGxhc3RTdHJva2UgPSB0aGlzLnZhbHVlcy5zdHJva2U7XG4gICAgICAgICAgICByZW5kZXJlci5jdHhTdHJva2VTdHlsZSh0aGlzLnZhbHVlcy5zdHJva2UpOyAvLyBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnZhbHVlcy5zdHJva2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29tbWFuZHMgPSB0aGlzLnRleHRTcGFuc1tpXS5lbGVtO1xuICAgICAgICAgIGpMZW4gPSBjb21tYW5kcy5sZW5ndGg7XG4gICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBwYXRoQXJyID0gY29tbWFuZHNbal07XG4gICAgICAgICAgICBrTGVuID0gcGF0aEFyci5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5tb3ZlVG8ocGF0aEFyclswXSwgcGF0aEFyclsxXSk7XG5cbiAgICAgICAgICAgIGZvciAoayA9IDI7IGsgPCBrTGVuOyBrICs9IDYpIHtcbiAgICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQuYmV6aWVyQ3VydmVUbyhwYXRoQXJyW2tdLCBwYXRoQXJyW2sgKyAxXSwgcGF0aEFycltrICsgMl0sIHBhdGhBcnJbayArIDNdLCBwYXRoQXJyW2sgKyA0XSwgcGF0aEFycltrICsgNV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgIHJlbmRlcmVyLmN0eFN0cm9rZSgpOyAvLyB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAvLy8gY3R4LnN0cm9rZVRleHQobGV0dGVyc1tpXS52YWwsMCwwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJlZExldHRlcikge1xuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gQ1ZJbWFnZUVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMuYXNzZXREYXRhID0gZ2xvYmFsRGF0YS5nZXRBc3NldERhdGEoZGF0YS5yZWZJZCk7XG4gICAgdGhpcy5pbWcgPSBnbG9iYWxEYXRhLmltYWdlTG9hZGVyLmdldEFzc2V0KHRoaXMuYXNzZXREYXRhKTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgQ1ZCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRWxlbWVudF0sIENWSW1hZ2VFbGVtZW50KTtcbiAgQ1ZJbWFnZUVsZW1lbnQucHJvdG90eXBlLmluaXRFbGVtZW50ID0gU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudDtcbiAgQ1ZJbWFnZUVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IElJbWFnZUVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZTtcblxuICBDVkltYWdlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pbWcud2lkdGggJiYgKHRoaXMuYXNzZXREYXRhLncgIT09IHRoaXMuaW1nLndpZHRoIHx8IHRoaXMuYXNzZXREYXRhLmggIT09IHRoaXMuaW1nLmhlaWdodCkpIHtcbiAgICAgIHZhciBjYW52YXMgPSBjcmVhdGVUYWcoJ2NhbnZhcycpO1xuICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5hc3NldERhdGEudztcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLmFzc2V0RGF0YS5oO1xuICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgdmFyIGltZ1cgPSB0aGlzLmltZy53aWR0aDtcbiAgICAgIHZhciBpbWdIID0gdGhpcy5pbWcuaGVpZ2h0O1xuICAgICAgdmFyIGltZ1JlbCA9IGltZ1cgLyBpbWdIO1xuICAgICAgdmFyIGNhbnZhc1JlbCA9IHRoaXMuYXNzZXREYXRhLncgLyB0aGlzLmFzc2V0RGF0YS5oO1xuICAgICAgdmFyIHdpZHRoQ3JvcDtcbiAgICAgIHZhciBoZWlnaHRDcm9wO1xuICAgICAgdmFyIHBhciA9IHRoaXMuYXNzZXREYXRhLnByIHx8IHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJDb25maWcuaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvO1xuXG4gICAgICBpZiAoaW1nUmVsID4gY2FudmFzUmVsICYmIHBhciA9PT0gJ3hNaWRZTWlkIHNsaWNlJyB8fCBpbWdSZWwgPCBjYW52YXNSZWwgJiYgcGFyICE9PSAneE1pZFlNaWQgc2xpY2UnKSB7XG4gICAgICAgIGhlaWdodENyb3AgPSBpbWdIO1xuICAgICAgICB3aWR0aENyb3AgPSBoZWlnaHRDcm9wICogY2FudmFzUmVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGhDcm9wID0gaW1nVztcbiAgICAgICAgaGVpZ2h0Q3JvcCA9IHdpZHRoQ3JvcCAvIGNhbnZhc1JlbDtcbiAgICAgIH1cblxuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmltZywgKGltZ1cgLSB3aWR0aENyb3ApIC8gMiwgKGltZ0ggLSBoZWlnaHRDcm9wKSAvIDIsIHdpZHRoQ3JvcCwgaGVpZ2h0Q3JvcCwgMCwgMCwgdGhpcy5hc3NldERhdGEudywgdGhpcy5hc3NldERhdGEuaCk7XG4gICAgICB0aGlzLmltZyA9IGNhbnZhcztcbiAgICB9XG4gIH07XG5cbiAgQ1ZJbWFnZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuZHJhd0ltYWdlKHRoaXMuaW1nLCAwLCAwKTtcbiAgfTtcblxuICBDVkltYWdlRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmltZyA9IG51bGw7XG4gIH07XG5cbiAgZnVuY3Rpb24gQ1ZTb2xpZEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBDVkJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVFbGVtZW50XSwgQ1ZTb2xpZEVsZW1lbnQpO1xuICBDVlNvbGlkRWxlbWVudC5wcm90b3R5cGUuaW5pdEVsZW1lbnQgPSBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmluaXRFbGVtZW50O1xuICBDVlNvbGlkRWxlbWVudC5wcm90b3R5cGUucHJlcGFyZUZyYW1lID0gSUltYWdlRWxlbWVudC5wcm90b3R5cGUucHJlcGFyZUZyYW1lO1xuXG4gIENWU29saWRFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gdmFyIGN0eCA9IHRoaXMuY2FudmFzQ29udGV4dDtcbiAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuY3R4RmlsbFN0eWxlKHRoaXMuZGF0YS5zYyk7IC8vIGN0eC5maWxsU3R5bGUgPSB0aGlzLmRhdGEuc2M7XG5cbiAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuY3R4RmlsbFJlY3QoMCwgMCwgdGhpcy5kYXRhLnN3LCB0aGlzLmRhdGEuc2gpOyAvLyBjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy5kYXRhLnN3LCB0aGlzLmRhdGEuc2gpO1xuICAgIC8vXG4gIH07XG5cbiAgZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXJCYXNlKCkge31cblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VSZW5kZXJlcl0sIENhbnZhc1JlbmRlcmVyQmFzZSk7XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVTaGFwZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBDVlNoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBDVlRleHRFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVJbWFnZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBDVkltYWdlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlU29saWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQ1ZTb2xpZEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZU51bGwgPSBTVkdSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlTnVsbDtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmN0eFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIGlmIChwcm9wc1swXSA9PT0gMSAmJiBwcm9wc1sxXSA9PT0gMCAmJiBwcm9wc1s0XSA9PT0gMCAmJiBwcm9wc1s1XSA9PT0gMSAmJiBwcm9wc1sxMl0gPT09IDAgJiYgcHJvcHNbMTNdID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jYW52YXNDb250ZXh0LnRyYW5zZm9ybShwcm9wc1swXSwgcHJvcHNbMV0sIHByb3BzWzRdLCBwcm9wc1s1XSwgcHJvcHNbMTJdLCBwcm9wc1sxM10pO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4T3BhY2l0eSA9IGZ1bmN0aW9uIChvcCkge1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5nbG9iYWxBbHBoYSAqPSBvcCA8IDAgPyAwIDogb3A7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jdHhGaWxsU3R5bGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuZmlsbFN0eWxlID0gdmFsdWU7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jdHhTdHJva2VTdHlsZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5zdHJva2VTdHlsZSA9IHZhbHVlO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4TGluZVdpZHRoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LmxpbmVXaWR0aCA9IHZhbHVlO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4TGluZUNhcCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5saW5lQ2FwID0gdmFsdWU7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jdHhMaW5lSm9pbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5saW5lSm9pbiA9IHZhbHVlO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4TWl0ZXJMaW1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5taXRlckxpbWl0ID0gdmFsdWU7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jdHhGaWxsID0gZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuZmlsbChydWxlKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmN0eEZpbGxSZWN0ID0gZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jdHhTdHJva2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LnN0cm9rZSgpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRleHREYXRhLnJlc2V0KCk7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5zYXZlKCk7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gKGFjdGlvbkZsYWcpIHtcbiAgICBpZiAoIXRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb25GbGFnKSB7XG4gICAgICB0aGlzLmdsb2JhbERhdGEuYmxlbmRNb2RlID0gJ3NvdXJjZS1vdmVyJztcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRleHREYXRhLnJlc3RvcmUoYWN0aW9uRmxhZyk7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jb25maWdBbmltYXRpb24gPSBmdW5jdGlvbiAoYW5pbURhdGEpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIgPSBjcmVhdGVUYWcoJ2NhbnZhcycpO1xuICAgICAgdmFyIGNvbnRhaW5lclN0eWxlID0gdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lci5zdHlsZTtcbiAgICAgIGNvbnRhaW5lclN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgY29udGFpbmVyU3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgdmFyIG9yaWdpbiA9ICcwcHggMHB4IDBweCc7XG4gICAgICBjb250YWluZXJTdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XG4gICAgICBjb250YWluZXJTdHlsZS5tb3pUcmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XG4gICAgICBjb250YWluZXJTdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XG4gICAgICBjb250YWluZXJTdHlsZVsnLXdlYmtpdC10cmFuc2Zvcm0nXSA9IG9yaWdpbjtcbiAgICAgIGNvbnRhaW5lclN0eWxlLmNvbnRlbnRWaXNpYmlsaXR5ID0gdGhpcy5yZW5kZXJDb25maWcuY29udGVudFZpc2liaWxpdHk7XG4gICAgICB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyKTtcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dCA9IHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmNsYXNzTmFtZSkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0aGlzLnJlbmRlckNvbmZpZy5jbGFzc05hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuaWQpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5yZW5kZXJDb25maWcuaWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQgPSB0aGlzLnJlbmRlckNvbmZpZy5jb250ZXh0O1xuICAgIH1cblxuICAgIHRoaXMuY29udGV4dERhdGEuc2V0Q29udGV4dCh0aGlzLmNhbnZhc0NvbnRleHQpO1xuICAgIHRoaXMuZGF0YSA9IGFuaW1EYXRhO1xuICAgIHRoaXMubGF5ZXJzID0gYW5pbURhdGEubGF5ZXJzO1xuICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzID0ge1xuICAgICAgdzogYW5pbURhdGEudyxcbiAgICAgIGg6IGFuaW1EYXRhLmgsXG4gICAgICBzeDogMCxcbiAgICAgIHN5OiAwLFxuICAgICAgdHg6IDAsXG4gICAgICB0eTogMFxuICAgIH07XG4gICAgdGhpcy5zZXR1cEdsb2JhbERhdGEoYW5pbURhdGEsIGRvY3VtZW50LmJvZHkpO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0ID0gdGhpcy5jYW52YXNDb250ZXh0O1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlciA9IHRoaXM7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmlzRGFzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5nbG9iYWxEYXRhLnByb2dyZXNzaXZlTG9hZCA9IHRoaXMucmVuZGVyQ29uZmlnLnByb2dyZXNzaXZlTG9hZDtcbiAgICB0aGlzLmdsb2JhbERhdGEudHJhbnNmb3JtQ2FudmFzID0gdGhpcy50cmFuc2Zvcm1DYW52YXM7XG4gICAgdGhpcy5lbGVtZW50cyA9IGNyZWF0ZVNpemVkQXJyYXkoYW5pbURhdGEubGF5ZXJzLmxlbmd0aCk7XG4gICAgdGhpcy51cGRhdGVDb250YWluZXJTaXplKCk7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS51cGRhdGVDb250YWluZXJTaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgdmFyIGVsZW1lbnRXaWR0aDtcbiAgICB2YXIgZWxlbWVudEhlaWdodDtcblxuICAgIGlmICh3aWR0aCkge1xuICAgICAgZWxlbWVudFdpZHRoID0gd2lkdGg7XG4gICAgICBlbGVtZW50SGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmNhbnZhcy53aWR0aCA9IGVsZW1lbnRXaWR0aDtcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMuaGVpZ2h0ID0gZWxlbWVudEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyICYmIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIpIHtcbiAgICAgICAgZWxlbWVudFdpZHRoID0gdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIub2Zmc2V0V2lkdGg7XG4gICAgICAgIGVsZW1lbnRIZWlnaHQgPSB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5vZmZzZXRIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50V2lkdGggPSB0aGlzLmNhbnZhc0NvbnRleHQuY2FudmFzLndpZHRoO1xuICAgICAgICBlbGVtZW50SGVpZ2h0ID0gdGhpcy5jYW52YXNDb250ZXh0LmNhbnZhcy5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMud2lkdGggPSBlbGVtZW50V2lkdGggKiB0aGlzLnJlbmRlckNvbmZpZy5kcHI7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQuY2FudmFzLmhlaWdodCA9IGVsZW1lbnRIZWlnaHQgKiB0aGlzLnJlbmRlckNvbmZpZy5kcHI7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRSZWw7XG4gICAgdmFyIGFuaW1hdGlvblJlbDtcblxuICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5wcmVzZXJ2ZUFzcGVjdFJhdGlvLmluZGV4T2YoJ21lZXQnKSAhPT0gLTEgfHwgdGhpcy5yZW5kZXJDb25maWcucHJlc2VydmVBc3BlY3RSYXRpby5pbmRleE9mKCdzbGljZScpICE9PSAtMSkge1xuICAgICAgdmFyIHBhciA9IHRoaXMucmVuZGVyQ29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8uc3BsaXQoJyAnKTtcbiAgICAgIHZhciBmaWxsVHlwZSA9IHBhclsxXSB8fCAnbWVldCc7XG4gICAgICB2YXIgcG9zID0gcGFyWzBdIHx8ICd4TWlkWU1pZCc7XG4gICAgICB2YXIgeFBvcyA9IHBvcy5zdWJzdHIoMCwgNCk7XG4gICAgICB2YXIgeVBvcyA9IHBvcy5zdWJzdHIoNCk7XG4gICAgICBlbGVtZW50UmVsID0gZWxlbWVudFdpZHRoIC8gZWxlbWVudEhlaWdodDtcbiAgICAgIGFuaW1hdGlvblJlbCA9IHRoaXMudHJhbnNmb3JtQ2FudmFzLncgLyB0aGlzLnRyYW5zZm9ybUNhbnZhcy5oO1xuXG4gICAgICBpZiAoYW5pbWF0aW9uUmVsID4gZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ21lZXQnIHx8IGFuaW1hdGlvblJlbCA8IGVsZW1lbnRSZWwgJiYgZmlsbFR5cGUgPT09ICdzbGljZScpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3ggPSBlbGVtZW50V2lkdGggLyAodGhpcy50cmFuc2Zvcm1DYW52YXMudyAvIHRoaXMucmVuZGVyQ29uZmlnLmRwcik7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN5ID0gZWxlbWVudFdpZHRoIC8gKHRoaXMudHJhbnNmb3JtQ2FudmFzLncgLyB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3ggPSBlbGVtZW50SGVpZ2h0IC8gKHRoaXMudHJhbnNmb3JtQ2FudmFzLmggLyB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSA9IGVsZW1lbnRIZWlnaHQgLyAodGhpcy50cmFuc2Zvcm1DYW52YXMuaCAvIHRoaXMucmVuZGVyQ29uZmlnLmRwcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh4UG9zID09PSAneE1pZCcgJiYgKGFuaW1hdGlvblJlbCA8IGVsZW1lbnRSZWwgJiYgZmlsbFR5cGUgPT09ICdtZWV0JyB8fCBhbmltYXRpb25SZWwgPiBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnc2xpY2UnKSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eCA9IChlbGVtZW50V2lkdGggLSB0aGlzLnRyYW5zZm9ybUNhbnZhcy53ICogKGVsZW1lbnRIZWlnaHQgLyB0aGlzLnRyYW5zZm9ybUNhbnZhcy5oKSkgLyAyICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xuICAgICAgfSBlbHNlIGlmICh4UG9zID09PSAneE1heCcgJiYgKGFuaW1hdGlvblJlbCA8IGVsZW1lbnRSZWwgJiYgZmlsbFR5cGUgPT09ICdtZWV0JyB8fCBhbmltYXRpb25SZWwgPiBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnc2xpY2UnKSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eCA9IChlbGVtZW50V2lkdGggLSB0aGlzLnRyYW5zZm9ybUNhbnZhcy53ICogKGVsZW1lbnRIZWlnaHQgLyB0aGlzLnRyYW5zZm9ybUNhbnZhcy5oKSkgKiB0aGlzLnJlbmRlckNvbmZpZy5kcHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh5UG9zID09PSAnWU1pZCcgJiYgKGFuaW1hdGlvblJlbCA+IGVsZW1lbnRSZWwgJiYgZmlsbFR5cGUgPT09ICdtZWV0JyB8fCBhbmltYXRpb25SZWwgPCBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnc2xpY2UnKSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eSA9IChlbGVtZW50SGVpZ2h0IC0gdGhpcy50cmFuc2Zvcm1DYW52YXMuaCAqIChlbGVtZW50V2lkdGggLyB0aGlzLnRyYW5zZm9ybUNhbnZhcy53KSkgLyAyICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xuICAgICAgfSBlbHNlIGlmICh5UG9zID09PSAnWU1heCcgJiYgKGFuaW1hdGlvblJlbCA+IGVsZW1lbnRSZWwgJiYgZmlsbFR5cGUgPT09ICdtZWV0JyB8fCBhbmltYXRpb25SZWwgPCBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnc2xpY2UnKSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eSA9IChlbGVtZW50SGVpZ2h0IC0gdGhpcy50cmFuc2Zvcm1DYW52YXMuaCAqIChlbGVtZW50V2lkdGggLyB0aGlzLnRyYW5zZm9ybUNhbnZhcy53KSkgKiB0aGlzLnJlbmRlckNvbmZpZy5kcHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eSA9IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnJlbmRlckNvbmZpZy5wcmVzZXJ2ZUFzcGVjdFJhdGlvID09PSAnbm9uZScpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN4ID0gZWxlbWVudFdpZHRoIC8gKHRoaXMudHJhbnNmb3JtQ2FudmFzLncgLyB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3kgPSBlbGVtZW50SGVpZ2h0IC8gKHRoaXMudHJhbnNmb3JtQ2FudmFzLmggLyB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHggPSAwO1xuICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeCA9IHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN5ID0gdGhpcy5yZW5kZXJDb25maWcuZHByO1xuICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHggPSAwO1xuICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHkgPSAwO1xuICAgIH1cblxuICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnByb3BzID0gW3RoaXMudHJhbnNmb3JtQ2FudmFzLnN4LCAwLCAwLCAwLCAwLCB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSwgMCwgMCwgMCwgMCwgMSwgMCwgdGhpcy50cmFuc2Zvcm1DYW52YXMudHgsIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR5LCAwLCAxXTtcbiAgICAvKiB2YXIgaSwgbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XHJcbiAgICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgICBpZih0aGlzLmVsZW1lbnRzW2ldICYmIHRoaXMuZWxlbWVudHNbaV0uZGF0YS50eSA9PT0gMCl7XHJcbiAgICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5yZXNpemUodGhpcy5nbG9iYWxEYXRhLnRyYW5zZm9ybUNhbnZhcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH0gKi9cblxuICAgIHRoaXMuY3R4VHJhbnNmb3JtKHRoaXMudHJhbnNmb3JtQ2FudmFzLnByb3BzKTtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LnJlY3QoMCwgMCwgdGhpcy50cmFuc2Zvcm1DYW52YXMudywgdGhpcy50cmFuc2Zvcm1DYW52YXMuaCk7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5jbGlwKCk7XG4gICAgdGhpcy5yZW5kZXJGcmFtZSh0aGlzLnJlbmRlcmVkRnJhbWUsIHRydWUpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMgJiYgdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLmlubmVyVGV4dCA9ICcnO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycyA/IHRoaXMubGF5ZXJzLmxlbmd0aCA6IDA7XG5cbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0gJiYgdGhpcy5lbGVtZW50c1tpXS5kZXN0cm95KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbaV0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAobnVtLCBmb3JjZVJlbmRlcikge1xuICAgIGlmICh0aGlzLnJlbmRlcmVkRnJhbWUgPT09IG51bSAmJiB0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcyA9PT0gdHJ1ZSAmJiAhZm9yY2VSZW5kZXIgfHwgdGhpcy5kZXN0cm95ZWQgfHwgbnVtID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyZWRGcmFtZSA9IG51bTtcbiAgICB0aGlzLmdsb2JhbERhdGEuZnJhbWVOdW0gPSBudW0gLSB0aGlzLmFuaW1hdGlvbkl0ZW0uX2lzRmlyc3RGcmFtZTtcbiAgICB0aGlzLmdsb2JhbERhdGEuZnJhbWVJZCArPSAxO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5fbWRmID0gIXRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzIHx8IGZvcmNlUmVuZGVyO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5wcm9qZWN0SW50ZXJmYWNlLmN1cnJlbnRGcmFtZSA9IG51bTsgLy8gY29uc29sZS5sb2coJy0tLS0tLS0tJyk7XG4gICAgLy8gY29uc29sZS5sb2coJ05FVzogJyxudW0pO1xuXG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcblxuICAgIGlmICghdGhpcy5jb21wbGV0ZUxheWVycykge1xuICAgICAgdGhpcy5jaGVja0xheWVycyhudW0pO1xuICAgIH1cblxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICBpZiAodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbaV0ucHJlcGFyZUZyYW1lKG51bSAtIHRoaXMubGF5ZXJzW2ldLnN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5nbG9iYWxEYXRhLl9tZGYpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMudHJhbnNmb3JtQ2FudmFzLncsIHRoaXMudHJhbnNmb3JtQ2FudmFzLmgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBsZXRlTGF5ZXJzIHx8IHRoaXMuZWxlbWVudHNbaV0pIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnJlbmRlckZyYW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmJ1aWxkSXRlbSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgaWYgKGVsZW1lbnRzW3Bvc10gfHwgdGhpcy5sYXllcnNbcG9zXS50eSA9PT0gOTkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuY3JlYXRlSXRlbSh0aGlzLmxheWVyc1twb3NdLCB0aGlzLCB0aGlzLmdsb2JhbERhdGEpO1xuICAgIGVsZW1lbnRzW3Bvc10gPSBlbGVtZW50O1xuICAgIGVsZW1lbnQuaW5pdEV4cHJlc3Npb25zKCk7XG4gICAgLyogaWYodGhpcy5sYXllcnNbcG9zXS50eSA9PT0gMCl7XHJcbiAgICAgICAgICBlbGVtZW50LnJlc2l6ZSh0aGlzLmdsb2JhbERhdGEudHJhbnNmb3JtQ2FudmFzKTtcclxuICAgICAgfSAqL1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY2hlY2tQZW5kaW5nRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgd2hpbGUgKHRoaXMucGVuZGluZ0VsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBlbmRpbmdFbGVtZW50cy5wb3AoKTtcbiAgICAgIGVsZW1lbnQuY2hlY2tQYXJlbnRpbmcoKTtcbiAgICB9XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgfTtcblxuICBmdW5jdGlvbiBDYW52YXNDb250ZXh0KCkge1xuICAgIHRoaXMub3BhY2l0eSA9IC0xO1xuICAgIHRoaXMudHJhbnNmb3JtID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIDE2KTtcbiAgICB0aGlzLmZpbGxTdHlsZSA9ICcnO1xuICAgIHRoaXMuc3Ryb2tlU3R5bGUgPSAnJztcbiAgICB0aGlzLmxpbmVXaWR0aCA9ICcnO1xuICAgIHRoaXMubGluZUNhcCA9ICcnO1xuICAgIHRoaXMubGluZUpvaW4gPSAnJztcbiAgICB0aGlzLm1pdGVyTGltaXQgPSAnJztcbiAgICB0aGlzLmlkID0gTWF0aC5yYW5kb20oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIENWQ29udGV4dERhdGEoKSB7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMuY0FyclBvcyA9IDA7XG4gICAgdGhpcy5jVHIgPSBuZXcgTWF0cml4KCk7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IDE1O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICB2YXIgY2FudmFzQ29udGV4dCA9IG5ldyBDYW52YXNDb250ZXh0KCk7XG4gICAgICB0aGlzLnN0YWNrW2ldID0gY2FudmFzQ29udGV4dDtcbiAgICB9XG5cbiAgICB0aGlzLl9sZW5ndGggPSBsZW47XG4gICAgdGhpcy5uYXRpdmVDb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zZm9ybU1hdCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLmN1cnJlbnRPcGFjaXR5ID0gMTsgLy9cblxuICAgIHRoaXMuY3VycmVudEZpbGxTdHlsZSA9ICcnO1xuICAgIHRoaXMuYXBwbGllZEZpbGxTdHlsZSA9ICcnOyAvL1xuXG4gICAgdGhpcy5jdXJyZW50U3Ryb2tlU3R5bGUgPSAnJztcbiAgICB0aGlzLmFwcGxpZWRTdHJva2VTdHlsZSA9ICcnOyAvL1xuXG4gICAgdGhpcy5jdXJyZW50TGluZVdpZHRoID0gJyc7XG4gICAgdGhpcy5hcHBsaWVkTGluZVdpZHRoID0gJyc7IC8vXG5cbiAgICB0aGlzLmN1cnJlbnRMaW5lQ2FwID0gJyc7XG4gICAgdGhpcy5hcHBsaWVkTGluZUNhcCA9ICcnOyAvL1xuXG4gICAgdGhpcy5jdXJyZW50TGluZUpvaW4gPSAnJztcbiAgICB0aGlzLmFwcGxpZWRMaW5lSm9pbiA9ICcnOyAvL1xuXG4gICAgdGhpcy5hcHBsaWVkTWl0ZXJMaW1pdCA9ICcnO1xuICAgIHRoaXMuY3VycmVudE1pdGVyTGltaXQgPSAnJztcbiAgfVxuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLmR1cGxpY2F0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV3TGVuZ3RoID0gdGhpcy5fbGVuZ3RoICogMjtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBmb3IgKGkgPSB0aGlzLl9sZW5ndGg7IGkgPCBuZXdMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdGhpcy5zdGFja1tpXSA9IG5ldyBDYW52YXNDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbGVuZ3RoID0gbmV3TGVuZ3RoO1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY0FyclBvcyA9IDA7XG4gICAgdGhpcy5jVHIucmVzZXQoKTtcbiAgICB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ub3BhY2l0eSA9IDE7XG4gIH07XG5cbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIChmb3JjZVJlc3RvcmUpIHtcbiAgICB0aGlzLmNBcnJQb3MgLT0gMTtcbiAgICB2YXIgY3VycmVudENvbnRleHQgPSB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc107XG4gICAgdmFyIHRyYW5zZm9ybSA9IGN1cnJlbnRDb250ZXh0LnRyYW5zZm9ybTtcbiAgICB2YXIgaTtcbiAgICB2YXIgYXJyID0gdGhpcy5jVHIucHJvcHM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkgKz0gMSkge1xuICAgICAgYXJyW2ldID0gdHJhbnNmb3JtW2ldO1xuICAgIH1cblxuICAgIGlmIChmb3JjZVJlc3RvcmUpIHtcbiAgICAgIHRoaXMubmF0aXZlQ29udGV4dC5yZXN0b3JlKCk7XG4gICAgICB2YXIgcHJldlN0YWNrID0gdGhpcy5zdGFja1t0aGlzLmNBcnJQb3MgKyAxXTtcbiAgICAgIHRoaXMuYXBwbGllZEZpbGxTdHlsZSA9IHByZXZTdGFjay5maWxsU3R5bGU7XG4gICAgICB0aGlzLmFwcGxpZWRTdHJva2VTdHlsZSA9IHByZXZTdGFjay5zdHJva2VTdHlsZTtcbiAgICAgIHRoaXMuYXBwbGllZExpbmVXaWR0aCA9IHByZXZTdGFjay5saW5lV2lkdGg7XG4gICAgICB0aGlzLmFwcGxpZWRMaW5lQ2FwID0gcHJldlN0YWNrLmxpbmVDYXA7XG4gICAgICB0aGlzLmFwcGxpZWRMaW5lSm9pbiA9IHByZXZTdGFjay5saW5lSm9pbjtcbiAgICAgIHRoaXMuYXBwbGllZE1pdGVyTGltaXQgPSBwcmV2U3RhY2subWl0ZXJMaW1pdDtcbiAgICB9XG5cbiAgICB0aGlzLm5hdGl2ZUNvbnRleHQuc2V0VHJhbnNmb3JtKHRyYW5zZm9ybVswXSwgdHJhbnNmb3JtWzFdLCB0cmFuc2Zvcm1bNF0sIHRyYW5zZm9ybVs1XSwgdHJhbnNmb3JtWzEyXSwgdHJhbnNmb3JtWzEzXSk7XG5cbiAgICBpZiAoZm9yY2VSZXN0b3JlIHx8IGN1cnJlbnRDb250ZXh0Lm9wYWNpdHkgIT09IC0xICYmIHRoaXMuY3VycmVudE9wYWNpdHkgIT09IGN1cnJlbnRDb250ZXh0Lm9wYWNpdHkpIHtcbiAgICAgIHRoaXMubmF0aXZlQ29udGV4dC5nbG9iYWxBbHBoYSA9IGN1cnJlbnRDb250ZXh0Lm9wYWNpdHk7XG4gICAgICB0aGlzLmN1cnJlbnRPcGFjaXR5ID0gY3VycmVudENvbnRleHQub3BhY2l0eTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRGaWxsU3R5bGUgPSBjdXJyZW50Q29udGV4dC5maWxsU3R5bGU7XG4gICAgdGhpcy5jdXJyZW50U3Ryb2tlU3R5bGUgPSBjdXJyZW50Q29udGV4dC5zdHJva2VTdHlsZTtcbiAgICB0aGlzLmN1cnJlbnRMaW5lV2lkdGggPSBjdXJyZW50Q29udGV4dC5saW5lV2lkdGg7XG4gICAgdGhpcy5jdXJyZW50TGluZUNhcCA9IGN1cnJlbnRDb250ZXh0LmxpbmVDYXA7XG4gICAgdGhpcy5jdXJyZW50TGluZUpvaW4gPSBjdXJyZW50Q29udGV4dC5saW5lSm9pbjtcbiAgICB0aGlzLmN1cnJlbnRNaXRlckxpbWl0ID0gY3VycmVudENvbnRleHQubWl0ZXJMaW1pdDtcbiAgfTtcblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKHNhdmVPbk5hdGl2ZUZsYWcpIHtcbiAgICBpZiAoc2F2ZU9uTmF0aXZlRmxhZykge1xuICAgICAgdGhpcy5uYXRpdmVDb250ZXh0LnNhdmUoKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLmNUci5wcm9wcztcblxuICAgIGlmICh0aGlzLl9sZW5ndGggPD0gdGhpcy5jQXJyUG9zKSB7XG4gICAgICB0aGlzLmR1cGxpY2F0ZSgpO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50U3RhY2sgPSB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc107XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkgKz0gMSkge1xuICAgICAgY3VycmVudFN0YWNrLnRyYW5zZm9ybVtpXSA9IHByb3BzW2ldO1xuICAgIH1cblxuICAgIHRoaXMuY0FyclBvcyArPSAxO1xuICAgIHZhciBuZXdTdGFjayA9IHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zXTtcbiAgICBuZXdTdGFjay5vcGFjaXR5ID0gY3VycmVudFN0YWNrLm9wYWNpdHk7XG4gICAgbmV3U3RhY2suZmlsbFN0eWxlID0gY3VycmVudFN0YWNrLmZpbGxTdHlsZTtcbiAgICBuZXdTdGFjay5zdHJva2VTdHlsZSA9IGN1cnJlbnRTdGFjay5zdHJva2VTdHlsZTtcbiAgICBuZXdTdGFjay5saW5lV2lkdGggPSBjdXJyZW50U3RhY2subGluZVdpZHRoO1xuICAgIG5ld1N0YWNrLmxpbmVDYXAgPSBjdXJyZW50U3RhY2subGluZUNhcDtcbiAgICBuZXdTdGFjay5saW5lSm9pbiA9IGN1cnJlbnRTdGFjay5saW5lSm9pbjtcbiAgICBuZXdTdGFjay5taXRlckxpbWl0ID0gY3VycmVudFN0YWNrLm1pdGVyTGltaXQ7XG4gIH07XG5cbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUuc2V0T3BhY2l0eSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zXS5vcGFjaXR5ID0gdmFsdWU7XG4gIH07XG5cbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUuc2V0Q29udGV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMubmF0aXZlQ29udGV4dCA9IHZhbHVlO1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLmZpbGxTdHlsZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10uZmlsbFN0eWxlICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5jdXJyZW50RmlsbFN0eWxlID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10uZmlsbFN0eWxlID0gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLnN0cm9rZVN0eWxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zXS5zdHJva2VTdHlsZSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuY3VycmVudFN0cm9rZVN0eWxlID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10uc3Ryb2tlU3R5bGUgPSB2YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUubGluZVdpZHRoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zXS5saW5lV2lkdGggIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRMaW5lV2lkdGggPSB2YWx1ZTtcbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zXS5saW5lV2lkdGggPSB2YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUubGluZUNhcCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubGluZUNhcCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuY3VycmVudExpbmVDYXAgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zXS5saW5lQ2FwID0gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLmxpbmVKb2luID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zXS5saW5lSm9pbiAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuY3VycmVudExpbmVKb2luID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubGluZUpvaW4gPSB2YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUubWl0ZXJMaW1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubWl0ZXJMaW1pdCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuY3VycmVudE1pdGVyTGltaXQgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zXS5taXRlckxpbWl0ID0gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHRoaXMudHJhbnNmb3JtTWF0LmNsb25lRnJvbVByb3BzKHByb3BzKTsgLy8gVGFraW5nIHRoZSBsYXN0IHRyYW5zZm9ybSB2YWx1ZSBmcm9tIHRoZSBzdG9yZWQgc3RhY2sgb2YgdHJhbnNmb3Jtc1xuXG4gICAgdmFyIGN1cnJlbnRUcmFuc2Zvcm0gPSB0aGlzLmNUcjsgLy8gQXBwbHlpbmcgdGhlIGxhc3QgdHJhbnNmb3JtIHZhbHVlIGFmdGVyIHRoZSBuZXcgdHJhbnNmb3JtIHRvIHJlc3BlY3QgdGhlIG9yZGVyIG9mIHRyYW5zZm9ybWF0aW9uc1xuXG4gICAgdGhpcy50cmFuc2Zvcm1NYXQubXVsdGlwbHkoY3VycmVudFRyYW5zZm9ybSk7IC8vIFN0b3JpbmcgdGhlIG5ldyB0cmFuc2Zvcm1lZCB2YWx1ZSBpbiB0aGUgc3RvcmVkIHRyYW5zZm9ybVxuXG4gICAgY3VycmVudFRyYW5zZm9ybS5jbG9uZUZyb21Qcm9wcyh0aGlzLnRyYW5zZm9ybU1hdC5wcm9wcyk7XG4gICAgdmFyIHRyUHJvcHMgPSBjdXJyZW50VHJhbnNmb3JtLnByb3BzOyAvLyBBcHBseWluZyB0aGUgbmV3IHRyYW5zZm9ybSB0byB0aGUgY2FudmFzXG5cbiAgICB0aGlzLm5hdGl2ZUNvbnRleHQuc2V0VHJhbnNmb3JtKHRyUHJvcHNbMF0sIHRyUHJvcHNbMV0sIHRyUHJvcHNbNF0sIHRyUHJvcHNbNV0sIHRyUHJvcHNbMTJdLCB0clByb3BzWzEzXSk7XG4gIH07XG5cbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUub3BhY2l0eSA9IGZ1bmN0aW9uIChvcCkge1xuICAgIHZhciBjdXJyZW50T3BhY2l0eSA9IHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zXS5vcGFjaXR5O1xuICAgIGN1cnJlbnRPcGFjaXR5ICo9IG9wIDwgMCA/IDAgOiBvcDtcblxuICAgIGlmICh0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ub3BhY2l0eSAhPT0gY3VycmVudE9wYWNpdHkpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRPcGFjaXR5ICE9PSBvcCkge1xuICAgICAgICB0aGlzLm5hdGl2ZUNvbnRleHQuZ2xvYmFsQWxwaGEgPSBvcDtcbiAgICAgICAgdGhpcy5jdXJyZW50T3BhY2l0eSA9IG9wO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ub3BhY2l0eSA9IGN1cnJlbnRPcGFjaXR5O1xuICAgIH1cbiAgfTtcblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICBpZiAodGhpcy5hcHBsaWVkRmlsbFN0eWxlICE9PSB0aGlzLmN1cnJlbnRGaWxsU3R5bGUpIHtcbiAgICAgIHRoaXMuYXBwbGllZEZpbGxTdHlsZSA9IHRoaXMuY3VycmVudEZpbGxTdHlsZTtcbiAgICAgIHRoaXMubmF0aXZlQ29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmFwcGxpZWRGaWxsU3R5bGU7XG4gICAgfVxuXG4gICAgdGhpcy5uYXRpdmVDb250ZXh0LmZpbGwocnVsZSk7XG4gIH07XG5cbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUuZmlsbFJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgIGlmICh0aGlzLmFwcGxpZWRGaWxsU3R5bGUgIT09IHRoaXMuY3VycmVudEZpbGxTdHlsZSkge1xuICAgICAgdGhpcy5hcHBsaWVkRmlsbFN0eWxlID0gdGhpcy5jdXJyZW50RmlsbFN0eWxlO1xuICAgICAgdGhpcy5uYXRpdmVDb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuYXBwbGllZEZpbGxTdHlsZTtcbiAgICB9XG5cbiAgICB0aGlzLm5hdGl2ZUNvbnRleHQuZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gIH07XG5cbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUuc3Ryb2tlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmFwcGxpZWRTdHJva2VTdHlsZSAhPT0gdGhpcy5jdXJyZW50U3Ryb2tlU3R5bGUpIHtcbiAgICAgIHRoaXMuYXBwbGllZFN0cm9rZVN0eWxlID0gdGhpcy5jdXJyZW50U3Ryb2tlU3R5bGU7XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aGlzLmFwcGxpZWRTdHJva2VTdHlsZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hcHBsaWVkTGluZVdpZHRoICE9PSB0aGlzLmN1cnJlbnRMaW5lV2lkdGgpIHtcbiAgICAgIHRoaXMuYXBwbGllZExpbmVXaWR0aCA9IHRoaXMuY3VycmVudExpbmVXaWR0aDtcbiAgICAgIHRoaXMubmF0aXZlQ29udGV4dC5saW5lV2lkdGggPSB0aGlzLmFwcGxpZWRMaW5lV2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYXBwbGllZExpbmVDYXAgIT09IHRoaXMuY3VycmVudExpbmVDYXApIHtcbiAgICAgIHRoaXMuYXBwbGllZExpbmVDYXAgPSB0aGlzLmN1cnJlbnRMaW5lQ2FwO1xuICAgICAgdGhpcy5uYXRpdmVDb250ZXh0LmxpbmVDYXAgPSB0aGlzLmFwcGxpZWRMaW5lQ2FwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFwcGxpZWRMaW5lSm9pbiAhPT0gdGhpcy5jdXJyZW50TGluZUpvaW4pIHtcbiAgICAgIHRoaXMuYXBwbGllZExpbmVKb2luID0gdGhpcy5jdXJyZW50TGluZUpvaW47XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQubGluZUpvaW4gPSB0aGlzLmFwcGxpZWRMaW5lSm9pbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hcHBsaWVkTWl0ZXJMaW1pdCAhPT0gdGhpcy5jdXJyZW50TWl0ZXJMaW1pdCkge1xuICAgICAgdGhpcy5hcHBsaWVkTWl0ZXJMaW1pdCA9IHRoaXMuY3VycmVudE1pdGVyTGltaXQ7XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQubWl0ZXJMaW1pdCA9IHRoaXMuYXBwbGllZE1pdGVyTGltaXQ7XG4gICAgfVxuXG4gICAgdGhpcy5uYXRpdmVDb250ZXh0LnN0cm9rZSgpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIENWQ29tcEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMuY29tcGxldGVMYXllcnMgPSBmYWxzZTtcbiAgICB0aGlzLmxheWVycyA9IGRhdGEubGF5ZXJzO1xuICAgIHRoaXMucGVuZGluZ0VsZW1lbnRzID0gW107XG4gICAgdGhpcy5lbGVtZW50cyA9IGNyZWF0ZVNpemVkQXJyYXkodGhpcy5sYXllcnMubGVuZ3RoKTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMudG0gPSBkYXRhLnRtID8gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS50bSwgMCwgZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIHRoaXMpIDoge1xuICAgICAgX3BsYWNlaG9sZGVyOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQ2FudmFzUmVuZGVyZXJCYXNlLCBJQ29tcEVsZW1lbnQsIENWQmFzZUVsZW1lbnRdLCBDVkNvbXBFbGVtZW50KTtcblxuICBDVkNvbXBFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzQ29udGV4dDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICBjdHgubGluZVRvKHRoaXMuZGF0YS53LCAwKTtcbiAgICBjdHgubGluZVRvKHRoaXMuZGF0YS53LCB0aGlzLmRhdGEuaCk7XG4gICAgY3R4LmxpbmVUbygwLCB0aGlzLmRhdGEuaCk7XG4gICAgY3R4LmxpbmVUbygwLCAwKTtcbiAgICBjdHguY2xpcCgpO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnJlbmRlckZyYW1lKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIENWQ29tcEVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICBpZiAodGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxheWVycyA9IG51bGw7XG4gICAgdGhpcy5lbGVtZW50cyA9IG51bGw7XG4gIH07XG5cbiAgQ1ZDb21wRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29tcCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBDVkNvbXBFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIoYW5pbWF0aW9uSXRlbSwgY29uZmlnKSB7XG4gICAgdGhpcy5hbmltYXRpb25JdGVtID0gYW5pbWF0aW9uSXRlbTtcbiAgICB0aGlzLnJlbmRlckNvbmZpZyA9IHtcbiAgICAgIGNsZWFyQ2FudmFzOiBjb25maWcgJiYgY29uZmlnLmNsZWFyQ2FudmFzICE9PSB1bmRlZmluZWQgPyBjb25maWcuY2xlYXJDYW52YXMgOiB0cnVlLFxuICAgICAgY29udGV4dDogY29uZmlnICYmIGNvbmZpZy5jb250ZXh0IHx8IG51bGwsXG4gICAgICBwcm9ncmVzc2l2ZUxvYWQ6IGNvbmZpZyAmJiBjb25maWcucHJvZ3Jlc3NpdmVMb2FkIHx8IGZhbHNlLFxuICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogY29uZmlnICYmIGNvbmZpZy5wcmVzZXJ2ZUFzcGVjdFJhdGlvIHx8ICd4TWlkWU1pZCBtZWV0JyxcbiAgICAgIGltYWdlUHJlc2VydmVBc3BlY3RSYXRpbzogY29uZmlnICYmIGNvbmZpZy5pbWFnZVByZXNlcnZlQXNwZWN0UmF0aW8gfHwgJ3hNaWRZTWlkIHNsaWNlJyxcbiAgICAgIGNvbnRlbnRWaXNpYmlsaXR5OiBjb25maWcgJiYgY29uZmlnLmNvbnRlbnRWaXNpYmlsaXR5IHx8ICd2aXNpYmxlJyxcbiAgICAgIGNsYXNzTmFtZTogY29uZmlnICYmIGNvbmZpZy5jbGFzc05hbWUgfHwgJycsXG4gICAgICBpZDogY29uZmlnICYmIGNvbmZpZy5pZCB8fCAnJyxcbiAgICAgIHJ1bkV4cHJlc3Npb25zOiAhY29uZmlnIHx8IGNvbmZpZy5ydW5FeHByZXNzaW9ucyA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5ydW5FeHByZXNzaW9uc1xuICAgIH07XG4gICAgdGhpcy5yZW5kZXJDb25maWcuZHByID0gY29uZmlnICYmIGNvbmZpZy5kcHIgfHwgMTtcblxuICAgIGlmICh0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlcikge1xuICAgICAgdGhpcy5yZW5kZXJDb25maWcuZHByID0gY29uZmlnICYmIGNvbmZpZy5kcHIgfHwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSAtMTtcbiAgICB0aGlzLmdsb2JhbERhdGEgPSB7XG4gICAgICBmcmFtZU51bTogLTEsXG4gICAgICBfbWRmOiBmYWxzZSxcbiAgICAgIHJlbmRlckNvbmZpZzogdGhpcy5yZW5kZXJDb25maWcsXG4gICAgICBjdXJyZW50R2xvYmFsQWxwaGE6IC0xXG4gICAgfTtcbiAgICB0aGlzLmNvbnRleHREYXRhID0gbmV3IENWQ29udGV4dERhdGEoKTtcbiAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgdGhpcy5wZW5kaW5nRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLnRyYW5zZm9ybU1hdCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLmNvbXBsZXRlTGF5ZXJzID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJlclR5cGUgPSAnY2FudmFzJztcblxuICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcykge1xuICAgICAgdGhpcy5jdHhUcmFuc2Zvcm0gPSB0aGlzLmNvbnRleHREYXRhLnRyYW5zZm9ybS5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhPcGFjaXR5ID0gdGhpcy5jb250ZXh0RGF0YS5vcGFjaXR5LmJpbmQodGhpcy5jb250ZXh0RGF0YSk7XG4gICAgICB0aGlzLmN0eEZpbGxTdHlsZSA9IHRoaXMuY29udGV4dERhdGEuZmlsbFN0eWxlLmJpbmQodGhpcy5jb250ZXh0RGF0YSk7XG4gICAgICB0aGlzLmN0eFN0cm9rZVN0eWxlID0gdGhpcy5jb250ZXh0RGF0YS5zdHJva2VTdHlsZS5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhMaW5lV2lkdGggPSB0aGlzLmNvbnRleHREYXRhLmxpbmVXaWR0aC5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhMaW5lQ2FwID0gdGhpcy5jb250ZXh0RGF0YS5saW5lQ2FwLmJpbmQodGhpcy5jb250ZXh0RGF0YSk7XG4gICAgICB0aGlzLmN0eExpbmVKb2luID0gdGhpcy5jb250ZXh0RGF0YS5saW5lSm9pbi5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhNaXRlckxpbWl0ID0gdGhpcy5jb250ZXh0RGF0YS5taXRlckxpbWl0LmJpbmQodGhpcy5jb250ZXh0RGF0YSk7XG4gICAgICB0aGlzLmN0eEZpbGwgPSB0aGlzLmNvbnRleHREYXRhLmZpbGwuYmluZCh0aGlzLmNvbnRleHREYXRhKTtcbiAgICAgIHRoaXMuY3R4RmlsbFJlY3QgPSB0aGlzLmNvbnRleHREYXRhLmZpbGxSZWN0LmJpbmQodGhpcy5jb250ZXh0RGF0YSk7XG4gICAgICB0aGlzLmN0eFN0cm9rZSA9IHRoaXMuY29udGV4dERhdGEuc3Ryb2tlLmJpbmQodGhpcy5jb250ZXh0RGF0YSk7XG4gICAgICB0aGlzLnNhdmUgPSB0aGlzLmNvbnRleHREYXRhLnNhdmUuYmluZCh0aGlzLmNvbnRleHREYXRhKTtcbiAgICB9XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0NhbnZhc1JlbmRlcmVyQmFzZV0sIENhbnZhc1JlbmRlcmVyKTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQ29tcCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBDVkNvbXBFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gSEJhc2VFbGVtZW50KCkge31cblxuICBIQmFzZUVsZW1lbnQucHJvdG90eXBlID0ge1xuICAgIGNoZWNrQmxlbmRNb2RlOiBmdW5jdGlvbiBjaGVja0JsZW5kTW9kZSgpIHt9LFxuICAgIGluaXRSZW5kZXJlckVsZW1lbnQ6IGZ1bmN0aW9uIGluaXRSZW5kZXJlckVsZW1lbnQoKSB7XG4gICAgICB0aGlzLmJhc2VFbGVtZW50ID0gY3JlYXRlVGFnKHRoaXMuZGF0YS50ZyB8fCAnZGl2Jyk7XG5cbiAgICAgIGlmICh0aGlzLmRhdGEuaGFzTWFzaykge1xuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQgPSBjcmVhdGVOUygnc3ZnJyk7XG4gICAgICAgIHRoaXMubGF5ZXJFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcbiAgICAgICAgdGhpcy5tYXNrZWRFbGVtZW50ID0gdGhpcy5sYXllckVsZW1lbnQ7XG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmxheWVyRWxlbWVudCk7XG4gICAgICAgIHRoaXMuYmFzZUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5zdmdFbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGF5ZXJFbGVtZW50ID0gdGhpcy5iYXNlRWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgc3R5bGVEaXYodGhpcy5iYXNlRWxlbWVudCk7XG4gICAgfSxcbiAgICBjcmVhdGVDb250YWluZXJFbGVtZW50czogZnVuY3Rpb24gY3JlYXRlQ29udGFpbmVyRWxlbWVudHMoKSB7XG4gICAgICB0aGlzLnJlbmRlcmFibGVFZmZlY3RzTWFuYWdlciA9IG5ldyBDVkVmZmVjdHModGhpcyk7XG4gICAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudCA9IHRoaXMuYmFzZUVsZW1lbnQ7XG4gICAgICB0aGlzLm1hc2tlZEVsZW1lbnQgPSB0aGlzLmxheWVyRWxlbWVudDtcblxuICAgICAgaWYgKHRoaXMuZGF0YS5sbikge1xuICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5kYXRhLmxuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZGF0YS5jbCkge1xuICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5kYXRhLmNsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZGF0YS5ibSAhPT0gMCkge1xuICAgICAgICB0aGlzLnNldEJsZW5kTW9kZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyRWxlbWVudDogZnVuY3Rpb24gcmVuZGVyRWxlbWVudCgpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1lZEVsZW1lbnRTdHlsZSA9IHRoaXMudHJhbnNmb3JtZWRFbGVtZW50ID8gdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQuc3R5bGUgOiB7fTtcblxuICAgICAgaWYgKHRoaXMuZmluYWxUcmFuc2Zvcm0uX21hdE1kZikge1xuICAgICAgICB2YXIgbWF0cml4VmFsdWUgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1hdC50b0NTUygpO1xuICAgICAgICB0cmFuc2Zvcm1lZEVsZW1lbnRTdHlsZS50cmFuc2Zvcm0gPSBtYXRyaXhWYWx1ZTtcbiAgICAgICAgdHJhbnNmb3JtZWRFbGVtZW50U3R5bGUud2Via2l0VHJhbnNmb3JtID0gbWF0cml4VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmZpbmFsVHJhbnNmb3JtLl9vcE1kZikge1xuICAgICAgICB0cmFuc2Zvcm1lZEVsZW1lbnRTdHlsZS5vcGFjaXR5ID0gdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5vLnY7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJGcmFtZTogZnVuY3Rpb24gcmVuZGVyRnJhbWUoKSB7XG4gICAgICAvLyBJZiBpdCBpcyBleHBvcnRlZCBhcyBoaWRkZW4gKGRhdGEuaGQgPT09IHRydWUpIG5vIG5lZWQgdG8gcmVuZGVyXG4gICAgICAvLyBJZiBpdCBpcyBub3QgdmlzaWJsZSBubyBuZWVkIHRvIHJlbmRlclxuICAgICAgaWYgKHRoaXMuZGF0YS5oZCB8fCB0aGlzLmhpZGRlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyVHJhbnNmb3JtKCk7XG4gICAgICB0aGlzLnJlbmRlclJlbmRlcmFibGUoKTtcbiAgICAgIHRoaXMucmVuZGVyRWxlbWVudCgpO1xuICAgICAgdGhpcy5yZW5kZXJJbm5lckNvbnRlbnQoKTtcblxuICAgICAgaWYgKHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudCA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLm1hdHRlRWxlbWVudCkge1xuICAgICAgICB0aGlzLm1hdHRlRWxlbWVudCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1hc2tNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMubWFza01hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1hc2tNYW5hZ2VyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzOiBmdW5jdGlvbiBjcmVhdGVSZW5kZXJhYmxlQ29tcG9uZW50cygpIHtcbiAgICAgIHRoaXMubWFza01hbmFnZXIgPSBuZXcgTWFza0VsZW1lbnQodGhpcy5kYXRhLCB0aGlzLCB0aGlzLmdsb2JhbERhdGEpO1xuICAgIH0sXG4gICAgYWRkRWZmZWN0czogZnVuY3Rpb24gYWRkRWZmZWN0cygpIHt9LFxuICAgIHNldE1hdHRlOiBmdW5jdGlvbiBzZXRNYXR0ZSgpIHt9XG4gIH07XG4gIEhCYXNlRWxlbWVudC5wcm90b3R5cGUuZ2V0QmFzZUVsZW1lbnQgPSBTVkdCYXNlRWxlbWVudC5wcm90b3R5cGUuZ2V0QmFzZUVsZW1lbnQ7XG4gIEhCYXNlRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveUJhc2VFbGVtZW50ID0gSEJhc2VFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95O1xuICBIQmFzZUVsZW1lbnQucHJvdG90eXBlLmJ1aWxkRWxlbWVudFBhcmVudGluZyA9IEJhc2VSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRFbGVtZW50UGFyZW50aW5nO1xuXG4gIGZ1bmN0aW9uIEhTb2xpZEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBIQmFzZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZURPTUVsZW1lbnRdLCBIU29saWRFbGVtZW50KTtcblxuICBIU29saWRFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWN0O1xuXG4gICAgaWYgKHRoaXMuZGF0YS5oYXNNYXNrKSB7XG4gICAgICByZWN0ID0gY3JlYXRlTlMoJ3JlY3QnKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuZGF0YS5zdyk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5kYXRhLnNoKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCdmaWxsJywgdGhpcy5kYXRhLnNjKTtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5kYXRhLnN3KTtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuZGF0YS5zaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY3QgPSBjcmVhdGVUYWcoJ2RpdicpO1xuICAgICAgcmVjdC5zdHlsZS53aWR0aCA9IHRoaXMuZGF0YS5zdyArICdweCc7XG4gICAgICByZWN0LnN0eWxlLmhlaWdodCA9IHRoaXMuZGF0YS5zaCArICdweCc7XG4gICAgICByZWN0LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZGF0YS5zYztcbiAgICB9XG5cbiAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChyZWN0KTtcbiAgfTtcblxuICBmdW5jdGlvbiBIU2hhcGVFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICAvLyBMaXN0IG9mIGRyYXdhYmxlIGVsZW1lbnRzXG4gICAgdGhpcy5zaGFwZXMgPSBbXTsgLy8gRnVsbCBzaGFwZSBkYXRhXG5cbiAgICB0aGlzLnNoYXBlc0RhdGEgPSBkYXRhLnNoYXBlczsgLy8gTGlzdCBvZiBzdHlsZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gc2hhcGVzXG5cbiAgICB0aGlzLnN0eWxlc0xpc3QgPSBbXTsgLy8gTGlzdCBvZiBtb2RpZmllcnMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gc2hhcGVzXG5cbiAgICB0aGlzLnNoYXBlTW9kaWZpZXJzID0gW107IC8vIExpc3Qgb2YgaXRlbXMgaW4gc2hhcGUgdHJlZVxuXG4gICAgdGhpcy5pdGVtc0RhdGEgPSBbXTsgLy8gTGlzdCBvZiBpdGVtcyBpbiBwcmV2aW91cyBzaGFwZSB0cmVlXG5cbiAgICB0aGlzLnByb2Nlc3NlZEVsZW1lbnRzID0gW107IC8vIExpc3Qgb2YgYW5pbWF0ZWQgY29tcG9uZW50c1xuXG4gICAgdGhpcy5hbmltYXRlZENvbnRlbnRzID0gW107XG4gICAgdGhpcy5zaGFwZXNDb250YWluZXIgPSBjcmVhdGVOUygnZycpO1xuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7IC8vIE1vdmluZyBhbnkgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGdldCB0b28gbXVjaCBhY2Nlc3MgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gYmVjYXVzZSBvZiB2OCB3YXkgb2YgaGFuZGxpbmcgbW9yZSB0aGFuIDEwIHByb3BlcnRpZXMuXG4gICAgLy8gTGlzdCBvZiBlbGVtZW50cyB0aGF0IGhhdmUgYmVlbiBjcmVhdGVkXG5cbiAgICB0aGlzLnByZXZWaWV3RGF0YSA9IFtdO1xuICAgIHRoaXMuY3VycmVudEJCb3ggPSB7XG4gICAgICB4OiA5OTk5OTksXG4gICAgICB5OiAtOTk5OTk5LFxuICAgICAgaDogMCxcbiAgICAgIHc6IDBcbiAgICB9O1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSFNvbGlkRWxlbWVudCwgU1ZHU2hhcGVFbGVtZW50LCBIQmFzZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZUVsZW1lbnRdLCBIU2hhcGVFbGVtZW50KTtcbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuX3JlbmRlclNoYXBlRnJhbWUgPSBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQ7XG5cbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udDtcbiAgICB0aGlzLmJhc2VFbGVtZW50LnN0eWxlLmZvbnRTaXplID0gMDtcblxuICAgIGlmICh0aGlzLmRhdGEuaGFzTWFzaykge1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5zaGFwZXNDb250YWluZXIpO1xuICAgICAgY29udCA9IHRoaXMuc3ZnRWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udCA9IGNyZWF0ZU5TKCdzdmcnKTtcbiAgICAgIHZhciBzaXplID0gdGhpcy5jb21wLmRhdGEgPyB0aGlzLmNvbXAuZGF0YSA6IHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZTtcbiAgICAgIGNvbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHNpemUudyk7XG4gICAgICBjb250LnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc2l6ZS5oKTtcbiAgICAgIGNvbnQuYXBwZW5kQ2hpbGQodGhpcy5zaGFwZXNDb250YWluZXIpO1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQoY29udCk7XG4gICAgfVxuXG4gICAgdGhpcy5zZWFyY2hTaGFwZXModGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdGhpcy5wcmV2Vmlld0RhdGEsIHRoaXMuc2hhcGVzQ29udGFpbmVyLCAwLCBbXSwgdHJ1ZSk7XG4gICAgdGhpcy5maWx0ZXJVbmlxdWVTaGFwZXMoKTtcbiAgICB0aGlzLnNoYXBlQ29udCA9IGNvbnQ7XG4gIH07XG5cbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuZ2V0VHJhbnNmb3JtZWRQb2ludCA9IGZ1bmN0aW9uICh0cmFuc2Zvcm1lcnMsIHBvaW50KSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRyYW5zZm9ybWVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHBvaW50ID0gdHJhbnNmb3JtZXJzW2ldLm1Qcm9wcy52LmFwcGx5VG9Qb2ludEFycmF5KHBvaW50WzBdLCBwb2ludFsxXSwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50O1xuICB9O1xuXG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNhbGN1bGF0ZVNoYXBlQm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoaXRlbSwgYm91bmRpbmdCb3gpIHtcbiAgICB2YXIgc2hhcGUgPSBpdGVtLnNoLnY7XG4gICAgdmFyIHRyYW5zZm9ybWVycyA9IGl0ZW0udHJhbnNmb3JtZXJzO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBzaGFwZS5fbGVuZ3RoO1xuICAgIHZhciB2UG9pbnQ7XG4gICAgdmFyIG9Qb2ludDtcbiAgICB2YXIgbmV4dElQb2ludDtcbiAgICB2YXIgbmV4dFZQb2ludDtcblxuICAgIGlmIChsZW4gPD0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpICs9IDEpIHtcbiAgICAgIHZQb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLnZbaV0pO1xuICAgICAgb1BvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50KHRyYW5zZm9ybWVycywgc2hhcGUub1tpXSk7XG4gICAgICBuZXh0SVBvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50KHRyYW5zZm9ybWVycywgc2hhcGUuaVtpICsgMV0pO1xuICAgICAgbmV4dFZQb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLnZbaSArIDFdKTtcbiAgICAgIHRoaXMuY2hlY2tCb3VuZHModlBvaW50LCBvUG9pbnQsIG5leHRJUG9pbnQsIG5leHRWUG9pbnQsIGJvdW5kaW5nQm94KTtcbiAgICB9XG5cbiAgICBpZiAoc2hhcGUuYykge1xuICAgICAgdlBvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50KHRyYW5zZm9ybWVycywgc2hhcGUudltpXSk7XG4gICAgICBvUG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS5vW2ldKTtcbiAgICAgIG5leHRJUG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS5pWzBdKTtcbiAgICAgIG5leHRWUG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS52WzBdKTtcbiAgICAgIHRoaXMuY2hlY2tCb3VuZHModlBvaW50LCBvUG9pbnQsIG5leHRJUG9pbnQsIG5leHRWUG9pbnQsIGJvdW5kaW5nQm94KTtcbiAgICB9XG4gIH07XG5cbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuY2hlY2tCb3VuZHMgPSBmdW5jdGlvbiAodlBvaW50LCBvUG9pbnQsIG5leHRJUG9pbnQsIG5leHRWUG9pbnQsIGJvdW5kaW5nQm94KSB7XG4gICAgdGhpcy5nZXRCb3VuZHNPZkN1cnZlKHZQb2ludCwgb1BvaW50LCBuZXh0SVBvaW50LCBuZXh0VlBvaW50KTtcbiAgICB2YXIgYm91bmRzID0gdGhpcy5zaGFwZUJvdW5kaW5nQm94O1xuICAgIGJvdW5kaW5nQm94LnggPSBibU1pbihib3VuZHMubGVmdCwgYm91bmRpbmdCb3gueCk7XG4gICAgYm91bmRpbmdCb3gueE1heCA9IGJtTWF4KGJvdW5kcy5yaWdodCwgYm91bmRpbmdCb3gueE1heCk7XG4gICAgYm91bmRpbmdCb3gueSA9IGJtTWluKGJvdW5kcy50b3AsIGJvdW5kaW5nQm94LnkpO1xuICAgIGJvdW5kaW5nQm94LnlNYXggPSBibU1heChib3VuZHMuYm90dG9tLCBib3VuZGluZ0JveC55TWF4KTtcbiAgfTtcblxuICBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5zaGFwZUJvdW5kaW5nQm94ID0ge1xuICAgIGxlZnQ6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIGJvdHRvbTogMFxuICB9O1xuICBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS50ZW1wQm91bmRpbmdCb3ggPSB7XG4gICAgeDogMCxcbiAgICB4TWF4OiAwLFxuICAgIHk6IDAsXG4gICAgeU1heDogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfTtcblxuICBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5nZXRCb3VuZHNPZkN1cnZlID0gZnVuY3Rpb24gKHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgdmFyIGJvdW5kcyA9IFtbcDBbMF0sIHAzWzBdXSwgW3AwWzFdLCBwM1sxXV1dO1xuXG4gICAgZm9yICh2YXIgYSwgYiwgYywgdCwgYjJhYywgdDEsIHQyLCBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wbHVzcGx1c1xuICAgICAgYiA9IDYgKiBwMFtpXSAtIDEyICogcDFbaV0gKyA2ICogcDJbaV07XG4gICAgICBhID0gLTMgKiBwMFtpXSArIDkgKiBwMVtpXSAtIDkgKiBwMltpXSArIDMgKiBwM1tpXTtcbiAgICAgIGMgPSAzICogcDFbaV0gLSAzICogcDBbaV07XG4gICAgICBiIHw9IDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYml0d2lzZVxuXG4gICAgICBhIHw9IDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYml0d2lzZVxuXG4gICAgICBjIHw9IDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYml0d2lzZVxuXG4gICAgICBpZiAoYSA9PT0gMCAmJiBiID09PSAwKSB7Ly9cbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gMCkge1xuICAgICAgICB0ID0gLWMgLyBiO1xuXG4gICAgICAgIGlmICh0ID4gMCAmJiB0IDwgMSkge1xuICAgICAgICAgIGJvdW5kc1tpXS5wdXNoKHRoaXMuY2FsY3VsYXRlRih0LCBwMCwgcDEsIHAyLCBwMywgaSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiMmFjID0gYiAqIGIgLSA0ICogYyAqIGE7XG5cbiAgICAgICAgaWYgKGIyYWMgPj0gMCkge1xuICAgICAgICAgIHQxID0gKC1iICsgYm1TcXJ0KGIyYWMpKSAvICgyICogYSk7XG4gICAgICAgICAgaWYgKHQxID4gMCAmJiB0MSA8IDEpIGJvdW5kc1tpXS5wdXNoKHRoaXMuY2FsY3VsYXRlRih0MSwgcDAsIHAxLCBwMiwgcDMsIGkpKTtcbiAgICAgICAgICB0MiA9ICgtYiAtIGJtU3FydChiMmFjKSkgLyAoMiAqIGEpO1xuICAgICAgICAgIGlmICh0MiA+IDAgJiYgdDIgPCAxKSBib3VuZHNbaV0ucHVzaCh0aGlzLmNhbGN1bGF0ZUYodDIsIHAwLCBwMSwgcDIsIHAzLCBpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNoYXBlQm91bmRpbmdCb3gubGVmdCA9IGJtTWluLmFwcGx5KG51bGwsIGJvdW5kc1swXSk7XG4gICAgdGhpcy5zaGFwZUJvdW5kaW5nQm94LnRvcCA9IGJtTWluLmFwcGx5KG51bGwsIGJvdW5kc1sxXSk7XG4gICAgdGhpcy5zaGFwZUJvdW5kaW5nQm94LnJpZ2h0ID0gYm1NYXguYXBwbHkobnVsbCwgYm91bmRzWzBdKTtcbiAgICB0aGlzLnNoYXBlQm91bmRpbmdCb3guYm90dG9tID0gYm1NYXguYXBwbHkobnVsbCwgYm91bmRzWzFdKTtcbiAgfTtcblxuICBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jYWxjdWxhdGVGID0gZnVuY3Rpb24gKHQsIHAwLCBwMSwgcDIsIHAzLCBpKSB7XG4gICAgcmV0dXJuIGJtUG93KDEgLSB0LCAzKSAqIHAwW2ldICsgMyAqIGJtUG93KDEgLSB0LCAyKSAqIHQgKiBwMVtpXSArIDMgKiAoMSAtIHQpICogYm1Qb3codCwgMikgKiBwMltpXSArIGJtUG93KHQsIDMpICogcDNbaV07XG4gIH07XG5cbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuY2FsY3VsYXRlQm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoaXRlbXNEYXRhLCBib3VuZGluZ0JveCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBpdGVtc0RhdGEubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAoaXRlbXNEYXRhW2ldICYmIGl0ZW1zRGF0YVtpXS5zaCkge1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZVNoYXBlQm91bmRpbmdCb3goaXRlbXNEYXRhW2ldLCBib3VuZGluZ0JveCk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1zRGF0YVtpXSAmJiBpdGVtc0RhdGFbaV0uaXQpIHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZGluZ0JveChpdGVtc0RhdGFbaV0uaXQsIGJvdW5kaW5nQm94KTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbXNEYXRhW2ldICYmIGl0ZW1zRGF0YVtpXS5zdHlsZSAmJiBpdGVtc0RhdGFbaV0udykge1xuICAgICAgICB0aGlzLmV4cGFuZFN0cm9rZUJvdW5kaW5nQm94KGl0ZW1zRGF0YVtpXS53LCBib3VuZGluZ0JveCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmV4cGFuZFN0cm9rZUJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKHdpZHRoUHJvcGVydHksIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHdpZHRoID0gMDtcblxuICAgIGlmICh3aWR0aFByb3BlcnR5LmtleWZyYW1lcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3aWR0aFByb3BlcnR5LmtleWZyYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIga2Z3ID0gd2lkdGhQcm9wZXJ0eS5rZXlmcmFtZXNbaV0ucztcblxuICAgICAgICBpZiAoa2Z3ID4gd2lkdGgpIHtcbiAgICAgICAgICB3aWR0aCA9IGtmdztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aWR0aCAqPSB3aWR0aFByb3BlcnR5Lm11bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gd2lkdGhQcm9wZXJ0eS52ICogd2lkdGhQcm9wZXJ0eS5tdWx0O1xuICAgIH1cblxuICAgIGJvdW5kaW5nQm94LnggLT0gd2lkdGg7XG4gICAgYm91bmRpbmdCb3gueE1heCArPSB3aWR0aDtcbiAgICBib3VuZGluZ0JveC55IC09IHdpZHRoO1xuICAgIGJvdW5kaW5nQm94LnlNYXggKz0gd2lkdGg7XG4gIH07XG5cbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuY3VycmVudEJveENvbnRhaW5zID0gZnVuY3Rpb24gKGJveCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRCQm94LnggPD0gYm94LnggJiYgdGhpcy5jdXJyZW50QkJveC55IDw9IGJveC55ICYmIHRoaXMuY3VycmVudEJCb3gud2lkdGggKyB0aGlzLmN1cnJlbnRCQm94LnggPj0gYm94LnggKyBib3gud2lkdGggJiYgdGhpcy5jdXJyZW50QkJveC5oZWlnaHQgKyB0aGlzLmN1cnJlbnRCQm94LnkgPj0gYm94LnkgKyBib3guaGVpZ2h0O1xuICB9O1xuXG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9yZW5kZXJTaGFwZUZyYW1lKCk7XG5cbiAgICBpZiAoIXRoaXMuaGlkZGVuICYmICh0aGlzLl9pc0ZpcnN0RnJhbWUgfHwgdGhpcy5fbWRmKSkge1xuICAgICAgdmFyIHRlbXBCb3VuZGluZ0JveCA9IHRoaXMudGVtcEJvdW5kaW5nQm94O1xuICAgICAgdmFyIG1heCA9IDk5OTk5OTtcbiAgICAgIHRlbXBCb3VuZGluZ0JveC54ID0gbWF4O1xuICAgICAgdGVtcEJvdW5kaW5nQm94LnhNYXggPSAtbWF4O1xuICAgICAgdGVtcEJvdW5kaW5nQm94LnkgPSBtYXg7XG4gICAgICB0ZW1wQm91bmRpbmdCb3gueU1heCA9IC1tYXg7XG4gICAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kaW5nQm94KHRoaXMuaXRlbXNEYXRhLCB0ZW1wQm91bmRpbmdCb3gpO1xuICAgICAgdGVtcEJvdW5kaW5nQm94LndpZHRoID0gdGVtcEJvdW5kaW5nQm94LnhNYXggPCB0ZW1wQm91bmRpbmdCb3gueCA/IDAgOiB0ZW1wQm91bmRpbmdCb3gueE1heCAtIHRlbXBCb3VuZGluZ0JveC54O1xuICAgICAgdGVtcEJvdW5kaW5nQm94LmhlaWdodCA9IHRlbXBCb3VuZGluZ0JveC55TWF4IDwgdGVtcEJvdW5kaW5nQm94LnkgPyAwIDogdGVtcEJvdW5kaW5nQm94LnlNYXggLSB0ZW1wQm91bmRpbmdCb3gueTsgLy8gdmFyIHRlbXBCb3VuZGluZ0JveCA9IHRoaXMuc2hhcGVDb250LmdldEJCb3goKTtcblxuICAgICAgaWYgKHRoaXMuY3VycmVudEJveENvbnRhaW5zKHRlbXBCb3VuZGluZ0JveCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5jdXJyZW50QkJveC53ICE9PSB0ZW1wQm91bmRpbmdCb3gud2lkdGgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QkJveC53ID0gdGVtcEJvdW5kaW5nQm94LndpZHRoO1xuICAgICAgICB0aGlzLnNoYXBlQ29udC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGVtcEJvdW5kaW5nQm94LndpZHRoKTtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRCQm94LmggIT09IHRlbXBCb3VuZGluZ0JveC5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QkJveC5oID0gdGVtcEJvdW5kaW5nQm94LmhlaWdodDtcbiAgICAgICAgdGhpcy5zaGFwZUNvbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0ZW1wQm91bmRpbmdCb3guaGVpZ2h0KTtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VkIHx8IHRoaXMuY3VycmVudEJCb3gueCAhPT0gdGVtcEJvdW5kaW5nQm94LnggfHwgdGhpcy5jdXJyZW50QkJveC55ICE9PSB0ZW1wQm91bmRpbmdCb3gueSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRCQm94LncgPSB0ZW1wQm91bmRpbmdCb3gud2lkdGg7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3guaCA9IHRlbXBCb3VuZGluZ0JveC5oZWlnaHQ7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3gueCA9IHRlbXBCb3VuZGluZ0JveC54O1xuICAgICAgICB0aGlzLmN1cnJlbnRCQm94LnkgPSB0ZW1wQm91bmRpbmdCb3gueTtcbiAgICAgICAgdGhpcy5zaGFwZUNvbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgdGhpcy5jdXJyZW50QkJveC54ICsgJyAnICsgdGhpcy5jdXJyZW50QkJveC55ICsgJyAnICsgdGhpcy5jdXJyZW50QkJveC53ICsgJyAnICsgdGhpcy5jdXJyZW50QkJveC5oKTtcbiAgICAgICAgdmFyIHNoYXBlU3R5bGUgPSB0aGlzLnNoYXBlQ29udC5zdHlsZTtcbiAgICAgICAgdmFyIHNoYXBlVHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgdGhpcy5jdXJyZW50QkJveC54ICsgJ3B4LCcgKyB0aGlzLmN1cnJlbnRCQm94LnkgKyAncHgpJztcbiAgICAgICAgc2hhcGVTdHlsZS50cmFuc2Zvcm0gPSBzaGFwZVRyYW5zZm9ybTtcbiAgICAgICAgc2hhcGVTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBzaGFwZVRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gSFRleHRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLnRleHRTcGFucyA9IFtdO1xuICAgIHRoaXMudGV4dFBhdGhzID0gW107XG4gICAgdGhpcy5jdXJyZW50QkJveCA9IHtcbiAgICAgIHg6IDk5OTk5OSxcbiAgICAgIHk6IC05OTk5OTksXG4gICAgICBoOiAwLFxuICAgICAgdzogMFxuICAgIH07XG4gICAgdGhpcy5yZW5kZXJUeXBlID0gJ3N2Zyc7XG4gICAgdGhpcy5pc01hc2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBIQmFzZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZURPTUVsZW1lbnQsIElUZXh0RWxlbWVudF0sIEhUZXh0RWxlbWVudCk7XG5cbiAgSFRleHRFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNNYXNrZWQgPSB0aGlzLmNoZWNrTWFza3MoKTtcblxuICAgIGlmICh0aGlzLmlzTWFza2VkKSB7XG4gICAgICB0aGlzLnJlbmRlclR5cGUgPSAnc3ZnJztcbiAgICAgIHRoaXMuY29tcFcgPSB0aGlzLmNvbXAuZGF0YS53O1xuICAgICAgdGhpcy5jb21wSCA9IHRoaXMuY29tcC5kYXRhLmg7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuY29tcFcpO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5jb21wSCk7XG4gICAgICB2YXIgZyA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICB0aGlzLm1hc2tlZEVsZW1lbnQuYXBwZW5kQ2hpbGQoZyk7XG4gICAgICB0aGlzLmlubmVyRWxlbSA9IGc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyVHlwZSA9ICdodG1sJztcbiAgICAgIHRoaXMuaW5uZXJFbGVtID0gdGhpcy5sYXllckVsZW1lbnQ7XG4gICAgfVxuXG4gICAgdGhpcy5jaGVja1BhcmVudGluZygpO1xuICB9O1xuXG4gIEhUZXh0RWxlbWVudC5wcm90b3R5cGUuYnVpbGROZXdUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkb2N1bWVudERhdGEgPSB0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YTtcbiAgICB0aGlzLnJlbmRlcmVkTGV0dGVycyA9IGNyZWF0ZVNpemVkQXJyYXkoZG9jdW1lbnREYXRhLmwgPyBkb2N1bWVudERhdGEubC5sZW5ndGggOiAwKTtcbiAgICB2YXIgaW5uZXJFbGVtU3R5bGUgPSB0aGlzLmlubmVyRWxlbS5zdHlsZTtcbiAgICB2YXIgdGV4dENvbG9yID0gZG9jdW1lbnREYXRhLmZjID8gdGhpcy5idWlsZENvbG9yKGRvY3VtZW50RGF0YS5mYykgOiAncmdiYSgwLDAsMCwwKSc7XG4gICAgaW5uZXJFbGVtU3R5bGUuZmlsbCA9IHRleHRDb2xvcjtcbiAgICBpbm5lckVsZW1TdHlsZS5jb2xvciA9IHRleHRDb2xvcjtcblxuICAgIGlmIChkb2N1bWVudERhdGEuc2MpIHtcbiAgICAgIGlubmVyRWxlbVN0eWxlLnN0cm9rZSA9IHRoaXMuYnVpbGRDb2xvcihkb2N1bWVudERhdGEuc2MpO1xuICAgICAgaW5uZXJFbGVtU3R5bGUuc3Ryb2tlV2lkdGggPSBkb2N1bWVudERhdGEuc3cgKyAncHgnO1xuICAgIH1cblxuICAgIHZhciBmb250RGF0YSA9IHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKTtcblxuICAgIGlmICghdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmNoYXJzKSB7XG4gICAgICBpbm5lckVsZW1TdHlsZS5mb250U2l6ZSA9IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKyAncHgnO1xuICAgICAgaW5uZXJFbGVtU3R5bGUubGluZUhlaWdodCA9IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKyAncHgnO1xuXG4gICAgICBpZiAoZm9udERhdGEuZkNsYXNzKSB7XG4gICAgICAgIHRoaXMuaW5uZXJFbGVtLmNsYXNzTmFtZSA9IGZvbnREYXRhLmZDbGFzcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlubmVyRWxlbVN0eWxlLmZvbnRGYW1pbHkgPSBmb250RGF0YS5mRmFtaWx5O1xuICAgICAgICB2YXIgZldlaWdodCA9IGRvY3VtZW50RGF0YS5mV2VpZ2h0O1xuICAgICAgICB2YXIgZlN0eWxlID0gZG9jdW1lbnREYXRhLmZTdHlsZTtcbiAgICAgICAgaW5uZXJFbGVtU3R5bGUuZm9udFN0eWxlID0gZlN0eWxlO1xuICAgICAgICBpbm5lckVsZW1TdHlsZS5mb250V2VpZ2h0ID0gZldlaWdodDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuICAgIHZhciBsZXR0ZXJzID0gZG9jdW1lbnREYXRhLmw7XG4gICAgbGVuID0gbGV0dGVycy5sZW5ndGg7XG4gICAgdmFyIHRTcGFuO1xuICAgIHZhciB0UGFyZW50O1xuICAgIHZhciB0Q29udDtcbiAgICB2YXIgbWF0cml4SGVscGVyID0gdGhpcy5tSGVscGVyO1xuICAgIHZhciBzaGFwZXM7XG4gICAgdmFyIHNoYXBlU3RyID0gJyc7XG4gICAgdmFyIGNudCA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuY2hhcnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRleHRQYXRoc1tjbnRdKSB7XG4gICAgICAgICAgdFNwYW4gPSBjcmVhdGVOUygncGF0aCcpO1xuICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCBsaW5lQ2FwRW51bVsxXSk7XG4gICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCBsaW5lSm9pbkVudW1bMl0pO1xuICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW1pdGVybGltaXQnLCAnNCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRTcGFuID0gdGhpcy50ZXh0UGF0aHNbY250XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5pc01hc2tlZCkge1xuICAgICAgICAgIGlmICh0aGlzLnRleHRTcGFuc1tjbnRdKSB7XG4gICAgICAgICAgICB0UGFyZW50ID0gdGhpcy50ZXh0U3BhbnNbY250XTtcbiAgICAgICAgICAgIHRDb250ID0gdFBhcmVudC5jaGlsZHJlblswXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdFBhcmVudCA9IGNyZWF0ZVRhZygnZGl2Jyk7XG4gICAgICAgICAgICB0UGFyZW50LnN0eWxlLmxpbmVIZWlnaHQgPSAwO1xuICAgICAgICAgICAgdENvbnQgPSBjcmVhdGVOUygnc3ZnJyk7XG4gICAgICAgICAgICB0Q29udC5hcHBlbmRDaGlsZCh0U3Bhbik7XG4gICAgICAgICAgICBzdHlsZURpdih0UGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNNYXNrZWQpIHtcbiAgICAgICAgaWYgKHRoaXMudGV4dFNwYW5zW2NudF0pIHtcbiAgICAgICAgICB0UGFyZW50ID0gdGhpcy50ZXh0U3BhbnNbY250XTtcbiAgICAgICAgICB0U3BhbiA9IHRoaXMudGV4dFBhdGhzW2NudF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdFBhcmVudCA9IGNyZWF0ZVRhZygnc3BhbicpO1xuICAgICAgICAgIHN0eWxlRGl2KHRQYXJlbnQpO1xuICAgICAgICAgIHRTcGFuID0gY3JlYXRlVGFnKCdzcGFuJyk7XG4gICAgICAgICAgc3R5bGVEaXYodFNwYW4pO1xuICAgICAgICAgIHRQYXJlbnQuYXBwZW5kQ2hpbGQodFNwYW4pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0U3BhbiA9IHRoaXMudGV4dFBhdGhzW2NudF0gPyB0aGlzLnRleHRQYXRoc1tjbnRdIDogY3JlYXRlTlMoJ3RleHQnKTtcbiAgICAgIH0gLy8gdFNwYW4uc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuXG5cbiAgICAgIGlmICh0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuY2hhcnMpIHtcbiAgICAgICAgdmFyIGNoYXJEYXRhID0gdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldENoYXJEYXRhKGRvY3VtZW50RGF0YS5maW5hbFRleHRbaV0sIGZvbnREYXRhLmZTdHlsZSwgdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpLmZGYW1pbHkpO1xuICAgICAgICB2YXIgc2hhcGVEYXRhO1xuXG4gICAgICAgIGlmIChjaGFyRGF0YSkge1xuICAgICAgICAgIHNoYXBlRGF0YSA9IGNoYXJEYXRhLmRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hhcGVEYXRhID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdHJpeEhlbHBlci5yZXNldCgpO1xuXG4gICAgICAgIGlmIChzaGFwZURhdGEgJiYgc2hhcGVEYXRhLnNoYXBlcyAmJiBzaGFwZURhdGEuc2hhcGVzLmxlbmd0aCkge1xuICAgICAgICAgIHNoYXBlcyA9IHNoYXBlRGF0YS5zaGFwZXNbMF0uaXQ7XG4gICAgICAgICAgbWF0cml4SGVscGVyLnNjYWxlKGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDAsIGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDApO1xuICAgICAgICAgIHNoYXBlU3RyID0gdGhpcy5jcmVhdGVQYXRoU2hhcGUobWF0cml4SGVscGVyLCBzaGFwZXMpO1xuICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnZCcsIHNoYXBlU3RyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5pc01hc2tlZCkge1xuICAgICAgICAgIHRoaXMuaW5uZXJFbGVtLmFwcGVuZENoaWxkKHRQYXJlbnQpO1xuXG4gICAgICAgICAgaWYgKHNoYXBlRGF0YSAmJiBzaGFwZURhdGEuc2hhcGVzKSB7XG4gICAgICAgICAgICAvLyBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkIGlzIG5lZWRlZCB0byBnZXQgZXhhY3QgbWVhc3VyZSBvZiBzaGFwZVxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0Q29udCk7XG4gICAgICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSB0Q29udC5nZXRCQm94KCk7XG4gICAgICAgICAgICB0Q29udC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgYm91bmRpbmdCb3gud2lkdGggKyAyKTtcbiAgICAgICAgICAgIHRDb250LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYm91bmRpbmdCb3guaGVpZ2h0ICsgMik7XG4gICAgICAgICAgICB0Q29udC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBib3VuZGluZ0JveC54IC0gMSArICcgJyArIChib3VuZGluZ0JveC55IC0gMSkgKyAnICcgKyAoYm91bmRpbmdCb3gud2lkdGggKyAyKSArICcgJyArIChib3VuZGluZ0JveC5oZWlnaHQgKyAyKSk7XG4gICAgICAgICAgICB2YXIgdENvbnRTdHlsZSA9IHRDb250LnN0eWxlO1xuICAgICAgICAgICAgdmFyIHRDb250VHJhbnNsYXRpb24gPSAndHJhbnNsYXRlKCcgKyAoYm91bmRpbmdCb3gueCAtIDEpICsgJ3B4LCcgKyAoYm91bmRpbmdCb3gueSAtIDEpICsgJ3B4KSc7XG4gICAgICAgICAgICB0Q29udFN0eWxlLnRyYW5zZm9ybSA9IHRDb250VHJhbnNsYXRpb247XG4gICAgICAgICAgICB0Q29udFN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHRDb250VHJhbnNsYXRpb247XG4gICAgICAgICAgICBsZXR0ZXJzW2ldLnlPZmZzZXQgPSBib3VuZGluZ0JveC55IC0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdENvbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIDEpO1xuICAgICAgICAgICAgdENvbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0UGFyZW50LmFwcGVuZENoaWxkKHRDb250KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmlubmVyRWxlbS5hcHBlbmRDaGlsZCh0U3Bhbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRTcGFuLnRleHRDb250ZW50ID0gbGV0dGVyc1tpXS52YWw7XG4gICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnLCAneG1sOnNwYWNlJywgJ3ByZXNlcnZlJyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzTWFza2VkKSB7XG4gICAgICAgICAgdGhpcy5pbm5lckVsZW0uYXBwZW5kQ2hpbGQodFBhcmVudCk7IC8vXG5cbiAgICAgICAgICB2YXIgdFN0eWxlID0gdFNwYW4uc3R5bGU7XG4gICAgICAgICAgdmFyIHRTcGFuVHJhbnNsYXRpb24gPSAndHJhbnNsYXRlM2QoMCwnICsgLWRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxLjIgKyAncHgsMCknO1xuICAgICAgICAgIHRTdHlsZS50cmFuc2Zvcm0gPSB0U3BhblRyYW5zbGF0aW9uO1xuICAgICAgICAgIHRTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0U3BhblRyYW5zbGF0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaW5uZXJFbGVtLmFwcGVuZENoaWxkKHRTcGFuKTtcbiAgICAgICAgfVxuICAgICAgfSAvL1xuXG5cbiAgICAgIGlmICghdGhpcy5pc01hc2tlZCkge1xuICAgICAgICB0aGlzLnRleHRTcGFuc1tjbnRdID0gdFBhcmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGV4dFNwYW5zW2NudF0gPSB0U3BhbjtcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZXh0U3BhbnNbY250XS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIHRoaXMudGV4dFBhdGhzW2NudF0gPSB0U3BhbjtcbiAgICAgIGNudCArPSAxO1xuICAgIH1cblxuICAgIHdoaWxlIChjbnQgPCB0aGlzLnRleHRTcGFucy5sZW5ndGgpIHtcbiAgICAgIHRoaXMudGV4dFNwYW5zW2NudF0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIGNudCArPSAxO1xuICAgIH1cbiAgfTtcblxuICBIVGV4dEVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnZhbGlkYXRlVGV4dCgpO1xuICAgIHZhciBzdmdTdHlsZTtcblxuICAgIGlmICh0aGlzLmRhdGEuc2luZ2xlU2hhcGUpIHtcbiAgICAgIGlmICghdGhpcy5faXNGaXJzdEZyYW1lICYmICF0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzTWFza2VkICYmIHRoaXMuZmluYWxUcmFuc2Zvcm0uX21hdE1kZikge1xuICAgICAgICAvLyBUb2RvIEJlbmNobWFyayBpZiB1c2luZyB0aGlzIGlzIGJldHRlciB0aGFuIGdldEJCb3hcbiAgICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIC10aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLnAudlswXSArICcgJyArIC10aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLnAudlsxXSArICcgJyArIHRoaXMuY29tcFcgKyAnICcgKyB0aGlzLmNvbXBIKTtcbiAgICAgICAgc3ZnU3R5bGUgPSB0aGlzLnN2Z0VsZW1lbnQuc3R5bGU7XG4gICAgICAgIHZhciB0cmFuc2xhdGlvbiA9ICd0cmFuc2xhdGUoJyArIC10aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLnAudlswXSArICdweCwnICsgLXRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3AucC52WzFdICsgJ3B4KSc7XG4gICAgICAgIHN2Z1N0eWxlLnRyYW5zZm9ybSA9IHRyYW5zbGF0aW9uO1xuICAgICAgICBzdmdTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0cmFuc2xhdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRleHRBbmltYXRvci5nZXRNZWFzdXJlcyh0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YSwgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcpO1xuXG4gICAgaWYgKCF0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyAmJiAhdGhpcy50ZXh0QW5pbWF0b3IubGV0dGVyc0NoYW5nZWRGbGFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciByZW5kZXJlZExldHRlcnMgPSB0aGlzLnRleHRBbmltYXRvci5yZW5kZXJlZExldHRlcnM7XG4gICAgdmFyIGxldHRlcnMgPSB0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YS5sO1xuICAgIGxlbiA9IGxldHRlcnMubGVuZ3RoO1xuICAgIHZhciByZW5kZXJlZExldHRlcjtcbiAgICB2YXIgdGV4dFNwYW47XG4gICAgdmFyIHRleHRQYXRoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAobGV0dGVyc1tpXS5uKSB7XG4gICAgICAgIGNvdW50ICs9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0U3BhbiA9IHRoaXMudGV4dFNwYW5zW2ldO1xuICAgICAgICB0ZXh0UGF0aCA9IHRoaXMudGV4dFBhdGhzW2ldO1xuICAgICAgICByZW5kZXJlZExldHRlciA9IHJlbmRlcmVkTGV0dGVyc1tjb3VudF07XG4gICAgICAgIGNvdW50ICs9IDE7XG5cbiAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLl9tZGYubSkge1xuICAgICAgICAgIGlmICghdGhpcy5pc01hc2tlZCkge1xuICAgICAgICAgICAgdGV4dFNwYW4uc3R5bGUud2Via2l0VHJhbnNmb3JtID0gcmVuZGVyZWRMZXR0ZXIubTtcbiAgICAgICAgICAgIHRleHRTcGFuLnN0eWxlLnRyYW5zZm9ybSA9IHJlbmRlcmVkTGV0dGVyLm07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRTcGFuLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgcmVuZGVyZWRMZXR0ZXIubSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vLyAvdGV4dFNwYW4uc2V0QXR0cmlidXRlKCdvcGFjaXR5JyxyZW5kZXJlZExldHRlci5vKTtcblxuXG4gICAgICAgIHRleHRTcGFuLnN0eWxlLm9wYWNpdHkgPSByZW5kZXJlZExldHRlci5vO1xuXG4gICAgICAgIGlmIChyZW5kZXJlZExldHRlci5zdyAmJiByZW5kZXJlZExldHRlci5fbWRmLnN3KSB7XG4gICAgICAgICAgdGV4dFBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCByZW5kZXJlZExldHRlci5zdyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuc2MgJiYgcmVuZGVyZWRMZXR0ZXIuX21kZi5zYykge1xuICAgICAgICAgIHRleHRQYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgcmVuZGVyZWRMZXR0ZXIuc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLmZjICYmIHJlbmRlcmVkTGV0dGVyLl9tZGYuZmMpIHtcbiAgICAgICAgICB0ZXh0UGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCByZW5kZXJlZExldHRlci5mYyk7XG4gICAgICAgICAgdGV4dFBhdGguc3R5bGUuY29sb3IgPSByZW5kZXJlZExldHRlci5mYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmlubmVyRWxlbS5nZXRCQm94ICYmICF0aGlzLmhpZGRlbiAmJiAodGhpcy5faXNGaXJzdEZyYW1lIHx8IHRoaXMuX21kZikpIHtcbiAgICAgIHZhciBib3VuZGluZ0JveCA9IHRoaXMuaW5uZXJFbGVtLmdldEJCb3goKTtcblxuICAgICAgaWYgKHRoaXMuY3VycmVudEJCb3gudyAhPT0gYm91bmRpbmdCb3gud2lkdGgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QkJveC53ID0gYm91bmRpbmdCb3gud2lkdGg7XG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgYm91bmRpbmdCb3gud2lkdGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jdXJyZW50QkJveC5oICE9PSBib3VuZGluZ0JveC5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QkJveC5oID0gYm91bmRpbmdCb3guaGVpZ2h0O1xuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBib3VuZGluZ0JveC5oZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWFyZ2luID0gMTtcblxuICAgICAgaWYgKHRoaXMuY3VycmVudEJCb3gudyAhPT0gYm91bmRpbmdCb3gud2lkdGggKyBtYXJnaW4gKiAyIHx8IHRoaXMuY3VycmVudEJCb3guaCAhPT0gYm91bmRpbmdCb3guaGVpZ2h0ICsgbWFyZ2luICogMiB8fCB0aGlzLmN1cnJlbnRCQm94LnggIT09IGJvdW5kaW5nQm94LnggLSBtYXJnaW4gfHwgdGhpcy5jdXJyZW50QkJveC55ICE9PSBib3VuZGluZ0JveC55IC0gbWFyZ2luKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3gudyA9IGJvdW5kaW5nQm94LndpZHRoICsgbWFyZ2luICogMjtcbiAgICAgICAgdGhpcy5jdXJyZW50QkJveC5oID0gYm91bmRpbmdCb3guaGVpZ2h0ICsgbWFyZ2luICogMjtcbiAgICAgICAgdGhpcy5jdXJyZW50QkJveC54ID0gYm91bmRpbmdCb3gueCAtIG1hcmdpbjtcbiAgICAgICAgdGhpcy5jdXJyZW50QkJveC55ID0gYm91bmRpbmdCb3gueSAtIG1hcmdpbjtcbiAgICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIHRoaXMuY3VycmVudEJCb3gueCArICcgJyArIHRoaXMuY3VycmVudEJCb3gueSArICcgJyArIHRoaXMuY3VycmVudEJCb3gudyArICcgJyArIHRoaXMuY3VycmVudEJCb3guaCk7XG4gICAgICAgIHN2Z1N0eWxlID0gdGhpcy5zdmdFbGVtZW50LnN0eWxlO1xuICAgICAgICB2YXIgc3ZnVHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgdGhpcy5jdXJyZW50QkJveC54ICsgJ3B4LCcgKyB0aGlzLmN1cnJlbnRCQm94LnkgKyAncHgpJztcbiAgICAgICAgc3ZnU3R5bGUudHJhbnNmb3JtID0gc3ZnVHJhbnNmb3JtO1xuICAgICAgICBzdmdTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBzdmdUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEhDYW1lcmFFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmluaXRGcmFtZSgpO1xuICAgIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMuaW5pdEhpZXJhcmNoeSgpO1xuICAgIHZhciBnZXRQcm9wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3A7XG4gICAgdGhpcy5wZSA9IGdldFByb3AodGhpcywgZGF0YS5wZSwgMCwgMCwgdGhpcyk7XG5cbiAgICBpZiAoZGF0YS5rcy5wLnMpIHtcbiAgICAgIHRoaXMucHggPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MucC54LCAxLCAwLCB0aGlzKTtcbiAgICAgIHRoaXMucHkgPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MucC55LCAxLCAwLCB0aGlzKTtcbiAgICAgIHRoaXMucHogPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MucC56LCAxLCAwLCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnAsIDEsIDAsIHRoaXMpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmtzLmEpIHtcbiAgICAgIHRoaXMuYSA9IGdldFByb3AodGhpcywgZGF0YS5rcy5hLCAxLCAwLCB0aGlzKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5rcy5vci5rLmxlbmd0aCAmJiBkYXRhLmtzLm9yLmtbMF0udG8pIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IGRhdGEua3Mub3Iuay5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBkYXRhLmtzLm9yLmtbaV0udG8gPSBudWxsO1xuICAgICAgICBkYXRhLmtzLm9yLmtbaV0udGkgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMub3IgPSBnZXRQcm9wKHRoaXMsIGRhdGEua3Mub3IsIDEsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgdGhpcy5vci5zaCA9IHRydWU7XG4gICAgdGhpcy5yeCA9IGdldFByb3AodGhpcywgZGF0YS5rcy5yeCwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcbiAgICB0aGlzLnJ5ID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnJ5LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgIHRoaXMucnogPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MucnosIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgdGhpcy5tYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5fcHJldk1hdCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlOyAvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIHdheSB0byBtYWtlIHRoZSBIQ2FtZXJhIGVsZW1lbnQgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBMYXllckludGVyZmFjZSBhbmQgVHJhbnNmb3JtSW50ZXJmYWNlLlxuXG4gICAgdGhpcy5maW5hbFRyYW5zZm9ybSA9IHtcbiAgICAgIG1Qcm9wOiB0aGlzXG4gICAgfTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudF0sIEhDYW1lcmFFbGVtZW50KTtcblxuICBIQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuY29tcC50aHJlZURFbGVtZW50cy5sZW5ndGg7XG4gICAgdmFyIGNvbXA7XG4gICAgdmFyIHBlcnNwZWN0aXZlU3R5bGU7XG4gICAgdmFyIGNvbnRhaW5lclN0eWxlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAvLyBbcGVyc3BlY3RpdmVFbGVtLGNvbnRhaW5lcl1cbiAgICAgIGNvbXAgPSB0aGlzLmNvbXAudGhyZWVERWxlbWVudHNbaV07XG5cbiAgICAgIGlmIChjb21wLnR5cGUgPT09ICczZCcpIHtcbiAgICAgICAgcGVyc3BlY3RpdmVTdHlsZSA9IGNvbXAucGVyc3BlY3RpdmVFbGVtLnN0eWxlO1xuICAgICAgICBjb250YWluZXJTdHlsZSA9IGNvbXAuY29udGFpbmVyLnN0eWxlO1xuICAgICAgICB2YXIgcGVyc3BlY3RpdmUgPSB0aGlzLnBlLnYgKyAncHgnO1xuICAgICAgICB2YXIgb3JpZ2luID0gJzBweCAwcHggMHB4JztcbiAgICAgICAgdmFyIG1hdHJpeCA9ICdtYXRyaXgzZCgxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxKSc7XG4gICAgICAgIHBlcnNwZWN0aXZlU3R5bGUucGVyc3BlY3RpdmUgPSBwZXJzcGVjdGl2ZTtcbiAgICAgICAgcGVyc3BlY3RpdmVTdHlsZS53ZWJraXRQZXJzcGVjdGl2ZSA9IHBlcnNwZWN0aXZlO1xuICAgICAgICBjb250YWluZXJTdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIGNvbnRhaW5lclN0eWxlLm1velRyYW5zZm9ybU9yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgY29udGFpbmVyU3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xuICAgICAgICBwZXJzcGVjdGl2ZVN0eWxlLnRyYW5zZm9ybSA9IG1hdHJpeDtcbiAgICAgICAgcGVyc3BlY3RpdmVTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBtYXRyaXg7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEhDYW1lcmFFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIEhDYW1lcmFFbGVtZW50LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge307XG5cbiAgSENhbWVyYUVsZW1lbnQucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfbWRmID0gdGhpcy5faXNGaXJzdEZyYW1lO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG5cbiAgICBpZiAodGhpcy5oaWVyYXJjaHkpIHtcbiAgICAgIGxlbiA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIF9tZGYgPSB0aGlzLmhpZXJhcmNoeVtpXS5maW5hbFRyYW5zZm9ybS5tUHJvcC5fbWRmIHx8IF9tZGY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF9tZGYgfHwgdGhpcy5wZS5fbWRmIHx8IHRoaXMucCAmJiB0aGlzLnAuX21kZiB8fCB0aGlzLnB4ICYmICh0aGlzLnB4Ll9tZGYgfHwgdGhpcy5weS5fbWRmIHx8IHRoaXMucHouX21kZikgfHwgdGhpcy5yeC5fbWRmIHx8IHRoaXMucnkuX21kZiB8fCB0aGlzLnJ6Ll9tZGYgfHwgdGhpcy5vci5fbWRmIHx8IHRoaXMuYSAmJiB0aGlzLmEuX21kZikge1xuICAgICAgdGhpcy5tYXQucmVzZXQoKTtcblxuICAgICAgaWYgKHRoaXMuaGllcmFyY2h5KSB7XG4gICAgICAgIGxlbiA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aCAtIDE7XG5cbiAgICAgICAgZm9yIChpID0gbGVuOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICAgIHZhciBtVHJhbnNmID0gdGhpcy5oaWVyYXJjaHlbaV0uZmluYWxUcmFuc2Zvcm0ubVByb3A7XG4gICAgICAgICAgdGhpcy5tYXQudHJhbnNsYXRlKC1tVHJhbnNmLnAudlswXSwgLW1UcmFuc2YucC52WzFdLCBtVHJhbnNmLnAudlsyXSk7XG4gICAgICAgICAgdGhpcy5tYXQucm90YXRlWCgtbVRyYW5zZi5vci52WzBdKS5yb3RhdGVZKC1tVHJhbnNmLm9yLnZbMV0pLnJvdGF0ZVoobVRyYW5zZi5vci52WzJdKTtcbiAgICAgICAgICB0aGlzLm1hdC5yb3RhdGVYKC1tVHJhbnNmLnJ4LnYpLnJvdGF0ZVkoLW1UcmFuc2Yucnkudikucm90YXRlWihtVHJhbnNmLnJ6LnYpO1xuICAgICAgICAgIHRoaXMubWF0LnNjYWxlKDEgLyBtVHJhbnNmLnMudlswXSwgMSAvIG1UcmFuc2Yucy52WzFdLCAxIC8gbVRyYW5zZi5zLnZbMl0pO1xuICAgICAgICAgIHRoaXMubWF0LnRyYW5zbGF0ZShtVHJhbnNmLmEudlswXSwgbVRyYW5zZi5hLnZbMV0sIG1UcmFuc2YuYS52WzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wKSB7XG4gICAgICAgIHRoaXMubWF0LnRyYW5zbGF0ZSgtdGhpcy5wLnZbMF0sIC10aGlzLnAudlsxXSwgdGhpcy5wLnZbMl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXQudHJhbnNsYXRlKC10aGlzLnB4LnYsIC10aGlzLnB5LnYsIHRoaXMucHoudik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmEpIHtcbiAgICAgICAgdmFyIGRpZmZWZWN0b3I7XG5cbiAgICAgICAgaWYgKHRoaXMucCkge1xuICAgICAgICAgIGRpZmZWZWN0b3IgPSBbdGhpcy5wLnZbMF0gLSB0aGlzLmEudlswXSwgdGhpcy5wLnZbMV0gLSB0aGlzLmEudlsxXSwgdGhpcy5wLnZbMl0gLSB0aGlzLmEudlsyXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlmZlZlY3RvciA9IFt0aGlzLnB4LnYgLSB0aGlzLmEudlswXSwgdGhpcy5weS52IC0gdGhpcy5hLnZbMV0sIHRoaXMucHoudiAtIHRoaXMuYS52WzJdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYWcgPSBNYXRoLnNxcnQoTWF0aC5wb3coZGlmZlZlY3RvclswXSwgMikgKyBNYXRoLnBvdyhkaWZmVmVjdG9yWzFdLCAyKSArIE1hdGgucG93KGRpZmZWZWN0b3JbMl0sIDIpKTsgLy8gdmFyIGxvb2tEaXIgPSBnZXROb3JtYWxpemVkUG9pbnQoZ2V0RGlmZlZlY3Rvcih0aGlzLmEudix0aGlzLnAudikpO1xuXG4gICAgICAgIHZhciBsb29rRGlyID0gW2RpZmZWZWN0b3JbMF0gLyBtYWcsIGRpZmZWZWN0b3JbMV0gLyBtYWcsIGRpZmZWZWN0b3JbMl0gLyBtYWddO1xuICAgICAgICB2YXIgbG9va0xlbmd0aE9uWFogPSBNYXRoLnNxcnQobG9va0RpclsyXSAqIGxvb2tEaXJbMl0gKyBsb29rRGlyWzBdICogbG9va0RpclswXSk7XG4gICAgICAgIHZhciBtUm90YXRpb25YID0gTWF0aC5hdGFuMihsb29rRGlyWzFdLCBsb29rTGVuZ3RoT25YWik7XG4gICAgICAgIHZhciBtUm90YXRpb25ZID0gTWF0aC5hdGFuMihsb29rRGlyWzBdLCAtbG9va0RpclsyXSk7XG4gICAgICAgIHRoaXMubWF0LnJvdGF0ZVkobVJvdGF0aW9uWSkucm90YXRlWCgtbVJvdGF0aW9uWCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWF0LnJvdGF0ZVgoLXRoaXMucngudikucm90YXRlWSgtdGhpcy5yeS52KS5yb3RhdGVaKHRoaXMucnoudik7XG4gICAgICB0aGlzLm1hdC5yb3RhdGVYKC10aGlzLm9yLnZbMF0pLnJvdGF0ZVkoLXRoaXMub3IudlsxXSkucm90YXRlWih0aGlzLm9yLnZbMl0pO1xuICAgICAgdGhpcy5tYXQudHJhbnNsYXRlKHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53IC8gMiwgdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmggLyAyLCAwKTtcbiAgICAgIHRoaXMubWF0LnRyYW5zbGF0ZSgwLCAwLCB0aGlzLnBlLnYpO1xuICAgICAgdmFyIGhhc01hdHJpeENoYW5nZWQgPSAhdGhpcy5fcHJldk1hdC5lcXVhbHModGhpcy5tYXQpO1xuXG4gICAgICBpZiAoKGhhc01hdHJpeENoYW5nZWQgfHwgdGhpcy5wZS5fbWRmKSAmJiB0aGlzLmNvbXAudGhyZWVERWxlbWVudHMpIHtcbiAgICAgICAgbGVuID0gdGhpcy5jb21wLnRocmVlREVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvbXA7XG4gICAgICAgIHZhciBwZXJzcGVjdGl2ZVN0eWxlO1xuICAgICAgICB2YXIgY29udGFpbmVyU3R5bGU7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgY29tcCA9IHRoaXMuY29tcC50aHJlZURFbGVtZW50c1tpXTtcblxuICAgICAgICAgIGlmIChjb21wLnR5cGUgPT09ICczZCcpIHtcbiAgICAgICAgICAgIGlmIChoYXNNYXRyaXhDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIHZhciBtYXRWYWx1ZSA9IHRoaXMubWF0LnRvQ1NTKCk7XG4gICAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlID0gY29tcC5jb250YWluZXIuc3R5bGU7XG4gICAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlLnRyYW5zZm9ybSA9IG1hdFZhbHVlO1xuICAgICAgICAgICAgICBjb250YWluZXJTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBtYXRWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMucGUuX21kZikge1xuICAgICAgICAgICAgICBwZXJzcGVjdGl2ZVN0eWxlID0gY29tcC5wZXJzcGVjdGl2ZUVsZW0uc3R5bGU7XG4gICAgICAgICAgICAgIHBlcnNwZWN0aXZlU3R5bGUucGVyc3BlY3RpdmUgPSB0aGlzLnBlLnYgKyAncHgnO1xuICAgICAgICAgICAgICBwZXJzcGVjdGl2ZVN0eWxlLndlYmtpdFBlcnNwZWN0aXZlID0gdGhpcy5wZS52ICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1hdC5jbG9uZSh0aGlzLl9wcmV2TWF0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcbiAgfTtcblxuICBIQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUucHJlcGFyZUZyYW1lID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHRoaXMucHJlcGFyZVByb3BlcnRpZXMobnVtLCB0cnVlKTtcbiAgfTtcblxuICBIQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIEhDYW1lcmFFbGVtZW50LnByb3RvdHlwZS5nZXRCYXNlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBmdW5jdGlvbiBISW1hZ2VFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmFzc2V0RGF0YSA9IGdsb2JhbERhdGEuZ2V0QXNzZXREYXRhKGRhdGEucmVmSWQpO1xuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBIQmFzZUVsZW1lbnQsIEhTb2xpZEVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZUVsZW1lbnRdLCBISW1hZ2VFbGVtZW50KTtcblxuICBISW1hZ2VFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhc3NldFBhdGggPSB0aGlzLmdsb2JhbERhdGEuZ2V0QXNzZXRzUGF0aCh0aGlzLmFzc2V0RGF0YSk7XG4gICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuXG4gICAgaWYgKHRoaXMuZGF0YS5oYXNNYXNrKSB7XG4gICAgICB0aGlzLmltYWdlRWxlbSA9IGNyZWF0ZU5TKCdpbWFnZScpO1xuICAgICAgdGhpcy5pbWFnZUVsZW0uc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuYXNzZXREYXRhLncgKyAncHgnKTtcbiAgICAgIHRoaXMuaW1hZ2VFbGVtLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5hc3NldERhdGEuaCArICdweCcpO1xuICAgICAgdGhpcy5pbWFnZUVsZW0uc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicsIGFzc2V0UGF0aCk7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmltYWdlRWxlbSk7XG4gICAgICB0aGlzLmJhc2VFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmFzc2V0RGF0YS53KTtcbiAgICAgIHRoaXMuYmFzZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmFzc2V0RGF0YS5oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICB9XG5cbiAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcbiAgICBpbWcuc3JjID0gYXNzZXRQYXRoO1xuXG4gICAgaWYgKHRoaXMuZGF0YS5sbikge1xuICAgICAgdGhpcy5iYXNlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5kYXRhLmxuKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gSHlicmlkUmVuZGVyZXJCYXNlKGFuaW1hdGlvbkl0ZW0sIGNvbmZpZykge1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbSA9IGFuaW1hdGlvbkl0ZW07XG4gICAgdGhpcy5sYXllcnMgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyZWRGcmFtZSA9IC0xO1xuICAgIHRoaXMucmVuZGVyQ29uZmlnID0ge1xuICAgICAgY2xhc3NOYW1lOiBjb25maWcgJiYgY29uZmlnLmNsYXNzTmFtZSB8fCAnJyxcbiAgICAgIGltYWdlUHJlc2VydmVBc3BlY3RSYXRpbzogY29uZmlnICYmIGNvbmZpZy5pbWFnZVByZXNlcnZlQXNwZWN0UmF0aW8gfHwgJ3hNaWRZTWlkIHNsaWNlJyxcbiAgICAgIGhpZGVPblRyYW5zcGFyZW50OiAhKGNvbmZpZyAmJiBjb25maWcuaGlkZU9uVHJhbnNwYXJlbnQgPT09IGZhbHNlKSxcbiAgICAgIGZpbHRlclNpemU6IHtcbiAgICAgICAgd2lkdGg6IGNvbmZpZyAmJiBjb25maWcuZmlsdGVyU2l6ZSAmJiBjb25maWcuZmlsdGVyU2l6ZS53aWR0aCB8fCAnNDAwJScsXG4gICAgICAgIGhlaWdodDogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLmhlaWdodCB8fCAnNDAwJScsXG4gICAgICAgIHg6IGNvbmZpZyAmJiBjb25maWcuZmlsdGVyU2l6ZSAmJiBjb25maWcuZmlsdGVyU2l6ZS54IHx8ICctMTAwJScsXG4gICAgICAgIHk6IGNvbmZpZyAmJiBjb25maWcuZmlsdGVyU2l6ZSAmJiBjb25maWcuZmlsdGVyU2l6ZS55IHx8ICctMTAwJSdcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZ2xvYmFsRGF0YSA9IHtcbiAgICAgIF9tZGY6IGZhbHNlLFxuICAgICAgZnJhbWVOdW06IC0xLFxuICAgICAgcmVuZGVyQ29uZmlnOiB0aGlzLnJlbmRlckNvbmZpZ1xuICAgIH07XG4gICAgdGhpcy5wZW5kaW5nRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgdGhpcy50aHJlZURFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5jYW1lcmEgPSBudWxsO1xuICAgIHRoaXMuc3VwcG9ydHMzZCA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXJlclR5cGUgPSAnaHRtbCc7XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VSZW5kZXJlcl0sIEh5YnJpZFJlbmRlcmVyQmFzZSk7XG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuYnVpbGRJdGVtID0gU1ZHUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkSXRlbTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmNoZWNrUGVuZGluZ0VsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHdoaWxlICh0aGlzLnBlbmRpbmdFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wZW5kaW5nRWxlbWVudHMucG9wKCk7XG4gICAgICBlbGVtZW50LmNoZWNrUGFyZW50aW5nKCk7XG4gICAgfVxuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuYXBwZW5kRWxlbWVudEluUG9zID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBvcykge1xuICAgIHZhciBuZXdET01FbGVtZW50ID0gZWxlbWVudC5nZXRCYXNlRWxlbWVudCgpO1xuXG4gICAgaWYgKCFuZXdET01FbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxheWVyID0gdGhpcy5sYXllcnNbcG9zXTtcblxuICAgIGlmICghbGF5ZXIuZGRkIHx8ICF0aGlzLnN1cHBvcnRzM2QpIHtcbiAgICAgIGlmICh0aGlzLnRocmVlREVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMuYWRkVG8zZENvbnRhaW5lcihuZXdET01FbGVtZW50LCBwb3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbmV4dERPTUVsZW1lbnQ7XG4gICAgICAgIHZhciBuZXh0TGF5ZXI7XG4gICAgICAgIHZhciB0bXBET01FbGVtZW50O1xuXG4gICAgICAgIHdoaWxlIChpIDwgcG9zKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0gJiYgdGhpcy5lbGVtZW50c1tpXSAhPT0gdHJ1ZSAmJiB0aGlzLmVsZW1lbnRzW2ldLmdldEJhc2VFbGVtZW50KSB7XG4gICAgICAgICAgICBuZXh0TGF5ZXIgPSB0aGlzLmVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgdG1wRE9NRWxlbWVudCA9IHRoaXMubGF5ZXJzW2ldLmRkZCA/IHRoaXMuZ2V0VGhyZWVEQ29udGFpbmVyQnlQb3MoaSkgOiBuZXh0TGF5ZXIuZ2V0QmFzZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIG5leHRET01FbGVtZW50ID0gdG1wRE9NRWxlbWVudCB8fCBuZXh0RE9NRWxlbWVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dERPTUVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoIWxheWVyLmRkZCB8fCAhdGhpcy5zdXBwb3J0czNkKSB7XG4gICAgICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5pbnNlcnRCZWZvcmUobmV3RE9NRWxlbWVudCwgbmV4dERPTUVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghbGF5ZXIuZGRkIHx8ICF0aGlzLnN1cHBvcnRzM2QpIHtcbiAgICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChuZXdET01FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZFRvM2RDb250YWluZXIobmV3RE9NRWxlbWVudCwgcG9zKTtcbiAgICB9XG4gIH07XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVTaGFwZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKCF0aGlzLnN1cHBvcnRzM2QpIHtcbiAgICAgIHJldHVybiBuZXcgU1ZHU2hhcGVFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBIU2hhcGVFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVUZXh0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydHMzZCkge1xuICAgICAgcmV0dXJuIG5ldyBTVkdUZXh0TG90dGllRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSFRleHRFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVDYW1lcmEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuY2FtZXJhID0gbmV3IEhDYW1lcmFFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuY2FtZXJhO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlSW1hZ2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICghdGhpcy5zdXBwb3J0czNkKSB7XG4gICAgICByZXR1cm4gbmV3IElJbWFnZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEhJbWFnZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZVNvbGlkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydHMzZCkge1xuICAgICAgcmV0dXJuIG5ldyBJU29saWRFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBIU29saWRFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVOdWxsID0gU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZU51bGw7XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5nZXRUaHJlZURDb250YWluZXJCeVBvcyA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHRoaXMudGhyZWVERWxlbWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGlmICh0aGlzLnRocmVlREVsZW1lbnRzW2ldLnN0YXJ0UG9zIDw9IHBvcyAmJiB0aGlzLnRocmVlREVsZW1lbnRzW2ldLmVuZFBvcyA+PSBwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhyZWVERWxlbWVudHNbaV0ucGVyc3BlY3RpdmVFbGVtO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVUaHJlZURDb250YWluZXIgPSBmdW5jdGlvbiAocG9zLCB0eXBlKSB7XG4gICAgdmFyIHBlcnNwZWN0aXZlRWxlbSA9IGNyZWF0ZVRhZygnZGl2Jyk7XG4gICAgdmFyIHN0eWxlO1xuICAgIHZhciBjb250YWluZXJTdHlsZTtcbiAgICBzdHlsZURpdihwZXJzcGVjdGl2ZUVsZW0pO1xuICAgIHZhciBjb250YWluZXIgPSBjcmVhdGVUYWcoJ2RpdicpO1xuICAgIHN0eWxlRGl2KGNvbnRhaW5lcik7XG5cbiAgICBpZiAodHlwZSA9PT0gJzNkJykge1xuICAgICAgc3R5bGUgPSBwZXJzcGVjdGl2ZUVsZW0uc3R5bGU7XG4gICAgICBzdHlsZS53aWR0aCA9IHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53ICsgJ3B4JztcbiAgICAgIHN0eWxlLmhlaWdodCA9IHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oICsgJ3B4JztcbiAgICAgIHZhciBjZW50ZXIgPSAnNTAlIDUwJSc7XG4gICAgICBzdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSBjZW50ZXI7XG4gICAgICBzdHlsZS5tb3pUcmFuc2Zvcm1PcmlnaW4gPSBjZW50ZXI7XG4gICAgICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBjZW50ZXI7XG4gICAgICBjb250YWluZXJTdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcbiAgICAgIHZhciBtYXRyaXggPSAnbWF0cml4M2QoMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMSknO1xuICAgICAgY29udGFpbmVyU3R5bGUudHJhbnNmb3JtID0gbWF0cml4O1xuICAgICAgY29udGFpbmVyU3R5bGUud2Via2l0VHJhbnNmb3JtID0gbWF0cml4O1xuICAgIH1cblxuICAgIHBlcnNwZWN0aXZlRWxlbS5hcHBlbmRDaGlsZChjb250YWluZXIpOyAvLyB0aGlzLnJlc2l6ZXJFbGVtLmFwcGVuZENoaWxkKHBlcnNwZWN0aXZlRWxlbSk7XG5cbiAgICB2YXIgdGhyZWVEQ29udGFpbmVyRGF0YSA9IHtcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgcGVyc3BlY3RpdmVFbGVtOiBwZXJzcGVjdGl2ZUVsZW0sXG4gICAgICBzdGFydFBvczogcG9zLFxuICAgICAgZW5kUG9zOiBwb3MsXG4gICAgICB0eXBlOiB0eXBlXG4gICAgfTtcbiAgICB0aGlzLnRocmVlREVsZW1lbnRzLnB1c2godGhyZWVEQ29udGFpbmVyRGF0YSk7XG4gICAgcmV0dXJuIHRocmVlRENvbnRhaW5lckRhdGE7XG4gIH07XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5idWlsZDNkQ29udGFpbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuICAgIHZhciBsYXN0VGhyZWVEQ29udGFpbmVyRGF0YTtcbiAgICB2YXIgY3VycmVudENvbnRhaW5lciA9ICcnO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5sYXllcnNbaV0uZGRkICYmIHRoaXMubGF5ZXJzW2ldLnR5ICE9PSAzKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q29udGFpbmVyICE9PSAnM2QnKSB7XG4gICAgICAgICAgY3VycmVudENvbnRhaW5lciA9ICczZCc7XG4gICAgICAgICAgbGFzdFRocmVlRENvbnRhaW5lckRhdGEgPSB0aGlzLmNyZWF0ZVRocmVlRENvbnRhaW5lcihpLCAnM2QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RUaHJlZURDb250YWluZXJEYXRhLmVuZFBvcyA9IE1hdGgubWF4KGxhc3RUaHJlZURDb250YWluZXJEYXRhLmVuZFBvcywgaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY3VycmVudENvbnRhaW5lciAhPT0gJzJkJykge1xuICAgICAgICAgIGN1cnJlbnRDb250YWluZXIgPSAnMmQnO1xuICAgICAgICAgIGxhc3RUaHJlZURDb250YWluZXJEYXRhID0gdGhpcy5jcmVhdGVUaHJlZURDb250YWluZXIoaSwgJzJkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0VGhyZWVEQ29udGFpbmVyRGF0YS5lbmRQb3MgPSBNYXRoLm1heChsYXN0VGhyZWVEQ29udGFpbmVyRGF0YS5lbmRQb3MsIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxlbiA9IHRoaXMudGhyZWVERWxlbWVudHMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIHRoaXMucmVzaXplckVsZW0uYXBwZW5kQ2hpbGQodGhpcy50aHJlZURFbGVtZW50c1tpXS5wZXJzcGVjdGl2ZUVsZW0pO1xuICAgIH1cbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmFkZFRvM2RDb250YWluZXIgPSBmdW5jdGlvbiAoZWxlbSwgcG9zKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0aGlzLnRocmVlREVsZW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAocG9zIDw9IHRoaXMudGhyZWVERWxlbWVudHNbaV0uZW5kUG9zKSB7XG4gICAgICAgIHZhciBqID0gdGhpcy50aHJlZURFbGVtZW50c1tpXS5zdGFydFBvcztcbiAgICAgICAgdmFyIG5leHRFbGVtZW50O1xuXG4gICAgICAgIHdoaWxlIChqIDwgcG9zKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNbal0gJiYgdGhpcy5lbGVtZW50c1tqXS5nZXRCYXNlRWxlbWVudCkge1xuICAgICAgICAgICAgbmV4dEVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2pdLmdldEJhc2VFbGVtZW50KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaiArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRFbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy50aHJlZURFbGVtZW50c1tpXS5jb250YWluZXIuaW5zZXJ0QmVmb3JlKGVsZW0sIG5leHRFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRocmVlREVsZW1lbnRzW2ldLmNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuY29uZmlnQW5pbWF0aW9uID0gZnVuY3Rpb24gKGFuaW1EYXRhKSB7XG4gICAgdmFyIHJlc2l6ZXJFbGVtID0gY3JlYXRlVGFnKCdkaXYnKTtcbiAgICB2YXIgd3JhcHBlciA9IHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyO1xuICAgIHZhciBzdHlsZSA9IHJlc2l6ZXJFbGVtLnN0eWxlO1xuICAgIHN0eWxlLndpZHRoID0gYW5pbURhdGEudyArICdweCc7XG4gICAgc3R5bGUuaGVpZ2h0ID0gYW5pbURhdGEuaCArICdweCc7XG4gICAgdGhpcy5yZXNpemVyRWxlbSA9IHJlc2l6ZXJFbGVtO1xuICAgIHN0eWxlRGl2KHJlc2l6ZXJFbGVtKTtcbiAgICBzdHlsZS50cmFuc2Zvcm1TdHlsZSA9ICdmbGF0JztcbiAgICBzdHlsZS5tb3pUcmFuc2Zvcm1TdHlsZSA9ICdmbGF0JztcbiAgICBzdHlsZS53ZWJraXRUcmFuc2Zvcm1TdHlsZSA9ICdmbGF0JztcblxuICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5jbGFzc05hbWUpIHtcbiAgICAgIHJlc2l6ZXJFbGVtLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0aGlzLnJlbmRlckNvbmZpZy5jbGFzc05hbWUpO1xuICAgIH1cblxuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQocmVzaXplckVsZW0pO1xuICAgIHN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgdmFyIHN2ZyA9IGNyZWF0ZU5TKCdzdmcnKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcxJyk7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzEnKTtcbiAgICBzdHlsZURpdihzdmcpO1xuICAgIHRoaXMucmVzaXplckVsZW0uYXBwZW5kQ2hpbGQoc3ZnKTtcbiAgICB2YXIgZGVmcyA9IGNyZWF0ZU5TKCdkZWZzJyk7XG4gICAgc3ZnLmFwcGVuZENoaWxkKGRlZnMpO1xuICAgIHRoaXMuZGF0YSA9IGFuaW1EYXRhOyAvLyBNYXNrIGFuaW1hdGlvblxuXG4gICAgdGhpcy5zZXR1cEdsb2JhbERhdGEoYW5pbURhdGEsIHN2Zyk7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMgPSBkZWZzO1xuICAgIHRoaXMubGF5ZXJzID0gYW5pbURhdGEubGF5ZXJzO1xuICAgIHRoaXMubGF5ZXJFbGVtZW50ID0gdGhpcy5yZXNpemVyRWxlbTtcbiAgICB0aGlzLmJ1aWxkM2RDb250YWluZXJzKCk7XG4gICAgdGhpcy51cGRhdGVDb250YWluZXJTaXplKCk7XG4gIH07XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlcikge1xuICAgICAgdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIuaW5uZXJUZXh0ID0gJyc7XG4gICAgfVxuXG4gICAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMgPSBudWxsO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycyA/IHRoaXMubGF5ZXJzLmxlbmd0aCA6IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldICYmIHRoaXMuZWxlbWVudHNbaV0uZGVzdHJveSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbSA9IG51bGw7XG4gIH07XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS51cGRhdGVDb250YWluZXJTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGVtZW50V2lkdGggPSB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5vZmZzZXRXaWR0aDtcbiAgICB2YXIgZWxlbWVudEhlaWdodCA9IHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLm9mZnNldEhlaWdodDtcbiAgICB2YXIgZWxlbWVudFJlbCA9IGVsZW1lbnRXaWR0aCAvIGVsZW1lbnRIZWlnaHQ7XG4gICAgdmFyIGFuaW1hdGlvblJlbCA9IHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53IC8gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmg7XG4gICAgdmFyIHN4O1xuICAgIHZhciBzeTtcbiAgICB2YXIgdHg7XG4gICAgdmFyIHR5O1xuXG4gICAgaWYgKGFuaW1hdGlvblJlbCA+IGVsZW1lbnRSZWwpIHtcbiAgICAgIHN4ID0gZWxlbWVudFdpZHRoIC8gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLnc7XG4gICAgICBzeSA9IGVsZW1lbnRXaWR0aCAvIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53O1xuICAgICAgdHggPSAwO1xuICAgICAgdHkgPSAoZWxlbWVudEhlaWdodCAtIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oICogKGVsZW1lbnRXaWR0aCAvIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53KSkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBzeCA9IGVsZW1lbnRIZWlnaHQgLyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaDtcbiAgICAgIHN5ID0gZWxlbWVudEhlaWdodCAvIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oO1xuICAgICAgdHggPSAoZWxlbWVudFdpZHRoIC0gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLncgKiAoZWxlbWVudEhlaWdodCAvIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oKSkgLyAyO1xuICAgICAgdHkgPSAwO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IHRoaXMucmVzaXplckVsZW0uc3R5bGU7XG4gICAgc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ21hdHJpeDNkKCcgKyBzeCArICcsMCwwLDAsMCwnICsgc3kgKyAnLDAsMCwwLDAsMSwwLCcgKyB0eCArICcsJyArIHR5ICsgJywwLDEpJztcbiAgICBzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS53ZWJraXRUcmFuc2Zvcm07XG4gIH07XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IFNWR1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZXNpemVyRWxlbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlc2l6ZXJFbGVtLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuaW5pdEl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYnVpbGRBbGxJdGVtcygpO1xuXG4gICAgaWYgKHRoaXMuY2FtZXJhKSB7XG4gICAgICB0aGlzLmNhbWVyYS5zZXR1cCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY1dpZHRoID0gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLnc7XG4gICAgICB2YXIgY0hlaWdodCA9IHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gdGhpcy50aHJlZURFbGVtZW50cy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnRocmVlREVsZW1lbnRzW2ldLnBlcnNwZWN0aXZlRWxlbS5zdHlsZTtcbiAgICAgICAgc3R5bGUud2Via2l0UGVyc3BlY3RpdmUgPSBNYXRoLnNxcnQoTWF0aC5wb3coY1dpZHRoLCAyKSArIE1hdGgucG93KGNIZWlnaHQsIDIpKSArICdweCc7XG4gICAgICAgIHN0eWxlLnBlcnNwZWN0aXZlID0gc3R5bGUud2Via2l0UGVyc3BlY3RpdmU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuc2VhcmNoRXh0cmFDb21wb3NpdGlvbnMgPSBmdW5jdGlvbiAoYXNzZXRzKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGFzc2V0cy5sZW5ndGg7XG4gICAgdmFyIGZsb2F0aW5nQ29udGFpbmVyID0gY3JlYXRlVGFnKCdkaXYnKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKGFzc2V0c1tpXS54dCkge1xuICAgICAgICB2YXIgY29tcCA9IHRoaXMuY3JlYXRlQ29tcChhc3NldHNbaV0sIGZsb2F0aW5nQ29udGFpbmVyLCB0aGlzLmdsb2JhbERhdGEuY29tcCwgbnVsbCk7XG4gICAgICAgIGNvbXAuaW5pdEV4cHJlc3Npb25zKCk7XG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5wcm9qZWN0SW50ZXJmYWNlLnJlZ2lzdGVyQ29tcG9zaXRpb24oY29tcCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEhDb21wRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5sYXllcnMgPSBkYXRhLmxheWVycztcbiAgICB0aGlzLnN1cHBvcnRzM2QgPSAhZGF0YS5oYXNNYXNrO1xuICAgIHRoaXMuY29tcGxldGVMYXllcnMgPSBmYWxzZTtcbiAgICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuZWxlbWVudHMgPSB0aGlzLmxheWVycyA/IGNyZWF0ZVNpemVkQXJyYXkodGhpcy5sYXllcnMubGVuZ3RoKSA6IFtdO1xuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy50bSA9IGRhdGEudG0gPyBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLnRtLCAwLCBnbG9iYWxEYXRhLmZyYW1lUmF0ZSwgdGhpcykgOiB7XG4gICAgICBfcGxhY2Vob2xkZXI6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtIeWJyaWRSZW5kZXJlckJhc2UsIElDb21wRWxlbWVudCwgSEJhc2VFbGVtZW50XSwgSENvbXBFbGVtZW50KTtcbiAgSENvbXBFbGVtZW50LnByb3RvdHlwZS5fY3JlYXRlQmFzZUNvbnRhaW5lckVsZW1lbnRzID0gSENvbXBFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250YWluZXJFbGVtZW50cztcblxuICBIQ29tcEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NyZWF0ZUJhc2VDb250YWluZXJFbGVtZW50cygpOyAvLyBkaXZFbGVtZW50LnN0eWxlLmNsaXAgPSAncmVjdCgwcHgsICcrdGhpcy5kYXRhLncrJ3B4LCAnK3RoaXMuZGF0YS5oKydweCwgMHB4KSc7XG5cblxuICAgIGlmICh0aGlzLmRhdGEuaGFzTWFzaykge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmRhdGEudyk7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmRhdGEuaCk7XG4gICAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudCA9IHRoaXMuYmFzZUVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50ID0gdGhpcy5sYXllckVsZW1lbnQ7XG4gICAgfVxuICB9O1xuXG4gIEhDb21wRWxlbWVudC5wcm90b3R5cGUuYWRkVG8zZENvbnRhaW5lciA9IGZ1bmN0aW9uIChlbGVtLCBwb3MpIHtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIG5leHRFbGVtZW50O1xuXG4gICAgd2hpbGUgKGogPCBwb3MpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2pdICYmIHRoaXMuZWxlbWVudHNbal0uZ2V0QmFzZUVsZW1lbnQpIHtcbiAgICAgICAgbmV4dEVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2pdLmdldEJhc2VFbGVtZW50KCk7XG4gICAgICB9XG5cbiAgICAgIGogKz0gMTtcbiAgICB9XG5cbiAgICBpZiAobmV4dEVsZW1lbnQpIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50Lmluc2VydEJlZm9yZShlbGVtLCBuZXh0RWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKGVsZW0pO1xuICAgIH1cbiAgfTtcblxuICBIQ29tcEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICghdGhpcy5zdXBwb3J0czNkKSB7XG4gICAgICByZXR1cm4gbmV3IFNWR0NvbXBFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBIQ29tcEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBmdW5jdGlvbiBIeWJyaWRSZW5kZXJlcihhbmltYXRpb25JdGVtLCBjb25maWcpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0gPSBhbmltYXRpb25JdGVtO1xuICAgIHRoaXMubGF5ZXJzID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSAtMTtcbiAgICB0aGlzLnJlbmRlckNvbmZpZyA9IHtcbiAgICAgIGNsYXNzTmFtZTogY29uZmlnICYmIGNvbmZpZy5jbGFzc05hbWUgfHwgJycsXG4gICAgICBpbWFnZVByZXNlcnZlQXNwZWN0UmF0aW86IGNvbmZpZyAmJiBjb25maWcuaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvIHx8ICd4TWlkWU1pZCBzbGljZScsXG4gICAgICBoaWRlT25UcmFuc3BhcmVudDogIShjb25maWcgJiYgY29uZmlnLmhpZGVPblRyYW5zcGFyZW50ID09PSBmYWxzZSksXG4gICAgICBmaWx0ZXJTaXplOiB7XG4gICAgICAgIHdpZHRoOiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUud2lkdGggfHwgJzQwMCUnLFxuICAgICAgICBoZWlnaHQ6IGNvbmZpZyAmJiBjb25maWcuZmlsdGVyU2l6ZSAmJiBjb25maWcuZmlsdGVyU2l6ZS5oZWlnaHQgfHwgJzQwMCUnLFxuICAgICAgICB4OiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUueCB8fCAnLTEwMCUnLFxuICAgICAgICB5OiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUueSB8fCAnLTEwMCUnXG4gICAgICB9LFxuICAgICAgcnVuRXhwcmVzc2lvbnM6ICFjb25maWcgfHwgY29uZmlnLnJ1bkV4cHJlc3Npb25zID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnJ1bkV4cHJlc3Npb25zXG4gICAgfTtcbiAgICB0aGlzLmdsb2JhbERhdGEgPSB7XG4gICAgICBfbWRmOiBmYWxzZSxcbiAgICAgIGZyYW1lTnVtOiAtMSxcbiAgICAgIHJlbmRlckNvbmZpZzogdGhpcy5yZW5kZXJDb25maWdcbiAgICB9O1xuICAgIHRoaXMucGVuZGluZ0VsZW1lbnRzID0gW107XG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICAgIHRoaXMudGhyZWVERWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FtZXJhID0gbnVsbDtcbiAgICB0aGlzLnN1cHBvcnRzM2QgPSB0cnVlO1xuICAgIHRoaXMucmVuZGVyZXJUeXBlID0gJ2h0bWwnO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtIeWJyaWRSZW5kZXJlckJhc2VdLCBIeWJyaWRSZW5kZXJlcik7XG5cbiAgSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNvbXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICghdGhpcy5zdXBwb3J0czNkKSB7XG4gICAgICByZXR1cm4gbmV3IFNWR0NvbXBFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBIQ29tcEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICB2YXIgQ29tcEV4cHJlc3Npb25JbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb21wKSB7XG4gICAgICBmdW5jdGlvbiBfdGhpc0xheWVyRnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBjb21wLmxheWVycy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICBpZiAoY29tcC5sYXllcnNbaV0ubm0gPT09IG5hbWUgfHwgY29tcC5sYXllcnNbaV0uaW5kID09PSBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcC5lbGVtZW50c1tpXS5sYXllckludGVyZmFjZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDsgLy8gcmV0dXJuIHthY3RpdmU6ZmFsc2V9O1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNMYXllckZ1bmN0aW9uLCAnX25hbWUnLCB7XG4gICAgICAgIHZhbHVlOiBjb21wLmRhdGEubm1cbiAgICAgIH0pO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmxheWVyID0gX3RoaXNMYXllckZ1bmN0aW9uO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnBpeGVsQXNwZWN0ID0gMTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5oZWlnaHQgPSBjb21wLmRhdGEuaCB8fCBjb21wLmdsb2JhbERhdGEuY29tcFNpemUuaDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi53aWR0aCA9IGNvbXAuZGF0YS53IHx8IGNvbXAuZ2xvYmFsRGF0YS5jb21wU2l6ZS53O1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnBpeGVsQXNwZWN0ID0gMTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5mcmFtZUR1cmF0aW9uID0gMSAvIGNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uZGlzcGxheVN0YXJ0VGltZSA9IDA7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24ubnVtTGF5ZXJzID0gY29tcC5sYXllcnMubGVuZ3RoO1xuICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbjtcbiAgICB9O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gX3R5cGVvZiQyKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mJDIgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiQyID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2YkMihvYmopOyB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgKi9cblxuICAvKlxyXG4gICBDb3B5cmlnaHQgMjAxNCBEYXZpZCBCYXUuXHJcblxyXG4gICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcclxuICAgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXHJcbiAgIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4gICB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXHJcbiAgIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xyXG4gICBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cclxuICAgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxyXG4gICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcclxuICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxyXG4gICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWVxyXG4gICBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULFxyXG4gICBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRVxyXG4gICBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuXHJcbiAgICovXG4gIGZ1bmN0aW9uIHNlZWRSYW5kb20ocG9vbCwgbWF0aCkge1xuICAgIC8vXG4gICAgLy8gVGhlIGZvbGxvd2luZyBjb25zdGFudHMgYXJlIHJlbGF0ZWQgdG8gSUVFRSA3NTQgbGltaXRzLlxuICAgIC8vXG4gICAgdmFyIGdsb2JhbCA9IHRoaXMsXG4gICAgICAgIHdpZHRoID0gMjU2LFxuICAgICAgICAvLyBlYWNoIFJDNCBvdXRwdXQgaXMgMCA8PSB4IDwgMjU2XG4gICAgY2h1bmtzID0gNixcbiAgICAgICAgLy8gYXQgbGVhc3Qgc2l4IFJDNCBvdXRwdXRzIGZvciBlYWNoIGRvdWJsZVxuICAgIGRpZ2l0cyA9IDUyLFxuICAgICAgICAvLyB0aGVyZSBhcmUgNTIgc2lnbmlmaWNhbnQgZGlnaXRzIGluIGEgZG91YmxlXG4gICAgcm5nbmFtZSA9ICdyYW5kb20nLFxuICAgICAgICAvLyBybmduYW1lOiBuYW1lIGZvciBNYXRoLnJhbmRvbSBhbmQgTWF0aC5zZWVkcmFuZG9tXG4gICAgc3RhcnRkZW5vbSA9IG1hdGgucG93KHdpZHRoLCBjaHVua3MpLFxuICAgICAgICBzaWduaWZpY2FuY2UgPSBtYXRoLnBvdygyLCBkaWdpdHMpLFxuICAgICAgICBvdmVyZmxvdyA9IHNpZ25pZmljYW5jZSAqIDIsXG4gICAgICAgIG1hc2sgPSB3aWR0aCAtIDEsXG4gICAgICAgIG5vZGVjcnlwdG87IC8vIG5vZGUuanMgY3J5cHRvIG1vZHVsZSwgaW5pdGlhbGl6ZWQgYXQgdGhlIGJvdHRvbS5cbiAgICAvL1xuICAgIC8vIHNlZWRyYW5kb20oKVxuICAgIC8vIFRoaXMgaXMgdGhlIHNlZWRyYW5kb20gZnVuY3Rpb24gZGVzY3JpYmVkIGFib3ZlLlxuICAgIC8vXG5cbiAgICBmdW5jdGlvbiBzZWVkcmFuZG9tKHNlZWQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIga2V5ID0gW107XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA9PT0gdHJ1ZSA/IHtcbiAgICAgICAgZW50cm9weTogdHJ1ZVxuICAgICAgfSA6IG9wdGlvbnMgfHwge307IC8vIEZsYXR0ZW4gdGhlIHNlZWQgc3RyaW5nIG9yIGJ1aWxkIG9uZSBmcm9tIGxvY2FsIGVudHJvcHkgaWYgbmVlZGVkLlxuXG4gICAgICB2YXIgc2hvcnRzZWVkID0gbWl4a2V5KGZsYXR0ZW4ob3B0aW9ucy5lbnRyb3B5ID8gW3NlZWQsIHRvc3RyaW5nKHBvb2wpXSA6IHNlZWQgPT09IG51bGwgPyBhdXRvc2VlZCgpIDogc2VlZCwgMyksIGtleSk7IC8vIFVzZSB0aGUgc2VlZCB0byBpbml0aWFsaXplIGFuIEFSQzQgZ2VuZXJhdG9yLlxuXG4gICAgICB2YXIgYXJjNCA9IG5ldyBBUkM0KGtleSk7IC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHJhbmRvbSBkb3VibGUgaW4gWzAsIDEpIHRoYXQgY29udGFpbnNcbiAgICAgIC8vIHJhbmRvbW5lc3MgaW4gZXZlcnkgYml0IG9mIHRoZSBtYW50aXNzYSBvZiB0aGUgSUVFRSA3NTQgdmFsdWUuXG5cbiAgICAgIHZhciBwcm5nID0gZnVuY3Rpb24gcHJuZygpIHtcbiAgICAgICAgdmFyIG4gPSBhcmM0LmcoY2h1bmtzKSxcbiAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggYSBudW1lcmF0b3IgbiA8IDIgXiA0OFxuICAgICAgICBkID0gc3RhcnRkZW5vbSxcbiAgICAgICAgICAgIC8vICAgYW5kIGRlbm9taW5hdG9yIGQgPSAyIF4gNDguXG4gICAgICAgIHggPSAwOyAvLyAgIGFuZCBubyAnZXh0cmEgbGFzdCBieXRlJy5cblxuICAgICAgICB3aGlsZSAobiA8IHNpZ25pZmljYW5jZSkge1xuICAgICAgICAgIC8vIEZpbGwgdXAgYWxsIHNpZ25pZmljYW50IGRpZ2l0cyBieVxuICAgICAgICAgIG4gPSAobiArIHgpICogd2lkdGg7IC8vICAgc2hpZnRpbmcgbnVtZXJhdG9yIGFuZFxuXG4gICAgICAgICAgZCAqPSB3aWR0aDsgLy8gICBkZW5vbWluYXRvciBhbmQgZ2VuZXJhdGluZyBhXG5cbiAgICAgICAgICB4ID0gYXJjNC5nKDEpOyAvLyAgIG5ldyBsZWFzdC1zaWduaWZpY2FudC1ieXRlLlxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKG4gPj0gb3ZlcmZsb3cpIHtcbiAgICAgICAgICAvLyBUbyBhdm9pZCByb3VuZGluZyB1cCwgYmVmb3JlIGFkZGluZ1xuICAgICAgICAgIG4gLz0gMjsgLy8gICBsYXN0IGJ5dGUsIHNoaWZ0IGV2ZXJ5dGhpbmdcblxuICAgICAgICAgIGQgLz0gMjsgLy8gICByaWdodCB1c2luZyBpbnRlZ2VyIG1hdGggdW50aWxcblxuICAgICAgICAgIHggPj4+PSAxOyAvLyAgIHdlIGhhdmUgZXhhY3RseSB0aGUgZGVzaXJlZCBiaXRzLlxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChuICsgeCkgLyBkOyAvLyBGb3JtIHRoZSBudW1iZXIgd2l0aGluIFswLCAxKS5cbiAgICAgIH07XG5cbiAgICAgIHBybmcuaW50MzIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmM0LmcoNCkgfCAwO1xuICAgICAgfTtcblxuICAgICAgcHJuZy5xdWljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyYzQuZyg0KSAvIDB4MTAwMDAwMDAwO1xuICAgICAgfTtcblxuICAgICAgcHJuZ1tcImRvdWJsZVwiXSA9IHBybmc7IC8vIE1peCB0aGUgcmFuZG9tbmVzcyBpbnRvIGFjY3VtdWxhdGVkIGVudHJvcHkuXG5cbiAgICAgIG1peGtleSh0b3N0cmluZyhhcmM0LlMpLCBwb29sKTsgLy8gQ2FsbGluZyBjb252ZW50aW9uOiB3aGF0IHRvIHJldHVybiBhcyBhIGZ1bmN0aW9uIG9mIHBybmcsIHNlZWQsIGlzX21hdGguXG5cbiAgICAgIHJldHVybiAob3B0aW9ucy5wYXNzIHx8IGNhbGxiYWNrIHx8IGZ1bmN0aW9uIChwcm5nLCBzZWVkLCBpc19tYXRoX2NhbGwsIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIC8vIExvYWQgdGhlIGFyYzQgc3RhdGUgZnJvbSB0aGUgZ2l2ZW4gc3RhdGUgaWYgaXQgaGFzIGFuIFMgYXJyYXkuXG4gICAgICAgICAgaWYgKHN0YXRlLlMpIHtcbiAgICAgICAgICAgIGNvcHkoc3RhdGUsIGFyYzQpO1xuICAgICAgICAgIH0gLy8gT25seSBwcm92aWRlIHRoZSAuc3RhdGUgbWV0aG9kIGlmIHJlcXVlc3RlZCB2aWEgb3B0aW9ucy5zdGF0ZS5cblxuXG4gICAgICAgICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3B5KGFyYzQsIHt9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IC8vIElmIGNhbGxlZCBhcyBhIG1ldGhvZCBvZiBNYXRoIChNYXRoLnNlZWRyYW5kb20oKSksIG11dGF0ZVxuICAgICAgICAvLyBNYXRoLnJhbmRvbSBiZWNhdXNlIHRoYXQgaXMgaG93IHNlZWRyYW5kb20uanMgaGFzIHdvcmtlZCBzaW5jZSB2MS4wLlxuXG5cbiAgICAgICAgaWYgKGlzX21hdGhfY2FsbCkge1xuICAgICAgICAgIG1hdGhbcm5nbmFtZV0gPSBwcm5nO1xuICAgICAgICAgIHJldHVybiBzZWVkO1xuICAgICAgICB9IC8vIE90aGVyd2lzZSwgaXQgaXMgYSBuZXdlciBjYWxsaW5nIGNvbnZlbnRpb24sIHNvIHJldHVybiB0aGVcbiAgICAgICAgLy8gcHJuZyBkaXJlY3RseS5cbiAgICAgICAgZWxzZSByZXR1cm4gcHJuZztcbiAgICAgIH0pKHBybmcsIHNob3J0c2VlZCwgJ2dsb2JhbCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZ2xvYmFsIDogdGhpcyA9PSBtYXRoLCBvcHRpb25zLnN0YXRlKTtcbiAgICB9XG5cbiAgICBtYXRoWydzZWVkJyArIHJuZ25hbWVdID0gc2VlZHJhbmRvbTsgLy9cbiAgICAvLyBBUkM0XG4gICAgLy9cbiAgICAvLyBBbiBBUkM0IGltcGxlbWVudGF0aW9uLiAgVGhlIGNvbnN0cnVjdG9yIHRha2VzIGEga2V5IGluIHRoZSBmb3JtIG9mXG4gICAgLy8gYW4gYXJyYXkgb2YgYXQgbW9zdCAod2lkdGgpIGludGVnZXJzIHRoYXQgc2hvdWxkIGJlIDAgPD0geCA8ICh3aWR0aCkuXG4gICAgLy9cbiAgICAvLyBUaGUgZyhjb3VudCkgbWV0aG9kIHJldHVybnMgYSBwc2V1ZG9yYW5kb20gaW50ZWdlciB0aGF0IGNvbmNhdGVuYXRlc1xuICAgIC8vIHRoZSBuZXh0IChjb3VudCkgb3V0cHV0cyBmcm9tIEFSQzQuICBJdHMgcmV0dXJuIHZhbHVlIGlzIGEgbnVtYmVyIHhcbiAgICAvLyB0aGF0IGlzIGluIHRoZSByYW5nZSAwIDw9IHggPCAod2lkdGggXiBjb3VudCkuXG4gICAgLy9cblxuICAgIGZ1bmN0aW9uIEFSQzQoa2V5KSB7XG4gICAgICB2YXIgdCxcbiAgICAgICAgICBrZXlsZW4gPSBrZXkubGVuZ3RoLFxuICAgICAgICAgIG1lID0gdGhpcyxcbiAgICAgICAgICBpID0gMCxcbiAgICAgICAgICBqID0gbWUuaSA9IG1lLmogPSAwLFxuICAgICAgICAgIHMgPSBtZS5TID0gW107IC8vIFRoZSBlbXB0eSBrZXkgW10gaXMgdHJlYXRlZCBhcyBbMF0uXG5cbiAgICAgIGlmICgha2V5bGVuKSB7XG4gICAgICAgIGtleSA9IFtrZXlsZW4rK107XG4gICAgICB9IC8vIFNldCB1cCBTIHVzaW5nIHRoZSBzdGFuZGFyZCBrZXkgc2NoZWR1bGluZyBhbGdvcml0aG0uXG5cblxuICAgICAgd2hpbGUgKGkgPCB3aWR0aCkge1xuICAgICAgICBzW2ldID0gaSsrO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICBzW2ldID0gc1tqID0gbWFzayAmIGogKyBrZXlbaSAlIGtleWxlbl0gKyAodCA9IHNbaV0pXTtcbiAgICAgICAgc1tqXSA9IHQ7XG4gICAgICB9IC8vIFRoZSBcImdcIiBtZXRob2QgcmV0dXJucyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgYXMgb25lIG51bWJlci5cblxuXG4gICAgICBtZS5nID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICAgIC8vIFVzaW5nIGluc3RhbmNlIG1lbWJlcnMgaW5zdGVhZCBvZiBjbG9zdXJlIHN0YXRlIG5lYXJseSBkb3VibGVzIHNwZWVkLlxuICAgICAgICB2YXIgdCxcbiAgICAgICAgICAgIHIgPSAwLFxuICAgICAgICAgICAgaSA9IG1lLmksXG4gICAgICAgICAgICBqID0gbWUuaixcbiAgICAgICAgICAgIHMgPSBtZS5TO1xuXG4gICAgICAgIHdoaWxlIChjb3VudC0tKSB7XG4gICAgICAgICAgdCA9IHNbaSA9IG1hc2sgJiBpICsgMV07XG4gICAgICAgICAgciA9IHIgKiB3aWR0aCArIHNbbWFzayAmIChzW2ldID0gc1tqID0gbWFzayAmIGogKyB0XSkgKyAoc1tqXSA9IHQpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lLmkgPSBpO1xuICAgICAgICBtZS5qID0gajtcbiAgICAgICAgcmV0dXJuIHI7IC8vIEZvciByb2J1c3QgdW5wcmVkaWN0YWJpbGl0eSwgdGhlIGZ1bmN0aW9uIGNhbGwgYmVsb3cgYXV0b21hdGljYWxseVxuICAgICAgICAvLyBkaXNjYXJkcyBhbiBpbml0aWFsIGJhdGNoIG9mIHZhbHVlcy4gIFRoaXMgaXMgY2FsbGVkIFJDNC1kcm9wWzI1Nl0uXG4gICAgICAgIC8vIFNlZSBodHRwOi8vZ29vZ2xlLmNvbS9zZWFyY2g/cT1yc2ErZmx1aHJlcityZXNwb25zZSZidG5JXG4gICAgICB9O1xuICAgIH0gLy9cbiAgICAvLyBjb3B5KClcbiAgICAvLyBDb3BpZXMgaW50ZXJuYWwgc3RhdGUgb2YgQVJDNCB0byBvciBmcm9tIGEgcGxhaW4gb2JqZWN0LlxuICAgIC8vXG5cblxuICAgIGZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICAgICAgdC5pID0gZi5pO1xuICAgICAgdC5qID0gZi5qO1xuICAgICAgdC5TID0gZi5TLnNsaWNlKCk7XG4gICAgICByZXR1cm4gdDtcbiAgICB9IC8vXG4gICAgLy8gZmxhdHRlbigpXG4gICAgLy8gQ29udmVydHMgYW4gb2JqZWN0IHRyZWUgdG8gbmVzdGVkIGFycmF5cyBvZiBzdHJpbmdzLlxuICAgIC8vXG5cblxuICAgIGZ1bmN0aW9uIGZsYXR0ZW4ob2JqLCBkZXB0aCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHR5cCA9IF90eXBlb2YkMihvYmopLFxuICAgICAgICAgIHByb3A7XG5cbiAgICAgIGlmIChkZXB0aCAmJiB0eXAgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yIChwcm9wIGluIG9iaikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChmbGF0dGVuKG9ialtwcm9wXSwgZGVwdGggLSAxKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA/IHJlc3VsdCA6IHR5cCA9PSAnc3RyaW5nJyA/IG9iaiA6IG9iaiArICdcXDAnO1xuICAgIH0gLy9cbiAgICAvLyBtaXhrZXkoKVxuICAgIC8vIE1peGVzIGEgc3RyaW5nIHNlZWQgaW50byBhIGtleSB0aGF0IGlzIGFuIGFycmF5IG9mIGludGVnZXJzLCBhbmRcbiAgICAvLyByZXR1cm5zIGEgc2hvcnRlbmVkIHN0cmluZyBzZWVkIHRoYXQgaXMgZXF1aXZhbGVudCB0byB0aGUgcmVzdWx0IGtleS5cbiAgICAvL1xuXG5cbiAgICBmdW5jdGlvbiBtaXhrZXkoc2VlZCwga2V5KSB7XG4gICAgICB2YXIgc3RyaW5nc2VlZCA9IHNlZWQgKyAnJyxcbiAgICAgICAgICBzbWVhcixcbiAgICAgICAgICBqID0gMDtcblxuICAgICAgd2hpbGUgKGogPCBzdHJpbmdzZWVkLmxlbmd0aCkge1xuICAgICAgICBrZXlbbWFzayAmIGpdID0gbWFzayAmIChzbWVhciBePSBrZXlbbWFzayAmIGpdICogMTkpICsgc3RyaW5nc2VlZC5jaGFyQ29kZUF0KGorKyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b3N0cmluZyhrZXkpO1xuICAgIH0gLy9cbiAgICAvLyBhdXRvc2VlZCgpXG4gICAgLy8gUmV0dXJucyBhbiBvYmplY3QgZm9yIGF1dG9zZWVkaW5nLCB1c2luZyB3aW5kb3cuY3J5cHRvIGFuZCBOb2RlIGNyeXB0b1xuICAgIC8vIG1vZHVsZSBpZiBhdmFpbGFibGUuXG4gICAgLy9cblxuXG4gICAgZnVuY3Rpb24gYXV0b3NlZWQoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAobm9kZWNyeXB0bykge1xuICAgICAgICAgIHJldHVybiB0b3N0cmluZyhub2RlY3J5cHRvLnJhbmRvbUJ5dGVzKHdpZHRoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0ID0gbmV3IFVpbnQ4QXJyYXkod2lkdGgpO1xuICAgICAgICAoZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG8pLmdldFJhbmRvbVZhbHVlcyhvdXQpO1xuICAgICAgICByZXR1cm4gdG9zdHJpbmcob3V0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdmFyIGJyb3dzZXIgPSBnbG9iYWwubmF2aWdhdG9yLFxuICAgICAgICAgICAgcGx1Z2lucyA9IGJyb3dzZXIgJiYgYnJvd3Nlci5wbHVnaW5zO1xuICAgICAgICByZXR1cm4gWytuZXcgRGF0ZSgpLCBnbG9iYWwsIHBsdWdpbnMsIGdsb2JhbC5zY3JlZW4sIHRvc3RyaW5nKHBvb2wpXTtcbiAgICAgIH1cbiAgICB9IC8vXG4gICAgLy8gdG9zdHJpbmcoKVxuICAgIC8vIENvbnZlcnRzIGFuIGFycmF5IG9mIGNoYXJjb2RlcyB0byBhIHN0cmluZ1xuICAgIC8vXG5cblxuICAgIGZ1bmN0aW9uIHRvc3RyaW5nKGEpIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KDAsIGEpO1xuICAgIH0gLy9cbiAgICAvLyBXaGVuIHNlZWRyYW5kb20uanMgaXMgbG9hZGVkLCB3ZSBpbW1lZGlhdGVseSBtaXggYSBmZXcgYml0c1xuICAgIC8vIGZyb20gdGhlIGJ1aWx0LWluIFJORyBpbnRvIHRoZSBlbnRyb3B5IHBvb2wuICBCZWNhdXNlIHdlIGRvXG4gICAgLy8gbm90IHdhbnQgdG8gaW50ZXJmZXJlIHdpdGggZGV0ZXJtaW5pc3RpYyBQUk5HIHN0YXRlIGxhdGVyLFxuICAgIC8vIHNlZWRyYW5kb20gd2lsbCBub3QgY2FsbCBtYXRoLnJhbmRvbSBvbiBpdHMgb3duIGFnYWluIGFmdGVyXG4gICAgLy8gaW5pdGlhbGl6YXRpb24uXG4gICAgLy9cblxuXG4gICAgbWl4a2V5KG1hdGgucmFuZG9tKCksIHBvb2wpOyAvL1xuICAgIC8vIE5vZGVqcyBhbmQgQU1EIHN1cHBvcnQ6IGV4cG9ydCB0aGUgaW1wbGVtZW50YXRpb24gYXMgYSBtb2R1bGUgdXNpbmdcbiAgICAvLyBlaXRoZXIgY29udmVudGlvbi5cbiAgICAvL1xuICAgIC8vIEVuZCBhbm9ueW1vdXMgc2NvcGUsIGFuZCBwYXNzIGluaXRpYWwgdmFsdWVzLlxuICB9XG5cbiAgO1xuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUkMihCTU1hdGgpIHtcbiAgICBzZWVkUmFuZG9tKFtdLCBCTU1hdGgpO1xuICB9XG5cbiAgdmFyIHByb3BUeXBlcyA9IHtcbiAgICBTSEFQRTogJ3NoYXBlJ1xuICB9O1xuXG4gIGZ1bmN0aW9uIF90eXBlb2YkMShvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiQxID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YkMSA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mJDEob2JqKTsgfVxuXG4gIHZhciBFeHByZXNzaW9uTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgb2IgPSB7fTtcbiAgICB2YXIgTWF0aCA9IEJNTWF0aDtcbiAgICB2YXIgd2luZG93ID0gbnVsbDtcbiAgICB2YXIgZG9jdW1lbnQgPSBudWxsO1xuICAgIHZhciBYTUxIdHRwUmVxdWVzdCA9IG51bGw7XG4gICAgdmFyIGZldGNoID0gbnVsbDtcbiAgICB2YXIgZnJhbWVzID0gbnVsbDtcbiAgICB2YXIgX2xvdHRpZUdsb2JhbCA9IHt9O1xuICAgIGluaXRpYWxpemUkMihCTU1hdGgpO1xuXG4gICAgZnVuY3Rpb24gcmVzZXRGcmFtZSgpIHtcbiAgICAgIF9sb3R0aWVHbG9iYWwgPSB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkYm1faXNJbnN0YW5jZU9mQXJyYXkoYXJyKSB7XG4gICAgICByZXR1cm4gYXJyLmNvbnN0cnVjdG9yID09PSBBcnJheSB8fCBhcnIuY29uc3RydWN0b3IgPT09IEZsb2F0MzJBcnJheTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWVyYWJsZSh0T2ZWLCB2KSB7XG4gICAgICByZXR1cm4gdE9mViA9PT0gJ251bWJlcicgfHwgdiBpbnN0YW5jZW9mIE51bWJlciB8fCB0T2ZWID09PSAnYm9vbGVhbicgfHwgdE9mViA9PT0gJ3N0cmluZyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJGJtX25lZyhhKSB7XG4gICAgICB2YXIgdE9mQSA9IF90eXBlb2YkMShhKTtcblxuICAgICAgaWYgKHRPZkEgPT09ICdudW1iZXInIHx8IGEgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdE9mQSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiAtYTtcbiAgICAgIH1cblxuICAgICAgaWYgKCRibV9pc0luc3RhbmNlT2ZBcnJheShhKSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxlbkEgPSBhLmxlbmd0aDtcbiAgICAgICAgdmFyIHJldEFyciA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5BOyBpICs9IDEpIHtcbiAgICAgICAgICByZXRBcnJbaV0gPSAtYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICB9XG5cbiAgICAgIGlmIChhLnByb3BUeXBlKSB7XG4gICAgICAgIHJldHVybiBhLnY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtYTtcbiAgICB9XG5cbiAgICB2YXIgZWFzZUluQmV6ID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcoMC4zMzMsIDAsIDAuODMzLCAwLjgzMywgJ2Vhc2VJbicpLmdldDtcbiAgICB2YXIgZWFzZU91dEJleiA9IEJlemllckZhY3RvcnkuZ2V0QmV6aWVyRWFzaW5nKDAuMTY3LCAwLjE2NywgMC42NjcsIDEsICdlYXNlT3V0JykuZ2V0O1xuICAgIHZhciBlYXNlSW5PdXRCZXogPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZygwLjMzLCAwLCAwLjY2NywgMSwgJ2Vhc2VJbk91dCcpLmdldDtcblxuICAgIGZ1bmN0aW9uIHN1bShhLCBiKSB7XG4gICAgICB2YXIgdE9mQSA9IF90eXBlb2YkMShhKTtcblxuICAgICAgdmFyIHRPZkIgPSBfdHlwZW9mJDEoYik7XG5cbiAgICAgIGlmIChpc051bWVyYWJsZSh0T2ZBLCBhKSAmJiBpc051bWVyYWJsZSh0T2ZCLCBiKSB8fCB0T2ZBID09PSAnc3RyaW5nJyB8fCB0T2ZCID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYSArIGI7XG4gICAgICB9XG5cbiAgICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcbiAgICAgICAgYSA9IGEuc2xpY2UoMCk7XG4gICAgICAgIGFbMF0gKz0gYjtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc051bWVyYWJsZSh0T2ZBLCBhKSAmJiAkYm1faXNJbnN0YW5jZU9mQXJyYXkoYikpIHtcbiAgICAgICAgYiA9IGIuc2xpY2UoMCk7XG4gICAgICAgIGJbMF0gPSBhICsgYlswXTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG5cbiAgICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkgJiYgJGJtX2lzSW5zdGFuY2VPZkFycmF5KGIpKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbkEgPSBhLmxlbmd0aDtcbiAgICAgICAgdmFyIGxlbkIgPSBiLmxlbmd0aDtcbiAgICAgICAgdmFyIHJldEFyciA9IFtdO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuQSB8fCBpIDwgbGVuQikge1xuICAgICAgICAgIGlmICgodHlwZW9mIGFbaV0gPT09ICdudW1iZXInIHx8IGFbaV0gaW5zdGFuY2VvZiBOdW1iZXIpICYmICh0eXBlb2YgYltpXSA9PT0gJ251bWJlcicgfHwgYltpXSBpbnN0YW5jZW9mIE51bWJlcikpIHtcbiAgICAgICAgICAgIHJldEFycltpXSA9IGFbaV0gKyBiW2ldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXRBcnJbaV0gPSBiW2ldID09PSB1bmRlZmluZWQgPyBhW2ldIDogYVtpXSB8fCBiW2ldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBhZGQgPSBzdW07XG5cbiAgICBmdW5jdGlvbiBzdWIoYSwgYikge1xuICAgICAgdmFyIHRPZkEgPSBfdHlwZW9mJDEoYSk7XG5cbiAgICAgIHZhciB0T2ZCID0gX3R5cGVvZiQxKGIpO1xuXG4gICAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcbiAgICAgICAgaWYgKHRPZkEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgYSA9IHBhcnNlSW50KGEsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0T2ZCID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGIgPSBwYXJzZUludChiLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICB9XG5cbiAgICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcbiAgICAgICAgYSA9IGEuc2xpY2UoMCk7XG4gICAgICAgIGFbMF0gLT0gYjtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc051bWVyYWJsZSh0T2ZBLCBhKSAmJiAkYm1faXNJbnN0YW5jZU9mQXJyYXkoYikpIHtcbiAgICAgICAgYiA9IGIuc2xpY2UoMCk7XG4gICAgICAgIGJbMF0gPSBhIC0gYlswXTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG5cbiAgICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkgJiYgJGJtX2lzSW5zdGFuY2VPZkFycmF5KGIpKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbkEgPSBhLmxlbmd0aDtcbiAgICAgICAgdmFyIGxlbkIgPSBiLmxlbmd0aDtcbiAgICAgICAgdmFyIHJldEFyciA9IFtdO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuQSB8fCBpIDwgbGVuQikge1xuICAgICAgICAgIGlmICgodHlwZW9mIGFbaV0gPT09ICdudW1iZXInIHx8IGFbaV0gaW5zdGFuY2VvZiBOdW1iZXIpICYmICh0eXBlb2YgYltpXSA9PT0gJ251bWJlcicgfHwgYltpXSBpbnN0YW5jZW9mIE51bWJlcikpIHtcbiAgICAgICAgICAgIHJldEFycltpXSA9IGFbaV0gLSBiW2ldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXRBcnJbaV0gPSBiW2ldID09PSB1bmRlZmluZWQgPyBhW2ldIDogYVtpXSB8fCBiW2ldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG11bChhLCBiKSB7XG4gICAgICB2YXIgdE9mQSA9IF90eXBlb2YkMShhKTtcblxuICAgICAgdmFyIHRPZkIgPSBfdHlwZW9mJDEoYik7XG5cbiAgICAgIHZhciBhcnI7XG5cbiAgICAgIGlmIChpc051bWVyYWJsZSh0T2ZBLCBhKSAmJiBpc051bWVyYWJsZSh0T2ZCLCBiKSkge1xuICAgICAgICByZXR1cm4gYSAqIGI7XG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbjtcblxuICAgICAgaWYgKCRibV9pc0luc3RhbmNlT2ZBcnJheShhKSAmJiBpc051bWVyYWJsZSh0T2ZCLCBiKSkge1xuICAgICAgICBsZW4gPSBhLmxlbmd0aDtcbiAgICAgICAgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgYXJyW2ldID0gYVtpXSAqIGI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgJGJtX2lzSW5zdGFuY2VPZkFycmF5KGIpKSB7XG4gICAgICAgIGxlbiA9IGIubGVuZ3RoO1xuICAgICAgICBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBhcnJbaV0gPSBhICogYltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpdihhLCBiKSB7XG4gICAgICB2YXIgdE9mQSA9IF90eXBlb2YkMShhKTtcblxuICAgICAgdmFyIHRPZkIgPSBfdHlwZW9mJDEoYik7XG5cbiAgICAgIHZhciBhcnI7XG5cbiAgICAgIGlmIChpc051bWVyYWJsZSh0T2ZBLCBhKSAmJiBpc051bWVyYWJsZSh0T2ZCLCBiKSkge1xuICAgICAgICByZXR1cm4gYSAvIGI7XG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbjtcblxuICAgICAgaWYgKCRibV9pc0luc3RhbmNlT2ZBcnJheShhKSAmJiBpc051bWVyYWJsZSh0T2ZCLCBiKSkge1xuICAgICAgICBsZW4gPSBhLmxlbmd0aDtcbiAgICAgICAgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgYXJyW2ldID0gYVtpXSAvIGI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgJGJtX2lzSW5zdGFuY2VPZkFycmF5KGIpKSB7XG4gICAgICAgIGxlbiA9IGIubGVuZ3RoO1xuICAgICAgICBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBhcnJbaV0gPSBhIC8gYltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGEgPSBwYXJzZUludChhLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYiA9IHBhcnNlSW50KGIsIDEwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGEgJSBiO1xuICAgIH1cblxuICAgIHZhciAkYm1fc3VtID0gc3VtO1xuICAgIHZhciAkYm1fc3ViID0gc3ViO1xuICAgIHZhciAkYm1fbXVsID0gbXVsO1xuICAgIHZhciAkYm1fZGl2ID0gZGl2O1xuICAgIHZhciAkYm1fbW9kID0gbW9kO1xuXG4gICAgZnVuY3Rpb24gY2xhbXAobnVtLCBtaW4sIG1heCkge1xuICAgICAgaWYgKG1pbiA+IG1heCkge1xuICAgICAgICB2YXIgbW0gPSBtYXg7XG4gICAgICAgIG1heCA9IG1pbjtcbiAgICAgICAgbWluID0gbW07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChudW0sIG1pbiksIG1heCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmFkaWFuc1RvRGVncmVlcyh2YWwpIHtcbiAgICAgIHJldHVybiB2YWwgLyBkZWdUb1JhZHM7XG4gICAgfVxuXG4gICAgdmFyIHJhZGlhbnNfdG9fZGVncmVlcyA9IHJhZGlhbnNUb0RlZ3JlZXM7XG5cbiAgICBmdW5jdGlvbiBkZWdyZWVzVG9SYWRpYW5zKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbCAqIGRlZ1RvUmFkcztcbiAgICB9XG5cbiAgICB2YXIgZGVncmVlc190b19yYWRpYW5zID0gcmFkaWFuc1RvRGVncmVlcztcbiAgICB2YXIgaGVscGVyTGVuZ3RoQXJyYXkgPSBbMCwgMCwgMCwgMCwgMCwgMF07XG5cbiAgICBmdW5jdGlvbiBsZW5ndGgoYXJyMSwgYXJyMikge1xuICAgICAgaWYgKHR5cGVvZiBhcnIxID09PSAnbnVtYmVyJyB8fCBhcnIxIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgIGFycjIgPSBhcnIyIHx8IDA7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhhcnIxIC0gYXJyMik7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXJyMikge1xuICAgICAgICBhcnIyID0gaGVscGVyTGVuZ3RoQXJyYXk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycjEubGVuZ3RoLCBhcnIyLmxlbmd0aCk7XG4gICAgICB2YXIgYWRkZWRMZW5ndGggPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYWRkZWRMZW5ndGggKz0gTWF0aC5wb3coYXJyMltpXSAtIGFycjFbaV0sIDIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KGFkZGVkTGVuZ3RoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemUodmVjKSB7XG4gICAgICByZXR1cm4gZGl2KHZlYywgbGVuZ3RoKHZlYykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJnYlRvSHNsKHZhbCkge1xuICAgICAgdmFyIHIgPSB2YWxbMF07XG4gICAgICB2YXIgZyA9IHZhbFsxXTtcbiAgICAgIHZhciBiID0gdmFsWzJdO1xuICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgICAgdmFyIGg7XG4gICAgICB2YXIgcztcbiAgICAgIHZhciBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgaCA9IDA7IC8vIGFjaHJvbWF0aWNcblxuICAgICAgICBzID0gMDsgLy8gYWNocm9tYXRpY1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcblxuICAgICAgICBzd2l0Y2ggKG1heCkge1xuICAgICAgICAgIGNhc2UgcjpcbiAgICAgICAgICAgIGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBnOlxuICAgICAgICAgICAgaCA9IChiIC0gcikgLyBkICsgMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBiOlxuICAgICAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaCAvPSA2O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2gsIHMsIGwsIHZhbFszXV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gICAgICBpZiAodCA8IDApIHQgKz0gMTtcbiAgICAgIGlmICh0ID4gMSkgdCAtPSAxO1xuICAgICAgaWYgKHQgPCAxIC8gNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgICBpZiAodCA8IDEgLyAyKSByZXR1cm4gcTtcbiAgICAgIGlmICh0IDwgMiAvIDMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhzbFRvUmdiKHZhbCkge1xuICAgICAgdmFyIGggPSB2YWxbMF07XG4gICAgICB2YXIgcyA9IHZhbFsxXTtcbiAgICAgIHZhciBsID0gdmFsWzJdO1xuICAgICAgdmFyIHI7XG4gICAgICB2YXIgZztcbiAgICAgIHZhciBiO1xuXG4gICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICByID0gbDsgLy8gYWNocm9tYXRpY1xuXG4gICAgICAgIGIgPSBsOyAvLyBhY2hyb21hdGljXG5cbiAgICAgICAgZyA9IGw7IC8vIGFjaHJvbWF0aWNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIHAgPSAyICogbCAtIHE7XG4gICAgICAgIHIgPSBodWUycmdiKHAsIHEsIGggKyAxIC8gMyk7XG4gICAgICAgIGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICAgICAgICBiID0gaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3IsIGcsIGIsIHZhbFszXV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZWFyKHQsIHRNaW4sIHRNYXgsIHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgICBpZiAodmFsdWUxID09PSB1bmRlZmluZWQgfHwgdmFsdWUyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUxID0gdE1pbjtcbiAgICAgICAgdmFsdWUyID0gdE1heDtcbiAgICAgICAgdE1pbiA9IDA7XG4gICAgICAgIHRNYXggPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAodE1heCA8IHRNaW4pIHtcbiAgICAgICAgdmFyIF90TWluID0gdE1heDtcbiAgICAgICAgdE1heCA9IHRNaW47XG4gICAgICAgIHRNaW4gPSBfdE1pbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHQgPD0gdE1pbikge1xuICAgICAgICByZXR1cm4gdmFsdWUxO1xuICAgICAgfVxuXG4gICAgICBpZiAodCA+PSB0TWF4KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTI7XG4gICAgICB9XG5cbiAgICAgIHZhciBwZXJjID0gdE1heCA9PT0gdE1pbiA/IDAgOiAodCAtIHRNaW4pIC8gKHRNYXggLSB0TWluKTtcblxuICAgICAgaWYgKCF2YWx1ZTEubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTEgKyAodmFsdWUyIC0gdmFsdWUxKSAqIHBlcmM7XG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHZhbHVlMS5sZW5ndGg7XG4gICAgICB2YXIgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBhcnJbaV0gPSB2YWx1ZTFbaV0gKyAodmFsdWUyW2ldIC0gdmFsdWUxW2ldKSAqIHBlcmM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbWluID0gMDtcbiAgICAgICAgICBtYXggPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1heCA9IG1pbjtcbiAgICAgICAgICBtaW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1heC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSBtYXgubGVuZ3RoO1xuXG4gICAgICAgIGlmICghbWluKSB7XG4gICAgICAgICAgbWluID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG4gICAgICAgIHZhciBybmQgPSBCTU1hdGgucmFuZG9tKCk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgYXJyW2ldID0gbWluW2ldICsgcm5kICogKG1heFtpXSAtIG1pbltpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfVxuXG4gICAgICBpZiAobWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWluID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJuZG0gPSBCTU1hdGgucmFuZG9tKCk7XG4gICAgICByZXR1cm4gbWluICsgcm5kbSAqIChtYXggLSBtaW4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhdGgocG9pbnRzLCBpblRhbmdlbnRzLCBvdXRUYW5nZW50cywgY2xvc2VkKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgdmFyIHBhdGggPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xuICAgICAgcGF0aC5zZXRQYXRoRGF0YSghIWNsb3NlZCwgbGVuKTtcbiAgICAgIHZhciBhcnJQbGFjZWhvbGRlciA9IFswLCAwXTtcbiAgICAgIHZhciBpblZlcnRleFBvaW50O1xuICAgICAgdmFyIG91dFZlcnRleFBvaW50O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaW5WZXJ0ZXhQb2ludCA9IGluVGFuZ2VudHMgJiYgaW5UYW5nZW50c1tpXSA/IGluVGFuZ2VudHNbaV0gOiBhcnJQbGFjZWhvbGRlcjtcbiAgICAgICAgb3V0VmVydGV4UG9pbnQgPSBvdXRUYW5nZW50cyAmJiBvdXRUYW5nZW50c1tpXSA/IG91dFRhbmdlbnRzW2ldIDogYXJyUGxhY2Vob2xkZXI7XG4gICAgICAgIHBhdGguc2V0VHJpcGxlQXQocG9pbnRzW2ldWzBdLCBwb2ludHNbaV1bMV0sIG91dFZlcnRleFBvaW50WzBdICsgcG9pbnRzW2ldWzBdLCBvdXRWZXJ0ZXhQb2ludFsxXSArIHBvaW50c1tpXVsxXSwgaW5WZXJ0ZXhQb2ludFswXSArIHBvaW50c1tpXVswXSwgaW5WZXJ0ZXhQb2ludFsxXSArIHBvaW50c1tpXVsxXSwgaSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRpYXRlRXhwcmVzc2lvbihlbGVtLCBkYXRhLCBwcm9wZXJ0eSkge1xuICAgICAgLy8gQmFpbCBvdXQgaWYgd2UgZG9uJ3Qgd2FudCBleHByZXNzaW9uc1xuICAgICAgZnVuY3Rpb24gbm9PcChfdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF92YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlbGVtLmdsb2JhbERhdGEucmVuZGVyQ29uZmlnLnJ1bkV4cHJlc3Npb25zKSB7XG4gICAgICAgIHJldHVybiBub09wO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsID0gZGF0YS54O1xuICAgICAgdmFyIG5lZWRzVmVsb2NpdHkgPSAvdmVsb2NpdHkoPyFbXFx3XFxkXSkvLnRlc3QodmFsKTtcblxuICAgICAgdmFyIF9uZWVkc1JhbmRvbSA9IHZhbC5pbmRleE9mKCdyYW5kb20nKSAhPT0gLTE7XG5cbiAgICAgIHZhciBlbGVtVHlwZSA9IGVsZW0uZGF0YS50eTtcbiAgICAgIHZhciB0cmFuc2Zvcm07XG4gICAgICB2YXIgJGJtX3RyYW5zZm9ybTtcbiAgICAgIHZhciBjb250ZW50O1xuICAgICAgdmFyIGVmZmVjdDtcbiAgICAgIHZhciB0aGlzUHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgIHRoaXNQcm9wZXJ0eS52YWx1ZUF0VGltZSA9IHRoaXNQcm9wZXJ0eS5nZXRWYWx1ZUF0VGltZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzUHJvcGVydHksICd2YWx1ZScsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNQcm9wZXJ0eS52O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVsZW0uY29tcC5mcmFtZUR1cmF0aW9uID0gMSAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgIGVsZW0uY29tcC5kaXNwbGF5U3RhcnRUaW1lID0gMDtcbiAgICAgIHZhciBpblBvaW50ID0gZWxlbS5kYXRhLmlwIC8gZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgdmFyIG91dFBvaW50ID0gZWxlbS5kYXRhLm9wIC8gZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgdmFyIHdpZHRoID0gZWxlbS5kYXRhLnN3ID8gZWxlbS5kYXRhLnN3IDogMDtcbiAgICAgIHZhciBoZWlnaHQgPSBlbGVtLmRhdGEuc2ggPyBlbGVtLmRhdGEuc2ggOiAwO1xuICAgICAgdmFyIG5hbWUgPSBlbGVtLmRhdGEubm07XG4gICAgICB2YXIgbG9vcEluO1xuICAgICAgdmFyIGxvb3BfaW47XG4gICAgICB2YXIgbG9vcE91dDtcbiAgICAgIHZhciBsb29wX291dDtcbiAgICAgIHZhciBzbW9vdGg7XG4gICAgICB2YXIgdG9Xb3JsZDtcbiAgICAgIHZhciBmcm9tV29ybGQ7XG4gICAgICB2YXIgZnJvbUNvbXA7XG4gICAgICB2YXIgdG9Db21wO1xuICAgICAgdmFyIGZyb21Db21wVG9TdXJmYWNlO1xuICAgICAgdmFyIHBvc2l0aW9uO1xuICAgICAgdmFyIHJvdGF0aW9uO1xuICAgICAgdmFyIGFuY2hvclBvaW50O1xuICAgICAgdmFyIHNjYWxlO1xuICAgICAgdmFyIHRoaXNMYXllcjtcbiAgICAgIHZhciB0aGlzQ29tcDtcbiAgICAgIHZhciBtYXNrO1xuICAgICAgdmFyIHZhbHVlQXRUaW1lO1xuICAgICAgdmFyIHZlbG9jaXR5QXRUaW1lO1xuICAgICAgdmFyIHNjb3BlZF9ibV9ydDsgLy8gdmFsID0gdmFsLnJlcGxhY2UoLyhcXFxcP1wifCcpKChodHRwKShzKT8oOlxcLykpP1xcLy4qPyhcXFxcP1wifCcpL2csIFwiXFxcIlxcXCJcIik7IC8vIGRldGVyIHBvdGVudGlhbCBuZXR3b3JrIGNhbGxzXG5cbiAgICAgIHZhciBleHByZXNzaW9uX2Z1bmN0aW9uID0gZXZhbCgnW2Z1bmN0aW9uIF9leHByZXNzaW9uX2Z1bmN0aW9uKCl7JyArIHZhbCArICc7c2NvcGVkX2JtX3J0PSRibV9ydH1dJylbMF07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuXG4gICAgICB2YXIgbnVtS2V5cyA9IHByb3BlcnR5LmtmID8gZGF0YS5rLmxlbmd0aCA6IDA7XG4gICAgICB2YXIgYWN0aXZlID0gIXRoaXMuZGF0YSB8fCB0aGlzLmRhdGEuaGQgIT09IHRydWU7XG5cbiAgICAgIHZhciB3aWdnbGUgPSBmdW5jdGlvbiB3aWdnbGUoZnJlcSwgYW1wKSB7XG4gICAgICAgIHZhciBpV2lnZ2xlO1xuICAgICAgICB2YXIgajtcbiAgICAgICAgdmFyIGxlbldpZ2dsZSA9IHRoaXMucHYubGVuZ3RoID8gdGhpcy5wdi5sZW5ndGggOiAxO1xuICAgICAgICB2YXIgYWRkZWRBbXBzID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbldpZ2dsZSk7XG4gICAgICAgIGZyZXEgPSA1O1xuICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IE1hdGguZmxvb3IodGltZSAqIGZyZXEpO1xuICAgICAgICBpV2lnZ2xlID0gMDtcbiAgICAgICAgaiA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGlXaWdnbGUgPCBpdGVyYXRpb25zKSB7XG4gICAgICAgICAgLy8gdmFyIHJuZCA9IEJNTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGVuV2lnZ2xlOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGFkZGVkQW1wc1tqXSArPSAtYW1wICsgYW1wICogMiAqIEJNTWF0aC5yYW5kb20oKTsgLy8gYWRkZWRBbXBzW2pdICs9IC1hbXAgKyBhbXAqMipybmQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaVdpZ2dsZSArPSAxO1xuICAgICAgICB9IC8vIHZhciBybmQyID0gQk1NYXRoLnJhbmRvbSgpO1xuXG5cbiAgICAgICAgdmFyIHBlcmlvZHMgPSB0aW1lICogZnJlcTtcbiAgICAgICAgdmFyIHBlcmMgPSBwZXJpb2RzIC0gTWF0aC5mbG9vcihwZXJpb2RzKTtcbiAgICAgICAgdmFyIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW5XaWdnbGUpO1xuXG4gICAgICAgIGlmIChsZW5XaWdnbGUgPiAxKSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbldpZ2dsZTsgaiArPSAxKSB7XG4gICAgICAgICAgICBhcnJbal0gPSB0aGlzLnB2W2pdICsgYWRkZWRBbXBzW2pdICsgKC1hbXAgKyBhbXAgKiAyICogQk1NYXRoLnJhbmRvbSgpKSAqIHBlcmM7IC8vIGFycltqXSA9IHRoaXMucHZbal0gKyBhZGRlZEFtcHNbal0gKyAoLWFtcCArIGFtcCoyKnJuZCkqcGVyYztcbiAgICAgICAgICAgIC8vIGFycltpXSA9IHRoaXMucHZbaV0gKyBhZGRlZEFtcCArIGFtcDEqcGVyYyArIGFtcDIqKDEtcGVyYyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnB2ICsgYWRkZWRBbXBzWzBdICsgKC1hbXAgKyBhbXAgKiAyICogQk1NYXRoLnJhbmRvbSgpKSAqIHBlcmM7XG4gICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgIGlmICh0aGlzUHJvcGVydHkubG9vcEluKSB7XG4gICAgICAgIGxvb3BJbiA9IHRoaXNQcm9wZXJ0eS5sb29wSW4uYmluZCh0aGlzUHJvcGVydHkpO1xuICAgICAgICBsb29wX2luID0gbG9vcEluO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1Byb3BlcnR5Lmxvb3BPdXQpIHtcbiAgICAgICAgbG9vcE91dCA9IHRoaXNQcm9wZXJ0eS5sb29wT3V0LmJpbmQodGhpc1Byb3BlcnR5KTtcbiAgICAgICAgbG9vcF9vdXQgPSBsb29wT3V0O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1Byb3BlcnR5LnNtb290aCkge1xuICAgICAgICBzbW9vdGggPSB0aGlzUHJvcGVydHkuc21vb3RoLmJpbmQodGhpc1Byb3BlcnR5KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbG9vcEluRHVyYXRpb24odHlwZSwgZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGxvb3BJbih0eXBlLCBkdXJhdGlvbiwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxvb3BPdXREdXJhdGlvbih0eXBlLCBkdXJhdGlvbikge1xuICAgICAgICByZXR1cm4gbG9vcE91dCh0eXBlLCBkdXJhdGlvbiwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmdldFZhbHVlQXRUaW1lKSB7XG4gICAgICAgIHZhbHVlQXRUaW1lID0gdGhpcy5nZXRWYWx1ZUF0VGltZS5iaW5kKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5nZXRWZWxvY2l0eUF0VGltZSkge1xuICAgICAgICB2ZWxvY2l0eUF0VGltZSA9IHRoaXMuZ2V0VmVsb2NpdHlBdFRpbWUuYmluZCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXAgPSBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5wcm9qZWN0SW50ZXJmYWNlLmJpbmQoZWxlbS5jb21wLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZSk7XG5cbiAgICAgIGZ1bmN0aW9uIGxvb2tBdChlbGVtMSwgZWxlbTIpIHtcbiAgICAgICAgdmFyIGZWZWMgPSBbZWxlbTJbMF0gLSBlbGVtMVswXSwgZWxlbTJbMV0gLSBlbGVtMVsxXSwgZWxlbTJbMl0gLSBlbGVtMVsyXV07XG4gICAgICAgIHZhciBwaXRjaCA9IE1hdGguYXRhbjIoZlZlY1swXSwgTWF0aC5zcXJ0KGZWZWNbMV0gKiBmVmVjWzFdICsgZlZlY1syXSAqIGZWZWNbMl0pKSAvIGRlZ1RvUmFkcztcbiAgICAgICAgdmFyIHlhdyA9IC1NYXRoLmF0YW4yKGZWZWNbMV0sIGZWZWNbMl0pIC8gZGVnVG9SYWRzO1xuICAgICAgICByZXR1cm4gW3lhdywgcGl0Y2gsIDBdO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlYXNlT3V0KHQsIHRNaW4sIHRNYXgsIHZhbDEsIHZhbDIpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5RWFzZShlYXNlT3V0QmV6LCB0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZWFzZUluKHQsIHRNaW4sIHRNYXgsIHZhbDEsIHZhbDIpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5RWFzZShlYXNlSW5CZXosIHQsIHRNaW4sIHRNYXgsIHZhbDEsIHZhbDIpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlYXNlKHQsIHRNaW4sIHRNYXgsIHZhbDEsIHZhbDIpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5RWFzZShlYXNlSW5PdXRCZXosIHQsIHRNaW4sIHRNYXgsIHZhbDEsIHZhbDIpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhcHBseUVhc2UoZm4sIHQsIHRNaW4sIHRNYXgsIHZhbDEsIHZhbDIpIHtcbiAgICAgICAgaWYgKHZhbDEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhbDEgPSB0TWluO1xuICAgICAgICAgIHZhbDIgPSB0TWF4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHQgPSAodCAtIHRNaW4pIC8gKHRNYXggLSB0TWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICAgIHQgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHQgPCAwKSB7XG4gICAgICAgICAgdCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbXVsdCA9IGZuKHQpO1xuXG4gICAgICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkodmFsMSkpIHtcbiAgICAgICAgICB2YXIgaUtleTtcbiAgICAgICAgICB2YXIgbGVuS2V5ID0gdmFsMS5sZW5ndGg7XG4gICAgICAgICAgdmFyIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW5LZXkpO1xuXG4gICAgICAgICAgZm9yIChpS2V5ID0gMDsgaUtleSA8IGxlbktleTsgaUtleSArPSAxKSB7XG4gICAgICAgICAgICBhcnJbaUtleV0gPSAodmFsMltpS2V5XSAtIHZhbDFbaUtleV0pICogbXVsdCArIHZhbDFbaUtleV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAodmFsMiAtIHZhbDEpICogbXVsdCArIHZhbDE7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG5lYXJlc3RLZXkodGltZSkge1xuICAgICAgICB2YXIgaUtleTtcbiAgICAgICAgdmFyIGxlbktleSA9IGRhdGEuay5sZW5ndGg7XG4gICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgdmFyIGtleVRpbWU7XG5cbiAgICAgICAgaWYgKCFkYXRhLmsubGVuZ3RoIHx8IHR5cGVvZiBkYXRhLmtbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICAgIGtleVRpbWUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgdGltZSAqPSBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG5cbiAgICAgICAgICBpZiAodGltZSA8IGRhdGEua1swXS50KSB7XG4gICAgICAgICAgICBpbmRleCA9IDE7XG4gICAgICAgICAgICBrZXlUaW1lID0gZGF0YS5rWzBdLnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaUtleSA9IDA7IGlLZXkgPCBsZW5LZXkgLSAxOyBpS2V5ICs9IDEpIHtcbiAgICAgICAgICAgICAgaWYgKHRpbWUgPT09IGRhdGEua1tpS2V5XS50KSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpS2V5ICsgMTtcbiAgICAgICAgICAgICAgICBrZXlUaW1lID0gZGF0YS5rW2lLZXldLnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZSA+IGRhdGEua1tpS2V5XS50ICYmIHRpbWUgPCBkYXRhLmtbaUtleSArIDFdLnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZSAtIGRhdGEua1tpS2V5XS50ID4gZGF0YS5rW2lLZXkgKyAxXS50IC0gdGltZSkge1xuICAgICAgICAgICAgICAgICAgaW5kZXggPSBpS2V5ICsgMjtcbiAgICAgICAgICAgICAgICAgIGtleVRpbWUgPSBkYXRhLmtbaUtleSArIDFdLnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGluZGV4ID0gaUtleSArIDE7XG4gICAgICAgICAgICAgICAgICBrZXlUaW1lID0gZGF0YS5rW2lLZXldLnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICBpbmRleCA9IGlLZXkgKyAxO1xuICAgICAgICAgICAgICBrZXlUaW1lID0gZGF0YS5rW2lLZXldLnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9iS2V5ID0ge307XG4gICAgICAgIG9iS2V5LmluZGV4ID0gaW5kZXg7XG4gICAgICAgIG9iS2V5LnRpbWUgPSBrZXlUaW1lIC8gZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgICByZXR1cm4gb2JLZXk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGtleShpbmQpIHtcbiAgICAgICAgdmFyIG9iS2V5O1xuICAgICAgICB2YXIgaUtleTtcbiAgICAgICAgdmFyIGxlbktleTtcblxuICAgICAgICBpZiAoIWRhdGEuay5sZW5ndGggfHwgdHlwZW9mIGRhdGEua1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwcm9wZXJ0eSBoYXMgbm8ga2V5ZnJhbWUgYXQgaW5kZXggJyArIGluZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmQgLT0gMTtcbiAgICAgICAgb2JLZXkgPSB7XG4gICAgICAgICAgdGltZTogZGF0YS5rW2luZF0udCAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSxcbiAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFyciA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLmtbaW5kXSwgJ3MnKSA/IGRhdGEua1tpbmRdLnMgOiBkYXRhLmtbaW5kIC0gMV0uZTtcbiAgICAgICAgbGVuS2V5ID0gYXJyLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGlLZXkgPSAwOyBpS2V5IDwgbGVuS2V5OyBpS2V5ICs9IDEpIHtcbiAgICAgICAgICBvYktleVtpS2V5XSA9IGFycltpS2V5XTtcbiAgICAgICAgICBvYktleS52YWx1ZVtpS2V5XSA9IGFycltpS2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYktleTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZnJhbWVzVG9UaW1lKGZyLCBmcHMpIHtcbiAgICAgICAgaWYgKCFmcHMpIHtcbiAgICAgICAgICBmcHMgPSBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnIgLyBmcHM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRpbWVUb0ZyYW1lcyh0LCBmcHMpIHtcbiAgICAgICAgaWYgKCF0ICYmIHQgIT09IDApIHtcbiAgICAgICAgICB0ID0gdGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZnBzKSB7XG4gICAgICAgICAgZnBzID0gZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHQgKiBmcHM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNlZWRSYW5kb20oc2VlZCkge1xuICAgICAgICBCTU1hdGguc2VlZHJhbmRvbShyYW5kU2VlZCArIHNlZWQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzb3VyY2VSZWN0QXRUaW1lKCkge1xuICAgICAgICByZXR1cm4gZWxlbS5zb3VyY2VSZWN0QXRUaW1lKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHN1YnN0cmluZyhpbml0LCBlbmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcoaW5pdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cmluZyhpbml0LCBlbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdWJzdHIoaW5pdCwgZW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyKGluaXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWx1ZS5zdWJzdHIoaW5pdCwgZW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcG9zdGVyaXplVGltZShmcmFtZXNQZXJTZWNvbmQpIHtcbiAgICAgICAgdGltZSA9IGZyYW1lc1BlclNlY29uZCA9PT0gMCA/IDAgOiBNYXRoLmZsb29yKHRpbWUgKiBmcmFtZXNQZXJTZWNvbmQpIC8gZnJhbWVzUGVyU2Vjb25kO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGltZTtcbiAgICAgIHZhciB2ZWxvY2l0eTtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHZhciB0ZXh0O1xuICAgICAgdmFyIHRleHRJbmRleDtcbiAgICAgIHZhciB0ZXh0VG90YWw7XG4gICAgICB2YXIgc2VsZWN0b3JWYWx1ZTtcbiAgICAgIHZhciBpbmRleCA9IGVsZW0uZGF0YS5pbmQ7XG4gICAgICB2YXIgaGFzUGFyZW50ID0gISEoZWxlbS5oaWVyYXJjaHkgJiYgZWxlbS5oaWVyYXJjaHkubGVuZ3RoKTtcbiAgICAgIHZhciBwYXJlbnQ7XG4gICAgICB2YXIgcmFuZFNlZWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKTtcbiAgICAgIHZhciBnbG9iYWxEYXRhID0gZWxlbS5nbG9iYWxEYXRhO1xuXG4gICAgICBmdW5jdGlvbiBleGVjdXRlRXhwcmVzc2lvbihfdmFsdWUpIHtcbiAgICAgICAgLy8gZ2xvYmFsRGF0YS5wdXNoRXhwcmVzc2lvbigpO1xuICAgICAgICB2YWx1ZSA9IF92YWx1ZTtcblxuICAgICAgICBpZiAodGhpcy5mcmFtZUV4cHJlc3Npb25JZCA9PT0gZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgJiYgdGhpcy5wcm9wVHlwZSAhPT0gJ3RleHRTZWxlY3RvcicpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wcm9wVHlwZSA9PT0gJ3RleHRTZWxlY3RvcicpIHtcbiAgICAgICAgICB0ZXh0SW5kZXggPSB0aGlzLnRleHRJbmRleDtcbiAgICAgICAgICB0ZXh0VG90YWwgPSB0aGlzLnRleHRUb3RhbDtcbiAgICAgICAgICBzZWxlY3RvclZhbHVlID0gdGhpcy5zZWxlY3RvclZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzTGF5ZXIpIHtcbiAgICAgICAgICB0ZXh0ID0gZWxlbS5sYXllckludGVyZmFjZS50ZXh0O1xuICAgICAgICAgIHRoaXNMYXllciA9IGVsZW0ubGF5ZXJJbnRlcmZhY2U7XG4gICAgICAgICAgdGhpc0NvbXAgPSBlbGVtLmNvbXAuY29tcEludGVyZmFjZTtcbiAgICAgICAgICB0b1dvcmxkID0gdGhpc0xheWVyLnRvV29ybGQuYmluZCh0aGlzTGF5ZXIpO1xuICAgICAgICAgIGZyb21Xb3JsZCA9IHRoaXNMYXllci5mcm9tV29ybGQuYmluZCh0aGlzTGF5ZXIpO1xuICAgICAgICAgIGZyb21Db21wID0gdGhpc0xheWVyLmZyb21Db21wLmJpbmQodGhpc0xheWVyKTtcbiAgICAgICAgICB0b0NvbXAgPSB0aGlzTGF5ZXIudG9Db21wLmJpbmQodGhpc0xheWVyKTtcbiAgICAgICAgICBtYXNrID0gdGhpc0xheWVyLm1hc2sgPyB0aGlzTGF5ZXIubWFzay5iaW5kKHRoaXNMYXllcikgOiBudWxsO1xuICAgICAgICAgIGZyb21Db21wVG9TdXJmYWNlID0gZnJvbUNvbXA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICAgIHRyYW5zZm9ybSA9IGVsZW0ubGF5ZXJJbnRlcmZhY2UoJ0FEQkUgVHJhbnNmb3JtIEdyb3VwJyk7XG4gICAgICAgICAgJGJtX3RyYW5zZm9ybSA9IHRyYW5zZm9ybTtcblxuICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGFuY2hvclBvaW50ID0gdHJhbnNmb3JtLmFuY2hvclBvaW50O1xuICAgICAgICAgICAgLyogcG9zaXRpb24gPSB0cmFuc2Zvcm0ucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbiA9IHRyYW5zZm9ybS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgIHNjYWxlID0gdHJhbnNmb3JtLnNjYWxlOyAqL1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGVtVHlwZSA9PT0gNCAmJiAhY29udGVudCkge1xuICAgICAgICAgIGNvbnRlbnQgPSB0aGlzTGF5ZXIoJ0FEQkUgUm9vdCBWZWN0b3JzIEdyb3VwJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVmZmVjdCkge1xuICAgICAgICAgIGVmZmVjdCA9IHRoaXNMYXllcig0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc1BhcmVudCA9ICEhKGVsZW0uaGllcmFyY2h5ICYmIGVsZW0uaGllcmFyY2h5Lmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKGhhc1BhcmVudCAmJiAhcGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50ID0gZWxlbS5oaWVyYXJjaHlbMF0ubGF5ZXJJbnRlcmZhY2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lID0gdGhpcy5jb21wLnJlbmRlcmVkRnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG5cbiAgICAgICAgaWYgKF9uZWVkc1JhbmRvbSkge1xuICAgICAgICAgIHNlZWRSYW5kb20ocmFuZFNlZWQgKyB0aW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZWVkc1ZlbG9jaXR5KSB7XG4gICAgICAgICAgdmVsb2NpdHkgPSB2ZWxvY2l0eUF0VGltZSh0aW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cHJlc3Npb25fZnVuY3Rpb24oKTtcbiAgICAgICAgdGhpcy5mcmFtZUV4cHJlc3Npb25JZCA9IGVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkOyAvLyBUT0RPOiBDaGVjayBpZiBpdCdzIHBvc3NpYmxlIHRvIHJldHVybiBvbiBTaGFwZUludGVyZmFjZSB0aGUgLnYgdmFsdWVcbiAgICAgICAgLy8gQ2hhbmdlZCB0aGlzIHRvIGEgdGVybmFyeSBvcGVyYXRpb24gYmVjYXVzZSBSb2xsdXAgZmFpbGVkIGNvbXBpbGluZyBpdCBjb3JyZWN0bHlcblxuICAgICAgICBzY29wZWRfYm1fcnQgPSBzY29wZWRfYm1fcnQucHJvcFR5cGUgPT09IHByb3BUeXBlcy5TSEFQRSA/IHNjb3BlZF9ibV9ydC52IDogc2NvcGVkX2JtX3J0O1xuICAgICAgICByZXR1cm4gc2NvcGVkX2JtX3J0O1xuICAgICAgfSAvLyBCdW5kbGVycyB3aWxsIHNlZSB0aGVzZSBhcyBkZWFkIGNvZGUgYW5kIHVubGVzcyB3ZSByZWZlcmVuY2UgdGhlbVxuXG5cbiAgICAgIGV4ZWN1dGVFeHByZXNzaW9uLl9fcHJldmVudERlYWRDb2RlUmVtb3ZhbCA9IFskYm1fdHJhbnNmb3JtLCBhbmNob3JQb2ludCwgdGltZSwgdmVsb2NpdHksIGluUG9pbnQsIG91dFBvaW50LCB3aWR0aCwgaGVpZ2h0LCBuYW1lLCBsb29wX2luLCBsb29wX291dCwgc21vb3RoLCB0b0NvbXAsIGZyb21Db21wVG9TdXJmYWNlLCB0b1dvcmxkLCBmcm9tV29ybGQsIG1hc2ssIHBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGUsIHRoaXNDb21wLCBudW1LZXlzLCBhY3RpdmUsIHdpZ2dsZSwgbG9vcEluRHVyYXRpb24sIGxvb3BPdXREdXJhdGlvbiwgY29tcCwgbG9va0F0LCBlYXNlT3V0LCBlYXNlSW4sIGVhc2UsIG5lYXJlc3RLZXksIGtleSwgdGV4dCwgdGV4dEluZGV4LCB0ZXh0VG90YWwsIHNlbGVjdG9yVmFsdWUsIGZyYW1lc1RvVGltZSwgdGltZVRvRnJhbWVzLCBzb3VyY2VSZWN0QXRUaW1lLCBzdWJzdHJpbmcsIHN1YnN0ciwgcG9zdGVyaXplVGltZSwgaW5kZXgsIGdsb2JhbERhdGFdO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVFeHByZXNzaW9uO1xuICAgIH1cblxuICAgIG9iLmluaXRpYXRlRXhwcmVzc2lvbiA9IGluaXRpYXRlRXhwcmVzc2lvbjtcbiAgICBvYi5fX3ByZXZlbnREZWFkQ29kZVJlbW92YWwgPSBbd2luZG93LCBkb2N1bWVudCwgWE1MSHR0cFJlcXVlc3QsIGZldGNoLCBmcmFtZXMsICRibV9uZWcsIGFkZCwgJGJtX3N1bSwgJGJtX3N1YiwgJGJtX211bCwgJGJtX2RpdiwgJGJtX21vZCwgY2xhbXAsIHJhZGlhbnNfdG9fZGVncmVlcywgZGVncmVlc1RvUmFkaWFucywgZGVncmVlc190b19yYWRpYW5zLCBub3JtYWxpemUsIHJnYlRvSHNsLCBoc2xUb1JnYiwgbGluZWFyLCByYW5kb20sIGNyZWF0ZVBhdGgsIF9sb3R0aWVHbG9iYWxdO1xuICAgIG9iLnJlc2V0RnJhbWUgPSByZXNldEZyYW1lO1xuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIHZhciBFeHByZXNzaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2IgPSB7fTtcbiAgICBvYi5pbml0RXhwcmVzc2lvbnMgPSBpbml0RXhwcmVzc2lvbnM7XG4gICAgb2IucmVzZXRGcmFtZSA9IEV4cHJlc3Npb25NYW5hZ2VyLnJlc2V0RnJhbWU7XG5cbiAgICBmdW5jdGlvbiBpbml0RXhwcmVzc2lvbnMoYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgc3RhY2tDb3VudCA9IDA7XG4gICAgICB2YXIgcmVnaXN0ZXJzID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIHB1c2hFeHByZXNzaW9uKCkge1xuICAgICAgICBzdGFja0NvdW50ICs9IDE7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBvcEV4cHJlc3Npb24oKSB7XG4gICAgICAgIHN0YWNrQ291bnQgLT0gMTtcblxuICAgICAgICBpZiAoc3RhY2tDb3VudCA9PT0gMCkge1xuICAgICAgICAgIHJlbGVhc2VJbnN0YW5jZXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZWdpc3RlckV4cHJlc3Npb25Qcm9wZXJ0eShleHByZXNzaW9uKSB7XG4gICAgICAgIGlmIChyZWdpc3RlcnMuaW5kZXhPZihleHByZXNzaW9uKSA9PT0gLTEpIHtcbiAgICAgICAgICByZWdpc3RlcnMucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZWxlYXNlSW5zdGFuY2VzKCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxlbiA9IHJlZ2lzdGVycy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgcmVnaXN0ZXJzW2ldLnJlbGVhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVycy5sZW5ndGggPSAwO1xuICAgICAgfVxuXG4gICAgICBhbmltYXRpb24ucmVuZGVyZXIuY29tcEludGVyZmFjZSA9IENvbXBFeHByZXNzaW9uSW50ZXJmYWNlKGFuaW1hdGlvbi5yZW5kZXJlcik7XG4gICAgICBhbmltYXRpb24ucmVuZGVyZXIuZ2xvYmFsRGF0YS5wcm9qZWN0SW50ZXJmYWNlLnJlZ2lzdGVyQ29tcG9zaXRpb24oYW5pbWF0aW9uLnJlbmRlcmVyKTtcbiAgICAgIGFuaW1hdGlvbi5yZW5kZXJlci5nbG9iYWxEYXRhLnB1c2hFeHByZXNzaW9uID0gcHVzaEV4cHJlc3Npb247XG4gICAgICBhbmltYXRpb24ucmVuZGVyZXIuZ2xvYmFsRGF0YS5wb3BFeHByZXNzaW9uID0gcG9wRXhwcmVzc2lvbjtcbiAgICAgIGFuaW1hdGlvbi5yZW5kZXJlci5nbG9iYWxEYXRhLnJlZ2lzdGVyRXhwcmVzc2lvblByb3BlcnR5ID0gcmVnaXN0ZXJFeHByZXNzaW9uUHJvcGVydHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iO1xuICB9KCk7XG5cbiAgdmFyIE1hc2tNYW5hZ2VySW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hc2tJbnRlcmZhY2UobWFzaywgZGF0YSkge1xuICAgICAgdGhpcy5fbWFzayA9IG1hc2s7XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFza0ludGVyZmFjZS5wcm90b3R5cGUsICdtYXNrUGF0aCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5fbWFzay5wcm9wLmspIHtcbiAgICAgICAgICB0aGlzLl9tYXNrLnByb3AuZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXNrLnByb3A7XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hc2tJbnRlcmZhY2UucHJvdG90eXBlLCAnbWFza09wYWNpdHknLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hc2sub3Auaykge1xuICAgICAgICAgIHRoaXMuX21hc2sub3AuZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXNrLm9wLnYgKiAxMDA7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgTWFza01hbmFnZXIgPSBmdW5jdGlvbiBNYXNrTWFuYWdlcihtYXNrTWFuYWdlcikge1xuICAgICAgdmFyIF9tYXNrc0ludGVyZmFjZXMgPSBjcmVhdGVTaXplZEFycmF5KG1hc2tNYW5hZ2VyLnZpZXdEYXRhLmxlbmd0aCk7XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IG1hc2tNYW5hZ2VyLnZpZXdEYXRhLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIF9tYXNrc0ludGVyZmFjZXNbaV0gPSBuZXcgTWFza0ludGVyZmFjZShtYXNrTWFuYWdlci52aWV3RGF0YVtpXSwgbWFza01hbmFnZXIubWFza3NQcm9wZXJ0aWVzW2ldKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hc2tGdW5jdGlvbiA9IGZ1bmN0aW9uIG1hc2tGdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGkgPSAwO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKG1hc2tNYW5hZ2VyLm1hc2tzUHJvcGVydGllc1tpXS5ubSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9tYXNrc0ludGVyZmFjZXNbaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbWFza0Z1bmN0aW9uO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWFza01hbmFnZXI7XG4gIH0oKTtcblxuICB2YXIgRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkZWZhdWx0VW5pZGltZW5zaW9uYWxWYWx1ZSA9IHtcbiAgICAgIHB2OiAwLFxuICAgICAgdjogMCxcbiAgICAgIG11bHQ6IDFcbiAgICB9O1xuICAgIHZhciBkZWZhdWx0TXVsdGlkaW1lbnNpb25hbFZhbHVlID0ge1xuICAgICAgcHY6IFswLCAwLCAwXSxcbiAgICAgIHY6IFswLCAwLCAwXSxcbiAgICAgIG11bHQ6IDFcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY29tcGxldGVQcm9wZXJ0eShleHByZXNzaW9uVmFsdWUsIHByb3BlcnR5LCB0eXBlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwcmVzc2lvblZhbHVlLCAndmVsb2NpdHknLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBwcm9wZXJ0eS5nZXRWZWxvY2l0eUF0VGltZShwcm9wZXJ0eS5jb21wLmN1cnJlbnRGcmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZXhwcmVzc2lvblZhbHVlLm51bUtleXMgPSBwcm9wZXJ0eS5rZXlmcmFtZXMgPyBwcm9wZXJ0eS5rZXlmcmFtZXMubGVuZ3RoIDogMDtcblxuICAgICAgZXhwcmVzc2lvblZhbHVlLmtleSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgaWYgKCFleHByZXNzaW9uVmFsdWUubnVtS2V5cykge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlID0gJyc7XG5cbiAgICAgICAgaWYgKCdzJyBpbiBwcm9wZXJ0eS5rZXlmcmFtZXNbcG9zIC0gMV0pIHtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BlcnR5LmtleWZyYW1lc1twb3MgLSAxXS5zO1xuICAgICAgICB9IGVsc2UgaWYgKCdlJyBpbiBwcm9wZXJ0eS5rZXlmcmFtZXNbcG9zIC0gMl0pIHtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BlcnR5LmtleWZyYW1lc1twb3MgLSAyXS5lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gcHJvcGVydHkua2V5ZnJhbWVzW3BvcyAtIDJdLnM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWVQcm9wID0gdHlwZSA9PT0gJ3VuaWRpbWVuc2lvbmFsJyA/IG5ldyBOdW1iZXIodmFsdWUpIDogT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXG4gICAgICAgIHZhbHVlUHJvcC50aW1lID0gcHJvcGVydHkua2V5ZnJhbWVzW3BvcyAtIDFdLnQgLyBwcm9wZXJ0eS5lbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICAgIHZhbHVlUHJvcC52YWx1ZSA9IHR5cGUgPT09ICd1bmlkaW1lbnNpb25hbCcgPyB2YWx1ZVswXSA6IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWVQcm9wO1xuICAgICAgfTtcblxuICAgICAgZXhwcmVzc2lvblZhbHVlLnZhbHVlQXRUaW1lID0gcHJvcGVydHkuZ2V0VmFsdWVBdFRpbWU7XG4gICAgICBleHByZXNzaW9uVmFsdWUuc3BlZWRBdFRpbWUgPSBwcm9wZXJ0eS5nZXRTcGVlZEF0VGltZTtcbiAgICAgIGV4cHJlc3Npb25WYWx1ZS52ZWxvY2l0eUF0VGltZSA9IHByb3BlcnR5LmdldFZlbG9jaXR5QXRUaW1lO1xuICAgICAgZXhwcmVzc2lvblZhbHVlLnByb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eS5wcm9wZXJ0eUdyb3VwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFVuaWRpbWVuc2lvbmFsUHJvcGVydHlJbnRlcmZhY2UocHJvcGVydHkpIHtcbiAgICAgIGlmICghcHJvcGVydHkgfHwgISgncHYnIGluIHByb3BlcnR5KSkge1xuICAgICAgICBwcm9wZXJ0eSA9IGRlZmF1bHRVbmlkaW1lbnNpb25hbFZhbHVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbXVsdCA9IDEgLyBwcm9wZXJ0eS5tdWx0O1xuICAgICAgdmFyIHZhbCA9IHByb3BlcnR5LnB2ICogbXVsdDtcbiAgICAgIHZhciBleHByZXNzaW9uVmFsdWUgPSBuZXcgTnVtYmVyKHZhbCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cbiAgICAgIGV4cHJlc3Npb25WYWx1ZS52YWx1ZSA9IHZhbDtcbiAgICAgIGNvbXBsZXRlUHJvcGVydHkoZXhwcmVzc2lvblZhbHVlLCBwcm9wZXJ0eSwgJ3VuaWRpbWVuc2lvbmFsJyk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocHJvcGVydHkuaykge1xuICAgICAgICAgIHByb3BlcnR5LmdldFZhbHVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWwgPSBwcm9wZXJ0eS52ICogbXVsdDtcblxuICAgICAgICBpZiAoZXhwcmVzc2lvblZhbHVlLnZhbHVlICE9PSB2YWwpIHtcbiAgICAgICAgICBleHByZXNzaW9uVmFsdWUgPSBuZXcgTnVtYmVyKHZhbCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cbiAgICAgICAgICBleHByZXNzaW9uVmFsdWUudmFsdWUgPSB2YWw7XG4gICAgICAgICAgY29tcGxldGVQcm9wZXJ0eShleHByZXNzaW9uVmFsdWUsIHByb3BlcnR5LCAndW5pZGltZW5zaW9uYWwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByZXNzaW9uVmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIE11bHRpZGltZW5zaW9uYWxQcm9wZXJ0eUludGVyZmFjZShwcm9wZXJ0eSkge1xuICAgICAgaWYgKCFwcm9wZXJ0eSB8fCAhKCdwdicgaW4gcHJvcGVydHkpKSB7XG4gICAgICAgIHByb3BlcnR5ID0gZGVmYXVsdE11bHRpZGltZW5zaW9uYWxWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG11bHQgPSAxIC8gcHJvcGVydHkubXVsdDtcbiAgICAgIHZhciBsZW4gPSBwcm9wZXJ0eS5kYXRhICYmIHByb3BlcnR5LmRhdGEubCB8fCBwcm9wZXJ0eS5wdi5sZW5ndGg7XG4gICAgICB2YXIgZXhwcmVzc2lvblZhbHVlID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG4gICAgICB2YXIgYXJyVmFsdWUgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcbiAgICAgIGV4cHJlc3Npb25WYWx1ZS52YWx1ZSA9IGFyclZhbHVlO1xuICAgICAgY29tcGxldGVQcm9wZXJ0eShleHByZXNzaW9uVmFsdWUsIHByb3BlcnR5LCAnbXVsdGlkaW1lbnNpb25hbCcpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5LmspIHtcbiAgICAgICAgICBwcm9wZXJ0eS5nZXRWYWx1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGFyclZhbHVlW2ldID0gcHJvcGVydHkudltpXSAqIG11bHQ7XG4gICAgICAgICAgZXhwcmVzc2lvblZhbHVlW2ldID0gYXJyVmFsdWVbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvblZhbHVlO1xuICAgICAgfTtcbiAgICB9IC8vIFRPRE86IHRyeSB0byBhdm9pZCB1c2luZyB0aGlzIGdldHRlclxuXG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0R2V0dGVyKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRVbmlkaW1lbnNpb25hbFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgIGlmICghcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRHZXR0ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wZXJ0eS5wcm9wVHlwZSA9PT0gJ3VuaWRpbWVuc2lvbmFsJykge1xuICAgICAgICByZXR1cm4gVW5pZGltZW5zaW9uYWxQcm9wZXJ0eUludGVyZmFjZShwcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBNdWx0aWRpbWVuc2lvbmFsUHJvcGVydHlJbnRlcmZhY2UocHJvcGVydHkpO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgVHJhbnNmb3JtRXhwcmVzc2lvbkludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuICAgICAgZnVuY3Rpb24gX3RoaXNGdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgIGNhc2UgJ3NjYWxlJzpcbiAgICAgICAgICBjYXNlICdTY2FsZSc6XG4gICAgICAgICAgY2FzZSAnQURCRSBTY2FsZSc6XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24uc2NhbGU7XG5cbiAgICAgICAgICBjYXNlICdyb3RhdGlvbic6XG4gICAgICAgICAgY2FzZSAnUm90YXRpb24nOlxuICAgICAgICAgIGNhc2UgJ0FEQkUgUm90YXRpb24nOlxuICAgICAgICAgIGNhc2UgJ0FEQkUgUm90YXRlIFonOlxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi5yb3RhdGlvbjtcblxuICAgICAgICAgIGNhc2UgJ0FEQkUgUm90YXRlIFgnOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24ueFJvdGF0aW9uO1xuXG4gICAgICAgICAgY2FzZSAnQURCRSBSb3RhdGUgWSc6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi55Um90YXRpb247XG5cbiAgICAgICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgICAgY2FzZSAnUG9zaXRpb24nOlxuICAgICAgICAgIGNhc2UgJ0FEQkUgUG9zaXRpb24nOlxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLnBvc2l0aW9uO1xuXG4gICAgICAgICAgY2FzZSAnQURCRSBQb3NpdGlvbl8wJzpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLnhQb3NpdGlvbjtcblxuICAgICAgICAgIGNhc2UgJ0FEQkUgUG9zaXRpb25fMSc6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi55UG9zaXRpb247XG5cbiAgICAgICAgICBjYXNlICdBREJFIFBvc2l0aW9uXzInOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24uelBvc2l0aW9uO1xuXG4gICAgICAgICAgY2FzZSAnYW5jaG9yUG9pbnQnOlxuICAgICAgICAgIGNhc2UgJ0FuY2hvclBvaW50JzpcbiAgICAgICAgICBjYXNlICdBbmNob3IgUG9pbnQnOlxuICAgICAgICAgIGNhc2UgJ0FEQkUgQW5jaG9yUG9pbnQnOlxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLmFuY2hvclBvaW50O1xuXG4gICAgICAgICAgY2FzZSAnb3BhY2l0eSc6XG4gICAgICAgICAgY2FzZSAnT3BhY2l0eSc6XG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLm9wYWNpdHk7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICdyb3RhdGlvbicsIHtcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnIgfHwgdHJhbnNmb3JtLnJ6KVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3pSb3RhdGlvbicsIHtcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnJ6IHx8IHRyYW5zZm9ybS5yKVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3hSb3RhdGlvbicsIHtcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnJ4KVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3lSb3RhdGlvbicsIHtcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnJ5KVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3NjYWxlJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucylcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX3B4O1xuXG4gICAgICB2YXIgX3B5O1xuXG4gICAgICB2YXIgX3B6O1xuXG4gICAgICB2YXIgX3RyYW5zZm9ybUZhY3Rvcnk7XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0ucCkge1xuICAgICAgICBfdHJhbnNmb3JtRmFjdG9yeSA9IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcHggPSBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnB4KTtcbiAgICAgICAgX3B5ID0gRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5weSk7XG5cbiAgICAgICAgaWYgKHRyYW5zZm9ybS5weikge1xuICAgICAgICAgIF9weiA9IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHopO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAncG9zaXRpb24nLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIGlmICh0cmFuc2Zvcm0ucCkge1xuICAgICAgICAgICAgcmV0dXJuIF90cmFuc2Zvcm1GYWN0b3J5KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFtfcHgoKSwgX3B5KCksIF9weiA/IF9weigpIDogMF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICd4UG9zaXRpb24nLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5weClcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICd5UG9zaXRpb24nLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5weSlcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICd6UG9zaXRpb24nLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5weilcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICdhbmNob3JQb2ludCcsIHtcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLmEpXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAnb3BhY2l0eScsIHtcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLm8pXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAnc2tldycsIHtcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnNrKVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3NrZXdBeGlzJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0uc2EpXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAnb3JpZW50YXRpb24nLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5vcilcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb247XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBMYXllckV4cHJlc3Npb25JbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0TWF0cml4KHRpbWUpIHtcbiAgICAgIHZhciB0b1dvcmxkTWF0ID0gbmV3IE1hdHJpeCgpO1xuXG4gICAgICBpZiAodGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBwcm9wTWF0cml4ID0gdGhpcy5fZWxlbS5maW5hbFRyYW5zZm9ybS5tUHJvcC5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcblxuICAgICAgICBwcm9wTWF0cml4LmNsb25lKHRvV29ybGRNYXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybU1hdCA9IHRoaXMuX2VsZW0uZmluYWxUcmFuc2Zvcm0ubVByb3A7XG4gICAgICAgIHRyYW5zZm9ybU1hdC5hcHBseVRvTWF0cml4KHRvV29ybGRNYXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9Xb3JsZE1hdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b1dvcmxkVmVjKGFyciwgdGltZSkge1xuICAgICAgdmFyIHRvV29ybGRNYXQgPSB0aGlzLmdldE1hdHJpeCh0aW1lKTtcbiAgICAgIHRvV29ybGRNYXQucHJvcHNbMTJdID0gMDtcbiAgICAgIHRvV29ybGRNYXQucHJvcHNbMTNdID0gMDtcbiAgICAgIHRvV29ybGRNYXQucHJvcHNbMTRdID0gMDtcbiAgICAgIHJldHVybiB0aGlzLmFwcGx5UG9pbnQodG9Xb3JsZE1hdCwgYXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b1dvcmxkKGFyciwgdGltZSkge1xuICAgICAgdmFyIHRvV29ybGRNYXQgPSB0aGlzLmdldE1hdHJpeCh0aW1lKTtcbiAgICAgIHJldHVybiB0aGlzLmFwcGx5UG9pbnQodG9Xb3JsZE1hdCwgYXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tV29ybGRWZWMoYXJyLCB0aW1lKSB7XG4gICAgICB2YXIgdG9Xb3JsZE1hdCA9IHRoaXMuZ2V0TWF0cml4KHRpbWUpO1xuICAgICAgdG9Xb3JsZE1hdC5wcm9wc1sxMl0gPSAwO1xuICAgICAgdG9Xb3JsZE1hdC5wcm9wc1sxM10gPSAwO1xuICAgICAgdG9Xb3JsZE1hdC5wcm9wc1sxNF0gPSAwO1xuICAgICAgcmV0dXJuIHRoaXMuaW52ZXJ0UG9pbnQodG9Xb3JsZE1hdCwgYXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tV29ybGQoYXJyLCB0aW1lKSB7XG4gICAgICB2YXIgdG9Xb3JsZE1hdCA9IHRoaXMuZ2V0TWF0cml4KHRpbWUpO1xuICAgICAgcmV0dXJuIHRoaXMuaW52ZXJ0UG9pbnQodG9Xb3JsZE1hdCwgYXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVBvaW50KG1hdHJpeCwgYXJyKSB7XG4gICAgICBpZiAodGhpcy5fZWxlbS5oaWVyYXJjaHkgJiYgdGhpcy5fZWxlbS5oaWVyYXJjaHkubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5fZWxlbS5oaWVyYXJjaHkubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHRoaXMuX2VsZW0uaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLmFwcGx5VG9NYXRyaXgobWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0cml4LmFwcGx5VG9Qb2ludEFycmF5KGFyclswXSwgYXJyWzFdLCBhcnJbMl0gfHwgMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52ZXJ0UG9pbnQobWF0cml4LCBhcnIpIHtcbiAgICAgIGlmICh0aGlzLl9lbGVtLmhpZXJhcmNoeSAmJiB0aGlzLl9lbGVtLmhpZXJhcmNoeS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLl9lbGVtLmhpZXJhcmNoeS5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgdGhpcy5fZWxlbS5oaWVyYXJjaHlbaV0uZmluYWxUcmFuc2Zvcm0ubVByb3AuYXBwbHlUb01hdHJpeChtYXRyaXgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRyaXguaW52ZXJzZVBvaW50KGFycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbUNvbXAoYXJyKSB7XG4gICAgICB2YXIgdG9Xb3JsZE1hdCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgIHRvV29ybGRNYXQucmVzZXQoKTtcblxuICAgICAgdGhpcy5fZWxlbS5maW5hbFRyYW5zZm9ybS5tUHJvcC5hcHBseVRvTWF0cml4KHRvV29ybGRNYXQpO1xuXG4gICAgICBpZiAodGhpcy5fZWxlbS5oaWVyYXJjaHkgJiYgdGhpcy5fZWxlbS5oaWVyYXJjaHkubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5fZWxlbS5oaWVyYXJjaHkubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHRoaXMuX2VsZW0uaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLmFwcGx5VG9NYXRyaXgodG9Xb3JsZE1hdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9Xb3JsZE1hdC5pbnZlcnNlUG9pbnQoYXJyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvV29ybGRNYXQuaW52ZXJzZVBvaW50KGFycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2FtcGxlSW1hZ2UoKSB7XG4gICAgICByZXR1cm4gWzEsIDEsIDEsIDFdO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgdmFyIHRyYW5zZm9ybUludGVyZmFjZTtcblxuICAgICAgZnVuY3Rpb24gX3JlZ2lzdGVyTWFza0ludGVyZmFjZShtYXNrTWFuYWdlcikge1xuICAgICAgICBfdGhpc0xheWVyRnVuY3Rpb24ubWFzayA9IG5ldyBNYXNrTWFuYWdlckludGVyZmFjZShtYXNrTWFuYWdlciwgZWxlbSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF9yZWdpc3RlckVmZmVjdHNJbnRlcmZhY2UoZWZmZWN0cykge1xuICAgICAgICBfdGhpc0xheWVyRnVuY3Rpb24uZWZmZWN0ID0gZWZmZWN0cztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3RoaXNMYXllckZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgY2FzZSAnQURCRSBSb290IFZlY3RvcnMgR3JvdXAnOlxuICAgICAgICAgIGNhc2UgJ0NvbnRlbnRzJzpcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNMYXllckZ1bmN0aW9uLnNoYXBlSW50ZXJmYWNlO1xuXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBjYXNlICdUcmFuc2Zvcm0nOlxuICAgICAgICAgIGNhc2UgJ3RyYW5zZm9ybSc6XG4gICAgICAgICAgY2FzZSAnQURCRSBUcmFuc2Zvcm0gR3JvdXAnOlxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybUludGVyZmFjZTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlICdBREJFIEVmZmVjdCBQYXJhZGUnOlxuICAgICAgICAgIGNhc2UgJ2VmZmVjdHMnOlxuICAgICAgICAgIGNhc2UgJ0VmZmVjdHMnOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbi5lZmZlY3Q7XG5cbiAgICAgICAgICBjYXNlICdBREJFIFRleHQgUHJvcGVydGllcyc6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNMYXllckZ1bmN0aW9uLnRleHRJbnRlcmZhY2U7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmdldE1hdHJpeCA9IGdldE1hdHJpeDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5pbnZlcnRQb2ludCA9IGludmVydFBvaW50O1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmFwcGx5UG9pbnQgPSBhcHBseVBvaW50O1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnRvV29ybGQgPSB0b1dvcmxkO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnRvV29ybGRWZWMgPSB0b1dvcmxkVmVjO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmZyb21Xb3JsZCA9IGZyb21Xb3JsZDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5mcm9tV29ybGRWZWMgPSBmcm9tV29ybGRWZWM7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24udG9Db21wID0gdG9Xb3JsZDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5mcm9tQ29tcCA9IGZyb21Db21wO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnNhbXBsZUltYWdlID0gc2FtcGxlSW1hZ2U7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uc291cmNlUmVjdEF0VGltZSA9IGVsZW0uc291cmNlUmVjdEF0VGltZS5iaW5kKGVsZW0pO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLl9lbGVtID0gZWxlbTtcbiAgICAgIHRyYW5zZm9ybUludGVyZmFjZSA9IFRyYW5zZm9ybUV4cHJlc3Npb25JbnRlcmZhY2UoZWxlbS5maW5hbFRyYW5zZm9ybS5tUHJvcCk7XG4gICAgICB2YXIgYW5jaG9yUG9pbnREZXNjcmlwdG9yID0gZ2V0RGVzY3JpcHRvcih0cmFuc2Zvcm1JbnRlcmZhY2UsICdhbmNob3JQb2ludCcpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXNMYXllckZ1bmN0aW9uLCB7XG4gICAgICAgIGhhc1BhcmVudDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uaGllcmFyY2h5Lmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uaGllcmFyY2h5WzBdLmxheWVySW50ZXJmYWNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcm90YXRpb246IGdldERlc2NyaXB0b3IodHJhbnNmb3JtSW50ZXJmYWNlLCAncm90YXRpb24nKSxcbiAgICAgICAgc2NhbGU6IGdldERlc2NyaXB0b3IodHJhbnNmb3JtSW50ZXJmYWNlLCAnc2NhbGUnKSxcbiAgICAgICAgcG9zaXRpb246IGdldERlc2NyaXB0b3IodHJhbnNmb3JtSW50ZXJmYWNlLCAncG9zaXRpb24nKSxcbiAgICAgICAgb3BhY2l0eTogZ2V0RGVzY3JpcHRvcih0cmFuc2Zvcm1JbnRlcmZhY2UsICdvcGFjaXR5JyksXG4gICAgICAgIGFuY2hvclBvaW50OiBhbmNob3JQb2ludERlc2NyaXB0b3IsXG4gICAgICAgIGFuY2hvcl9wb2ludDogYW5jaG9yUG9pbnREZXNjcmlwdG9yLFxuICAgICAgICB0cmFuc2Zvcm06IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1JbnRlcmZhY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhY3RpdmU6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmlzSW5SYW5nZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnN0YXJ0VGltZSA9IGVsZW0uZGF0YS5zdDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5pbmRleCA9IGVsZW0uZGF0YS5pbmQ7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uc291cmNlID0gZWxlbS5kYXRhLnJlZklkO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmhlaWdodCA9IGVsZW0uZGF0YS50eSA9PT0gMCA/IGVsZW0uZGF0YS5oIDogMTAwO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLndpZHRoID0gZWxlbS5kYXRhLnR5ID09PSAwID8gZWxlbS5kYXRhLncgOiAxMDA7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uaW5Qb2ludCA9IGVsZW0uZGF0YS5pcCAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5vdXRQb2ludCA9IGVsZW0uZGF0YS5vcCAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5fbmFtZSA9IGVsZW0uZGF0YS5ubTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5yZWdpc3Rlck1hc2tJbnRlcmZhY2UgPSBfcmVnaXN0ZXJNYXNrSW50ZXJmYWNlO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnJlZ2lzdGVyRWZmZWN0c0ludGVyZmFjZSA9IF9yZWdpc3RlckVmZmVjdHNJbnRlcmZhY2U7XG4gICAgICByZXR1cm4gX3RoaXNMYXllckZ1bmN0aW9uO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgcHJvcGVydHlHcm91cEZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbnRlcmZhY2VGdW5jdGlvbiwgcGFyZW50UHJvcGVydHlHcm91cCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFsID0gdmFsID09PSB1bmRlZmluZWQgPyAxIDogdmFsO1xuXG4gICAgICAgIGlmICh2YWwgPD0gMCkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnRQcm9wZXJ0eUdyb3VwKHZhbCAtIDEpO1xuICAgICAgfTtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIFByb3BlcnR5SW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAocHJvcGVydHlOYW1lLCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICB2YXIgaW50ZXJmYWNlRnVuY3Rpb24gPSB7XG4gICAgICAgIF9uYW1lOiBwcm9wZXJ0eU5hbWVcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIF9wcm9wZXJ0eUdyb3VwKHZhbCkge1xuICAgICAgICB2YWwgPSB2YWwgPT09IHVuZGVmaW5lZCA/IDEgOiB2YWw7XG5cbiAgICAgICAgaWYgKHZhbCA8PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb3BlcnR5R3JvdXAodmFsIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcHJvcGVydHlHcm91cDtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIEVmZmVjdHNFeHByZXNzaW9uSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYiA9IHtcbiAgICAgIGNyZWF0ZUVmZmVjdHNJbnRlcmZhY2U6IGNyZWF0ZUVmZmVjdHNJbnRlcmZhY2VcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRWZmZWN0c0ludGVyZmFjZShlbGVtLCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBpZiAoZWxlbS5lZmZlY3RzTWFuYWdlcikge1xuICAgICAgICB2YXIgZWZmZWN0RWxlbWVudHMgPSBbXTtcbiAgICAgICAgdmFyIGVmZmVjdHNEYXRhID0gZWxlbS5kYXRhLmVmO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxlbiA9IGVsZW0uZWZmZWN0c01hbmFnZXIuZWZmZWN0RWxlbWVudHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGVmZmVjdEVsZW1lbnRzLnB1c2goY3JlYXRlR3JvdXBJbnRlcmZhY2UoZWZmZWN0c0RhdGFbaV0sIGVsZW0uZWZmZWN0c01hbmFnZXIuZWZmZWN0RWxlbWVudHNbaV0sIHByb3BlcnR5R3JvdXAsIGVsZW0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlZmZlY3RzID0gZWxlbS5kYXRhLmVmIHx8IFtdO1xuXG4gICAgICAgIHZhciBncm91cEludGVyZmFjZSA9IGZ1bmN0aW9uIGdyb3VwSW50ZXJmYWNlKG5hbWUpIHtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgICBsZW4gPSBlZmZlY3RzLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gZWZmZWN0c1tpXS5ubSB8fCBuYW1lID09PSBlZmZlY3RzW2ldLm1uIHx8IG5hbWUgPT09IGVmZmVjdHNbaV0uaXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVmZmVjdEVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdyb3VwSW50ZXJmYWNlLCAnbnVtUHJvcGVydGllcycsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBlZmZlY3RzLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ3JvdXBJbnRlcmZhY2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUdyb3VwSW50ZXJmYWNlKGRhdGEsIGVsZW1lbnRzLCBwcm9wZXJ0eUdyb3VwLCBlbGVtKSB7XG4gICAgICBmdW5jdGlvbiBncm91cEludGVyZmFjZShuYW1lKSB7XG4gICAgICAgIHZhciBlZmZlY3RzID0gZGF0YS5lZjtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gZWZmZWN0cy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gZWZmZWN0c1tpXS5ubSB8fCBuYW1lID09PSBlZmZlY3RzW2ldLm1uIHx8IG5hbWUgPT09IGVmZmVjdHNbaV0uaXgpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3RzW2ldLnR5ID09PSA1KSB7XG4gICAgICAgICAgICAgIHJldHVybiBlZmZlY3RFbGVtZW50c1tpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVmZmVjdEVsZW1lbnRzW2ldKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGdyb3VwSW50ZXJmYWNlLCBwcm9wZXJ0eUdyb3VwKTtcblxuICAgICAgdmFyIGVmZmVjdEVsZW1lbnRzID0gW107XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBkYXRhLmVmLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmIChkYXRhLmVmW2ldLnR5ID09PSA1KSB7XG4gICAgICAgICAgZWZmZWN0RWxlbWVudHMucHVzaChjcmVhdGVHcm91cEludGVyZmFjZShkYXRhLmVmW2ldLCBlbGVtZW50cy5lZmZlY3RFbGVtZW50c1tpXSwgZWxlbWVudHMuZWZmZWN0RWxlbWVudHNbaV0ucHJvcGVydHlHcm91cCwgZWxlbSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVmZmVjdEVsZW1lbnRzLnB1c2goY3JlYXRlVmFsdWVJbnRlcmZhY2UoZWxlbWVudHMuZWZmZWN0RWxlbWVudHNbaV0sIGRhdGEuZWZbaV0udHksIGVsZW0sIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEubW4gPT09ICdBREJFIENvbG9yIENvbnRyb2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShncm91cEludGVyZmFjZSwgJ2NvbG9yJywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGVmZmVjdEVsZW1lbnRzWzBdKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZ3JvdXBJbnRlcmZhY2UsIHtcbiAgICAgICAgbnVtUHJvcGVydGllczoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubnA7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfbmFtZToge1xuICAgICAgICAgIHZhbHVlOiBkYXRhLm5tXG4gICAgICAgIH0sXG4gICAgICAgIHByb3BlcnR5R3JvdXA6IHtcbiAgICAgICAgICB2YWx1ZTogX3Byb3BlcnR5R3JvdXBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBncm91cEludGVyZmFjZS5lbmFibGVkID0gZGF0YS5lbiAhPT0gMDtcbiAgICAgIGdyb3VwSW50ZXJmYWNlLmFjdGl2ZSA9IGdyb3VwSW50ZXJmYWNlLmVuYWJsZWQ7XG4gICAgICByZXR1cm4gZ3JvdXBJbnRlcmZhY2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVmFsdWVJbnRlcmZhY2UoZWxlbWVudCwgdHlwZSwgZWxlbSwgcHJvcGVydHlHcm91cCkge1xuICAgICAgdmFyIGV4cHJlc3Npb25Qcm9wZXJ0eSA9IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShlbGVtZW50LnApO1xuXG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IDEwKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW0uY29tcC5jb21wSW50ZXJmYWNlKGVsZW1lbnQucC52KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHByZXNzaW9uUHJvcGVydHkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQucC5zZXRHcm91cFByb3BlcnR5KSB7XG4gICAgICAgIGVsZW1lbnQucC5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCcnLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gb2I7XG4gIH0oKTtcblxuICB2YXIgU2hhcGVQYXRoSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBwYXRoSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgdmFyIHByb3AgPSB2aWV3LnNoO1xuXG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gJ1NoYXBlJyB8fCB2YWwgPT09ICdzaGFwZScgfHwgdmFsID09PSAnUGF0aCcgfHwgdmFsID09PSAncGF0aCcgfHwgdmFsID09PSAnQURCRSBWZWN0b3IgU2hhcGUnIHx8IHZhbCA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGludGVyZmFjZUZ1bmN0aW9uLCBwcm9wZXJ0eUdyb3VwKTtcblxuICAgICAgcHJvcC5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdQYXRoJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIGlmIChwcm9wLmspIHtcbiAgICAgICAgICAgICAgcHJvcC5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAocHJvcC5rKSB7XG4gICAgICAgICAgICAgIHByb3AuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfbmFtZToge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5ubVxuICAgICAgICB9LFxuICAgICAgICBpeDoge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5peFxuICAgICAgICB9LFxuICAgICAgICBwcm9wZXJ0eUluZGV4OiB7XG4gICAgICAgICAgdmFsdWU6IHNoYXBlLml4XG4gICAgICAgIH0sXG4gICAgICAgIG1uOiB7XG4gICAgICAgICAgdmFsdWU6IHNoYXBlLm1uXG4gICAgICAgIH0sXG4gICAgICAgIHByb3BlcnR5R3JvdXA6IHtcbiAgICAgICAgICB2YWx1ZTogcHJvcGVydHlHcm91cFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIFNoYXBlRXhwcmVzc2lvbkludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBpdGVyYXRlRWxlbWVudHMoc2hhcGVzLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBzaGFwZXMgPyBzaGFwZXMubGVuZ3RoIDogMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmIChzaGFwZXNbaV0udHkgPT09ICdncicpIHtcbiAgICAgICAgICBhcnIucHVzaChncm91cEludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAnZmwnKSB7XG4gICAgICAgICAgYXJyLnB1c2goZmlsbEludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAnc3QnKSB7XG4gICAgICAgICAgYXJyLnB1c2goc3Ryb2tlSW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sIHZpZXdbaV0sIHByb3BlcnR5R3JvdXApKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICd0bScpIHtcbiAgICAgICAgICBhcnIucHVzaCh0cmltSW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sIHZpZXdbaV0sIHByb3BlcnR5R3JvdXApKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICd0cicpIHsvLyBhcnIucHVzaCh0cmFuc2Zvcm1JbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSx2aWV3W2ldLHByb3BlcnR5R3JvdXApKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICdlbCcpIHtcbiAgICAgICAgICBhcnIucHVzaChlbGxpcHNlSW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sIHZpZXdbaV0sIHByb3BlcnR5R3JvdXApKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICdzcicpIHtcbiAgICAgICAgICBhcnIucHVzaChzdGFySW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sIHZpZXdbaV0sIHByb3BlcnR5R3JvdXApKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICdzaCcpIHtcbiAgICAgICAgICBhcnIucHVzaChTaGFwZVBhdGhJbnRlcmZhY2Uoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAncmMnKSB7XG4gICAgICAgICAgYXJyLnB1c2gocmVjdEludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAncmQnKSB7XG4gICAgICAgICAgYXJyLnB1c2gocm91bmRlZEludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAncnAnKSB7XG4gICAgICAgICAgYXJyLnB1c2gocmVwZWF0ZXJJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ2dmJykge1xuICAgICAgICAgIGFyci5wdXNoKGdyYWRpZW50RmlsbEludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyLnB1c2goZGVmYXVsdEludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb250ZW50c0ludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIHZhciBpbnRlcmZhY2VzO1xuXG4gICAgICB2YXIgaW50ZXJmYWNlRnVuY3Rpb24gPSBmdW5jdGlvbiBfaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gaW50ZXJmYWNlcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICBpZiAoaW50ZXJmYWNlc1tpXS5fbmFtZSA9PT0gdmFsdWUgfHwgaW50ZXJmYWNlc1tpXS5tbiA9PT0gdmFsdWUgfHwgaW50ZXJmYWNlc1tpXS5wcm9wZXJ0eUluZGV4ID09PSB2YWx1ZSB8fCBpbnRlcmZhY2VzW2ldLml4ID09PSB2YWx1ZSB8fCBpbnRlcmZhY2VzW2ldLmluZCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VzW2ldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZXNbdmFsdWUgLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcblxuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGludGVyZmFjZUZ1bmN0aW9uLCBwcm9wZXJ0eUdyb3VwKTtcbiAgICAgIGludGVyZmFjZXMgPSBpdGVyYXRlRWxlbWVudHMoc2hhcGUuaXQsIHZpZXcuaXQsIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXApO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ubnVtUHJvcGVydGllcyA9IGludGVyZmFjZXMubGVuZ3RoO1xuICAgICAgdmFyIHRyYW5zZm9ybUludGVyZmFjZSA9IHRyYW5zZm9ybUludGVyZmFjZUZhY3Rvcnkoc2hhcGUuaXRbc2hhcGUuaXQubGVuZ3RoIC0gMV0sIHZpZXcuaXRbdmlldy5pdC5sZW5ndGggLSAxXSwgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1JbnRlcmZhY2U7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuY2l4O1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24uX25hbWUgPSBzaGFwZS5ubTtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBncm91cEludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIHZhciBpbnRlcmZhY2VGdW5jdGlvbiA9IGZ1bmN0aW9uIF9pbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAnQURCRSBWZWN0b3JzIEdyb3VwJzpcbiAgICAgICAgICBjYXNlICdDb250ZW50cyc6XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmNvbnRlbnQ7XG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSBmb3Igbm93LiBLZWVwaW5nIHRoZW0gaGVyZSBpbiBjYXNlIGEgbmV3IGNhc2UgYXBwZWFyc1xuICAgICAgICAgIC8vIGNhc2UgJ0FEQkUgVmVjdG9yIFRyYW5zZm9ybSBHcm91cCc6XG4gICAgICAgICAgLy8gY2FzZSAzOlxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi50cmFuc2Zvcm07XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG4gICAgICB2YXIgY29udGVudCA9IGNvbnRlbnRzSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCk7XG4gICAgICB2YXIgdHJhbnNmb3JtSW50ZXJmYWNlID0gdHJhbnNmb3JtSW50ZXJmYWNlRmFjdG9yeShzaGFwZS5pdFtzaGFwZS5pdC5sZW5ndGggLSAxXSwgdmlldy5pdFt2aWV3Lml0Lmxlbmd0aCAtIDFdLCBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwKTtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24udHJhbnNmb3JtID0gdHJhbnNmb3JtSW50ZXJmYWNlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGludGVyZmFjZUZ1bmN0aW9uLCAnX25hbWUnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBzaGFwZS5ubTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIGludGVyZmFjZUZ1bmN0aW9uLmNvbnRlbnQgPSBpbnRlcmZhY2VGdW5jdGlvbjtcblxuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ubnVtUHJvcGVydGllcyA9IHNoYXBlLm5wO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ubm0gPSBzaGFwZS5ubTtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsbEludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBpZiAodmFsID09PSAnQ29sb3InIHx8IHZhbCA9PT0gJ2NvbG9yJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5jb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPT09ICdPcGFjaXR5JyB8fCB2YWwgPT09ICdvcGFjaXR5Jykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vcGFjaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5jKVxuICAgICAgICB9LFxuICAgICAgICBvcGFjaXR5OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5vKVxuICAgICAgICB9LFxuICAgICAgICBfbmFtZToge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5ubVxuICAgICAgICB9LFxuICAgICAgICBtbjoge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5tblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZpZXcuYy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdDb2xvcicsIHByb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcuby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPcGFjaXR5JywgcHJvcGVydHlHcm91cCkpO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdyYWRpZW50RmlsbEludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBpZiAodmFsID09PSAnU3RhcnQgUG9pbnQnIHx8IHZhbCA9PT0gJ3N0YXJ0IHBvaW50Jykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5zdGFydFBvaW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbCA9PT0gJ0VuZCBQb2ludCcgfHwgdmFsID09PSAnZW5kIHBvaW50Jykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5lbmRQb2ludDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPT09ICdPcGFjaXR5JyB8fCB2YWwgPT09ICdvcGFjaXR5Jykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vcGFjaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XG4gICAgICAgIHN0YXJ0UG9pbnQ6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LnMpXG4gICAgICAgIH0sXG4gICAgICAgIGVuZFBvaW50OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5lKVxuICAgICAgICB9LFxuICAgICAgICBvcGFjaXR5OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5vKVxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2EnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfSxcbiAgICAgICAgbW46IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubW5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2aWV3LnMuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnU3RhcnQgUG9pbnQnLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3LmUuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnRW5kIFBvaW50JywgcHJvcGVydHlHcm91cCkpO1xuICAgICAgdmlldy5vLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ09wYWNpdHknLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdEludGVyZmFjZUZhY3RvcnkoKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJva2VJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIHZhciBfZGFzaFByb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShkYXNoT2IsIF9wcm9wZXJ0eUdyb3VwKTtcblxuICAgICAgZnVuY3Rpb24gYWRkUHJvcGVydHlUb0Rhc2hPYihpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXNoT2IsIHNoYXBlLmRbaV0ubm0sIHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LmQuZGF0YVByb3BzW2ldLnApXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBzaGFwZS5kID8gc2hhcGUuZC5sZW5ndGggOiAwO1xuICAgICAgdmFyIGRhc2hPYiA9IHt9O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYWRkUHJvcGVydHlUb0Rhc2hPYihpKTtcbiAgICAgICAgdmlldy5kLmRhdGFQcm9wc1tpXS5wLnNldEdyb3VwUHJvcGVydHkoX2Rhc2hQcm9wZXJ0eUdyb3VwKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT09ICdDb2xvcicgfHwgdmFsID09PSAnY29sb3InKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbCA9PT0gJ09wYWNpdHknIHx8IHZhbCA9PT0gJ29wYWNpdHknKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLm9wYWNpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsID09PSAnU3Ryb2tlIFdpZHRoJyB8fCB2YWwgPT09ICdzdHJva2Ugd2lkdGgnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnN0cm9rZVdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5jKVxuICAgICAgICB9LFxuICAgICAgICBvcGFjaXR5OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5vKVxuICAgICAgICB9LFxuICAgICAgICBzdHJva2VXaWR0aDoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudylcbiAgICAgICAgfSxcbiAgICAgICAgZGFzaDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhc2hPYjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9uYW1lOiB7XG4gICAgICAgICAgdmFsdWU6IHNoYXBlLm5tXG4gICAgICAgIH0sXG4gICAgICAgIG1uOiB7XG4gICAgICAgICAgdmFsdWU6IHNoYXBlLm1uXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmlldy5jLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ0NvbG9yJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcuby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPcGFjaXR5JywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcudy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTdHJva2UgV2lkdGgnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyaW1JbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gc2hhcGUuZS5peCB8fCB2YWwgPT09ICdFbmQnIHx8IHZhbCA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uZW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbCA9PT0gc2hhcGUucy5peCkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5zdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPT09IHNoYXBlLm8uaXgpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGludGVyZmFjZUZ1bmN0aW9uLCBwcm9wZXJ0eUdyb3VwKTtcblxuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xuICAgICAgdmlldy5zLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1N0YXJ0JywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcuZS5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdFbmQnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgdmlldy5vLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ09mZnNldCcsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuaXg7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cDtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5zKVxuICAgICAgICB9LFxuICAgICAgICBlbmQ6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LmUpXG4gICAgICAgIH0sXG4gICAgICAgIG9mZnNldDoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcubylcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChzaGFwZS5hLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ0FuY2hvciBQb2ludCcpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uYW5jaG9yUG9pbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUuby5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdPcGFjaXR5Jykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vcGFjaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLnAuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnUG9zaXRpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLnIuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnUm90YXRpb24nIHx8IHZhbHVlID09PSAnQURCRSBWZWN0b3IgUm90YXRpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnJvdGF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLnMuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnU2NhbGUnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLnNrICYmIHNoYXBlLnNrLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1NrZXcnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnNrZXc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUuc2EgJiYgc2hhcGUuc2EuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnU2tldyBBeGlzJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5za2V3QXhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5vLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ09wYWNpdHknLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgdmlldy50cmFuc2Zvcm0ubVByb3BzLnAuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnUG9zaXRpb24nLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgdmlldy50cmFuc2Zvcm0ubVByb3BzLmEuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnQW5jaG9yIFBvaW50JywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5zLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1NjYWxlJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5yLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1JvdGF0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcblxuICAgICAgaWYgKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5zaykge1xuICAgICAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMuc2suc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnU2tldycsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5zYS5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTa2V3IEFuZ2xlJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIH1cblxuICAgICAgdmlldy50cmFuc2Zvcm0ub3Auc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnT3BhY2l0eScsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBvcGFjaXR5OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLm8pXG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLnApXG4gICAgICAgIH0sXG4gICAgICAgIGFuY2hvclBvaW50OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLmEpXG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxlOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLnMpXG4gICAgICAgIH0sXG4gICAgICAgIHJvdGF0aW9uOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLnIpXG4gICAgICAgIH0sXG4gICAgICAgIHNrZXc6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LnRyYW5zZm9ybS5tUHJvcHMuc2spXG4gICAgICAgIH0sXG4gICAgICAgIHNrZXdBeGlzOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLnNhKVxuICAgICAgICB9LFxuICAgICAgICBfbmFtZToge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5ubVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnR5ID0gJ3RyJztcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cDtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbGxpcHNlSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHNoYXBlLnAuaXggPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLnMuaXggPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnNpemU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIF9wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xuXG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuaXg7XG4gICAgICB2YXIgcHJvcCA9IHZpZXcuc2gudHkgPT09ICd0bScgPyB2aWV3LnNoLnByb3AgOiB2aWV3LnNoO1xuICAgICAgcHJvcC5zLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1NpemUnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgcHJvcC5wLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1Bvc2l0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLnMpXG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5wKVxuICAgICAgICB9LFxuICAgICAgICBfbmFtZToge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5ubVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhckludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChzaGFwZS5wLml4ID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5yLml4ID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5yb3RhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5wdC5peCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucG9pbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLm9yLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ0FEQkUgVmVjdG9yIFN0YXIgT3V0ZXIgUmFkaXVzJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vdXRlclJhZGl1cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5vcy5peCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3V0ZXJSb3VuZG5lc3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUuaXIgJiYgKHNoYXBlLmlyLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ0FEQkUgVmVjdG9yIFN0YXIgSW5uZXIgUmFkaXVzJykpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uaW5uZXJSYWRpdXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUuaXMgJiYgc2hhcGUuaXMuaXggPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmlubmVyUm91bmRuZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGludGVyZmFjZUZ1bmN0aW9uLCBwcm9wZXJ0eUdyb3VwKTtcblxuICAgICAgdmFyIHByb3AgPSB2aWV3LnNoLnR5ID09PSAndG0nID8gdmlldy5zaC5wcm9wIDogdmlldy5zaDtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5peDtcbiAgICAgIHByb3Aub3Iuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnT3V0ZXIgUmFkaXVzJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHByb3Aub3Muc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnT3V0ZXIgUm91bmRuZXNzJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHByb3AucHQuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnUG9pbnRzJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHByb3AucC5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdQb3NpdGlvbicsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBwcm9wLnIuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnUm90YXRpb24nLCBfcHJvcGVydHlHcm91cCkpO1xuXG4gICAgICBpZiAoc2hhcGUuaXIpIHtcbiAgICAgICAgcHJvcC5pci5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdJbm5lciBSYWRpdXMnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgICBwcm9wLmlzLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ0lubmVyIFJvdW5kbmVzcycsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5wKVxuICAgICAgICB9LFxuICAgICAgICByb3RhdGlvbjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucilcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnRzOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5wdClcbiAgICAgICAgfSxcbiAgICAgICAgb3V0ZXJSYWRpdXM6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLm9yKVxuICAgICAgICB9LFxuICAgICAgICBvdXRlclJvdW5kbmVzczoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3Aub3MpXG4gICAgICAgIH0sXG4gICAgICAgIGlubmVyUmFkaXVzOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5pcilcbiAgICAgICAgfSxcbiAgICAgICAgaW5uZXJSb3VuZG5lc3M6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLmlzKVxuICAgICAgICB9LFxuICAgICAgICBfbmFtZToge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5ubVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVjdEludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChzaGFwZS5wLml4ID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5yLml4ID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5yb3VuZG5lc3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUucy5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdTaXplJyB8fCB2YWx1ZSA9PT0gJ0FEQkUgVmVjdG9yIFJlY3QgU2l6ZScpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIHZhciBwcm9wID0gdmlldy5zaC50eSA9PT0gJ3RtJyA/IHZpZXcuc2gucHJvcCA6IHZpZXcuc2g7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuaXg7XG4gICAgICBwcm9wLnAuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnUG9zaXRpb24nLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgcHJvcC5zLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1NpemUnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgcHJvcC5yLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1JvdGF0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5wKVxuICAgICAgICB9LFxuICAgICAgICByb3VuZG5lc3M6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLnIpXG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLnMpXG4gICAgICAgIH0sXG4gICAgICAgIF9uYW1lOiB7XG4gICAgICAgICAgdmFsdWU6IHNoYXBlLm5tXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ubW4gPSBzaGFwZS5tbjtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByb3VuZGVkSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHNoYXBlLnIuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnUm91bmQgQ29ybmVycyAxJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5yYWRpdXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIF9wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xuXG4gICAgICB2YXIgcHJvcCA9IHZpZXc7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuaXg7XG4gICAgICBwcm9wLnJkLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1JhZGl1cycsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICByYWRpdXM6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLnJkKVxuICAgICAgICB9LFxuICAgICAgICBfbmFtZToge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5ubVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwZWF0ZXJJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoc2hhcGUuYy5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdDb3BpZXMnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmNvcGllcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5vLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ09mZnNldCcpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGludGVyZmFjZUZ1bmN0aW9uLCBwcm9wZXJ0eUdyb3VwKTtcblxuICAgICAgdmFyIHByb3AgPSB2aWV3O1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xuICAgICAgcHJvcC5jLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ0NvcGllcycsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBwcm9wLm8uc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnT2Zmc2V0JywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XG4gICAgICAgIGNvcGllczoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AuYylcbiAgICAgICAgfSxcbiAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5vKVxuICAgICAgICB9LFxuICAgICAgICBfbmFtZToge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5ubVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzaGFwZXMsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIHZhciBpbnRlcmZhY2VzO1xuXG4gICAgICBmdW5jdGlvbiBfaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSB1bmRlZmluZWQgPyAxIDogdmFsdWU7XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eUdyb3VwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VzW3ZhbHVlIC0gMV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBpbnRlcmZhY2VzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgIGlmIChpbnRlcmZhY2VzW2ldLl9uYW1lID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVyZmFjZXNbaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBhcmVudEdyb3VwV3JhcHBlcigpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5R3JvdXA7XG4gICAgICB9XG5cbiAgICAgIF9pbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoX2ludGVyZmFjZUZ1bmN0aW9uLCBwYXJlbnRHcm91cFdyYXBwZXIpO1xuICAgICAgaW50ZXJmYWNlcyA9IGl0ZXJhdGVFbGVtZW50cyhzaGFwZXMsIHZpZXcsIF9pbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwKTtcbiAgICAgIF9pbnRlcmZhY2VGdW5jdGlvbi5udW1Qcm9wZXJ0aWVzID0gaW50ZXJmYWNlcy5sZW5ndGg7XG4gICAgICBfaW50ZXJmYWNlRnVuY3Rpb24uX25hbWUgPSAnQ29udGVudHMnO1xuICAgICAgcmV0dXJuIF9pbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIFRleHRFeHByZXNzaW9uSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgdmFyIF9zb3VyY2VUZXh0O1xuXG4gICAgICBmdW5jdGlvbiBfdGhpc0xheWVyRnVuY3Rpb24obmFtZSkge1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICBjYXNlICdBREJFIFRleHQgRG9jdW1lbnQnOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbi5zb3VyY2VUZXh0O1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0xheWVyRnVuY3Rpb24sICdzb3VyY2VUZXh0Jywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICBlbGVtLnRleHRQcm9wZXJ0eS5nZXRWYWx1ZSgpO1xuICAgICAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IGVsZW0udGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLnQ7XG5cbiAgICAgICAgICBpZiAoIV9zb3VyY2VUZXh0IHx8IHN0cmluZ1ZhbHVlICE9PSBfc291cmNlVGV4dC52YWx1ZSkge1xuICAgICAgICAgICAgX3NvdXJjZVRleHQgPSBuZXcgU3RyaW5nKHN0cmluZ1ZhbHVlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcbiAgICAgICAgICAgIC8vIElmIHN0cmluZ1ZhbHVlIGlzIGFuIGVtcHR5IHN0cmluZywgZXZhbCByZXR1cm5zIHVuZGVmaW5lZCwgc28gaXQgaGFzIHRvIGJlIHJldHVybmVkIGFzIGEgU3RyaW5nIHByaW1pdGl2ZVxuXG4gICAgICAgICAgICBfc291cmNlVGV4dC52YWx1ZSA9IHN0cmluZ1ZhbHVlIHx8IG5ldyBTdHJpbmcoc3RyaW5nVmFsdWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3NvdXJjZVRleHQsICdzdHlsZScsIHtcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogZWxlbS50ZXh0UHJvcGVydHkuY3VycmVudERhdGEuZmNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gX3NvdXJjZVRleHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbjtcbiAgICB9O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4gIHZhciBGb290YWdlSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvdXRsaW5lSW50ZXJmYWNlRmFjdG9yeSA9IGZ1bmN0aW9uIG91dGxpbmVJbnRlcmZhY2VGYWN0b3J5KGVsZW0pIHtcbiAgICAgIHZhciBjdXJyZW50UHJvcGVydHlOYW1lID0gJyc7XG4gICAgICB2YXIgY3VycmVudFByb3BlcnR5ID0gZWxlbS5nZXRGb290YWdlRGF0YSgpO1xuXG4gICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICBjdXJyZW50UHJvcGVydHlOYW1lID0gJyc7XG4gICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IGVsZW0uZ2V0Rm9vdGFnZURhdGEoKTtcbiAgICAgICAgcmV0dXJuIHNlYXJjaFByb3BlcnR5O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZWFyY2hQcm9wZXJ0eSh2YWx1ZSkge1xuICAgICAgICBpZiAoY3VycmVudFByb3BlcnR5W3ZhbHVlXSkge1xuICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eU5hbWUgPSB2YWx1ZTtcbiAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHlbdmFsdWVdO1xuXG4gICAgICAgICAgaWYgKF90eXBlb2YoY3VycmVudFByb3BlcnR5KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWFyY2hQcm9wZXJ0eTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY3VycmVudFByb3BlcnR5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3BlcnR5TmFtZUluZGV4ID0gdmFsdWUuaW5kZXhPZihjdXJyZW50UHJvcGVydHlOYW1lKTtcblxuICAgICAgICBpZiAocHJvcGVydHlOYW1lSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyKHByb3BlcnR5TmFtZUluZGV4ICsgY3VycmVudFByb3BlcnR5TmFtZS5sZW5ndGgpLCAxMCk7XG4gICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gY3VycmVudFByb3BlcnR5W2luZGV4XTtcblxuICAgICAgICAgIGlmIChfdHlwZW9mKGN1cnJlbnRQcm9wZXJ0eSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VhcmNoUHJvcGVydHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRQcm9wZXJ0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluaXQ7XG4gICAgfTtcblxuICAgIHZhciBkYXRhSW50ZXJmYWNlRmFjdG9yeSA9IGZ1bmN0aW9uIGRhdGFJbnRlcmZhY2VGYWN0b3J5KGVsZW0pIHtcbiAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ091dGxpbmUnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLm91dGxpbmVJbnRlcmZhY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5fbmFtZSA9ICdPdXRsaW5lJztcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm91dGxpbmVJbnRlcmZhY2UgPSBvdXRsaW5lSW50ZXJmYWNlRmFjdG9yeShlbGVtKTtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICBmdW5jdGlvbiBfaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSAnRGF0YScpIHtcbiAgICAgICAgICByZXR1cm4gX2ludGVyZmFjZUZ1bmN0aW9uLmRhdGFJbnRlcmZhY2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgX2ludGVyZmFjZUZ1bmN0aW9uLl9uYW1lID0gJ0RhdGEnO1xuICAgICAgX2ludGVyZmFjZUZ1bmN0aW9uLmRhdGFJbnRlcmZhY2UgPSBkYXRhSW50ZXJmYWNlRmFjdG9yeShlbGVtKTtcbiAgICAgIHJldHVybiBfaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBpbnRlcmZhY2VzID0ge1xuICAgIGxheWVyOiBMYXllckV4cHJlc3Npb25JbnRlcmZhY2UsXG4gICAgZWZmZWN0czogRWZmZWN0c0V4cHJlc3Npb25JbnRlcmZhY2UsXG4gICAgY29tcDogQ29tcEV4cHJlc3Npb25JbnRlcmZhY2UsXG4gICAgc2hhcGU6IFNoYXBlRXhwcmVzc2lvbkludGVyZmFjZSxcbiAgICB0ZXh0OiBUZXh0RXhwcmVzc2lvbkludGVyZmFjZSxcbiAgICBmb290YWdlOiBGb290YWdlSW50ZXJmYWNlXG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0SW50ZXJmYWNlKHR5cGUpIHtcbiAgICByZXR1cm4gaW50ZXJmYWNlc1t0eXBlXSB8fCBudWxsO1xuICB9XG5cbiAgdmFyIGV4cHJlc3Npb25IZWxwZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHNlYXJjaEV4cHJlc3Npb25zKGVsZW0sIGRhdGEsIHByb3ApIHtcbiAgICAgIGlmIChkYXRhLngpIHtcbiAgICAgICAgcHJvcC5rID0gdHJ1ZTtcbiAgICAgICAgcHJvcC54ID0gdHJ1ZTtcbiAgICAgICAgcHJvcC5pbml0aWF0ZUV4cHJlc3Npb24gPSBFeHByZXNzaW9uTWFuYWdlci5pbml0aWF0ZUV4cHJlc3Npb247XG4gICAgICAgIHByb3AuZWZmZWN0c1NlcXVlbmNlLnB1c2gocHJvcC5pbml0aWF0ZUV4cHJlc3Npb24oZWxlbSwgZGF0YSwgcHJvcCkuYmluZChwcm9wKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVBdFRpbWUoZnJhbWVOdW0pIHtcbiAgICAgIGZyYW1lTnVtICo9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgIGZyYW1lTnVtIC09IHRoaXMub2Zmc2V0VGltZTtcblxuICAgICAgaWYgKGZyYW1lTnVtICE9PSB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RGcmFtZSkge1xuICAgICAgICB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RJbmRleCA9IHRoaXMuX2NhY2hpbmdBdFRpbWUubGFzdEZyYW1lIDwgZnJhbWVOdW0gPyB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RJbmRleCA6IDA7XG4gICAgICAgIHRoaXMuX2NhY2hpbmdBdFRpbWUudmFsdWUgPSB0aGlzLmludGVycG9sYXRlVmFsdWUoZnJhbWVOdW0sIHRoaXMuX2NhY2hpbmdBdFRpbWUpO1xuICAgICAgICB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RGcmFtZSA9IGZyYW1lTnVtO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGluZ0F0VGltZS52YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTcGVlZEF0VGltZShmcmFtZU51bSkge1xuICAgICAgdmFyIGRlbHRhID0gLTAuMDE7XG4gICAgICB2YXIgdjEgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGZyYW1lTnVtKTtcbiAgICAgIHZhciB2MiA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoZnJhbWVOdW0gKyBkZWx0YSk7XG4gICAgICB2YXIgc3BlZWQgPSAwO1xuXG4gICAgICBpZiAodjEubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2MS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHNwZWVkICs9IE1hdGgucG93KHYyW2ldIC0gdjFbaV0sIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3BlZWQgPSBNYXRoLnNxcnQoc3BlZWQpICogMTAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BlZWQgPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3BlZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VmVsb2NpdHlBdFRpbWUoZnJhbWVOdW0pIHtcbiAgICAgIGlmICh0aGlzLnZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlbHRhID0gLTAuMDAxOyAvLyBmcmFtZU51bSArPSB0aGlzLmVsZW0uZGF0YS5zdDtcblxuICAgICAgdmFyIHYxID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmcmFtZU51bSk7XG4gICAgICB2YXIgdjIgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGZyYW1lTnVtICsgZGVsdGEpO1xuICAgICAgdmFyIHZlbG9jaXR5O1xuXG4gICAgICBpZiAodjEubGVuZ3RoKSB7XG4gICAgICAgIHZlbG9jaXR5ID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIHYxLmxlbmd0aCk7XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2MS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIC8vIHJlbW92aW5nIGZyYW1lUmF0ZVxuICAgICAgICAgIC8vIGlmIG5lZWRlZCwgZG9uJ3QgYWRkIGl0IGhlcmVcbiAgICAgICAgICAvLyB2ZWxvY2l0eVtpXSA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lUmF0ZSooKHYyW2ldIC0gdjFbaV0pL2RlbHRhKTtcbiAgICAgICAgICB2ZWxvY2l0eVtpXSA9ICh2MltpXSAtIHYxW2ldKSAvIGRlbHRhO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ZWxvY2l0eSA9ICh2MiAtIHYxKSAvIGRlbHRhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmVsb2NpdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3RhdGljVmFsdWVBdFRpbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRHcm91cFByb3BlcnR5KHByb3BlcnR5R3JvdXApIHtcbiAgICAgIHRoaXMucHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNlYXJjaEV4cHJlc3Npb25zOiBzZWFyY2hFeHByZXNzaW9ucyxcbiAgICAgIGdldFNwZWVkQXRUaW1lOiBnZXRTcGVlZEF0VGltZSxcbiAgICAgIGdldFZlbG9jaXR5QXRUaW1lOiBnZXRWZWxvY2l0eUF0VGltZSxcbiAgICAgIGdldFZhbHVlQXRUaW1lOiBnZXRWYWx1ZUF0VGltZSxcbiAgICAgIGdldFN0YXRpY1ZhbHVlQXRUaW1lOiBnZXRTdGF0aWNWYWx1ZUF0VGltZSxcbiAgICAgIHNldEdyb3VwUHJvcGVydHk6IHNldEdyb3VwUHJvcGVydHlcbiAgICB9O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gYWRkUHJvcGVydHlEZWNvcmF0b3IoKSB7XG4gICAgZnVuY3Rpb24gbG9vcE91dCh0eXBlLCBkdXJhdGlvbiwgZHVyYXRpb25GbGFnKSB7XG4gICAgICBpZiAoIXRoaXMuayB8fCAhdGhpcy5rZXlmcmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHY7XG4gICAgICB9XG5cbiAgICAgIHR5cGUgPSB0eXBlID8gdHlwZS50b0xvd2VyQ2FzZSgpIDogJyc7XG4gICAgICB2YXIgY3VycmVudEZyYW1lID0gdGhpcy5jb21wLnJlbmRlcmVkRnJhbWU7XG4gICAgICB2YXIga2V5ZnJhbWVzID0gdGhpcy5rZXlmcmFtZXM7XG4gICAgICB2YXIgbGFzdEtleUZyYW1lID0ga2V5ZnJhbWVzW2tleWZyYW1lcy5sZW5ndGggLSAxXS50O1xuXG4gICAgICBpZiAoY3VycmVudEZyYW1lIDw9IGxhc3RLZXlGcmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdjtcbiAgICAgIH1cblxuICAgICAgdmFyIGN5Y2xlRHVyYXRpb247XG4gICAgICB2YXIgZmlyc3RLZXlGcmFtZTtcblxuICAgICAgaWYgKCFkdXJhdGlvbkZsYWcpIHtcbiAgICAgICAgaWYgKCFkdXJhdGlvbiB8fCBkdXJhdGlvbiA+IGtleWZyYW1lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgZHVyYXRpb24gPSBrZXlmcmFtZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpcnN0S2V5RnJhbWUgPSBrZXlmcmFtZXNba2V5ZnJhbWVzLmxlbmd0aCAtIDEgLSBkdXJhdGlvbl0udDtcbiAgICAgICAgY3ljbGVEdXJhdGlvbiA9IGxhc3RLZXlGcmFtZSAtIGZpcnN0S2V5RnJhbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICAgICAgY3ljbGVEdXJhdGlvbiA9IE1hdGgubWF4KDAsIGxhc3RLZXlGcmFtZSAtIHRoaXMuZWxlbS5kYXRhLmlwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeWNsZUR1cmF0aW9uID0gTWF0aC5hYnMobGFzdEtleUZyYW1lIC0gdGhpcy5lbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUgKiBkdXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBmaXJzdEtleUZyYW1lID0gbGFzdEtleUZyYW1lIC0gY3ljbGVEdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuO1xuICAgICAgdmFyIHJldDtcblxuICAgICAgaWYgKHR5cGUgPT09ICdwaW5ncG9uZycpIHtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBNYXRoLmZsb29yKChjdXJyZW50RnJhbWUgLSBmaXJzdEtleUZyYW1lKSAvIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpdGVyYXRpb25zICUgMiAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlQXRUaW1lKChjeWNsZUR1cmF0aW9uIC0gKGN1cnJlbnRGcmFtZSAtIGZpcnN0S2V5RnJhbWUpICUgY3ljbGVEdXJhdGlvbiArIGZpcnN0S2V5RnJhbWUpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvZmZzZXQnKSB7XG4gICAgICAgIHZhciBpbml0ViA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoZmlyc3RLZXlGcmFtZSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7XG4gICAgICAgIHZhciBlbmRWID0gdGhpcy5nZXRWYWx1ZUF0VGltZShsYXN0S2V5RnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoKChjdXJyZW50RnJhbWUgLSBmaXJzdEtleUZyYW1lKSAlIGN5Y2xlRHVyYXRpb24gKyBmaXJzdEtleUZyYW1lKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgICAgICB2YXIgcmVwZWF0cyA9IE1hdGguZmxvb3IoKGN1cnJlbnRGcmFtZSAtIGZpcnN0S2V5RnJhbWUpIC8gY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0ID0gbmV3IEFycmF5KGluaXRWLmxlbmd0aCk7XG4gICAgICAgICAgbGVuID0gcmV0Lmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcmV0W2ldID0gKGVuZFZbaV0gLSBpbml0VltpXSkgKiByZXBlYXRzICsgY3VycmVudFtpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChlbmRWIC0gaW5pdFYpICogcmVwZWF0cyArIGN1cnJlbnQ7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjb250aW51ZScpIHtcbiAgICAgICAgdmFyIGxhc3RWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUobGFzdEtleUZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgdmFyIG5leHRMYXN0VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKChsYXN0S2V5RnJhbWUgLSAwLjAwMSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xuXG4gICAgICAgIGlmICh0aGlzLnB2Lmxlbmd0aCkge1xuICAgICAgICAgIHJldCA9IG5ldyBBcnJheShsYXN0VmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICBsZW4gPSByZXQubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICByZXRbaV0gPSBsYXN0VmFsdWVbaV0gKyAobGFzdFZhbHVlW2ldIC0gbmV4dExhc3RWYWx1ZVtpXSkgKiAoKGN1cnJlbnRGcmFtZSAtIGxhc3RLZXlGcmFtZSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUpIC8gMC4wMDA1OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsYXN0VmFsdWUgKyAobGFzdFZhbHVlIC0gbmV4dExhc3RWYWx1ZSkgKiAoKGN1cnJlbnRGcmFtZSAtIGxhc3RLZXlGcmFtZSkgLyAwLjAwMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlQXRUaW1lKCgoY3VycmVudEZyYW1lIC0gZmlyc3RLZXlGcmFtZSkgJSBjeWNsZUR1cmF0aW9uICsgZmlyc3RLZXlGcmFtZSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9vcEluKHR5cGUsIGR1cmF0aW9uLCBkdXJhdGlvbkZsYWcpIHtcbiAgICAgIGlmICghdGhpcy5rKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB2O1xuICAgICAgfVxuXG4gICAgICB0eXBlID0gdHlwZSA/IHR5cGUudG9Mb3dlckNhc2UoKSA6ICcnO1xuICAgICAgdmFyIGN1cnJlbnRGcmFtZSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lO1xuICAgICAgdmFyIGtleWZyYW1lcyA9IHRoaXMua2V5ZnJhbWVzO1xuICAgICAgdmFyIGZpcnN0S2V5RnJhbWUgPSBrZXlmcmFtZXNbMF0udDtcblxuICAgICAgaWYgKGN1cnJlbnRGcmFtZSA+PSBmaXJzdEtleUZyYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB2O1xuICAgICAgfVxuXG4gICAgICB2YXIgY3ljbGVEdXJhdGlvbjtcbiAgICAgIHZhciBsYXN0S2V5RnJhbWU7XG5cbiAgICAgIGlmICghZHVyYXRpb25GbGFnKSB7XG4gICAgICAgIGlmICghZHVyYXRpb24gfHwgZHVyYXRpb24gPiBrZXlmcmFtZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGR1cmF0aW9uID0ga2V5ZnJhbWVzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0S2V5RnJhbWUgPSBrZXlmcmFtZXNbZHVyYXRpb25dLnQ7XG4gICAgICAgIGN5Y2xlRHVyYXRpb24gPSBsYXN0S2V5RnJhbWUgLSBmaXJzdEtleUZyYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICAgIGN5Y2xlRHVyYXRpb24gPSBNYXRoLm1heCgwLCB0aGlzLmVsZW0uZGF0YS5vcCAtIGZpcnN0S2V5RnJhbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5Y2xlRHVyYXRpb24gPSBNYXRoLmFicyh0aGlzLmVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSAqIGR1cmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RLZXlGcmFtZSA9IGZpcnN0S2V5RnJhbWUgKyBjeWNsZUR1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW47XG4gICAgICB2YXIgcmV0O1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ3Bpbmdwb25nJykge1xuICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IE1hdGguZmxvb3IoKGZpcnN0S2V5RnJhbWUgLSBjdXJyZW50RnJhbWUpIC8gY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGl0ZXJhdGlvbnMgJSAyID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVBdFRpbWUoKChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKSAlIGN5Y2xlRHVyYXRpb24gKyBmaXJzdEtleUZyYW1lKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2Zmc2V0Jykge1xuICAgICAgICB2YXIgaW5pdFYgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGZpcnN0S2V5RnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xuICAgICAgICB2YXIgZW5kViA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUobGFzdEtleUZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldFZhbHVlQXRUaW1lKChjeWNsZUR1cmF0aW9uIC0gKGZpcnN0S2V5RnJhbWUgLSBjdXJyZW50RnJhbWUpICUgY3ljbGVEdXJhdGlvbiArIGZpcnN0S2V5RnJhbWUpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgdmFyIHJlcGVhdHMgPSBNYXRoLmZsb29yKChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKSAvIGN5Y2xlRHVyYXRpb24pICsgMTtcblxuICAgICAgICBpZiAodGhpcy5wdi5sZW5ndGgpIHtcbiAgICAgICAgICByZXQgPSBuZXcgQXJyYXkoaW5pdFYubGVuZ3RoKTtcbiAgICAgICAgICBsZW4gPSByZXQubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICByZXRbaV0gPSBjdXJyZW50W2ldIC0gKGVuZFZbaV0gLSBpbml0VltpXSkgKiByZXBlYXRzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3VycmVudCAtIChlbmRWIC0gaW5pdFYpICogcmVwZWF0cztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NvbnRpbnVlJykge1xuICAgICAgICB2YXIgZmlyc3RWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoZmlyc3RLZXlGcmFtZSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7XG4gICAgICAgIHZhciBuZXh0Rmlyc3RWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoKGZpcnN0S2V5RnJhbWUgKyAwLjAwMSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xuXG4gICAgICAgIGlmICh0aGlzLnB2Lmxlbmd0aCkge1xuICAgICAgICAgIHJldCA9IG5ldyBBcnJheShmaXJzdFZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgbGVuID0gcmV0Lmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcmV0W2ldID0gZmlyc3RWYWx1ZVtpXSArIChmaXJzdFZhbHVlW2ldIC0gbmV4dEZpcnN0VmFsdWVbaV0pICogKGZpcnN0S2V5RnJhbWUgLSBjdXJyZW50RnJhbWUpIC8gMC4wMDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaXJzdFZhbHVlICsgKGZpcnN0VmFsdWUgLSBuZXh0Rmlyc3RWYWx1ZSkgKiAoZmlyc3RLZXlGcmFtZSAtIGN1cnJlbnRGcmFtZSkgLyAwLjAwMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVBdFRpbWUoKGN5Y2xlRHVyYXRpb24gLSAoKGZpcnN0S2V5RnJhbWUgLSBjdXJyZW50RnJhbWUpICUgY3ljbGVEdXJhdGlvbiArIGZpcnN0S2V5RnJhbWUpKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzbW9vdGgod2lkdGgsIHNhbXBsZXMpIHtcbiAgICAgIGlmICghdGhpcy5rKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB2O1xuICAgICAgfVxuXG4gICAgICB3aWR0aCA9ICh3aWR0aCB8fCAwLjQpICogMC41O1xuICAgICAgc2FtcGxlcyA9IE1hdGguZmxvb3Ioc2FtcGxlcyB8fCA1KTtcblxuICAgICAgaWYgKHNhbXBsZXMgPD0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdjtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gdGhpcy5jb21wLnJlbmRlcmVkRnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICB2YXIgaW5pdEZyYW1lID0gY3VycmVudFRpbWUgLSB3aWR0aDtcbiAgICAgIHZhciBlbmRGcmFtZSA9IGN1cnJlbnRUaW1lICsgd2lkdGg7XG4gICAgICB2YXIgc2FtcGxlRnJlcXVlbmN5ID0gc2FtcGxlcyA+IDEgPyAoZW5kRnJhbWUgLSBpbml0RnJhbWUpIC8gKHNhbXBsZXMgLSAxKSA6IDE7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgaiA9IDA7XG4gICAgICB2YXIgdmFsdWU7XG5cbiAgICAgIGlmICh0aGlzLnB2Lmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCB0aGlzLnB2Lmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBzYW1wbGVWYWx1ZTtcblxuICAgICAgd2hpbGUgKGkgPCBzYW1wbGVzKSB7XG4gICAgICAgIHNhbXBsZVZhbHVlID0gdGhpcy5nZXRWYWx1ZUF0VGltZShpbml0RnJhbWUgKyBpICogc2FtcGxlRnJlcXVlbmN5KTtcblxuICAgICAgICBpZiAodGhpcy5wdi5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdGhpcy5wdi5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgdmFsdWVbal0gKz0gc2FtcGxlVmFsdWVbal07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlICs9IHNhbXBsZVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wdi5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMucHYubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICB2YWx1ZVtqXSAvPSBzYW1wbGVzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSAvPSBzYW1wbGVzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtVmFsdWVBdFRpbWUodGltZSkge1xuICAgICAgaWYgKCF0aGlzLl90cmFuc2Zvcm1DYWNoaW5nQXRUaW1lKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybUNhY2hpbmdBdFRpbWUgPSB7XG4gICAgICAgICAgdjogbmV3IE1hdHJpeCgpXG4gICAgICAgIH07XG4gICAgICB9IC8vLyAvXG5cblxuICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX3RyYW5zZm9ybUNhY2hpbmdBdFRpbWUudjtcbiAgICAgIG1hdHJpeC5jbG9uZUZyb21Qcm9wcyh0aGlzLnByZS5wcm9wcyk7XG5cbiAgICAgIGlmICh0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCAxKSB7XG4gICAgICAgIHZhciBhbmNob3IgPSB0aGlzLmEuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG4gICAgICAgIG1hdHJpeC50cmFuc2xhdGUoLWFuY2hvclswXSAqIHRoaXMuYS5tdWx0LCAtYW5jaG9yWzFdICogdGhpcy5hLm11bHQsIGFuY2hvclsyXSAqIHRoaXMuYS5tdWx0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDIpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICBtYXRyaXguc2NhbGUoc2NhbGVbMF0gKiB0aGlzLnMubXVsdCwgc2NhbGVbMV0gKiB0aGlzLnMubXVsdCwgc2NhbGVbMl0gKiB0aGlzLnMubXVsdCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnNrICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDMpIHtcbiAgICAgICAgdmFyIHNrZXcgPSB0aGlzLnNrLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICB2YXIgc2tld0F4aXMgPSB0aGlzLnNhLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICBtYXRyaXguc2tld0Zyb21BeGlzKC1za2V3ICogdGhpcy5zay5tdWx0LCBza2V3QXhpcyAqIHRoaXMuc2EubXVsdCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnIgJiYgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgNCkge1xuICAgICAgICB2YXIgcm90YXRpb24gPSB0aGlzLnIuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG4gICAgICAgIG1hdHJpeC5yb3RhdGUoLXJvdGF0aW9uICogdGhpcy5yLm11bHQpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5yICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDQpIHtcbiAgICAgICAgdmFyIHJvdGF0aW9uWiA9IHRoaXMucnouZ2V0VmFsdWVBdFRpbWUodGltZSk7XG4gICAgICAgIHZhciByb3RhdGlvblkgPSB0aGlzLnJ5LmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICB2YXIgcm90YXRpb25YID0gdGhpcy5yeC5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgdmFyIG9yaWVudGF0aW9uID0gdGhpcy5vci5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgbWF0cml4LnJvdGF0ZVooLXJvdGF0aW9uWiAqIHRoaXMucnoubXVsdCkucm90YXRlWShyb3RhdGlvblkgKiB0aGlzLnJ5Lm11bHQpLnJvdGF0ZVgocm90YXRpb25YICogdGhpcy5yeC5tdWx0KS5yb3RhdGVaKC1vcmllbnRhdGlvblsyXSAqIHRoaXMub3IubXVsdCkucm90YXRlWShvcmllbnRhdGlvblsxXSAqIHRoaXMub3IubXVsdCkucm90YXRlWChvcmllbnRhdGlvblswXSAqIHRoaXMub3IubXVsdCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRhdGEucCAmJiB0aGlzLmRhdGEucC5zKSB7XG4gICAgICAgIHZhciBwb3NpdGlvblggPSB0aGlzLnB4LmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICB2YXIgcG9zaXRpb25ZID0gdGhpcy5weS5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcblxuICAgICAgICBpZiAodGhpcy5kYXRhLnAueikge1xuICAgICAgICAgIHZhciBwb3NpdGlvblogPSB0aGlzLnB6LmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICAgIG1hdHJpeC50cmFuc2xhdGUocG9zaXRpb25YICogdGhpcy5weC5tdWx0LCBwb3NpdGlvblkgKiB0aGlzLnB5Lm11bHQsIC1wb3NpdGlvblogKiB0aGlzLnB6Lm11bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdHJpeC50cmFuc2xhdGUocG9zaXRpb25YICogdGhpcy5weC5tdWx0LCBwb3NpdGlvblkgKiB0aGlzLnB5Lm11bHQsIDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnAuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG4gICAgICAgIG1hdHJpeC50cmFuc2xhdGUocG9zaXRpb25bMF0gKiB0aGlzLnAubXVsdCwgcG9zaXRpb25bMV0gKiB0aGlzLnAubXVsdCwgLXBvc2l0aW9uWzJdICogdGhpcy5wLm11bHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0cml4OyAvLy8gL1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRyYW5zZm9ybVN0YXRpY1ZhbHVlQXRUaW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMudi5jbG9uZShuZXcgTWF0cml4KCkpO1xuICAgIH1cblxuICAgIHZhciBnZXRUcmFuc2Zvcm1Qcm9wZXJ0eSA9IFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeS5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eTtcblxuICAgIFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeS5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhLCBjb250YWluZXIpIHtcbiAgICAgIHZhciBwcm9wID0gZ2V0VHJhbnNmb3JtUHJvcGVydHkoZWxlbSwgZGF0YSwgY29udGFpbmVyKTtcblxuICAgICAgaWYgKHByb3AuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgIHByb3AuZ2V0VmFsdWVBdFRpbWUgPSBnZXRUcmFuc2Zvcm1WYWx1ZUF0VGltZS5iaW5kKHByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC5nZXRWYWx1ZUF0VGltZSA9IGdldFRyYW5zZm9ybVN0YXRpY1ZhbHVlQXRUaW1lLmJpbmQocHJvcCk7XG4gICAgICB9XG5cbiAgICAgIHByb3Auc2V0R3JvdXBQcm9wZXJ0eSA9IGV4cHJlc3Npb25IZWxwZXJzLnNldEdyb3VwUHJvcGVydHk7XG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9O1xuXG4gICAgdmFyIHByb3BlcnR5R2V0UHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wO1xuXG4gICAgUHJvcGVydHlGYWN0b3J5LmdldFByb3AgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSwgdHlwZSwgbXVsdCwgY29udGFpbmVyKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BlcnR5R2V0UHJvcChlbGVtLCBkYXRhLCB0eXBlLCBtdWx0LCBjb250YWluZXIpOyAvLyBwcm9wLmdldFZlbG9jaXR5QXRUaW1lID0gZ2V0VmVsb2NpdHlBdFRpbWU7XG4gICAgICAvLyBwcm9wLmxvb3BPdXQgPSBsb29wT3V0O1xuICAgICAgLy8gcHJvcC5sb29wSW4gPSBsb29wSW47XG5cbiAgICAgIGlmIChwcm9wLmtmKSB7XG4gICAgICAgIHByb3AuZ2V0VmFsdWVBdFRpbWUgPSBleHByZXNzaW9uSGVscGVycy5nZXRWYWx1ZUF0VGltZS5iaW5kKHByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC5nZXRWYWx1ZUF0VGltZSA9IGV4cHJlc3Npb25IZWxwZXJzLmdldFN0YXRpY1ZhbHVlQXRUaW1lLmJpbmQocHJvcCk7XG4gICAgICB9XG5cbiAgICAgIHByb3Auc2V0R3JvdXBQcm9wZXJ0eSA9IGV4cHJlc3Npb25IZWxwZXJzLnNldEdyb3VwUHJvcGVydHk7XG4gICAgICBwcm9wLmxvb3BPdXQgPSBsb29wT3V0O1xuICAgICAgcHJvcC5sb29wSW4gPSBsb29wSW47XG4gICAgICBwcm9wLnNtb290aCA9IHNtb290aDtcbiAgICAgIHByb3AuZ2V0VmVsb2NpdHlBdFRpbWUgPSBleHByZXNzaW9uSGVscGVycy5nZXRWZWxvY2l0eUF0VGltZS5iaW5kKHByb3ApO1xuICAgICAgcHJvcC5nZXRTcGVlZEF0VGltZSA9IGV4cHJlc3Npb25IZWxwZXJzLmdldFNwZWVkQXRUaW1lLmJpbmQocHJvcCk7XG4gICAgICBwcm9wLm51bUtleXMgPSBkYXRhLmEgPT09IDEgPyBkYXRhLmsubGVuZ3RoIDogMDtcbiAgICAgIHByb3AucHJvcGVydHlJbmRleCA9IGRhdGEuaXg7XG4gICAgICB2YXIgdmFsdWUgPSAwO1xuXG4gICAgICBpZiAodHlwZSAhPT0gMCkge1xuICAgICAgICB2YWx1ZSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBkYXRhLmEgPT09IDEgPyBkYXRhLmtbMF0ucy5sZW5ndGggOiBkYXRhLmsubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgcHJvcC5fY2FjaGluZ0F0VGltZSA9IHtcbiAgICAgICAgbGFzdEZyYW1lOiBpbml0aWFsRGVmYXVsdEZyYW1lLFxuICAgICAgICBsYXN0SW5kZXg6IDAsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfTtcbiAgICAgIGV4cHJlc3Npb25IZWxwZXJzLnNlYXJjaEV4cHJlc3Npb25zKGVsZW0sIGRhdGEsIHByb3ApO1xuXG4gICAgICBpZiAocHJvcC5rKSB7XG4gICAgICAgIGNvbnRhaW5lci5hZGREeW5hbWljUHJvcGVydHkocHJvcCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRTaGFwZVZhbHVlQXRUaW1lKGZyYW1lTnVtKSB7XG4gICAgICAvLyBGb3Igbm93IHRoaXMgY2FjaGluZyBvYmplY3QgaXMgY3JlYXRlZCBvbmx5IHdoZW4gbmVlZGVkIGluc3RlYWQgb2YgY3JlYXRpbmcgaXQgd2hlbiB0aGUgc2hhcGUgaXMgaW5pdGlhbGl6ZWQuXG4gICAgICBpZiAoIXRoaXMuX2NhY2hpbmdBdFRpbWUpIHtcbiAgICAgICAgdGhpcy5fY2FjaGluZ0F0VGltZSA9IHtcbiAgICAgICAgICBzaGFwZVZhbHVlOiBzaGFwZVBvb2wuY2xvbmUodGhpcy5wdiksXG4gICAgICAgICAgbGFzdEluZGV4OiAwLFxuICAgICAgICAgIGxhc3RUaW1lOiBpbml0aWFsRGVmYXVsdEZyYW1lXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZyYW1lTnVtICo9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgIGZyYW1lTnVtIC09IHRoaXMub2Zmc2V0VGltZTtcblxuICAgICAgaWYgKGZyYW1lTnVtICE9PSB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RUaW1lKSB7XG4gICAgICAgIHRoaXMuX2NhY2hpbmdBdFRpbWUubGFzdEluZGV4ID0gdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0VGltZSA8IGZyYW1lTnVtID8gdGhpcy5fY2FjaGluZy5sYXN0SW5kZXggOiAwO1xuICAgICAgICB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RUaW1lID0gZnJhbWVOdW07XG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGVTaGFwZShmcmFtZU51bSwgdGhpcy5fY2FjaGluZ0F0VGltZS5zaGFwZVZhbHVlLCB0aGlzLl9jYWNoaW5nQXRUaW1lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hpbmdBdFRpbWUuc2hhcGVWYWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgU2hhcGVQcm9wZXJ0eUNvbnN0cnVjdG9yRnVuY3Rpb24gPSBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRDb25zdHJ1Y3RvckZ1bmN0aW9uKCk7XG4gICAgdmFyIEtleWZyYW1lZFNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uID0gU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0S2V5ZnJhbWVkQ29uc3RydWN0b3JGdW5jdGlvbigpO1xuXG4gICAgZnVuY3Rpb24gU2hhcGVFeHByZXNzaW9ucygpIHt9XG5cbiAgICBTaGFwZUV4cHJlc3Npb25zLnByb3RvdHlwZSA9IHtcbiAgICAgIHZlcnRpY2VzOiBmdW5jdGlvbiB2ZXJ0aWNlcyhwcm9wLCB0aW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmspIHtcbiAgICAgICAgICB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hhcGVQYXRoID0gdGhpcy52O1xuXG4gICAgICAgIGlmICh0aW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzaGFwZVBhdGggPSB0aGlzLmdldFZhbHVlQXRUaW1lKHRpbWUsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSBzaGFwZVBhdGguX2xlbmd0aDtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gc2hhcGVQYXRoW3Byb3BdO1xuICAgICAgICB2YXIgcG9pbnRzID0gc2hhcGVQYXRoLnY7XG4gICAgICAgIHZhciBhcnIgPSBjcmVhdGVTaXplZEFycmF5KGxlbik7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKHByb3AgPT09ICdpJyB8fCBwcm9wID09PSAnbycpIHtcbiAgICAgICAgICAgIGFycltpXSA9IFt2ZXJ0aWNlc1tpXVswXSAtIHBvaW50c1tpXVswXSwgdmVydGljZXNbaV1bMV0gLSBwb2ludHNbaV1bMV1dO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBbdmVydGljZXNbaV1bMF0sIHZlcnRpY2VzW2ldWzFdXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfSxcbiAgICAgIHBvaW50czogZnVuY3Rpb24gcG9pbnRzKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGljZXMoJ3YnLCB0aW1lKTtcbiAgICAgIH0sXG4gICAgICBpblRhbmdlbnRzOiBmdW5jdGlvbiBpblRhbmdlbnRzKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGljZXMoJ2knLCB0aW1lKTtcbiAgICAgIH0sXG4gICAgICBvdXRUYW5nZW50czogZnVuY3Rpb24gb3V0VGFuZ2VudHModGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZXJ0aWNlcygnbycsIHRpbWUpO1xuICAgICAgfSxcbiAgICAgIGlzQ2xvc2VkOiBmdW5jdGlvbiBpc0Nsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudi5jO1xuICAgICAgfSxcbiAgICAgIHBvaW50T25QYXRoOiBmdW5jdGlvbiBwb2ludE9uUGF0aChwZXJjLCB0aW1lKSB7XG4gICAgICAgIHZhciBzaGFwZVBhdGggPSB0aGlzLnY7XG5cbiAgICAgICAgaWYgKHRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNoYXBlUGF0aCA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUodGltZSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3NlZ21lbnRzTGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5fc2VnbWVudHNMZW5ndGggPSBiZXouZ2V0U2VnbWVudHNMZW5ndGgoc2hhcGVQYXRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWdtZW50c0xlbmd0aCA9IHRoaXMuX3NlZ21lbnRzTGVuZ3RoO1xuICAgICAgICB2YXIgbGVuZ3RocyA9IHNlZ21lbnRzTGVuZ3RoLmxlbmd0aHM7XG4gICAgICAgIHZhciBsZW5ndGhQb3MgPSBzZWdtZW50c0xlbmd0aC50b3RhbExlbmd0aCAqIHBlcmM7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IGxlbmd0aHMubGVuZ3RoO1xuICAgICAgICB2YXIgYWNjdW11bGF0ZWRMZW5ndGggPSAwO1xuICAgICAgICB2YXIgcHQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICBpZiAoYWNjdW11bGF0ZWRMZW5ndGggKyBsZW5ndGhzW2ldLmFkZGVkTGVuZ3RoID4gbGVuZ3RoUG9zKSB7XG4gICAgICAgICAgICB2YXIgaW5pdEluZGV4ID0gaTtcbiAgICAgICAgICAgIHZhciBlbmRJbmRleCA9IHNoYXBlUGF0aC5jICYmIGkgPT09IGxlbiAtIDEgPyAwIDogaSArIDE7XG4gICAgICAgICAgICB2YXIgc2VnbWVudFBlcmMgPSAobGVuZ3RoUG9zIC0gYWNjdW11bGF0ZWRMZW5ndGgpIC8gbGVuZ3Roc1tpXS5hZGRlZExlbmd0aDtcbiAgICAgICAgICAgIHB0ID0gYmV6LmdldFBvaW50SW5TZWdtZW50KHNoYXBlUGF0aC52W2luaXRJbmRleF0sIHNoYXBlUGF0aC52W2VuZEluZGV4XSwgc2hhcGVQYXRoLm9baW5pdEluZGV4XSwgc2hhcGVQYXRoLmlbZW5kSW5kZXhdLCBzZWdtZW50UGVyYywgbGVuZ3Roc1tpXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjdW11bGF0ZWRMZW5ndGggKz0gbGVuZ3Roc1tpXS5hZGRlZExlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXB0KSB7XG4gICAgICAgICAgcHQgPSBzaGFwZVBhdGguYyA/IFtzaGFwZVBhdGgudlswXVswXSwgc2hhcGVQYXRoLnZbMF1bMV1dIDogW3NoYXBlUGF0aC52W3NoYXBlUGF0aC5fbGVuZ3RoIC0gMV1bMF0sIHNoYXBlUGF0aC52W3NoYXBlUGF0aC5fbGVuZ3RoIC0gMV1bMV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHB0O1xuICAgICAgfSxcbiAgICAgIHZlY3Rvck9uUGF0aDogZnVuY3Rpb24gdmVjdG9yT25QYXRoKHBlcmMsIHRpbWUsIHZlY3RvclR5cGUpIHtcbiAgICAgICAgLy8gcGVyYyBkb2Vzbid0IHVzZSB0cmlwbGUgZXF1YWxpdHkgYmVjYXVzZSBpdCBjYW4gYmUgYSBOdW1iZXIgb2JqZWN0IGFzIHdlbGwgYXMgYSBwcmltaXRpdmUuXG4gICAgICAgIGlmIChwZXJjID09IDEpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgICAgIHBlcmMgPSB0aGlzLnYuYztcbiAgICAgICAgfSBlbHNlIGlmIChwZXJjID09IDApIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgICAgIHBlcmMgPSAwLjk5OTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwdDEgPSB0aGlzLnBvaW50T25QYXRoKHBlcmMsIHRpbWUpO1xuICAgICAgICB2YXIgcHQyID0gdGhpcy5wb2ludE9uUGF0aChwZXJjICsgMC4wMDEsIHRpbWUpO1xuICAgICAgICB2YXIgeExlbmd0aCA9IHB0MlswXSAtIHB0MVswXTtcbiAgICAgICAgdmFyIHlMZW5ndGggPSBwdDJbMV0gLSBwdDFbMV07XG4gICAgICAgIHZhciBtYWduaXR1ZGUgPSBNYXRoLnNxcnQoTWF0aC5wb3coeExlbmd0aCwgMikgKyBNYXRoLnBvdyh5TGVuZ3RoLCAyKSk7XG5cbiAgICAgICAgaWYgKG1hZ25pdHVkZSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdW5pdFZlY3RvciA9IHZlY3RvclR5cGUgPT09ICd0YW5nZW50JyA/IFt4TGVuZ3RoIC8gbWFnbml0dWRlLCB5TGVuZ3RoIC8gbWFnbml0dWRlXSA6IFsteUxlbmd0aCAvIG1hZ25pdHVkZSwgeExlbmd0aCAvIG1hZ25pdHVkZV07XG4gICAgICAgIHJldHVybiB1bml0VmVjdG9yO1xuICAgICAgfSxcbiAgICAgIHRhbmdlbnRPblBhdGg6IGZ1bmN0aW9uIHRhbmdlbnRPblBhdGgocGVyYywgdGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZWN0b3JPblBhdGgocGVyYywgdGltZSwgJ3RhbmdlbnQnKTtcbiAgICAgIH0sXG4gICAgICBub3JtYWxPblBhdGg6IGZ1bmN0aW9uIG5vcm1hbE9uUGF0aChwZXJjLCB0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlY3Rvck9uUGF0aChwZXJjLCB0aW1lLCAnbm9ybWFsJyk7XG4gICAgICB9LFxuICAgICAgc2V0R3JvdXBQcm9wZXJ0eTogZXhwcmVzc2lvbkhlbHBlcnMuc2V0R3JvdXBQcm9wZXJ0eSxcbiAgICAgIGdldFZhbHVlQXRUaW1lOiBleHByZXNzaW9uSGVscGVycy5nZXRTdGF0aWNWYWx1ZUF0VGltZVxuICAgIH07XG4gICAgZXh0ZW5kUHJvdG90eXBlKFtTaGFwZUV4cHJlc3Npb25zXSwgU2hhcGVQcm9wZXJ0eUNvbnN0cnVjdG9yRnVuY3Rpb24pO1xuICAgIGV4dGVuZFByb3RvdHlwZShbU2hhcGVFeHByZXNzaW9uc10sIEtleWZyYW1lZFNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uKTtcbiAgICBLZXlmcmFtZWRTaGFwZVByb3BlcnR5Q29uc3RydWN0b3JGdW5jdGlvbi5wcm90b3R5cGUuZ2V0VmFsdWVBdFRpbWUgPSBnZXRTaGFwZVZhbHVlQXRUaW1lO1xuICAgIEtleWZyYW1lZFNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uLnByb3RvdHlwZS5pbml0aWF0ZUV4cHJlc3Npb24gPSBFeHByZXNzaW9uTWFuYWdlci5pbml0aWF0ZUV4cHJlc3Npb247XG4gICAgdmFyIHByb3BlcnR5R2V0U2hhcGVQcm9wID0gU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0U2hhcGVQcm9wO1xuXG4gICAgU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0U2hhcGVQcm9wID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEsIHR5cGUsIGFyciwgdHJpbXMpIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcGVydHlHZXRTaGFwZVByb3AoZWxlbSwgZGF0YSwgdHlwZSwgYXJyLCB0cmltcyk7XG4gICAgICBwcm9wLnByb3BlcnR5SW5kZXggPSBkYXRhLml4O1xuICAgICAgcHJvcC5sb2NrID0gZmFsc2U7XG5cbiAgICAgIGlmICh0eXBlID09PSAzKSB7XG4gICAgICAgIGV4cHJlc3Npb25IZWxwZXJzLnNlYXJjaEV4cHJlc3Npb25zKGVsZW0sIGRhdGEucHQsIHByb3ApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA0KSB7XG4gICAgICAgIGV4cHJlc3Npb25IZWxwZXJzLnNlYXJjaEV4cHJlc3Npb25zKGVsZW0sIGRhdGEua3MsIHByb3ApO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcC5rKSB7XG4gICAgICAgIGVsZW0uYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSQxKCkge1xuICAgIGFkZFByb3BlcnR5RGVjb3JhdG9yKCk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGREZWNvcmF0b3IoKSB7XG4gICAgZnVuY3Rpb24gc2VhcmNoRXhwcmVzc2lvbnMoKSB7XG4gICAgICBpZiAodGhpcy5kYXRhLmQueCkge1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZUV4cHJlc3Npb24gPSBFeHByZXNzaW9uTWFuYWdlci5pbml0aWF0ZUV4cHJlc3Npb24uYmluZCh0aGlzKSh0aGlzLmVsZW0sIHRoaXMuZGF0YS5kLCB0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRFZmZlY3QodGhpcy5nZXRFeHByZXNzaW9uVmFsdWUuYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBUZXh0UHJvcGVydHkucHJvdG90eXBlLmdldEV4cHJlc3Npb25WYWx1ZSA9IGZ1bmN0aW9uIChjdXJyZW50VmFsdWUsIHRleHQpIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuY2FsY3VsYXRlRXhwcmVzc2lvbih0ZXh0KTtcblxuICAgICAgaWYgKGN1cnJlbnRWYWx1ZS50ICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICB2YXIgbmV3RGF0YSA9IHt9O1xuICAgICAgICB0aGlzLmNvcHlEYXRhKG5ld0RhdGEsIGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIG5ld0RhdGEudCA9IG5ld1ZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIG5ld0RhdGEuX19jb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICB9O1xuXG4gICAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5zZWFyY2hQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpc0tleWZyYW1lZCA9IHRoaXMuc2VhcmNoS2V5ZnJhbWVzKCk7XG4gICAgICB2YXIgaGFzRXhwcmVzc2lvbnMgPSB0aGlzLnNlYXJjaEV4cHJlc3Npb25zKCk7XG4gICAgICB0aGlzLmtmID0gaXNLZXlmcmFtZWQgfHwgaGFzRXhwcmVzc2lvbnM7XG4gICAgICByZXR1cm4gdGhpcy5rZjtcbiAgICB9O1xuXG4gICAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5zZWFyY2hFeHByZXNzaW9ucyA9IHNlYXJjaEV4cHJlc3Npb25zO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBhZGREZWNvcmF0b3IoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFNWR0NvbXBvc2FibGVFZmZlY3QoKSB7fVxuXG4gIFNWR0NvbXBvc2FibGVFZmZlY3QucHJvdG90eXBlID0ge1xuICAgIGNyZWF0ZU1lcmdlTm9kZTogZnVuY3Rpb24gY3JlYXRlTWVyZ2VOb2RlKHJlc3VsdElkLCBpbnMpIHtcbiAgICAgIHZhciBmZU1lcmdlID0gY3JlYXRlTlMoJ2ZlTWVyZ2UnKTtcbiAgICAgIGZlTWVyZ2Uuc2V0QXR0cmlidXRlKCdyZXN1bHQnLCByZXN1bHRJZCk7XG4gICAgICB2YXIgZmVNZXJnZU5vZGU7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGlucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBmZU1lcmdlTm9kZSA9IGNyZWF0ZU5TKCdmZU1lcmdlTm9kZScpO1xuICAgICAgICBmZU1lcmdlTm9kZS5zZXRBdHRyaWJ1dGUoJ2luJywgaW5zW2ldKTtcbiAgICAgICAgZmVNZXJnZS5hcHBlbmRDaGlsZChmZU1lcmdlTm9kZSk7XG4gICAgICAgIGZlTWVyZ2UuYXBwZW5kQ2hpbGQoZmVNZXJnZU5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmVNZXJnZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpbmVhckZpbHRlclZhbHVlID0gJzAuMzMzMyAwLjMzMzMgMC4zMzMzIDAgMCAwLjMzMzMgMC4zMzMzIDAuMzMzMyAwIDAgMC4zMzMzIDAuMzMzMyAwLjMzMzMgMCAwIDAgMCAwJztcblxuICBmdW5jdGlvbiBTVkdUaW50RmlsdGVyKGZpbHRlciwgZmlsdGVyTWFuYWdlciwgZWxlbSwgaWQsIHNvdXJjZSkge1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XG4gICAgdmFyIGZlQ29sb3JNYXRyaXggPSBjcmVhdGVOUygnZmVDb2xvck1hdHJpeCcpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd0eXBlJywgJ21hdHJpeCcpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnbGluZWFyUkdCJyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsIGxpbmVhckZpbHRlclZhbHVlICsgJyAxIDAnKTtcbiAgICB0aGlzLmxpbmVhckZpbHRlciA9IGZlQ29sb3JNYXRyaXg7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3Jlc3VsdCcsIGlkICsgJ190aW50XzEnKTtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb2xvck1hdHJpeCk7XG4gICAgZmVDb2xvck1hdHJpeCA9IGNyZWF0ZU5TKCdmZUNvbG9yTWF0cml4Jyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnbWF0cml4Jyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdzUkdCJyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsICcxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgncmVzdWx0JywgaWQgKyAnX3RpbnRfMicpO1xuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUNvbG9yTWF0cml4KTtcbiAgICB0aGlzLm1hdHJpeEZpbHRlciA9IGZlQ29sb3JNYXRyaXg7XG4gICAgdmFyIGZlTWVyZ2UgPSB0aGlzLmNyZWF0ZU1lcmdlTm9kZShpZCwgW3NvdXJjZSwgaWQgKyAnX3RpbnRfMScsIGlkICsgJ190aW50XzInXSk7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlTWVyZ2UpO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtTVkdDb21wb3NhYmxlRWZmZWN0XSwgU1ZHVGludEZpbHRlcik7XG5cbiAgU1ZHVGludEZpbHRlci5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoZm9yY2VSZW5kZXIpIHtcbiAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYpIHtcbiAgICAgIHZhciBjb2xvckJsYWNrID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzBdLnAudjtcbiAgICAgIHZhciBjb2xvcldoaXRlID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzFdLnAudjtcbiAgICAgIHZhciBvcGFjaXR5ID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudiAvIDEwMDtcbiAgICAgIHRoaXMubGluZWFyRmlsdGVyLnNldEF0dHJpYnV0ZSgndmFsdWVzJywgbGluZWFyRmlsdGVyVmFsdWUgKyAnICcgKyBvcGFjaXR5ICsgJyAwJyk7XG4gICAgICB0aGlzLm1hdHJpeEZpbHRlci5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsIGNvbG9yV2hpdGVbMF0gLSBjb2xvckJsYWNrWzBdICsgJyAwIDAgMCAnICsgY29sb3JCbGFja1swXSArICcgJyArIChjb2xvcldoaXRlWzFdIC0gY29sb3JCbGFja1sxXSkgKyAnIDAgMCAwICcgKyBjb2xvckJsYWNrWzFdICsgJyAnICsgKGNvbG9yV2hpdGVbMl0gLSBjb2xvckJsYWNrWzJdKSArICcgMCAwIDAgJyArIGNvbG9yQmxhY2tbMl0gKyAnIDAgMCAwIDEgMCcpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBTVkdGaWxsRmlsdGVyKGZpbHRlciwgZmlsdGVyTWFuYWdlciwgZWxlbSwgaWQpIHtcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyO1xuICAgIHZhciBmZUNvbG9yTWF0cml4ID0gY3JlYXRlTlMoJ2ZlQ29sb3JNYXRyaXgnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndHlwZScsICdtYXRyaXgnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ3NSR0InKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndmFsdWVzJywgJzEgMCAwIDAgMCAwIDEgMCAwIDAgMCAwIDEgMCAwIDAgMCAwIDEgMCcpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCk7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29sb3JNYXRyaXgpO1xuICAgIHRoaXMubWF0cml4RmlsdGVyID0gZmVDb2xvck1hdHJpeDtcbiAgfVxuXG4gIFNWR0ZpbGxGaWx0ZXIucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5fbWRmKSB7XG4gICAgICB2YXIgY29sb3IgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMl0ucC52O1xuICAgICAgdmFyIG9wYWNpdHkgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNl0ucC52O1xuICAgICAgdGhpcy5tYXRyaXhGaWx0ZXIuc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCAnMCAwIDAgMCAnICsgY29sb3JbMF0gKyAnIDAgMCAwIDAgJyArIGNvbG9yWzFdICsgJyAwIDAgMCAwICcgKyBjb2xvclsyXSArICcgMCAwIDAgJyArIG9wYWNpdHkgKyAnIDAnKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gU1ZHU3Ryb2tlRWZmZWN0KGZpbCwgZmlsdGVyTWFuYWdlciwgZWxlbSkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyO1xuICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgdGhpcy5wYXRocyA9IFtdO1xuICB9XG5cbiAgU1ZHU3Ryb2tlRWZmZWN0LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGVtQ2hpbGRyZW4gPSB0aGlzLmVsZW0ubGF5ZXJFbGVtZW50LmNoaWxkcmVuIHx8IHRoaXMuZWxlbS5sYXllckVsZW1lbnQuY2hpbGROb2RlcztcbiAgICB2YXIgcGF0aDtcbiAgICB2YXIgZ3JvdXBQYXRoO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG5cbiAgICBpZiAodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzFdLnAudiA9PT0gMSkge1xuICAgICAgbGVuID0gdGhpcy5lbGVtLm1hc2tNYW5hZ2VyLm1hc2tzUHJvcGVydGllcy5sZW5ndGg7XG4gICAgICBpID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaSA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnYgLSAxO1xuICAgICAgbGVuID0gaSArIDE7XG4gICAgfVxuXG4gICAgZ3JvdXBQYXRoID0gY3JlYXRlTlMoJ2cnKTtcbiAgICBncm91cFBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcbiAgICBncm91cFBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsICdyb3VuZCcpO1xuICAgIGdyb3VwUGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0JywgMSk7XG5cbiAgICBmb3IgKGk7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgcGF0aCA9IGNyZWF0ZU5TKCdwYXRoJyk7XG4gICAgICBncm91cFBhdGguYXBwZW5kQ2hpbGQocGF0aCk7XG4gICAgICB0aGlzLnBhdGhzLnB1c2goe1xuICAgICAgICBwOiBwYXRoLFxuICAgICAgICBtOiBpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzEwXS5wLnYgPT09IDMpIHtcbiAgICAgIHZhciBtYXNrID0gY3JlYXRlTlMoJ21hc2snKTtcbiAgICAgIHZhciBpZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoJ2lkJywgaWQpO1xuICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoJ21hc2stdHlwZScsICdhbHBoYScpO1xuICAgICAgbWFzay5hcHBlbmRDaGlsZChncm91cFBhdGgpO1xuICAgICAgdGhpcy5lbGVtLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChtYXNrKTtcbiAgICAgIHZhciBnID0gY3JlYXRlTlMoJ2cnKTtcbiAgICAgIGcuc2V0QXR0cmlidXRlKCdtYXNrJywgJ3VybCgnICsgZ2V0TG9jYXRpb25IcmVmKCkgKyAnIycgKyBpZCArICcpJyk7XG5cbiAgICAgIHdoaWxlIChlbGVtQ2hpbGRyZW5bMF0pIHtcbiAgICAgICAgZy5hcHBlbmRDaGlsZChlbGVtQ2hpbGRyZW5bMF0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsZW0ubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKGcpO1xuICAgICAgdGhpcy5tYXNrZXIgPSBtYXNrO1xuICAgICAgZ3JvdXBQYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJyNmZmYnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAxIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAyKSB7XG4gICAgICBpZiAodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzEwXS5wLnYgPT09IDIpIHtcbiAgICAgICAgZWxlbUNoaWxkcmVuID0gdGhpcy5lbGVtLmxheWVyRWxlbWVudC5jaGlsZHJlbiB8fCB0aGlzLmVsZW0ubGF5ZXJFbGVtZW50LmNoaWxkTm9kZXM7XG5cbiAgICAgICAgd2hpbGUgKGVsZW1DaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmVsZW0ubGF5ZXJFbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1DaGlsZHJlblswXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5lbGVtLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChncm91cFBhdGgpO1xuICAgICAgdGhpcy5lbGVtLmxheWVyRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ21hc2snKTtcbiAgICAgIGdyb3VwUGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICcjZmZmJyk7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgdGhpcy5wYXRoTWFza2VyID0gZ3JvdXBQYXRoO1xuICB9O1xuXG4gIFNWR1N0cm9rZUVmZmVjdC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoZm9yY2VSZW5kZXIpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLnBhdGhzLmxlbmd0aDtcbiAgICB2YXIgbWFzaztcbiAgICB2YXIgcGF0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMucGF0aHNbaV0ubSAhPT0gLTEpIHtcbiAgICAgICAgbWFzayA9IHRoaXMuZWxlbS5tYXNrTWFuYWdlci52aWV3RGF0YVt0aGlzLnBhdGhzW2ldLm1dO1xuICAgICAgICBwYXRoID0gdGhpcy5wYXRoc1tpXS5wO1xuXG4gICAgICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuX21kZiB8fCBtYXNrLnByb3AuX21kZikge1xuICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdkJywgbWFzay5sYXN0UGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzldLnAuX21kZiB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNF0ucC5fbWRmIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s3XS5wLl9tZGYgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzhdLnAuX21kZiB8fCBtYXNrLnByb3AuX21kZikge1xuICAgICAgICAgIHZhciBkYXNoYXJyYXlWYWx1ZTtcblxuICAgICAgICAgIGlmICh0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbN10ucC52ICE9PSAwIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s4XS5wLnYgIT09IDEwMCkge1xuICAgICAgICAgICAgdmFyIHMgPSBNYXRoLm1pbih0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbN10ucC52LCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOF0ucC52KSAqIDAuMDE7XG4gICAgICAgICAgICB2YXIgZSA9IE1hdGgubWF4KHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s3XS5wLnYsIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s4XS5wLnYpICogMC4wMTtcbiAgICAgICAgICAgIHZhciBsID0gcGF0aC5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgICAgICAgZGFzaGFycmF5VmFsdWUgPSAnMCAwIDAgJyArIGwgKiBzICsgJyAnO1xuICAgICAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBsICogKGUgLSBzKTtcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gMSArIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLnYgKiAyICogdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzldLnAudiAqIDAuMDE7XG4gICAgICAgICAgICB2YXIgdW5pdHMgPSBNYXRoLmZsb29yKGxpbmVMZW5ndGggLyBzZWdtZW50KTtcbiAgICAgICAgICAgIHZhciBqO1xuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdW5pdHM7IGogKz0gMSkge1xuICAgICAgICAgICAgICBkYXNoYXJyYXlWYWx1ZSArPSAnMSAnICsgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAudiAqIDIgKiB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOV0ucC52ICogMC4wMSArICcgJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGFzaGFycmF5VmFsdWUgKz0gJzAgJyArIGwgKiAxMCArICcgMCAwJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGFzaGFycmF5VmFsdWUgPSAnMSAnICsgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAudiAqIDIgKiB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOV0ucC52ICogMC4wMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIGRhc2hhcnJheVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNF0ucC5fbWRmKSB7XG4gICAgICB0aGlzLnBhdGhNYXNrZXIuc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNF0ucC52ICogMik7XG4gICAgfVxuXG4gICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s2XS5wLl9tZGYpIHtcbiAgICAgIHRoaXMucGF0aE1hc2tlci5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNl0ucC52KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzEwXS5wLnYgPT09IDEgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzEwXS5wLnYgPT09IDIpIHtcbiAgICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbM10ucC5fbWRmKSB7XG4gICAgICAgIHZhciBjb2xvciA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1szXS5wLnY7XG4gICAgICAgIHRoaXMucGF0aE1hc2tlci5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdyZ2IoJyArIGJtRmxvb3IoY29sb3JbMF0gKiAyNTUpICsgJywnICsgYm1GbG9vcihjb2xvclsxXSAqIDI1NSkgKyAnLCcgKyBibUZsb29yKGNvbG9yWzJdICogMjU1KSArICcpJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR1RyaXRvbmVGaWx0ZXIoZmlsdGVyLCBmaWx0ZXJNYW5hZ2VyLCBlbGVtLCBpZCkge1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XG4gICAgdmFyIGZlQ29sb3JNYXRyaXggPSBjcmVhdGVOUygnZmVDb2xvck1hdHJpeCcpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd0eXBlJywgJ21hdHJpeCcpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnbGluZWFyUkdCJyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsICcwLjMzMzMgMC4zMzMzIDAuMzMzMyAwIDAgMC4zMzMzIDAuMzMzMyAwLjMzMzMgMCAwIDAuMzMzMyAwLjMzMzMgMC4zMzMzIDAgMCAwIDAgMCAxIDAnKTtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb2xvck1hdHJpeCk7XG4gICAgdmFyIGZlQ29tcG9uZW50VHJhbnNmZXIgPSBjcmVhdGVOUygnZmVDb21wb25lbnRUcmFuc2ZlcicpO1xuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnc1JHQicpO1xuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCk7XG4gICAgdGhpcy5tYXRyaXhGaWx0ZXIgPSBmZUNvbXBvbmVudFRyYW5zZmVyO1xuICAgIHZhciBmZUZ1bmNSID0gY3JlYXRlTlMoJ2ZlRnVuY1InKTtcbiAgICBmZUZ1bmNSLnNldEF0dHJpYnV0ZSgndHlwZScsICd0YWJsZScpO1xuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuYXBwZW5kQ2hpbGQoZmVGdW5jUik7XG4gICAgdGhpcy5mZUZ1bmNSID0gZmVGdW5jUjtcbiAgICB2YXIgZmVGdW5jRyA9IGNyZWF0ZU5TKCdmZUZ1bmNHJyk7XG4gICAgZmVGdW5jRy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGFibGUnKTtcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLmFwcGVuZENoaWxkKGZlRnVuY0cpO1xuICAgIHRoaXMuZmVGdW5jRyA9IGZlRnVuY0c7XG4gICAgdmFyIGZlRnVuY0IgPSBjcmVhdGVOUygnZmVGdW5jQicpO1xuICAgIGZlRnVuY0Iuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RhYmxlJyk7XG4gICAgZmVDb21wb25lbnRUcmFuc2Zlci5hcHBlbmRDaGlsZChmZUZ1bmNCKTtcbiAgICB0aGlzLmZlRnVuY0IgPSBmZUZ1bmNCO1xuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgfVxuXG4gIFNWR1RyaXRvbmVGaWx0ZXIucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5fbWRmKSB7XG4gICAgICB2YXIgY29sb3IxID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzBdLnAudjtcbiAgICAgIHZhciBjb2xvcjIgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC52O1xuICAgICAgdmFyIGNvbG9yMyA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1syXS5wLnY7XG4gICAgICB2YXIgdGFibGVSID0gY29sb3IzWzBdICsgJyAnICsgY29sb3IyWzBdICsgJyAnICsgY29sb3IxWzBdO1xuICAgICAgdmFyIHRhYmxlRyA9IGNvbG9yM1sxXSArICcgJyArIGNvbG9yMlsxXSArICcgJyArIGNvbG9yMVsxXTtcbiAgICAgIHZhciB0YWJsZUIgPSBjb2xvcjNbMl0gKyAnICcgKyBjb2xvcjJbMl0gKyAnICcgKyBjb2xvcjFbMl07XG4gICAgICB0aGlzLmZlRnVuY1Iuc2V0QXR0cmlidXRlKCd0YWJsZVZhbHVlcycsIHRhYmxlUik7XG4gICAgICB0aGlzLmZlRnVuY0cuc2V0QXR0cmlidXRlKCd0YWJsZVZhbHVlcycsIHRhYmxlRyk7XG4gICAgICB0aGlzLmZlRnVuY0Iuc2V0QXR0cmlidXRlKCd0YWJsZVZhbHVlcycsIHRhYmxlQik7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR1Byb0xldmVsc0ZpbHRlcihmaWx0ZXIsIGZpbHRlck1hbmFnZXIsIGVsZW0sIGlkKSB7XG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcbiAgICB2YXIgZWZmZWN0RWxlbWVudHMgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHM7XG4gICAgdmFyIGZlQ29tcG9uZW50VHJhbnNmZXIgPSBjcmVhdGVOUygnZmVDb21wb25lbnRUcmFuc2ZlcicpOyAvLyBSZWRcblxuICAgIGlmIChlZmZlY3RFbGVtZW50c1sxMF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzEwXS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMTFdLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxMV0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzEyXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTJdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1sxM10ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzEzXS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMTRdLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxNF0ucC52ICE9PSAxKSB7XG4gICAgICB0aGlzLmZlRnVuY1IgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jUicsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIH0gLy8gR3JlZW5cblxuXG4gICAgaWYgKGVmZmVjdEVsZW1lbnRzWzE3XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTddLnAudiAhPT0gMCB8fCBlZmZlY3RFbGVtZW50c1sxOF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzE4XS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbMTldLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxOV0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzIwXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMjBdLnAudiAhPT0gMCB8fCBlZmZlY3RFbGVtZW50c1syMV0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzIxXS5wLnYgIT09IDEpIHtcbiAgICAgIHRoaXMuZmVGdW5jRyA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNHJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgfSAvLyBCbHVlXG5cblxuICAgIGlmIChlZmZlY3RFbGVtZW50c1syNF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzI0XS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMjVdLnAuayB8fCBlZmZlY3RFbGVtZW50c1syNV0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzI2XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMjZdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1syN10ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzI3XS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMjhdLnAuayB8fCBlZmZlY3RFbGVtZW50c1syOF0ucC52ICE9PSAxKSB7XG4gICAgICB0aGlzLmZlRnVuY0IgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jQicsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIH0gLy8gQWxwaGFcblxuXG4gICAgaWYgKGVmZmVjdEVsZW1lbnRzWzMxXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMzFdLnAudiAhPT0gMCB8fCBlZmZlY3RFbGVtZW50c1szMl0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzMyXS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbMzNdLnAuayB8fCBlZmZlY3RFbGVtZW50c1szM10ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzM0XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMzRdLnAudiAhPT0gMCB8fCBlZmZlY3RFbGVtZW50c1szNV0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzM1XS5wLnYgIT09IDEpIHtcbiAgICAgIHRoaXMuZmVGdW5jQSA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNBJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgfSAvLyBSR0JcblxuXG4gICAgaWYgKHRoaXMuZmVGdW5jUiB8fCB0aGlzLmZlRnVuY0cgfHwgdGhpcy5mZUZ1bmNCIHx8IHRoaXMuZmVGdW5jQSkge1xuICAgICAgZmVDb21wb25lbnRUcmFuc2Zlci5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdzUkdCJyk7XG4gICAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgfVxuXG4gICAgaWYgKGVmZmVjdEVsZW1lbnRzWzNdLnAuayB8fCBlZmZlY3RFbGVtZW50c1szXS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbNF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzRdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1s1XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbNV0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzZdLnAuayB8fCBlZmZlY3RFbGVtZW50c1s2XS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbN10ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzddLnAudiAhPT0gMSkge1xuICAgICAgZmVDb21wb25lbnRUcmFuc2ZlciA9IGNyZWF0ZU5TKCdmZUNvbXBvbmVudFRyYW5zZmVyJyk7XG4gICAgICBmZUNvbXBvbmVudFRyYW5zZmVyLnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ3NSR0InKTtcbiAgICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCk7XG4gICAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgICB0aGlzLmZlRnVuY1JDb21wb3NlZCA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNSJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgICB0aGlzLmZlRnVuY0dDb21wb3NlZCA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNHJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgICB0aGlzLmZlRnVuY0JDb21wb3NlZCA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNCJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgfVxuICB9XG5cbiAgU1ZHUHJvTGV2ZWxzRmlsdGVyLnByb3RvdHlwZS5jcmVhdGVGZUZ1bmMgPSBmdW5jdGlvbiAodHlwZSwgZmVDb21wb25lbnRUcmFuc2Zlcikge1xuICAgIHZhciBmZUZ1bmMgPSBjcmVhdGVOUyh0eXBlKTtcbiAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RhYmxlJyk7XG4gICAgZmVDb21wb25lbnRUcmFuc2Zlci5hcHBlbmRDaGlsZChmZUZ1bmMpO1xuICAgIHJldHVybiBmZUZ1bmM7XG4gIH07XG5cbiAgU1ZHUHJvTGV2ZWxzRmlsdGVyLnByb3RvdHlwZS5nZXRUYWJsZVZhbHVlID0gZnVuY3Rpb24gKGlucHV0QmxhY2ssIGlucHV0V2hpdGUsIGdhbW1hLCBvdXRwdXRCbGFjaywgb3V0cHV0V2hpdGUpIHtcbiAgICB2YXIgY250ID0gMDtcbiAgICB2YXIgc2VnbWVudHMgPSAyNTY7XG4gICAgdmFyIHBlcmM7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKGlucHV0QmxhY2ssIGlucHV0V2hpdGUpO1xuICAgIHZhciBtYXggPSBNYXRoLm1heChpbnB1dEJsYWNrLCBpbnB1dFdoaXRlKTtcbiAgICB2YXIgdGFibGUgPSBBcnJheS5jYWxsKG51bGwsIHtcbiAgICAgIGxlbmd0aDogc2VnbWVudHNcbiAgICB9KTtcbiAgICB2YXIgY29sb3JWYWx1ZTtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgb3V0cHV0RGVsdGEgPSBvdXRwdXRXaGl0ZSAtIG91dHB1dEJsYWNrO1xuICAgIHZhciBpbnB1dERlbHRhID0gaW5wdXRXaGl0ZSAtIGlucHV0QmxhY2s7XG5cbiAgICB3aGlsZSAoY250IDw9IDI1Nikge1xuICAgICAgcGVyYyA9IGNudCAvIDI1NjtcblxuICAgICAgaWYgKHBlcmMgPD0gbWluKSB7XG4gICAgICAgIGNvbG9yVmFsdWUgPSBpbnB1dERlbHRhIDwgMCA/IG91dHB1dFdoaXRlIDogb3V0cHV0QmxhY2s7XG4gICAgICB9IGVsc2UgaWYgKHBlcmMgPj0gbWF4KSB7XG4gICAgICAgIGNvbG9yVmFsdWUgPSBpbnB1dERlbHRhIDwgMCA/IG91dHB1dEJsYWNrIDogb3V0cHV0V2hpdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xvclZhbHVlID0gb3V0cHV0QmxhY2sgKyBvdXRwdXREZWx0YSAqIE1hdGgucG93KChwZXJjIC0gaW5wdXRCbGFjaykgLyBpbnB1dERlbHRhLCAxIC8gZ2FtbWEpO1xuICAgICAgfVxuXG4gICAgICB0YWJsZVtwb3NdID0gY29sb3JWYWx1ZTtcbiAgICAgIHBvcyArPSAxO1xuICAgICAgY250ICs9IDI1NiAvIChzZWdtZW50cyAtIDEpO1xuICAgIH1cblxuICAgIHJldHVybiB0YWJsZS5qb2luKCcgJyk7XG4gIH07XG5cbiAgU1ZHUHJvTGV2ZWxzRmlsdGVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xuICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuX21kZikge1xuICAgICAgdmFyIHZhbDtcbiAgICAgIHZhciBlZmZlY3RFbGVtZW50cyA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50cztcblxuICAgICAgaWYgKHRoaXMuZmVGdW5jUkNvbXBvc2VkICYmIChmb3JjZVJlbmRlciB8fCBlZmZlY3RFbGVtZW50c1szXS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbNF0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzVdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1s2XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbN10ucC5fbWRmKSkge1xuICAgICAgICB2YWwgPSB0aGlzLmdldFRhYmxlVmFsdWUoZWZmZWN0RWxlbWVudHNbM10ucC52LCBlZmZlY3RFbGVtZW50c1s0XS5wLnYsIGVmZmVjdEVsZW1lbnRzWzVdLnAudiwgZWZmZWN0RWxlbWVudHNbNl0ucC52LCBlZmZlY3RFbGVtZW50c1s3XS5wLnYpO1xuICAgICAgICB0aGlzLmZlRnVuY1JDb21wb3NlZC5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcbiAgICAgICAgdGhpcy5mZUZ1bmNHQ29tcG9zZWQuc2V0QXR0cmlidXRlKCd0YWJsZVZhbHVlcycsIHZhbCk7XG4gICAgICAgIHRoaXMuZmVGdW5jQkNvbXBvc2VkLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB2YWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5mZUZ1bmNSICYmIChmb3JjZVJlbmRlciB8fCBlZmZlY3RFbGVtZW50c1sxMF0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzExXS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMTJdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1sxM10ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzE0XS5wLl9tZGYpKSB7XG4gICAgICAgIHZhbCA9IHRoaXMuZ2V0VGFibGVWYWx1ZShlZmZlY3RFbGVtZW50c1sxMF0ucC52LCBlZmZlY3RFbGVtZW50c1sxMV0ucC52LCBlZmZlY3RFbGVtZW50c1sxMl0ucC52LCBlZmZlY3RFbGVtZW50c1sxM10ucC52LCBlZmZlY3RFbGVtZW50c1sxNF0ucC52KTtcbiAgICAgICAgdGhpcy5mZUZ1bmNSLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB2YWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5mZUZ1bmNHICYmIChmb3JjZVJlbmRlciB8fCBlZmZlY3RFbGVtZW50c1sxN10ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzE4XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMTldLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1syMF0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzIxXS5wLl9tZGYpKSB7XG4gICAgICAgIHZhbCA9IHRoaXMuZ2V0VGFibGVWYWx1ZShlZmZlY3RFbGVtZW50c1sxN10ucC52LCBlZmZlY3RFbGVtZW50c1sxOF0ucC52LCBlZmZlY3RFbGVtZW50c1sxOV0ucC52LCBlZmZlY3RFbGVtZW50c1syMF0ucC52LCBlZmZlY3RFbGVtZW50c1syMV0ucC52KTtcbiAgICAgICAgdGhpcy5mZUZ1bmNHLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB2YWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5mZUZ1bmNCICYmIChmb3JjZVJlbmRlciB8fCBlZmZlY3RFbGVtZW50c1syNF0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzI1XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMjZdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1syN10ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzI4XS5wLl9tZGYpKSB7XG4gICAgICAgIHZhbCA9IHRoaXMuZ2V0VGFibGVWYWx1ZShlZmZlY3RFbGVtZW50c1syNF0ucC52LCBlZmZlY3RFbGVtZW50c1syNV0ucC52LCBlZmZlY3RFbGVtZW50c1syNl0ucC52LCBlZmZlY3RFbGVtZW50c1syN10ucC52LCBlZmZlY3RFbGVtZW50c1syOF0ucC52KTtcbiAgICAgICAgdGhpcy5mZUZ1bmNCLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB2YWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5mZUZ1bmNBICYmIChmb3JjZVJlbmRlciB8fCBlZmZlY3RFbGVtZW50c1szMV0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzMyXS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMzNdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1szNF0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzM1XS5wLl9tZGYpKSB7XG4gICAgICAgIHZhbCA9IHRoaXMuZ2V0VGFibGVWYWx1ZShlZmZlY3RFbGVtZW50c1szMV0ucC52LCBlZmZlY3RFbGVtZW50c1szMl0ucC52LCBlZmZlY3RFbGVtZW50c1szM10ucC52LCBlZmZlY3RFbGVtZW50c1szNF0ucC52LCBlZmZlY3RFbGVtZW50c1szNV0ucC52KTtcbiAgICAgICAgdGhpcy5mZUZ1bmNBLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBTVkdEcm9wU2hhZG93RWZmZWN0KGZpbHRlciwgZmlsdGVyTWFuYWdlciwgZWxlbSwgaWQsIHNvdXJjZSkge1xuICAgIHZhciBnbG9iYWxGaWx0ZXJTaXplID0gZmlsdGVyTWFuYWdlci5jb250YWluZXIuZ2xvYmFsRGF0YS5yZW5kZXJDb25maWcuZmlsdGVyU2l6ZTtcbiAgICB2YXIgZmlsdGVyU2l6ZSA9IGZpbHRlck1hbmFnZXIuZGF0YS5mcyB8fCBnbG9iYWxGaWx0ZXJTaXplO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ3gnLCBmaWx0ZXJTaXplLnggfHwgZ2xvYmFsRmlsdGVyU2l6ZS54KTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKCd5JywgZmlsdGVyU2l6ZS55IHx8IGdsb2JhbEZpbHRlclNpemUueSk7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBmaWx0ZXJTaXplLndpZHRoIHx8IGdsb2JhbEZpbHRlclNpemUud2lkdGgpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGZpbHRlclNpemUuaGVpZ2h0IHx8IGdsb2JhbEZpbHRlclNpemUuaGVpZ2h0KTtcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyO1xuICAgIHZhciBmZUdhdXNzaWFuQmx1ciA9IGNyZWF0ZU5TKCdmZUdhdXNzaWFuQmx1cicpO1xuICAgIGZlR2F1c3NpYW5CbHVyLnNldEF0dHJpYnV0ZSgnaW4nLCAnU291cmNlQWxwaGEnKTtcbiAgICBmZUdhdXNzaWFuQmx1ci5zZXRBdHRyaWJ1dGUoJ3Jlc3VsdCcsIGlkICsgJ19kcm9wX3NoYWRvd18xJyk7XG4gICAgZmVHYXVzc2lhbkJsdXIuc2V0QXR0cmlidXRlKCdzdGREZXZpYXRpb24nLCAnMCcpO1xuICAgIHRoaXMuZmVHYXVzc2lhbkJsdXIgPSBmZUdhdXNzaWFuQmx1cjtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVHYXVzc2lhbkJsdXIpO1xuICAgIHZhciBmZU9mZnNldCA9IGNyZWF0ZU5TKCdmZU9mZnNldCcpO1xuICAgIGZlT2Zmc2V0LnNldEF0dHJpYnV0ZSgnZHgnLCAnMjUnKTtcbiAgICBmZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ2R5JywgJzAnKTtcbiAgICBmZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ2luJywgaWQgKyAnX2Ryb3Bfc2hhZG93XzEnKTtcbiAgICBmZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ3Jlc3VsdCcsIGlkICsgJ19kcm9wX3NoYWRvd18yJyk7XG4gICAgdGhpcy5mZU9mZnNldCA9IGZlT2Zmc2V0O1xuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZU9mZnNldCk7XG4gICAgdmFyIGZlRmxvb2QgPSBjcmVhdGVOUygnZmVGbG9vZCcpO1xuICAgIGZlRmxvb2Quc2V0QXR0cmlidXRlKCdmbG9vZC1jb2xvcicsICcjMDBmZjAwJyk7XG4gICAgZmVGbG9vZC5zZXRBdHRyaWJ1dGUoJ2Zsb29kLW9wYWNpdHknLCAnMScpO1xuICAgIGZlRmxvb2Quc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCArICdfZHJvcF9zaGFkb3dfMycpO1xuICAgIHRoaXMuZmVGbG9vZCA9IGZlRmxvb2Q7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlRmxvb2QpO1xuICAgIHZhciBmZUNvbXBvc2l0ZSA9IGNyZWF0ZU5TKCdmZUNvbXBvc2l0ZScpO1xuICAgIGZlQ29tcG9zaXRlLnNldEF0dHJpYnV0ZSgnaW4nLCBpZCArICdfZHJvcF9zaGFkb3dfMycpO1xuICAgIGZlQ29tcG9zaXRlLnNldEF0dHJpYnV0ZSgnaW4yJywgaWQgKyAnX2Ryb3Bfc2hhZG93XzInKTtcbiAgICBmZUNvbXBvc2l0ZS5zZXRBdHRyaWJ1dGUoJ29wZXJhdG9yJywgJ2luJyk7XG4gICAgZmVDb21wb3NpdGUuc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCArICdfZHJvcF9zaGFkb3dfNCcpO1xuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUNvbXBvc2l0ZSk7XG4gICAgdmFyIGZlTWVyZ2UgPSB0aGlzLmNyZWF0ZU1lcmdlTm9kZShpZCwgW2lkICsgJ19kcm9wX3NoYWRvd180Jywgc291cmNlXSk7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlTWVyZ2UpOyAvL1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtTVkdDb21wb3NhYmxlRWZmZWN0XSwgU1ZHRHJvcFNoYWRvd0VmZmVjdCk7XG5cbiAgU1ZHRHJvcFNoYWRvd0VmZmVjdC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoZm9yY2VSZW5kZXIpIHtcbiAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYpIHtcbiAgICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNF0ucC5fbWRmKSB7XG4gICAgICAgIHRoaXMuZmVHYXVzc2lhbkJsdXIuc2V0QXR0cmlidXRlKCdzdGREZXZpYXRpb24nLCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNF0ucC52IC8gNCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMF0ucC5fbWRmKSB7XG4gICAgICAgIHZhciBjb2wgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMF0ucC52O1xuICAgICAgICB0aGlzLmZlRmxvb2Quc2V0QXR0cmlidXRlKCdmbG9vZC1jb2xvcicsIHJnYlRvSGV4KE1hdGgucm91bmQoY29sWzBdICogMjU1KSwgTWF0aC5yb3VuZChjb2xbMV0gKiAyNTUpLCBNYXRoLnJvdW5kKGNvbFsyXSAqIDI1NSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxXS5wLl9tZGYpIHtcbiAgICAgICAgdGhpcy5mZUZsb29kLnNldEF0dHJpYnV0ZSgnZmxvb2Qtb3BhY2l0eScsIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxXS5wLnYgLyAyNTUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAuX21kZiB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbM10ucC5fbWRmKSB7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1szXS5wLnY7XG4gICAgICAgIHZhciBhbmdsZSA9ICh0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMl0ucC52IC0gOTApICogZGVnVG9SYWRzO1xuICAgICAgICB2YXIgeCA9IGRpc3RhbmNlICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICB2YXIgeSA9IGRpc3RhbmNlICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICB0aGlzLmZlT2Zmc2V0LnNldEF0dHJpYnV0ZSgnZHgnLCB4KTtcbiAgICAgICAgdGhpcy5mZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ2R5JywgeSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBfc3ZnTWF0dGVTeW1ib2xzID0gW107XG5cbiAgZnVuY3Rpb24gU1ZHTWF0dGUzRWZmZWN0KGZpbHRlckVsZW0sIGZpbHRlck1hbmFnZXIsIGVsZW0pIHtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcbiAgICB0aGlzLmZpbHRlckVsZW0gPSBmaWx0ZXJFbGVtO1xuICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgZWxlbS5tYXR0ZUVsZW1lbnQgPSBjcmVhdGVOUygnZycpO1xuICAgIGVsZW0ubWF0dGVFbGVtZW50LmFwcGVuZENoaWxkKGVsZW0ubGF5ZXJFbGVtZW50KTtcbiAgICBlbGVtLm1hdHRlRWxlbWVudC5hcHBlbmRDaGlsZChlbGVtLnRyYW5zZm9ybWVkRWxlbWVudCk7XG4gICAgZWxlbS5iYXNlRWxlbWVudCA9IGVsZW0ubWF0dGVFbGVtZW50O1xuICB9XG5cbiAgU1ZHTWF0dGUzRWZmZWN0LnByb3RvdHlwZS5maW5kU3ltYm9sID0gZnVuY3Rpb24gKG1hc2spIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IF9zdmdNYXR0ZVN5bWJvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGlmIChfc3ZnTWF0dGVTeW1ib2xzW2ldID09PSBtYXNrKSB7XG4gICAgICAgIHJldHVybiBfc3ZnTWF0dGVTeW1ib2xzW2ldO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgU1ZHTWF0dGUzRWZmZWN0LnByb3RvdHlwZS5yZXBsYWNlSW5QYXJlbnQgPSBmdW5jdGlvbiAobWFzaywgc3ltYm9sSWQpIHtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IG1hc2subGF5ZXJFbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnROb2RlLmNoaWxkcmVuO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGlmIChjaGlsZHJlbltpXSA9PT0gbWFzay5sYXllckVsZW1lbnQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENoaWxkO1xuXG4gICAgaWYgKGkgPD0gbGVuIC0gMikge1xuICAgICAgbmV4dENoaWxkID0gY2hpbGRyZW5baSArIDFdO1xuICAgIH1cblxuICAgIHZhciB1c2VFbGVtID0gY3JlYXRlTlMoJ3VzZScpO1xuICAgIHVzZUVsZW0uc2V0QXR0cmlidXRlKCdocmVmJywgJyMnICsgc3ltYm9sSWQpO1xuXG4gICAgaWYgKG5leHRDaGlsZCkge1xuICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodXNlRWxlbSwgbmV4dENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh1c2VFbGVtKTtcbiAgICB9XG4gIH07XG5cbiAgU1ZHTWF0dGUzRWZmZWN0LnByb3RvdHlwZS5zZXRFbGVtZW50QXNNYXNrID0gZnVuY3Rpb24gKGVsZW0sIG1hc2spIHtcbiAgICBpZiAoIXRoaXMuZmluZFN5bWJvbChtYXNrKSkge1xuICAgICAgdmFyIHN5bWJvbElkID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgICB2YXIgbWFza2VyID0gY3JlYXRlTlMoJ21hc2snKTtcbiAgICAgIG1hc2tlci5zZXRBdHRyaWJ1dGUoJ2lkJywgbWFzay5sYXllcklkKTtcbiAgICAgIG1hc2tlci5zZXRBdHRyaWJ1dGUoJ21hc2stdHlwZScsICdhbHBoYScpO1xuXG4gICAgICBfc3ZnTWF0dGVTeW1ib2xzLnB1c2gobWFzayk7XG5cbiAgICAgIHZhciBkZWZzID0gZWxlbS5nbG9iYWxEYXRhLmRlZnM7XG4gICAgICBkZWZzLmFwcGVuZENoaWxkKG1hc2tlcik7XG4gICAgICB2YXIgc3ltYm9sID0gY3JlYXRlTlMoJ3N5bWJvbCcpO1xuICAgICAgc3ltYm9sLnNldEF0dHJpYnV0ZSgnaWQnLCBzeW1ib2xJZCk7XG4gICAgICB0aGlzLnJlcGxhY2VJblBhcmVudChtYXNrLCBzeW1ib2xJZCk7XG4gICAgICBzeW1ib2wuYXBwZW5kQ2hpbGQobWFzay5sYXllckVsZW1lbnQpO1xuICAgICAgZGVmcy5hcHBlbmRDaGlsZChzeW1ib2wpO1xuICAgICAgdmFyIHVzZUVsZW0gPSBjcmVhdGVOUygndXNlJyk7XG4gICAgICB1c2VFbGVtLnNldEF0dHJpYnV0ZSgnaHJlZicsICcjJyArIHN5bWJvbElkKTtcbiAgICAgIG1hc2tlci5hcHBlbmRDaGlsZCh1c2VFbGVtKTtcbiAgICAgIG1hc2suZGF0YS5oZCA9IGZhbHNlO1xuICAgICAgbWFzay5zaG93KCk7XG4gICAgfVxuXG4gICAgZWxlbS5zZXRNYXR0ZShtYXNrLmxheWVySWQpO1xuICB9O1xuXG4gIFNWR01hdHRlM0VmZmVjdC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5kID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzBdLnAudjtcbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW0uY29tcC5lbGVtZW50cztcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAoZWxlbWVudHNbaV0gJiYgZWxlbWVudHNbaV0uZGF0YS5pbmQgPT09IGluZCkge1xuICAgICAgICB0aGlzLnNldEVsZW1lbnRBc01hc2sodGhpcy5lbGVtLCBlbGVtZW50c1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgfTtcblxuICBTVkdNYXR0ZTNFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR0dhdXNzaWFuQmx1ckVmZmVjdChmaWx0ZXIsIGZpbHRlck1hbmFnZXIsIGVsZW0sIGlkKSB7XG4gICAgLy8gT3V0c2V0IHRoZSBmaWx0ZXIgcmVnaW9uIGJ5IDEwMCUgb24gYWxsIHNpZGVzIHRvIGFjY29tbW9kYXRlIGJsdXIgZXhwYW5zaW9uLlxuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ3gnLCAnLTEwMCUnKTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKCd5JywgJy0xMDAlJyk7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMzAwJScpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICczMDAlJyk7XG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcbiAgICB2YXIgZmVHYXVzc2lhbkJsdXIgPSBjcmVhdGVOUygnZmVHYXVzc2lhbkJsdXInKTtcbiAgICBmZUdhdXNzaWFuQmx1ci5zZXRBdHRyaWJ1dGUoJ3Jlc3VsdCcsIGlkKTtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVHYXVzc2lhbkJsdXIpO1xuICAgIHRoaXMuZmVHYXVzc2lhbkJsdXIgPSBmZUdhdXNzaWFuQmx1cjtcbiAgfVxuXG4gIFNWR0dhdXNzaWFuQmx1ckVmZmVjdC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoZm9yY2VSZW5kZXIpIHtcbiAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYpIHtcbiAgICAgIC8vIEVtcGlyaWNhbCB2YWx1ZSwgbWF0Y2hpbmcgQUUncyBibHVyIGFwcGVhcmFuY2UuXG4gICAgICB2YXIga0JsdXJyaW5lc3NUb1NpZ21hID0gMC4zO1xuICAgICAgdmFyIHNpZ21hID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzBdLnAudiAqIGtCbHVycmluZXNzVG9TaWdtYTsgLy8gRGltZW5zaW9ucyBtYXBwaW5nOlxuICAgICAgLy9cbiAgICAgIC8vICAgMSAtPiBob3Jpem9udGFsICYgdmVydGljYWxcbiAgICAgIC8vICAgMiAtPiBob3Jpem9udGFsIG9ubHlcbiAgICAgIC8vICAgMyAtPiB2ZXJ0aWNhbCBvbmx5XG4gICAgICAvL1xuXG4gICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxXS5wLnY7XG4gICAgICB2YXIgc2lnbWFYID0gZGltZW5zaW9ucyA9PSAzID8gMCA6IHNpZ21hOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuXG4gICAgICB2YXIgc2lnbWFZID0gZGltZW5zaW9ucyA9PSAyID8gMCA6IHNpZ21hOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuXG4gICAgICB0aGlzLmZlR2F1c3NpYW5CbHVyLnNldEF0dHJpYnV0ZSgnc3RkRGV2aWF0aW9uJywgc2lnbWFYICsgJyAnICsgc2lnbWFZKTsgLy8gUmVwZWF0IGVkZ2VzIG1hcHBpbmc6XG4gICAgICAvL1xuICAgICAgLy8gICAwIC0+IG9mZiAtPiBkdXBsaWNhdGVcbiAgICAgIC8vICAgMSAtPiBvbiAgLT4gd3JhcFxuXG4gICAgICB2YXIgZWRnZU1vZGUgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMl0ucC52ID09IDEgPyAnd3JhcCcgOiAnZHVwbGljYXRlJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcblxuICAgICAgdGhpcy5mZUdhdXNzaWFuQmx1ci5zZXRBdHRyaWJ1dGUoJ2VkZ2VNb2RlJywgZWRnZU1vZGUpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBUcmFuc2Zvcm1FZmZlY3QoKSB7fVxuXG4gIFRyYW5zZm9ybUVmZmVjdC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChlZmZlY3RzTWFuYWdlcikge1xuICAgIHRoaXMuZWZmZWN0c01hbmFnZXIgPSBlZmZlY3RzTWFuYWdlcjtcbiAgICB0aGlzLnR5cGUgPSBlZmZlY3RUeXBlcy5UUkFOU0ZPUk1fRUZGRUNUO1xuICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMub3BhY2l0eSA9IC0xO1xuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIHRoaXMuX29wTWRmID0gZmFsc2U7XG4gIH07XG5cbiAgVHJhbnNmb3JtRWZmZWN0LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChmb3JjZUZyYW1lKSB7XG4gICAgdGhpcy5fb3BNZGYgPSBmYWxzZTtcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcblxuICAgIGlmIChmb3JjZUZyYW1lIHx8IHRoaXMuZWZmZWN0c01hbmFnZXIuX21kZikge1xuICAgICAgdmFyIGVmZmVjdEVsZW1lbnRzID0gdGhpcy5lZmZlY3RzTWFuYWdlci5lZmZlY3RFbGVtZW50cztcbiAgICAgIHZhciBhbmNob3IgPSBlZmZlY3RFbGVtZW50c1swXS5wLnY7XG4gICAgICB2YXIgcG9zaXRpb24gPSBlZmZlY3RFbGVtZW50c1sxXS5wLnY7XG4gICAgICB2YXIgaXNVbmlmb3JtU2NhbGUgPSBlZmZlY3RFbGVtZW50c1syXS5wLnYgPT09IDE7XG4gICAgICB2YXIgc2NhbGVIZWlnaHQgPSBlZmZlY3RFbGVtZW50c1szXS5wLnY7XG4gICAgICB2YXIgc2NhbGVXaWR0aCA9IGlzVW5pZm9ybVNjYWxlID8gc2NhbGVIZWlnaHQgOiBlZmZlY3RFbGVtZW50c1s0XS5wLnY7XG4gICAgICB2YXIgc2tldyA9IGVmZmVjdEVsZW1lbnRzWzVdLnAudjtcbiAgICAgIHZhciBza2V3QXhpcyA9IGVmZmVjdEVsZW1lbnRzWzZdLnAudjtcbiAgICAgIHZhciByb3RhdGlvbiA9IGVmZmVjdEVsZW1lbnRzWzddLnAudjtcbiAgICAgIHRoaXMubWF0cml4LnJlc2V0KCk7XG4gICAgICB0aGlzLm1hdHJpeC50cmFuc2xhdGUoLWFuY2hvclswXSwgLWFuY2hvclsxXSwgYW5jaG9yWzJdKTtcbiAgICAgIHRoaXMubWF0cml4LnNjYWxlKHNjYWxlV2lkdGggKiAwLjAxLCBzY2FsZUhlaWdodCAqIDAuMDEsIDEpO1xuICAgICAgdGhpcy5tYXRyaXgucm90YXRlKC1yb3RhdGlvbiAqIGRlZ1RvUmFkcyk7XG4gICAgICB0aGlzLm1hdHJpeC5za2V3RnJvbUF4aXMoLXNrZXcgKiBkZWdUb1JhZHMsIChza2V3QXhpcyArIDkwKSAqIGRlZ1RvUmFkcyk7XG4gICAgICB0aGlzLm1hdHJpeC50cmFuc2xhdGUocG9zaXRpb25bMF0sIHBvc2l0aW9uWzFdLCAwKTtcbiAgICAgIHRoaXMuX21kZiA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLm9wYWNpdHkgIT09IGVmZmVjdEVsZW1lbnRzWzhdLnAudikge1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSBlZmZlY3RFbGVtZW50c1s4XS5wLnY7XG4gICAgICAgIHRoaXMuX29wTWRmID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gU1ZHVHJhbnNmb3JtRWZmZWN0KF8sIGZpbHRlck1hbmFnZXIpIHtcbiAgICB0aGlzLmluaXQoZmlsdGVyTWFuYWdlcik7XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW1RyYW5zZm9ybUVmZmVjdF0sIFNWR1RyYW5zZm9ybUVmZmVjdCk7XG5cbiAgZnVuY3Rpb24gQ1ZUcmFuc2Zvcm1FZmZlY3QoZWZmZWN0c01hbmFnZXIpIHtcbiAgICB0aGlzLmluaXQoZWZmZWN0c01hbmFnZXIpO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtUcmFuc2Zvcm1FZmZlY3RdLCBDVlRyYW5zZm9ybUVmZmVjdCk7XG5cbiAgcmVnaXN0ZXJSZW5kZXJlcignY2FudmFzJywgQ2FudmFzUmVuZGVyZXIpO1xuICByZWdpc3RlclJlbmRlcmVyKCdodG1sJywgSHlicmlkUmVuZGVyZXIpO1xuICByZWdpc3RlclJlbmRlcmVyKCdzdmcnLCBTVkdSZW5kZXJlcik7IC8vIFJlZ2lzdGVyaW5nIHNoYXBlIG1vZGlmaWVyc1xuXG4gIFNoYXBlTW9kaWZpZXJzLnJlZ2lzdGVyTW9kaWZpZXIoJ3RtJywgVHJpbU1vZGlmaWVyKTtcbiAgU2hhcGVNb2RpZmllcnMucmVnaXN0ZXJNb2RpZmllcigncGInLCBQdWNrZXJBbmRCbG9hdE1vZGlmaWVyKTtcbiAgU2hhcGVNb2RpZmllcnMucmVnaXN0ZXJNb2RpZmllcigncnAnLCBSZXBlYXRlck1vZGlmaWVyKTtcbiAgU2hhcGVNb2RpZmllcnMucmVnaXN0ZXJNb2RpZmllcigncmQnLCBSb3VuZENvcm5lcnNNb2RpZmllcik7XG4gIFNoYXBlTW9kaWZpZXJzLnJlZ2lzdGVyTW9kaWZpZXIoJ3p6JywgWmlnWmFnTW9kaWZpZXIpO1xuICBTaGFwZU1vZGlmaWVycy5yZWdpc3Rlck1vZGlmaWVyKCdvcCcsIE9mZnNldFBhdGhNb2RpZmllcik7IC8vIFJlZ2lzdGVyaW5nIGV4cHJlc3Npb24gcGx1Z2luXG5cbiAgc2V0RXhwcmVzc2lvbnNQbHVnaW4oRXhwcmVzc2lvbnMpO1xuICBzZXRFeHByZXNzaW9uSW50ZXJmYWNlcyhnZXRJbnRlcmZhY2UpO1xuICBpbml0aWFsaXplJDEoKTtcbiAgaW5pdGlhbGl6ZSgpOyAvLyBSZWdpc3RlcmluZyBzdmcgZWZmZWN0c1xuXG4gIHJlZ2lzdGVyRWZmZWN0JDEoMjAsIFNWR1RpbnRGaWx0ZXIsIHRydWUpO1xuICByZWdpc3RlckVmZmVjdCQxKDIxLCBTVkdGaWxsRmlsdGVyLCB0cnVlKTtcbiAgcmVnaXN0ZXJFZmZlY3QkMSgyMiwgU1ZHU3Ryb2tlRWZmZWN0LCBmYWxzZSk7XG4gIHJlZ2lzdGVyRWZmZWN0JDEoMjMsIFNWR1RyaXRvbmVGaWx0ZXIsIHRydWUpO1xuICByZWdpc3RlckVmZmVjdCQxKDI0LCBTVkdQcm9MZXZlbHNGaWx0ZXIsIHRydWUpO1xuICByZWdpc3RlckVmZmVjdCQxKDI1LCBTVkdEcm9wU2hhZG93RWZmZWN0LCB0cnVlKTtcbiAgcmVnaXN0ZXJFZmZlY3QkMSgyOCwgU1ZHTWF0dGUzRWZmZWN0LCBmYWxzZSk7XG4gIHJlZ2lzdGVyRWZmZWN0JDEoMjksIFNWR0dhdXNzaWFuQmx1ckVmZmVjdCwgdHJ1ZSk7XG4gIHJlZ2lzdGVyRWZmZWN0JDEoMzUsIFNWR1RyYW5zZm9ybUVmZmVjdCwgZmFsc2UpO1xuICByZWdpc3RlckVmZmVjdCgzNSwgQ1ZUcmFuc2Zvcm1FZmZlY3QpO1xuXG4gIHJldHVybiBsb3R0aWU7XG5cbn0pKTtcbiJdLCJuYW1lcyI6WyJuYXZpZ2F0b3IiLCJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsImdsb2JhbFRoaXMiLCJzZWxmIiwibG90dGllIiwic3ZnTlMiLCJsb2NhdGlvbkhyZWYiLCJfdXNlV2ViV29ya2VyIiwiaW5pdGlhbERlZmF1bHRGcmFtZSIsInNldFdlYldvcmtlciIsImZsYWciLCJnZXRXZWJXb3JrZXIiLCJzZXRMb2NhdGlvbkhyZWYiLCJ2YWx1ZSIsImdldExvY2F0aW9uSHJlZiIsImNyZWF0ZVRhZyIsInR5cGUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJleHRlbmRQcm90b3R5cGUiLCJzb3VyY2VzIiwiZGVzdGluYXRpb24iLCJpIiwibGVuIiwibGVuZ3RoIiwic291cmNlUHJvdG90eXBlIiwicHJvdG90eXBlIiwiYXR0ciIsIk9iamVjdCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImdldERlc2NyaXB0b3IiLCJvYmplY3QiLCJwcm9wIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiY3JlYXRlUHJveHlGdW5jdGlvbiIsIlByb3h5RnVuY3Rpb24iLCJhdWRpb0NvbnRyb2xsZXJGYWN0b3J5IiwiQXVkaW9Db250cm9sbGVyIiwiYXVkaW9GYWN0b3J5IiwiYXVkaW9zIiwiX3ZvbHVtZSIsIl9pc011dGVkIiwiYWRkQXVkaW8iLCJhdWRpbyIsInB1c2giLCJwYXVzZSIsInJlc3VtZSIsInNldFJhdGUiLCJyYXRlVmFsdWUiLCJjcmVhdGVBdWRpbyIsImFzc2V0UGF0aCIsIndpbmRvdyIsIkhvd2wiLCJzcmMiLCJpc1BsYXlpbmciLCJwbGF5Iiwic2VlayIsInBsYXlpbmciLCJyYXRlIiwic2V0Vm9sdW1lIiwic2V0QXVkaW9GYWN0b3J5IiwiX3VwZGF0ZVZvbHVtZSIsIm11dGUiLCJ1bm11dGUiLCJnZXRWb2x1bWUiLCJ2b2x1bWUiLCJjcmVhdGVUeXBlZEFycmF5IiwiY3JlYXRlUmVndWxhckFycmF5IiwiYXJyIiwiY3JlYXRlVHlwZWRBcnJheUZhY3RvcnkiLCJGbG9hdDMyQXJyYXkiLCJJbnQxNkFycmF5IiwiVWludDhDbGFtcGVkQXJyYXkiLCJjcmVhdGVTaXplZEFycmF5IiwiQXJyYXkiLCJhcHBseSIsIl90eXBlb2YkNiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX3R5cGVvZiIsImNvbnN0cnVjdG9yIiwic3ViZnJhbWVFbmFibGVkIiwiZXhwcmVzc2lvbnNQbHVnaW4iLCJleHByZXNzaW9uc0ludGVyZmFjZXMiLCJpZFByZWZpeCQxIiwiaXNTYWZhcmkiLCJ0ZXN0IiwidXNlckFnZW50IiwiX3Nob3VsZFJvdW5kVmFsdWVzIiwiYm1Qb3ciLCJNYXRoIiwicG93IiwiYm1TcXJ0Iiwic3FydCIsImJtRmxvb3IiLCJmbG9vciIsImJtTWF4IiwibWF4IiwiYm1NaW4iLCJtaW4iLCJCTU1hdGgiLCJwcm9wZXJ0eU5hbWVzIiwiUHJvamVjdEludGVyZmFjZSQxIiwicmFuZG9tIiwiYWJzIiwidmFsIiwidE9mVmFsIiwiYWJzQXJyIiwiZGVmYXVsdEN1cnZlU2VnbWVudHMiLCJkZWdUb1JhZHMiLCJQSSIsInJvdW5kQ29ybmVyIiwicm91bmRWYWx1ZXMiLCJibVJuZCIsInJvdW5kIiwic3R5bGVEaXYiLCJlbGVtZW50Iiwic3R5bGUiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJkaXNwbGF5IiwidHJhbnNmb3JtT3JpZ2luIiwid2Via2l0VHJhbnNmb3JtT3JpZ2luIiwiYmFja2ZhY2VWaXNpYmlsaXR5Iiwid2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5IiwidHJhbnNmb3JtU3R5bGUiLCJ3ZWJraXRUcmFuc2Zvcm1TdHlsZSIsIm1velRyYW5zZm9ybVN0eWxlIiwiQk1FbnRlckZyYW1lRXZlbnQiLCJjdXJyZW50VGltZSIsInRvdGFsVGltZSIsImZyYW1lTXVsdGlwbGllciIsImRpcmVjdGlvbiIsIkJNQ29tcGxldGVFdmVudCIsIkJNQ29tcGxldGVMb29wRXZlbnQiLCJ0b3RhbExvb3BzIiwiY3VycmVudExvb3AiLCJCTVNlZ21lbnRTdGFydEV2ZW50IiwiZmlyc3RGcmFtZSIsInRvdGFsRnJhbWVzIiwiQk1EZXN0cm95RXZlbnQiLCJ0YXJnZXQiLCJCTVJlbmRlckZyYW1lRXJyb3JFdmVudCIsIm5hdGl2ZUVycm9yIiwiQk1Db25maWdFcnJvckV2ZW50IiwiQk1BbmltYXRpb25Db25maWdFcnJvckV2ZW50IiwiY3JlYXRlRWxlbWVudElEIiwiX2NvdW50IiwiY3JlYXRlSUQiLCJIU1Z0b1JHQiIsImgiLCJzIiwidiIsInIiLCJnIiwiYiIsImYiLCJwIiwicSIsInQiLCJSR0J0b0hTViIsImQiLCJhZGRTYXR1cmF0aW9uVG9SR0IiLCJjb2xvciIsIm9mZnNldCIsImhzdiIsImFkZEJyaWdodG5lc3NUb1JHQiIsImFkZEh1ZVRvUkdCIiwicmdiVG9IZXgiLCJjb2xvck1hcCIsImhleCIsInRvU3RyaW5nIiwic2V0U3ViZnJhbWVFbmFibGVkIiwiZ2V0U3ViZnJhbWVFbmFibGVkIiwic2V0RXhwcmVzc2lvbnNQbHVnaW4iLCJnZXRFeHByZXNzaW9uc1BsdWdpbiIsInNldEV4cHJlc3Npb25JbnRlcmZhY2VzIiwiZ2V0RXhwcmVzc2lvbkludGVyZmFjZXMiLCJzZXREZWZhdWx0Q3VydmVTZWdtZW50cyIsImdldERlZmF1bHRDdXJ2ZVNlZ21lbnRzIiwic2V0SWRQcmVmaXgiLCJnZXRJZFByZWZpeCIsImNyZWF0ZU5TIiwiY3JlYXRlRWxlbWVudE5TIiwiX3R5cGVvZiQ1IiwiZGF0YU1hbmFnZXIiLCJfY291bnRlcklkIiwicHJvY2Vzc2VzIiwid29ya2VyRm4iLCJ3b3JrZXJJbnN0YW5jZSIsIndvcmtlclByb3h5Iiwib25tZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJwYXRoIiwiZGF0YSIsIl93b3JrZXJTZWxmIiwiY3JlYXRlV29ya2VyIiwiZm4iLCJXb3JrZXIiLCJCbG9iIiwiYmxvYiIsInVybCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsInNldHVwV29ya2VyIiwid29ya2VyU3RhcnQiLCJlIiwiZGF0YUZ1bmN0aW9uTWFuYWdlciIsImNvbXBsZXRlTGF5ZXJzIiwibGF5ZXJzIiwiY29tcHMiLCJsYXllckRhdGEiLCJqIiwiakxlbiIsImsiLCJrTGVuIiwiY29tcGxldGVkIiwiaGFzTWFzayIsIm1hc2tQcm9wcyIsIm1hc2tzUHJvcGVydGllcyIsInB0IiwiY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyIsInR5IiwiZmluZENvbXBMYXllcnMiLCJyZWZJZCIsImNvbXBsZXRlU2hhcGVzIiwic2hhcGVzIiwiY29tcGxldGVUZXh0IiwiY29tcGxldGVDaGFycyIsImNoYXJzIiwiYXNzZXRzIiwiZmluZENvbXAiLCJpZCIsImNvbXAiLCJfX3VzZWQiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJrcyIsIml0IiwibyIsImNoZWNrVmVyc2lvbiIsIm1pbmltdW0iLCJhbmltVmVyc2lvblN0cmluZyIsImFuaW1WZXJzaW9uIiwic3BsaXQiLCJjaGVja1RleHQiLCJtaW5pbXVtVmVyc2lvbiIsInVwZGF0ZVRleHRMYXllciIsInRleHRMYXllciIsImRvY3VtZW50RGF0YSIsIml0ZXJhdGVMYXllcnMiLCJhbmltYXRpb25EYXRhIiwiY2hlY2tDaGFycyIsImNoYXJEYXRhIiwiaXAiLCJvcCIsInN0Iiwic3IiLCJhIiwic2siLCJzYSIsImNoZWNrUGF0aFByb3BlcnRpZXMiLCJwYXRoRGF0YSIsImNoZWNrQ29sb3JzIiwiaXRlcmF0ZVNoYXBlcyIsImMiLCJjaGVja1NoYXBlcyIsImNvbXBsZXRlQ2xvc2luZ1NoYXBlcyIsImNsb3NlZCIsImNsIiwiY29tcGxldGVEYXRhIiwiX19jb21wbGV0ZSIsIm1vZHVsZU9iIiwiYXNzZXRMb2FkZXIiLCJmb3JtYXRSZXNwb25zZSIsInhociIsImNvbnRlbnRUeXBlSGVhZGVyIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJyZXNwb25zZVR5cGUiLCJpbmRleE9mIiwicmVzcG9uc2UiLCJyZXNwb25zZVRleHQiLCJsb2FkQXNzZXQiLCJmdWxsUGF0aCIsImNhbGxiYWNrIiwiZXJyb3JDYWxsYmFjayIsIlhNTEh0dHBSZXF1ZXN0IiwiZXJyIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsInN0YXR1cyIsIm9wZW4iLCJqb2luIiwiZXJyb3IiLCJzZW5kIiwibG9hZCIsInBheWxvYWQiLCJhbmltYXRpb24iLCJldmVudCIsInByb2Nlc3MiLCJvbkNvbXBsZXRlIiwib25FcnJvciIsImNyZWF0ZVByb2Nlc3MiLCJsb2FkQW5pbWF0aW9uIiwicHJvY2Vzc0lkIiwibG9jYXRpb24iLCJvcmlnaW4iLCJwYXRobmFtZSIsImxvYWREYXRhIiwiY29tcGxldGVBbmltYXRpb24iLCJhbmltIiwiSW1hZ2VQcmVsb2FkZXIiLCJwcm94eUltYWdlIiwiY2FudmFzIiwid2lkdGgiLCJoZWlnaHQiLCJjdHgiLCJnZXRDb250ZXh0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJpbWFnZUxvYWRlZCIsImxvYWRlZEFzc2V0cyIsInRvdGFsSW1hZ2VzIiwibG9hZGVkRm9vdGFnZXNDb3VudCIsInRvdGFsRm9vdGFnZXMiLCJpbWFnZXNMb2FkZWRDYiIsImZvb3RhZ2VMb2FkZWQiLCJnZXRBc3NldHNQYXRoIiwiYXNzZXREYXRhIiwiYXNzZXRzUGF0aCIsIm9yaWdpbmFsUGF0aCIsImltYWdlUGF0aCIsInUiLCJ0ZXN0SW1hZ2VMb2FkZWQiLCJpbWciLCJpbnRlcnZhbElkIiwic2V0SW50ZXJ2YWwiLCJib3giLCJnZXRCQm94IiwiX2ltYWdlTG9hZGVkIiwiY2xlYXJJbnRlcnZhbCIsImJpbmQiLCJjcmVhdGVJbWFnZURhdGEiLCJhZGRFdmVudExpc3RlbmVyIiwib2IiLCJzZXRBdHRyaWJ1dGVOUyIsIl9lbGVtZW50SGVscGVyIiwiYXBwZW5kIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVJbWdEYXRhIiwiY3Jvc3NPcmlnaW4iLCJjcmVhdGVGb290YWdlRGF0YSIsImZvb3RhZ2VEYXRhIiwiX2Zvb3RhZ2VMb2FkZWQiLCJsb2FkQXNzZXRzIiwiY2IiLCJpbWFnZXMiLCJfY3JlYXRlSW1hZ2VEYXRhIiwic2V0UGF0aCIsInNldEFzc2V0c1BhdGgiLCJnZXRBc3NldCIsImRlc3Ryb3kiLCJsb2FkZWRJbWFnZXMiLCJsb2FkZWRGb290YWdlcyIsInNldENhY2hlVHlwZSIsImVsZW1lbnRIZWxwZXIiLCJJbWFnZVByZWxvYWRlckZhY3RvcnkiLCJCYXNlRXZlbnQiLCJ0cmlnZ2VyRXZlbnQiLCJldmVudE5hbWUiLCJhcmdzIiwiX2NicyIsImNhbGxiYWNrcyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzcGxpY2UiLCJtYXJrZXJQYXJzZXIiLCJwYXJzZVBheWxvYWRMaW5lcyIsImxpbmVzIiwia2V5cyIsImxpbmUiLCJrZXlzQ291bnQiLCJ0cmltIiwiRXJyb3IiLCJfbWFya2VycyIsIm1hcmtlcnMiLCJfbWFya2VyIiwibWFya2VyRGF0YSIsInRpbWUiLCJ0bSIsImR1cmF0aW9uIiwiZHIiLCJjbSIsIl8iLCJfXyIsIm5hbWUiLCJQcm9qZWN0SW50ZXJmYWNlIiwicmVnaXN0ZXJDb21wb3NpdGlvbiIsImNvbXBvc2l0aW9ucyIsIl90aGlzUHJvamVjdEZ1bmN0aW9uIiwibm0iLCJwcmVwYXJlRnJhbWUiLCJ4dCIsImN1cnJlbnRGcmFtZSIsImNvbXBJbnRlcmZhY2UiLCJyZW5kZXJlcnMiLCJyZWdpc3RlclJlbmRlcmVyIiwia2V5IiwiZ2V0UmVuZGVyZXIiLCJnZXRSZWdpc3RlcmVkUmVuZGVyZXIiLCJfdHlwZW9mJDQiLCJBbmltYXRpb25JdGVtIiwiaXNMb2FkZWQiLCJjdXJyZW50UmF3RnJhbWUiLCJmcmFtZVJhdGUiLCJmcmFtZU11bHQiLCJwbGF5U3BlZWQiLCJwbGF5RGlyZWN0aW9uIiwicGxheUNvdW50IiwiaXNQYXVzZWQiLCJhdXRvcGxheSIsImxvb3AiLCJyZW5kZXJlciIsImFuaW1hdGlvbklEIiwidGltZUNvbXBsZXRlZCIsInNlZ21lbnRQb3MiLCJpc1N1YmZyYW1lRW5hYmxlZCIsInNlZ21lbnRzIiwiX2lkbGUiLCJfY29tcGxldGVkTG9vcCIsInByb2plY3RJbnRlcmZhY2UiLCJpbWFnZVByZWxvYWRlciIsImF1ZGlvQ29udHJvbGxlciIsImNvbmZpZ0FuaW1hdGlvbiIsIm9uU2V0dXBFcnJvciIsIm9uU2VnbWVudENvbXBsZXRlIiwiZHJhd25GcmFtZUV2ZW50Iiwic2V0UGFyYW1zIiwicGFyYW1zIiwid3JhcHBlciIsImNvbnRhaW5lciIsImFuaW1UeXBlIiwiUmVuZGVyZXJDbGFzcyIsInJlbmRlcmVyU2V0dGluZ3MiLCJnbG9iYWxEYXRhIiwiZGVmcyIsInNldFByb2plY3RJbnRlcmZhY2UiLCJ1bmRlZmluZWQiLCJwYXJzZUludCIsImF1dG9sb2FkU2VnbWVudHMiLCJpbml0aWFsU2VnbWVudCIsInNldHVwQW5pbWF0aW9uIiwibGFzdEluZGV4T2YiLCJzdWJzdHIiLCJmaWxlTmFtZSIsInRyaWdnZXIiLCJzZXREYXRhIiwid3JhcHBlckF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwiZ2V0TmFtZWRJdGVtIiwicHJlcmVuZGVyIiwiaW5jbHVkZUxheWVycyIsIm5ld0xheWVycyIsImZvbnRzIiwiZm9udE1hbmFnZXIiLCJhZGRDaGFycyIsImFkZEZvbnRzIiwiaW5pdEV4cHJlc3Npb25zIiwibG9hZE5leHRTZWdtZW50Iiwic2VnbWVudCIsInNoaWZ0Iiwic2VnbWVudFBhdGgiLCJsb2FkU2VnbWVudHMiLCJpbWFnZXNMb2FkZWQiLCJjaGVja0xvYWRlZCIsInByZWxvYWRJbWFnZXMiLCJhbmltRGF0YSIsImZyIiwic2VhcmNoRXh0cmFDb21wb3NpdGlvbnMiLCJ1cGRhRnJhbWVNb2RpZmllciIsIndhaXRGb3JGb250c0xvYWRlZCIsInRyaWdnZXJDb25maWdFcnJvciIsInNldFRpbWVvdXQiLCJyZW5kZXJlclR5cGUiLCJpbml0SXRlbXMiLCJnb3RvRnJhbWUiLCJyZXNpemUiLCJfd2lkdGgiLCJfaGVpZ2h0IiwidXBkYXRlQ29udGFpbmVyU2l6ZSIsInNldFN1YmZyYW1lIiwicmVuZGVyRnJhbWUiLCJyZXNldEZyYW1lIiwidHJpZ2dlclJlbmRlckZyYW1lRXJyb3IiLCJ0b2dnbGVQYXVzZSIsInN0b3AiLCJzZXRDdXJyZW50UmF3RnJhbWVWYWx1ZSIsImdldE1hcmtlckRhdGEiLCJtYXJrZXJOYW1lIiwibWFya2VyIiwiZ29Ub0FuZFN0b3AiLCJpc0ZyYW1lIiwibnVtVmFsdWUiLCJOdW1iZXIiLCJpc05hTiIsImZyYW1lTW9kaWZpZXIiLCJnb1RvQW5kUGxheSIsInBsYXlTZWdtZW50cyIsImFkdmFuY2VUaW1lIiwibmV4dFZhbHVlIiwiX2lzQ29tcGxldGUiLCJjaGVja1NlZ21lbnRzIiwiYWRqdXN0U2VnbWVudCIsInNldFNwZWVkIiwic2V0RGlyZWN0aW9uIiwic2V0U2VnbWVudCIsImluaXQiLCJlbmQiLCJwZW5kaW5nRnJhbWUiLCJmb3JjZUZsYWciLCJyZXNldFNlZ21lbnRzIiwib25FbnRlckZyYW1lIiwib25Mb29wQ29tcGxldGUiLCJvblNlZ21lbnRTdGFydCIsIm9uRGVzdHJveSIsInNldExvb3AiLCJpc0xvb3BpbmciLCJnZXRQYXRoIiwiZ2V0QXNzZXREYXRhIiwiaGlkZSIsInNob3ciLCJnZXREdXJhdGlvbiIsInVwZGF0ZURvY3VtZW50RGF0YSIsImluZGV4IiwiZ2V0RWxlbWVudEJ5UGF0aCIsImFuaW1hdGlvbk1hbmFnZXIiLCJyZWdpc3RlcmVkQW5pbWF0aW9ucyIsImluaXRUaW1lIiwicGxheWluZ0FuaW1hdGlvbnNOdW0iLCJfc3RvcHBlZCIsIl9pc0Zyb3plbiIsInJlbW92ZUVsZW1lbnQiLCJldiIsImFuaW1JdGVtIiwic3VidHJhY3RQbGF5aW5nQ291bnQiLCJyZWdpc3RlckFuaW1hdGlvbiIsImVsZW0iLCJnZXRSZWdpc3RlcmVkQW5pbWF0aW9ucyIsImxlbkFuaW1zIiwiYW5pbWF0aW9ucyIsImFkZFBsYXlpbmdDb3VudCIsImFjdGl2YXRlIiwibm93VGltZSIsImVsYXBzZWRUaW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZmlyc3QiLCJzZWFyY2hBbmltYXRpb25zIiwic3RhbmRhbG9uZSIsImFuaW1FbGVtZW50cyIsImNvbmNhdCIsInNsaWNlIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsInNldEF0dHJpYnV0ZSIsImJvZHkiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImlubmVyVGV4dCIsImRpdiIsImZyZWV6ZSIsInVuZnJlZXplIiwiQmV6aWVyRmFjdG9yeSIsImdldEJlemllckVhc2luZyIsImJlemllcnMiLCJzdHIiLCJyZXBsYWNlIiwiYmV6RWFzaW5nIiwiQmV6aWVyRWFzaW5nIiwiTkVXVE9OX0lURVJBVElPTlMiLCJORVdUT05fTUlOX1NMT1BFIiwiU1VCRElWSVNJT05fUFJFQ0lTSU9OIiwiU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMiLCJrU3BsaW5lVGFibGVTaXplIiwia1NhbXBsZVN0ZXBTaXplIiwiZmxvYXQzMkFycmF5U3VwcG9ydGVkIiwiQSIsImFBMSIsImFBMiIsIkIiLCJDIiwiY2FsY0JlemllciIsImFUIiwiZ2V0U2xvcGUiLCJiaW5hcnlTdWJkaXZpZGUiLCJhWCIsImFBIiwiYUIiLCJtWDEiLCJtWDIiLCJjdXJyZW50WCIsImN1cnJlbnRUIiwibmV3dG9uUmFwaHNvbkl0ZXJhdGUiLCJhR3Vlc3NUIiwiY3VycmVudFNsb3BlIiwicG9pbnRzIiwiX3AiLCJfbVNhbXBsZVZhbHVlcyIsIl9wcmVjb21wdXRlZCIsImdldCIsIngiLCJtWTEiLCJtWTIiLCJfcHJlY29tcHV0ZSIsIl9nZXRURm9yWCIsIl9jYWxjU2FtcGxlVmFsdWVzIiwibVNhbXBsZVZhbHVlcyIsImludGVydmFsU3RhcnQiLCJjdXJyZW50U2FtcGxlIiwibGFzdFNhbXBsZSIsImRpc3QiLCJndWVzc0ZvclQiLCJpbml0aWFsU2xvcGUiLCJwb29saW5nIiwiX2RvdWJsZSIsInBvb2xGYWN0b3J5IiwiaW5pdGlhbExlbmd0aCIsIl9jcmVhdGUiLCJfcmVsZWFzZSIsIl9sZW5ndGgiLCJfbWF4TGVuZ3RoIiwicG9vbCIsIm5ld0VsZW1lbnQiLCJyZWxlYXNlIiwiYmV6aWVyTGVuZ3RoUG9vbCIsImNyZWF0ZSIsImFkZGVkTGVuZ3RoIiwicGVyY2VudHMiLCJsZW5ndGhzIiwic2VnbWVudHNMZW5ndGhQb29sIiwidG90YWxMZW5ndGgiLCJiZXpGdW5jdGlvbiIsIm1hdGgiLCJwb2ludE9uTGluZTJEIiwieDEiLCJ5MSIsIngyIiwieTIiLCJ4MyIsInkzIiwiZGV0MSIsInBvaW50T25MaW5lM0QiLCJ6MSIsInoyIiwiejMiLCJkaXN0MSIsImRpc3QyIiwiZGlzdDMiLCJkaWZmRGlzdCIsImdldEJlemllckxlbmd0aCIsInB0MSIsInB0MiIsInB0MyIsInB0NCIsImN1cnZlU2VnbWVudHMiLCJwdENvb3JkIiwicGVyYyIsInB0RGlzdGFuY2UiLCJwb2ludCIsImxhc3RQb2ludCIsImxlbmd0aERhdGEiLCJnZXRTZWdtZW50c0xlbmd0aCIsInNoYXBlRGF0YSIsInNlZ21lbnRzTGVuZ3RoIiwicGF0aFYiLCJwYXRoTyIsInBhdGhJIiwiQmV6aWVyRGF0YSIsInNlZ21lbnRMZW5ndGgiLCJQb2ludERhdGEiLCJwYXJ0aWFsIiwicGFydGlhbExlbmd0aCIsImJ1aWxkQmV6aWVyRGF0YSIsInN0b3JlZERhdGEiLCJiZXppZXJOYW1lIiwiYmV6aWVyRGF0YSIsImdldERpc3RhbmNlUGVyYyIsImluaXRQb3MiLCJsZW5ndGhQb3MiLCJsUGVyYyIsImRpciIsImdldFBvaW50SW5TZWdtZW50IiwicGVyY2VudCIsInQxIiwidTEiLCJwdFgiLCJwdFkiLCJiZXppZXJTZWdtZW50UG9pbnRzIiwiZ2V0TmV3U2VnbWVudCIsInN0YXJ0UGVyYyIsImVuZFBlcmMiLCJ0MCIsInUwIiwidTB1MHUwIiwidDB1MHUwXzMiLCJ0MHQwdTBfMyIsInQwdDB0MCIsInUwdTB1MSIsInQwdTB1MV8zIiwidDB0MHUxXzMiLCJ0MHQwdDEiLCJ1MHUxdTEiLCJ0MHUxdTFfMyIsInQwdDF1MV8zIiwidDB0MXQxIiwidTF1MXUxIiwidDF1MXUxXzMiLCJ0MXQxdTFfMyIsInQxdDF0MSIsImJleiIsImluaXRGcmFtZSIsIm1hdGhBYnMiLCJpbnRlcnBvbGF0ZVZhbHVlIiwiZnJhbWVOdW0iLCJjYWNoaW5nIiwib2Zmc2V0VGltZSIsIm5ld1ZhbHVlIiwicHJvcFR5cGUiLCJwdiIsIml0ZXJhdGlvbkluZGV4IiwibGFzdEluZGV4Iiwia2V5ZnJhbWVzIiwia2V5RGF0YSIsIm5leHRLZXlEYXRhIiwia2V5ZnJhbWVNZXRhZGF0YSIsImtleWZyYW1lc01ldGFkYXRhIiwiZm5jIiwibmV4dEtleVRpbWUiLCJrZXlUaW1lIiwiZW5kVmFsdWUiLCJ0byIsInRpIiwiaW5kIiwiX19mbmN0IiwieSIsIm4iLCJkaXN0YW5jZUluTGluZSIsInNlZ21lbnRQZXJjIiwibGFzdEZyYW1lIiwiX2xhc3RLZXlmcmFtZUluZGV4IiwiX2xhc3RBZGRlZExlbmd0aCIsIl9sYXN0UG9pbnQiLCJvdXRYIiwib3V0WSIsImluWCIsImluWSIsImtleVZhbHVlIiwic2giLCJxdWF0U3RhcnQiLCJjcmVhdGVRdWF0ZXJuaW9uIiwicXVhdEVuZCIsInF1YXRlcm5pb25Ub0V1bGVyIiwic2xlcnAiLCJvdXQiLCJheCIsImF5IiwiYXoiLCJhdyIsImJ4IiwiYnkiLCJieiIsImJ3Iiwib21lZ2EiLCJjb3NvbSIsInNpbm9tIiwic2NhbGUwIiwic2NhbGUxIiwiYWNvcyIsInNpbiIsInF1YXQiLCJxeCIsInF5IiwicXoiLCJxdyIsImhlYWRpbmciLCJhdGFuMiIsImF0dGl0dWRlIiwiYXNpbiIsImJhbmsiLCJ2YWx1ZXMiLCJjMSIsImNvcyIsImMyIiwiYzMiLCJzMSIsInMyIiwiczMiLCJ3IiwieiIsImdldFZhbHVlQXRDdXJyZW50VGltZSIsInJlbmRlcmVkRnJhbWUiLCJlbmRUaW1lIiwiX2NhY2hpbmciLCJyZW5kZXJSZXN1bHQiLCJzZXRWVmFsdWUiLCJtdWx0aXBsaWVkVmFsdWUiLCJtdWx0IiwiX21kZiIsInByb2Nlc3NFZmZlY3RzU2VxdWVuY2UiLCJmcmFtZUlkIiwiZWZmZWN0c1NlcXVlbmNlIiwibG9jayIsIl9pc0ZpcnN0RnJhbWUiLCJmaW5hbFZhbHVlIiwia2YiLCJhZGRFZmZlY3QiLCJlZmZlY3RGdW5jdGlvbiIsImFkZER5bmFtaWNQcm9wZXJ0eSIsIlZhbHVlUHJvcGVydHkiLCJ2ZWwiLCJnZXRWYWx1ZSIsIk11bHRpRGltZW5zaW9uYWxQcm9wZXJ0eSIsIktleWZyYW1lZFZhbHVlUHJvcGVydHkiLCJLZXlmcmFtZWRNdWx0aWRpbWVuc2lvbmFsUHJvcGVydHkiLCJhcnJMZW4iLCJQcm9wZXJ0eUZhY3RvcnkiLCJnZXRQcm9wIiwic2lkIiwic2xvdE1hbmFnZXIiLCJEeW5hbWljUHJvcGVydHlDb250YWluZXIiLCJkeW5hbWljUHJvcGVydGllcyIsIl9pc0FuaW1hdGVkIiwiaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzIiwiaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lciIsInBvaW50UG9vbCIsIlNoYXBlUGF0aCIsInNldFBhdGhEYXRhIiwic2V0TGVuZ3RoIiwiZG91YmxlQXJyYXlMZW5ndGgiLCJzZXRYWUF0IiwicG9zIiwic2V0VHJpcGxlQXQiLCJ2WCIsInZZIiwib1giLCJvWSIsImlYIiwiaVkiLCJyZXZlcnNlIiwibmV3UGF0aCIsInZlcnRpY2VzIiwib3V0UG9pbnRzIiwiaW5Qb2ludHMiLCJjbnQiLCJzaGFwZVBvb2wiLCJzaGFwZVBhdGgiLCJjbG9uZSIsInNoYXBlIiwiY2xvbmVkIiwiU2hhcGVDb2xsZWN0aW9uIiwiYWRkU2hhcGUiLCJyZWxlYXNlU2hhcGVzIiwic2hhcGVDb2xsZWN0aW9uUG9vbCIsIm5ld1NoYXBlQ29sbGVjdGlvbiIsInNoYXBlQ29sbGVjdGlvbiIsIlNoYXBlUHJvcGVydHlGYWN0b3J5IiwiaW50ZXJwb2xhdGVTaGFwZSIsInByZXZpb3VzVmFsdWUiLCJrZXlQcm9wUyIsImtleVByb3BFIiwiaXNIb2xkIiwidmVydGV4VmFsdWUiLCJpbnRlcnBvbGF0ZVNoYXBlQ3VycmVudFRpbWUiLCJyZXNldFNoYXBlIiwicGF0aHMiLCJsb2NhbFNoYXBlQ29sbGVjdGlvbiIsInNoYXBlc0VxdWFsIiwic2hhcGUxIiwic2hhcGUyIiwiU2hhcGVQcm9wZXJ0eSIsInJlc2V0IiwiS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eSIsIkVsbFNoYXBlUHJvcGVydHkiLCJjUG9pbnQiLCJFbGxTaGFwZVByb3BlcnR5RmFjdG9yeSIsImNvbnZlcnRFbGxUb1BhdGgiLCJwMCIsInAxIiwiczAiLCJfY3ciLCJfdiIsIlN0YXJTaGFwZVByb3BlcnR5IiwiU3RhclNoYXBlUHJvcGVydHlGYWN0b3J5Iiwic3kiLCJpciIsImlzIiwiY29udmVydFRvUGF0aCIsImNvbnZlcnRTdGFyVG9QYXRoIiwiY29udmVydFBvbHlnb25Ub1BhdGgiLCJvciIsIm9zIiwibnVtUHRzIiwiYW5nbGUiLCJsb25nRmxhZyIsImxvbmdSYWQiLCJzaG9ydFJhZCIsImxvbmdSb3VuZCIsInNob3J0Um91bmQiLCJsb25nUGVyaW1TZWdtZW50Iiwic2hvcnRQZXJpbVNlZ21lbnQiLCJyYWQiLCJyb3VuZG5lc3MiLCJwZXJpbVNlZ21lbnQiLCJjdXJyZW50QW5nIiwib3giLCJveSIsIlJlY3RTaGFwZVByb3BlcnR5IiwiUmVjdFNoYXBlUHJvcGVydHlGYWN0b3J5IiwiY29udmVydFJlY3RUb1BhdGgiLCJ2MCIsInYxIiwiZ2V0U2hhcGVQcm9wIiwiZGF0YVByb3AiLCJnZXRDb25zdHJ1Y3RvckZ1bmN0aW9uIiwiZ2V0S2V5ZnJhbWVkQ29uc3RydWN0b3JGdW5jdGlvbiIsIk1hdHJpeCIsIl9jb3MiLCJfc2luIiwiX3RhbiIsInRhbiIsIl9ybmQiLCJwcm9wcyIsInJvdGF0ZSIsIm1Db3MiLCJtU2luIiwiX3QiLCJyb3RhdGVYIiwicm90YXRlWSIsInJvdGF0ZVoiLCJzaGVhciIsInN4Iiwic2tldyIsInNrZXdGcm9tQXhpcyIsInNjYWxlIiwic3oiLCJzZXRUcmFuc2Zvcm0iLCJsIiwibSIsInRyYW5zbGF0ZSIsInR4IiwidHoiLCJ0cmFuc2Zvcm0iLCJhMiIsImIyIiwiZDIiLCJlMiIsImYyIiwiZzIiLCJoMiIsImkyIiwiajIiLCJrMiIsImwyIiwibTIiLCJuMiIsIm8yIiwicDIiLCJfaWRlbnRpdHlDYWxjdWxhdGVkIiwiYTEiLCJiMSIsImQxIiwiZTEiLCJmMSIsImcxIiwiaDEiLCJpMSIsImoxIiwiazEiLCJsMSIsIm0xIiwibjEiLCJvMSIsIm11bHRpcGx5IiwibWF0cml4IiwibWF0cml4UHJvcHMiLCJpc0lkZW50aXR5IiwiX2lkZW50aXR5IiwiZXF1YWxzIiwibWF0ciIsImNsb25lRnJvbVByb3BzIiwiYXBwbHlUb1BvaW50IiwiYXBwbHlUb1giLCJhcHBseVRvWSIsImFwcGx5VG9aIiwiZ2V0SW52ZXJzZU1hdHJpeCIsImRldGVybWluYW50IiwiaW52ZXJzZU1hdHJpeCIsImludmVyc2VQb2ludCIsImFwcGx5VG9Qb2ludEFycmF5IiwiaW52ZXJzZVBvaW50cyIsInB0cyIsInJldFB0cyIsImFwcGx5VG9UcmlwbGVQb2ludHMiLCJwNCIsInA1IiwicDEyIiwicDEzIiwiYXBwbHlUb1BvaW50U3RyaW5naWZpZWQiLCJ0b0NTUyIsImNzc1ZhbHVlIiwicm91bmRNYXRyaXhQcm9wZXJ0eSIsInRvMmRDU1MiLCJfYSIsIl9iIiwiX2MiLCJfZCIsIl9lIiwiX2YiLCJfdHlwZW9mJDMiLCJzZXRMb2NhdGlvbiIsImhyZWYiLCJzZXRTdWJmcmFtZVJlbmRlcmluZyIsInNldFByZWZpeCIsInByZWZpeCIsInNldFF1YWxpdHkiLCJpbkJyb3dzZXIiLCJpbnN0YWxsUGx1Z2luIiwicGx1Z2luIiwiZ2V0RmFjdG9yeSIsInVzZVdlYldvcmtlciIsInNldElEUHJlZml4IiwiX19nZXRGYWN0b3J5IiwidmVyc2lvbiIsImNoZWNrUmVhZHkiLCJyZWFkeVN0YXRlQ2hlY2tJbnRlcnZhbCIsImdldFF1ZXJ5VmFyaWFibGUiLCJ2YXJpYWJsZSIsInZhcnMiLCJxdWVyeVN0cmluZyIsInBhaXIiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzY3JpcHRzIiwibXlTY3JpcHQiLCJib2R5bW92aW4iLCJTaGFwZU1vZGlmaWVycyIsIm1vZGlmaWVycyIsInJlZ2lzdGVyTW9kaWZpZXIiLCJnZXRNb2RpZmllciIsIlNoYXBlTW9kaWZpZXIiLCJpbml0TW9kaWZpZXJQcm9wZXJ0aWVzIiwiYWRkU2hhcGVUb01vZGlmaWVyIiwic2V0QXNBbmltYXRlZCIsInByb2Nlc3NLZXlzIiwiVHJpbU1vZGlmaWVyIiwic1ZhbHVlIiwiZVZhbHVlIiwicGF0aHNEYXRhIiwiY2FsY3VsYXRlU2hhcGVFZGdlcyIsInNoYXBlTGVuZ3RoIiwidG90YWxNb2RpZmllckxlbmd0aCIsInNoYXBlU2VnbWVudHMiLCJzZWdtZW50T2IiLCJzaGFwZVMiLCJzaGFwZUUiLCJyZWxlYXNlUGF0aHNEYXRhIiwicHJvY2Vzc1NoYXBlcyIsIl9zIiwic2hhcGVQYXRocyIsInRvdGFsU2hhcGVMZW5ndGgiLCJlZGdlcyIsIm5ld1NoYXBlc0RhdGEiLCJhZGRTaGFwZXMiLCJsYXN0U2hhcGVJbkNvbGxlY3Rpb24iLCJsYXN0U2hhcGUiLCJwb3AiLCJhZGRQYXRocyIsIm5ld1BhdGhzIiwiYWRkU2VnbWVudCIsIm5ld1NoYXBlIiwiYWRkU2VnbWVudEZyb21BcnJheSIsInNoYXBlU2VnbWVudCIsImN1cnJlbnRMZW5ndGhEYXRhIiwic2VnbWVudENvdW50IiwiUHVja2VyQW5kQmxvYXRNb2RpZmllciIsImFtb3VudCIsInByb2Nlc3NQYXRoIiwiY2VudGVyUG9pbnQiLCJwYXRoTGVuZ3RoIiwiY2xvbmVkUGF0aCIsIlRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeSIsImRlZmF1bHRWZWN0b3IiLCJhcHBseVRvTWF0cml4IiwibWF0IiwicnoiLCJyeSIsInJ4IiwicHgiLCJweSIsInB6IiwiZm9yY2VSZW5kZXIiLCJfaXNEaXJ0eSIsInByZWNhbGN1bGF0ZU1hdHJpeCIsInByZSIsImFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMiLCJhdXRvT3JpZW50ZWQiLCJ2MiIsImdldFZhbHVlQXRUaW1lIiwiYXV0b09yaWVudCIsIl9hZGREeW5hbWljUHJvcGVydHkiLCJUcmFuc2Zvcm1Qcm9wZXJ0eSIsImdldFRyYW5zZm9ybVByb3BlcnR5IiwiUmVwZWF0ZXJNb2RpZmllciIsInRyIiwic28iLCJlbyIsInBNYXRyaXgiLCJyTWF0cml4Iiwic01hdHJpeCIsInRNYXRyaXgiLCJhcHBseVRyYW5zZm9ybXMiLCJpbnYiLCJzY2FsZVgiLCJzY2FsZVkiLCJlbGVtc0RhdGEiLCJfY3VycmVudENvcGllcyIsIl9lbGVtZW50cyIsIl9ncm91cHMiLCJ1bnNoaWZ0IiwicmVzZXRFbGVtZW50cyIsImVsZW1lbnRzIiwiX3Byb2Nlc3NlZCIsImNsb25lRWxlbWVudHMiLCJuZXdFbGVtZW50cyIsImNoYW5nZUdyb3VwUmVuZGVyIiwicmVuZGVyRmxhZyIsIl9yZW5kZXIiLCJpdGVtcyIsIml0ZW1zVHJhbnNmb3JtIiwiY29udCIsImhhc1JlbG9hZGVkIiwiY29waWVzIiwiY2VpbCIsImdyb3VwIiwiaXgiLCJyZWxvYWRTaGFwZXMiLCJlbGVtcyIsInRyYW5zZm9ybURhdGEiLCJvZmZzZXRNb2R1bG8iLCJyb3VuZE9mZnNldCIsInBQcm9wcyIsInJQcm9wcyIsInNQcm9wcyIsIml0ZXJhdGlvbiIsIm1Qcm9wcyIsIlJvdW5kQ29ybmVyc01vZGlmaWVyIiwicmQiLCJjdXJyZW50ViIsImN1cnJlbnRJIiwiY3VycmVudE8iLCJjbG9zZXJWIiwiZGlzdGFuY2UiLCJuZXdQb3NQZXJjIiwiZmxvYXRFcXVhbCIsImZsb2F0WmVybyIsImxlcnAiLCJsZXJwUG9pbnQiLCJxdWFkUm9vdHMiLCJzaW5nbGVSb290IiwiZGVsdGEiLCJwb2x5bm9taWFsQ29lZmZpY2llbnRzIiwicDMiLCJzaW5nbGVQb2ludCIsIlBvbHlub21pYWxCZXppZXIiLCJsaW5lYXJpemUiLCJwb2ludEVxdWFsIiwiY29lZmZ4IiwiY29lZmZ5IiwiZGVyaXZhdGl2ZSIsInRhbmdlbnRBbmdsZSIsIm5vcm1hbEFuZ2xlIiwiaW5mbGVjdGlvblBvaW50cyIsImRlbm9tIiwidGN1c3AiLCJzcXVhcmUiLCJyb290IiwiZmlsdGVyIiwicDEwIiwicDExIiwicDIwIiwicDIxIiwiZXh0cmVtYSIsImJvdW5kcyIsImJvdW5kaW5nQm94IiwicmlnaHQiLCJib3R0b20iLCJjeCIsImN5IiwiaW50ZXJzZWN0RGF0YSIsInQyIiwic3BsaXREYXRhIiwiYm94SW50ZXJzZWN0IiwiaW50ZXJzZWN0c0ltcGwiLCJkZXB0aCIsInRvbGVyYW5jZSIsImludGVyc2VjdGlvbnMiLCJtYXhSZWN1cnNpb24iLCJkMXMiLCJkMnMiLCJvdGhlciIsIm5leHRJbmRleCIsInNoYXBlU2VnbWVudEludmVydGVkIiwiY3Jvc3NQcm9kdWN0IiwibGluZUludGVyc2VjdGlvbiIsInN0YXJ0MSIsImVuZDEiLCJzdGFydDIiLCJlbmQyIiwidjMiLCJ2NCIsInBvbGFyT2Zmc2V0IiwicG9pbnREaXN0YW5jZSIsImh5cG90IiwiWmlnWmFnTW9kaWZpZXIiLCJhbXBsaXR1ZGUiLCJmcmVxdWVuY3kiLCJwb2ludHNUeXBlIiwic2V0UG9pbnQiLCJvdXRwdXRCZXppZXIiLCJvdXRBbXBsaXR1ZGUiLCJpbkFtcGxpdHVkZSIsImFuZ08iLCJhbmdJIiwiZ2V0UGVycGVuZGljdWxhclZlY3RvciIsInZlY3RvciIsInJvdCIsInJvdGF0ZWRWZWN0b3IiLCJnZXRQcm9qZWN0aW5nQW5nbGUiLCJjdXIiLCJwcmV2SW5kZXgiLCJwcmV2UG9pbnQiLCJuZXh0UG9pbnQiLCJwVmVjdG9yIiwiemlnWmFnQ29ybmVyIiwicG9pbnRUeXBlIiwicHJldkRpc3QiLCJuZXh0RGlzdCIsInppZ1phZ1NlZ21lbnQiLCJjb3VudCIsImxpbmVhck9mZnNldCIsIm9mZnNldFNlZ21lbnQiLCJwMWEiLCJwMWIiLCJwMmIiLCJwMmEiLCJqb2luTGluZXMiLCJzZWcxIiwic2VnMiIsImxpbmVKb2luIiwibWl0ZXJMaW1pdCIsImFuZ2xlT3V0IiwiYW5nbGVJbiIsImNlbnRlciIsInJhZGl1cyIsImludGVyc2VjdGlvbiIsImdldEludGVyc2VjdGlvbiIsImludGVyc2VjdCIsInBydW5lU2VnbWVudEludGVyc2VjdGlvbiIsIm91dGEiLCJvdXRiIiwicHJ1bmVJbnRlcnNlY3Rpb25zIiwib2Zmc2V0U2VnbWVudFNwbGl0IiwiZmxleCIsIm1pZCIsIk9mZnNldFBhdGhNb2RpZmllciIsIm1sIiwibGoiLCJpbnB1dEJlemllciIsIm11bHRpU2VnbWVudHMiLCJsYXN0U2VnIiwibXVsdGlTZWdtZW50IiwiZ2V0Rm9udFByb3BlcnRpZXMiLCJmb250RGF0YSIsInN0eWxlcyIsImZTdHlsZSIsImZXZWlnaHQiLCJzdHlsZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsIndlaWdodCIsIkZvbnRNYW5hZ2VyIiwibWF4V2FpdGluZ1RpbWUiLCJlbXB0eUNoYXIiLCJzaXplIiwiY29tYmluZWRDaGFyYWN0ZXJzIiwiQkxBQ0tfRkxBR19DT0RFX1BPSU5UIiwiQ0FOQ0VMX1RBR19DT0RFX1BPSU5UIiwiQV9UQUdfQ09ERV9QT0lOVCIsIlpfVEFHX0NPREVfUE9JTlQiLCJWQVJJQVRJT05fU0VMRUNUT1JfMTZfQ09ERV9QT0lOVCIsIlpFUk9fV0lEVEhfSk9JTkVSX0NPREVfUE9JTlQiLCJSRUdJT05BTF9DSEFSQUNURVJfQV9DT0RFX1BPSU5UIiwiUkVHSU9OQUxfQ0hBUkFDVEVSX1pfQ09ERV9QT0lOVCIsInN1cnJvZ2F0ZU1vZGlmaWVycyIsInRyaW1Gb250T3B0aW9ucyIsImZvbnQiLCJmYW1pbHlBcnJheSIsImVuYWJsZWRGYW1pbGllcyIsInNldFVwTm9kZSIsImZhbWlseSIsInBhcmVudE5vZGUiLCJmb250RmFtaWx5Iiwibm9kZSIsImZvbnRTaXplIiwiZm9udFZhcmlhbnQiLCJmb250U3R5bGUiLCJmb250V2VpZ2h0IiwibGV0dGVyU3BhY2luZyIsIm9mZnNldFdpZHRoIiwicGFyZW50IiwiY2hlY2tMb2FkZWRGb250cyIsImxvYWRlZENvdW50IiwibG9hZGVkIiwiZk9yaWdpbiIsIm1vbm9DYXNlIiwic2Fuc0Nhc2UiLCJyZW1vdmVDaGlsZCIsIkRhdGUiLCJub3ciLCJjaGVja0xvYWRlZEZvbnRzQmluZGVkIiwic2V0SXNMb2FkZWRCaW5kZWQiLCJjcmVhdGVIZWxwZXIiLCJkZWYiLCJlbmdpbmUiLCJoZWxwZXIiLCJmb250UHJvcHMiLCJ0SGVscGVyIiwiZkZhbWlseSIsInRleHRDb250ZW50IiwiZkNsYXNzIiwidENhbnZhc0hlbHBlciIsIk9mZnNjcmVlbkNhbnZhcyIsIm1lYXN1cmUiLCJ0ZXh0IiwiZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoIiwibWVhc3VyZVRleHQiLCJsaXN0IiwiZm9yRWFjaCIsImNhY2hlIiwiZm9udEFyciIsIl9wZW5kaW5nRm9udHMiLCJzaG91bGRMb2FkRm9udCIsImxvYWRlZFNlbGVjdG9yIiwiZlBhdGgiLCJxdWVyeVNlbGVjdG9yQWxsIiwicmVsIiwic2MiLCJmb3VuZCIsImNoIiwiZ2V0Q2hhckRhdGEiLCJfY2hhciIsImNoYXJDb2RlQXQiLCJjb25zb2xlIiwid2FybiIsIl93YXJuZWQiLCJfY2hhcjIiLCJmb250TmFtZSIsImdldEZvbnRCeU5hbWUiLCJkb3VibGVTaXplIiwic2luZ2xlU2l6ZSIsImZOYW1lIiwiZ2V0Q29kZVBvaW50Iiwic3RyaW5nIiwiY29kZVBvaW50Iiwic2Vjb25kIiwiaXNNb2RpZmllciIsImZpcnN0Q2hhckNvZGUiLCJzZWNvbmRDaGFyQ29kZSIsInN1bSIsImlzWmVyb1dpZHRoSm9pbmVyIiwiY2hhckNvZGUiLCJpc1ZhcmlhdGlvblNlbGVjdG9yIiwiaXNSZWdpb25hbENvZGUiLCJpc0ZsYWdFbW9qaSIsImlzQ29tYmluZWRDaGFyYWN0ZXIiLCJfY2hhcjMiLCJpc1JlZ2lvbmFsRmxhZyIsInNldElzTG9hZGVkIiwiRm9udCIsInR5cGVraXRMb2FkZWQiLCJmb250UHJvdG90eXBlIiwiU2xvdE1hbmFnZXIiLCJzbG90cyIsImFzc2lnbiIsInNsb3RGYWN0b3J5IiwiUmVuZGVyYWJsZUVsZW1lbnQiLCJpbml0UmVuZGVyYWJsZSIsImlzSW5SYW5nZSIsImhpZGRlbiIsImlzVHJhbnNwYXJlbnQiLCJyZW5kZXJhYmxlQ29tcG9uZW50cyIsImFkZFJlbmRlcmFibGVDb21wb25lbnQiLCJjb21wb25lbnQiLCJyZW1vdmVSZW5kZXJhYmxlQ29tcG9uZW50IiwicHJlcGFyZVJlbmRlcmFibGVGcmFtZSIsIm51bSIsImNoZWNrTGF5ZXJMaW1pdHMiLCJjaGVja1RyYW5zcGFyZW5jeSIsImZpbmFsVHJhbnNmb3JtIiwibVByb3AiLCJyZW5kZXJDb25maWciLCJoaWRlT25UcmFuc3BhcmVudCIsInJlbmRlclJlbmRlcmFibGUiLCJzb3VyY2VSZWN0QXRUaW1lIiwiZ2V0TGF5ZXJTaXplIiwidGV4dERhdGEiLCJnZXRCbGVuZE1vZGUiLCJibGVuZE1vZGVFbnVtcyIsIm1vZGUiLCJTbGlkZXJFZmZlY3QiLCJBbmdsZUVmZmVjdCIsIkNvbG9yRWZmZWN0IiwiUG9pbnRFZmZlY3QiLCJMYXllckluZGV4RWZmZWN0IiwiTWFza0luZGV4RWZmZWN0IiwiQ2hlY2tib3hFZmZlY3QiLCJOb1ZhbHVlRWZmZWN0IiwiRWZmZWN0c01hbmFnZXIiLCJlZmZlY3RzIiwiZWYiLCJlZmZlY3RFbGVtZW50cyIsImVmZmVjdEl0ZW0iLCJHcm91cEVmZmVjdCIsImVmZiIsIkJhc2VFbGVtZW50IiwiY2hlY2tNYXNrcyIsIkxheWVyRXhwcmVzc2lvbkludGVyZmFjZSIsIkVmZmVjdHNFeHByZXNzaW9uSW50ZXJmYWNlIiwiU2hhcGVFeHByZXNzaW9uSW50ZXJmYWNlIiwiVGV4dEV4cHJlc3Npb25JbnRlcmZhY2UiLCJDb21wRXhwcmVzc2lvbkludGVyZmFjZSIsImxheWVySW50ZXJmYWNlIiwibWFza01hbmFnZXIiLCJyZWdpc3Rlck1hc2tJbnRlcmZhY2UiLCJlZmZlY3RzSW50ZXJmYWNlIiwiY3JlYXRlRWZmZWN0c0ludGVyZmFjZSIsInJlZ2lzdGVyRWZmZWN0c0ludGVyZmFjZSIsInNoYXBlSW50ZXJmYWNlIiwic2hhcGVzRGF0YSIsIml0ZW1zRGF0YSIsImNvbnRlbnQiLCJ0ZXh0SW50ZXJmYWNlIiwic2V0QmxlbmRNb2RlIiwiYmxlbmRNb2RlVmFsdWUiLCJibSIsImJhc2VFbGVtZW50IiwibGF5ZXJFbGVtZW50IiwiaW5pdEJhc2VEYXRhIiwibGF5ZXJJZCIsImVmZmVjdHNNYW5hZ2VyIiwiZ2V0VHlwZSIsIkZyYW1lRWxlbWVudCIsInByZXBhcmVQcm9wZXJ0aWVzIiwiaXNWaXNpYmxlIiwiX2lzUGFyZW50IiwiRm9vdGFnZUVsZW1lbnQiLCJpbWFnZUxvYWRlciIsImdldEJhc2VFbGVtZW50IiwiRm9vdGFnZUludGVyZmFjZSIsImdldEZvb3RhZ2VEYXRhIiwiQXVkaW9FbGVtZW50IiwiX2lzUGxheWluZyIsIl9jYW5QbGF5IiwiX2N1cnJlbnRUaW1lIiwiX3ZvbHVtZU11bHRpcGxpZXIiLCJfcHJldmlvdXNWb2x1bWUiLCJfcGxhY2Vob2xkZXIiLCJsdiIsImF1IiwidGltZVJlbWFwcGVkIiwidG90YWxWb2x1bWUiLCJ2b2x1bWVWYWx1ZSIsIkJhc2VSZW5kZXJlciIsImNoZWNrTGF5ZXJzIiwiYnVpbGRJdGVtIiwiY2hlY2tQZW5kaW5nRWxlbWVudHMiLCJjcmVhdGVJdGVtIiwibGF5ZXIiLCJjcmVhdGVJbWFnZSIsImNyZWF0ZUNvbXAiLCJjcmVhdGVTb2xpZCIsImNyZWF0ZU51bGwiLCJjcmVhdGVTaGFwZSIsImNyZWF0ZVRleHQiLCJjcmVhdGVDYW1lcmEiLCJjcmVhdGVGb290YWdlIiwiYnVpbGRBbGxJdGVtcyIsInBJbnRlcmZhY2UiLCJwcm9ncmVzc2l2ZUxvYWQiLCJidWlsZEVsZW1lbnRQYXJlbnRpbmciLCJwYXJlbnROYW1lIiwiaGllcmFyY2h5IiwiYWRkUGVuZGluZ0VsZW1lbnQiLCJzZXRBc1BhcmVudCIsInNldEhpZXJhcmNoeSIsInBlbmRpbmdFbGVtZW50cyIsImdldEVsZW1lbnRCeUlkIiwicGF0aFZhbHVlIiwic2V0dXBHbG9iYWxEYXRhIiwiZm9udHNDb250YWluZXIiLCJhbmltYXRpb25JdGVtIiwiY29tcFNpemUiLCJlZmZlY3RUeXBlcyIsIlRSQU5TRk9STV9FRkZFQ1QiLCJUcmFuc2Zvcm1FbGVtZW50IiwiaW5pdFRyYW5zZm9ybSIsIl9tYXRNZGYiLCJfbG9jYWxNYXRNZGYiLCJfb3BNZGYiLCJsb2NhbE1hdCIsImxvY2FsT3BhY2l0eSIsImFvIiwicmVuZGVyVHJhbnNmb3JtIiwiZmluYWxNYXQiLCJyZW5kZXJMb2NhbFRyYW5zZm9ybSIsImxvY2FsVHJhbnNmb3JtcyIsImxtYXQiLCJsb2NhbE9wIiwib3BhY2l0eSIsInNlYXJjaEVmZmVjdFRyYW5zZm9ybXMiLCJyZW5kZXJhYmxlRWZmZWN0c01hbmFnZXIiLCJ0cmFuc2Zvcm1FZmZlY3RzIiwiZ2V0RWZmZWN0cyIsImdsb2JhbFRvTG9jYWwiLCJ0cmFuc2Zvcm1zIiwicHROZXciLCJtSGVscGVyIiwiTWFza0VsZW1lbnQiLCJtYXNrRWxlbWVudCIsInZpZXdEYXRhIiwic29saWRQYXRoIiwicHJvcGVydGllcyIsImN1cnJlbnRNYXNrcyIsInJlY3QiLCJleHBhbnNvciIsImZlTW9ycGgiLCJtYXNrVHlwZSIsIm1hc2tSZWYiLCJsYXN0UGF0aCIsImZpbHRlcklEIiwiZXhwYW4iLCJsYXN0T3BlcmF0b3IiLCJmaWx0ZXJJZCIsImxhc3RSYWRpdXMiLCJtYXNrIiwiY3JlYXRlTGF5ZXJTb2xpZFBhdGgiLCJpbnZSZWN0IiwiZHJhd1BhdGgiLCJtYXNrZWRFbGVtZW50IiwiZ2V0TWFza1Byb3BlcnR5IiwiaXNGaXJzdEZyYW1lIiwiZ2V0TWFza2VsZW1lbnQiLCJwYXRoTm9kZXMiLCJwYXRoU3RyaW5nIiwicGF0aFNoYXBlVmFsdWUiLCJmaWx0ZXJzRmFjdG9yeSIsImNyZWF0ZUZpbHRlciIsImNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIiLCJmaWxJZCIsInNraXBDb29yZGluYXRlcyIsImZpbCIsImZlQ29sb3JNYXRyaXgiLCJmZWF0dXJlU3VwcG9ydCIsInN2Z0x1bWFIaWRkZW4iLCJvZmZzY3JlZW5DYW52YXMiLCJyZWdpc3RlcmVkRWZmZWN0cyQxIiwiaWRQcmVmaXgiLCJTVkdFZmZlY3RzIiwic291cmNlIiwiZmlsdGVycyIsImZpbHRlck1hbmFnZXIiLCJFZmZlY3QiLCJlZmZlY3QiLCJjb3VudHNBc0VmZmVjdCIsInJlZ2lzdGVyRWZmZWN0JDEiLCJTVkdCYXNlRWxlbWVudCIsImluaXRSZW5kZXJlckVsZW1lbnQiLCJjcmVhdGVDb250YWluZXJFbGVtZW50cyIsIm1hdHRlRWxlbWVudCIsInRyYW5zZm9ybWVkRWxlbWVudCIsIl9zaXplQ2hhbmdlZCIsImxheWVyRWxlbWVudFBhcmVudCIsInRkIiwibWF0dGVNYXNrcyIsImdnIiwidHQiLCJsbiIsImhkIiwiY3AiLCJjbGlwSWQiLCJjcEdyb3VwIiwicmVuZGVyRWxlbWVudCIsImRlc3Ryb3lCYXNlRWxlbWVudCIsImNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzIiwiZ2V0TWF0dGUiLCJtYXR0ZVR5cGUiLCJ1c2VFbGVtZW50IiwibWFza2VyIiwibWFza0dyb3VwIiwibWFza0dyb3VwZXIiLCJmZUNUciIsImZlRnVuYyIsImFscGhhUmVjdCIsInNldE1hdHRlIiwiSGllcmFyY2h5RWxlbWVudCIsImluaXRIaWVyYXJjaHkiLCJjaGVja1BhcmVudGluZyIsIlJlbmRlcmFibGVET01FbGVtZW50IiwiX3Byb3RvdHlwZSIsImluaXRFbGVtZW50IiwiY3JlYXRlQ29udGVudCIsInJlbmRlcklubmVyQ29udGVudCIsImlubmVyRWxlbSIsIklJbWFnZUVsZW1lbnQiLCJzb3VyY2VSZWN0IiwicHIiLCJpbWFnZVByZXNlcnZlQXNwZWN0UmF0aW8iLCJQcm9jZXNzZWRFbGVtZW50IiwiSVNoYXBlRWxlbWVudCIsImFkZFNoYXBlVG9Nb2RpZmllcnMiLCJzaGFwZU1vZGlmaWVycyIsImlzU2hhcGVJbkFuaW1hdGVkTW9kaWZpZXJzIiwiaXNBbmltYXRlZFdpdGhTaGFwZSIsInJlbmRlck1vZGlmaWVycyIsInNob3VsZEJyZWFrUHJvY2VzcyIsInNlYXJjaFByb2Nlc3NlZEVsZW1lbnQiLCJwcm9jZXNzZWRFbGVtZW50cyIsImFkZFByb2Nlc3NlZEVsZW1lbnQiLCJsaW5lQ2FwRW51bSIsImxpbmVKb2luRW51bSIsIlNWR1NoYXBlRGF0YSIsInRyYW5zZm9ybWVycyIsImxldmVsIiwiY2FjaGVzIiwibFN0ciIsImx2bCIsIlNWR1N0eWxlRGF0YSIsInBFbGVtIiwibXNFbGVtIiwiRGFzaFByb3BlcnR5IiwiZGF0YVByb3BzIiwiZGFzaFN0ciIsImRhc2hBcnJheSIsImRhc2hvZmZzZXQiLCJTVkdTdHJva2VTdHlsZURhdGEiLCJzdHlsZU9iIiwiU1ZHRmlsbFN0eWxlRGF0YSIsIlNWR05vU3R5bGVEYXRhIiwiR3JhZGllbnRQcm9wZXJ0eSIsImNMZW5ndGgiLCJfY21kZiIsIl9vbWRmIiwiX2NvbGxhcHNhYmxlIiwiY2hlY2tDb2xsYXBzYWJsZSIsIl9oYXNPcGFjaXR5IiwiY29tcGFyZVBvaW50cyIsImRpZmYiLCJTVkdHcmFkaWVudEZpbGxTdHlsZURhdGEiLCJpbml0R3JhZGllbnREYXRhIiwic3RvcHMiLCJzZXRHcmFkaWVudERhdGEiLCJzZXRHcmFkaWVudE9wYWNpdHkiLCJwYXRoRWxlbWVudCIsImdyYWRpZW50SWQiLCJnZmlsbCIsImdmIiwiY3N0Iiwib3BhY2l0eUlkIiwibWFza0lkIiwib3BGaWxsIiwibGMiLCJvZiIsIm1zIiwib3N0IiwiU1ZHR3JhZGllbnRTdHJva2VTdHlsZURhdGEiLCJTaGFwZUdyb3VwRGF0YSIsInByZXZWaWV3RGF0YSIsImdyIiwiU1ZHVHJhbnNmb3JtRGF0YSIsImJ1aWxkU2hhcGVTdHJpbmciLCJfbyIsIl9pIiwic2hhcGVTdHJpbmciLCJTVkdFbGVtZW50c1JlbmRlcmVyIiwiX2lkZW50aXR5TWF0cml4IiwiX21hdHJpeEhlbHBlciIsImNyZWF0ZVJlbmRlckZ1bmN0aW9uIiwicmVuZGVyRmlsbCIsInJlbmRlckdyYWRpZW50IiwicmVuZGVyR3JhZGllbnRTdHJva2UiLCJyZW5kZXJTdHJva2UiLCJyZW5kZXJQYXRoIiwicmVuZGVyQ29udGVudFRyYW5zZm9ybSIsInJlbmRlck5vb3AiLCJzdHlsZURhdGEiLCJpdGVtRGF0YSIsInBhdGhTdHJpbmdUcmFuc2Zvcm1lZCIsInJlZHJhdyIsImxMZW4iLCJpdGVyYXRpb25zIiwic3R5bGVFbGVtIiwiaGFzT3BhY2l0eSIsImF0dHIxIiwiYXR0cjIiLCJjVmFsdWVzIiwib1ZhbHVlcyIsImFuZyIsIlNWR1NoYXBlRWxlbWVudCIsInN0eWxlc0xpc3QiLCJhbmltYXRlZENvbnRlbnRzIiwiaW5pdFNlY29uZGFyeUVsZW1lbnQiLCJpZGVudGl0eU1hdHJpeCIsImJ1aWxkRXhwcmVzc2lvbkludGVyZmFjZSIsInNlYXJjaFNoYXBlcyIsImZpbHRlclVuaXF1ZVNoYXBlcyIsInRlbXBTaGFwZXMiLCJhcmVBbmltYXRlZCIsInNldFNoYXBlc0FzQW5pbWF0ZWQiLCJjcmVhdGVTdHlsZUVsZW1lbnQiLCJlbGVtZW50RGF0YSIsIkdyYWRpZW50Q29uc3RydWN0b3IiLCJhZGRUb0FuaW1hdGVkQ29udGVudHMiLCJjcmVhdGVHcm91cEVsZW1lbnQiLCJjcmVhdGVUcmFuc2Zvcm1FbGVtZW50IiwidHJhbnNmb3JtUHJvcGVydHkiLCJjcmVhdGVTaGFwZUVsZW1lbnQiLCJvd25UcmFuc2Zvcm1lcnMiLCJzaGFwZVByb3BlcnR5Iiwic2V0RWxlbWVudFN0eWxlcyIsInJlbmRlciIsIm93blN0eWxlcyIsIm93bk1vZGlmaWVycyIsImN1cnJlbnRUcmFuc2Zvcm0iLCJtb2RpZmllciIsInByb2Nlc3NlZFBvcyIsInJlbmRlclNoYXBlIiwiYW5pbWF0ZWRDb250ZW50IiwiTGV0dGVyUHJvcHMiLCJzdyIsImZjIiwidXBkYXRlIiwidXBkYXRlZCIsIlRleHRQcm9wZXJ0eSIsIl9mcmFtZUlkIiwia2V5c0luZGV4IiwiY2FuUmVzaXplIiwibWluaW11bUZvbnRTaXplIiwiY3VycmVudERhdGEiLCJhc2NlbnQiLCJib3hXaWR0aCIsImRlZmF1bHRCb3hXaWR0aCIsImp1c3RpZnlPZmZzZXQiLCJsaCIsImxpbmVXaWR0aHMiLCJscyIsInBzIiwiZmlsbENvbG9yQW5pbSIsInN0cm9rZUNvbG9yQW5pbSIsInN0cm9rZVdpZHRoQW5pbSIsInlPZmZzZXQiLCJmaW5hbFNpemUiLCJmaW5hbFRleHQiLCJmaW5hbExpbmVIZWlnaHQiLCJjb3B5RGF0YSIsInNlYXJjaFByb3BlcnR5IiwiY29tcGxldGVUZXh0RGF0YSIsInNldEN1cnJlbnREYXRhIiwic2VhcmNoS2V5ZnJhbWVzIiwiZ2V0S2V5ZnJhbWVWYWx1ZSIsIl9maW5hbFZhbHVlIiwiY3VycmVudFZhbHVlIiwiY3VycmVudEluZGV4IiwidGV4dEtleXMiLCJidWlsZEZpbmFsVGV4dCIsImNoYXJhY3RlcnNBcnJheSIsInNob3VsZENvbWJpbmUiLCJzaG91bGRDb21iaW5lTmV4dCIsImN1cnJlbnRDaGFycyIsImNoYXJBdCIsImxldHRlcnMiLCJuZXdMaW5lRmxhZyIsImFuY2hvckdyb3VwaW5nIiwiY3VycmVudFNpemUiLCJjdXJyZW50UG9zIiwiY3VycmVudExpbmUiLCJsaW5lV2lkdGgiLCJtYXhMaW5lV2lkdGgiLCJ0cmFja2luZ09mZnNldCIsImJveEhlaWdodCIsImN1cnJlbnRIZWlnaHQiLCJsYXN0U3BhY2VJbmRleCIsInVuY29sbGFwc2VkU3BhY2VzIiwiY3VycmVudENoYXIiLCJhbiIsImFkZCIsImFuSW5kZXhlcyIsImFuaW1hdG9ySnVzdGlmeU9mZnNldCIsImV4dHJhIiwiYW5pbWF0b3JzIiwiYW5pbWF0b3JEYXRhIiwibGV0dGVyRGF0YSIsImJhc2VkIiwiaW5kZXhlcyIsImZoIiwiZnMiLCJmYiIsInJuIiwidG90YWxDaGFycyIsImN1cnJlbnRJbmQiLCJuZXdJbmQiLCJuZXdEYXRhIiwiZERhdGEiLCJyZWNhbGN1bGF0ZSIsImNhblJlc2l6ZUZvbnQiLCJfY2FuUmVzaXplIiwic2V0TWluaW11bUZvbnRTaXplIiwiX2ZvbnRWYWx1ZSIsIlRleHRTZWxlY3RvclByb3AiLCJUZXh0U2VsZWN0b3JQcm9wRmFjdG9yeSIsIl9jdXJyZW50VGV4dExlbmd0aCIsImZpbmFsUyIsImZpbmFsRSIsInhlIiwibmUiLCJzbSIsImdldE11bHQiLCJ0ZXh0UHJvcGVydHkiLCJlYXNlciIsInRvdCIsInNtb290aG5lc3MiLCJ0aHJlc2hvbGQiLCJuZXdDaGFyc0ZsYWciLCJkaXZpc29yIiwiZ2V0VGV4dFNlbGVjdG9yUHJvcCIsIlRleHRBbmltYXRvckRhdGFQcm9wZXJ0eSIsImFuaW1hdG9yUHJvcHMiLCJkZWZhdWx0RGF0YSIsInRleHRBbmltYXRvckFuaW1hdGFibGVzIiwiVGV4dEFuaW1hdG9yUHJvcGVydHkiLCJyZW5kZXJUeXBlIiwiX2hhc01hc2tlZFBhdGgiLCJfdGV4dERhdGEiLCJfcmVuZGVyVHlwZSIsIl9lbGVtIiwiX2FuaW1hdG9yc0RhdGEiLCJfcGF0aERhdGEiLCJfbW9yZU9wdGlvbnMiLCJhbGlnbm1lbnQiLCJyZW5kZXJlZExldHRlcnMiLCJsZXR0ZXJzQ2hhbmdlZEZsYWciLCJzZWFyY2hQcm9wZXJ0aWVzIiwiZ2V0TWVhc3VyZXMiLCJtYXRyaXhIZWxwZXIiLCJyZW5kZXJlZExldHRlcnNDb3VudCIsInhQb3MiLCJ5UG9zIiwicGF0aEluZm8iLCJjdXJyZW50TGVuZ3RoIiwiY3VycmVudFBvaW50IiwicG9pbnRJbmQiLCJzZWdtZW50SW5kIiwidGFuQW5nbGUiLCJ0TGVuZ3RoIiwicGkiLCJ5T2ZmIiwiZmlyc3RMaW5lIiwiYW5pbWF0b3JTZWxlY3RvciIsImxldHRlclZhbHVlIiwib2ZmZiIsInhQYXRoUG9zIiwieVBhdGhQb3MiLCJpbml0UGF0aFBvcyIsImluaXRTZWdtZW50SW5kIiwiaW5pdFBvaW50SW5kIiwiZWxlbU9wYWNpdHkiLCJsZXR0ZXJTdyIsImxldHRlclNjIiwibGV0dGVyRmMiLCJsZXR0ZXJNIiwibGV0dGVyUCIsImRlZmF1bHRQcm9wc0FycmF5IiwibGV0dGVyTyIsImFuaW1hdG9yRmlyc3RDaGFyT2Zmc2V0IiwianVzdGlmeU9mZnNldE11bHQiLCJpc05ld0xpbmUiLCJhbmltYXRvck9mZnNldCIsImF0YW4iLCJJVGV4dEVsZW1lbnQiLCJ0ZXh0QW5pbWF0b3IiLCJjcmVhdGVQYXRoU2hhcGUiLCJzaGFwZVN0ciIsIl9mb250U2l6ZSIsImFwcGx5VGV4dFByb3BlcnRpZXNUb01hdHJpeCIsImxpbmVOdW1iZXIiLCJidWlsZENvbG9yIiwiY29sb3JEYXRhIiwiZW1wdHlQcm9wIiwidmFsaWRhdGVUZXh0IiwiYnVpbGROZXdUZXh0IiwiZW1wdHlTaGFwZURhdGEiLCJTVkdUZXh0TG90dGllRWxlbWVudCIsInRleHRTcGFucyIsInNpbmdsZVNoYXBlIiwidGV4dENvbnRhaW5lciIsImJ1aWxkVGV4dENvbnRlbnRzIiwidGV4dEFycmF5IiwidGV4dENvbnRlbnRzIiwiY3VycmVudFRleHRDb250ZW50IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYnVpbGRTaGFwZURhdGEiLCJzaGFwZUl0ZW0iLCJ1c2VzR2x5cGhzIiwidFNwYW4iLCJ0RWxlbWVudCIsImp1c3RpZnkiLCJzcGFuIiwiZ2x5cGgiLCJjYWNoZWRTcGFuc0xlbmd0aCIsImNoaWxkU3BhbiIsImdseXBoRWxlbWVudCIsIlNWR0NvbXBFbGVtZW50IiwiX2RlYnVnIiwidGV4dEJveCIsImJib3giLCJyZW5kZXJlZExldHRlciIsInRleHRTcGFuIiwiSVNvbGlkRWxlbWVudCIsIk51bGxFbGVtZW50IiwiU1ZHUmVuZGVyZXJCYXNlIiwic3ZnRWxlbWVudCIsInZpZXdCb3hTaXplIiwidmlld0JveE9ubHkiLCJjb250ZW50VmlzaWJpbGl0eSIsImNsYXNzTmFtZSIsImZvY3VzYWJsZSIsInByZXNlcnZlQXNwZWN0UmF0aW8iLCJkZXN0cm95ZWQiLCJmaW5kSW5kZXhCeUluZCIsImFwcGVuZEVsZW1lbnRJblBvcyIsImVsZW1lbnRJbmRleCIsInRwIiwibWF0dGVNYXNrIiwibmV4dEVsZW1lbnQiLCJpbnNlcnRCZWZvcmUiLCJJQ29tcEVsZW1lbnQiLCJzZXRFbGVtZW50cyIsImdldEVsZW1lbnRzIiwiZGVzdHJveUVsZW1lbnRzIiwic3VwcG9ydHMzZCIsIlNWR1JlbmRlcmVyIiwiY29uZmlnIiwiYXJpYUxhYmVsIiwidGl0bGUiLCJ0aXRsZUVsZW1lbnQiLCJ0aXRsZUlkIiwiZGVzY3JpcHRpb24iLCJkZXNjRWxlbWVudCIsImRlc2NJZCIsImZpbHRlclNpemUiLCJydW5FeHByZXNzaW9ucyIsIlNoYXBlVHJhbnNmb3JtTWFuYWdlciIsInNlcXVlbmNlcyIsInNlcXVlbmNlTGlzdCIsInRyYW5zZm9ybV9rZXlfY291bnQiLCJhZGRUcmFuc2Zvcm1TZXF1ZW5jZSIsInNlcXVlbmNlIiwicHJvY2Vzc1NlcXVlbmNlIiwicHJvY2Vzc1NlcXVlbmNlcyIsImdldE5ld0tleSIsImx1bWFMb2FkZXIiLCJsdW1hQnVmZmVyIiwibHVtYUJ1ZmZlckN0eCIsInN2ZyIsImNyZWF0ZUx1bWFTdmdGaWx0ZXIiLCJfc3ZnIiwibG9hZEx1bWEiLCJnZXRMdW1hIiwiY3JlYXRlQ2FudmFzIiwibG9hZEx1bWFDYW52YXMiLCJnZXRMdW1hQ2FudmFzIiwicmVnaXN0ZXJlZEVmZmVjdHMiLCJDVkVmZmVjdHMiLCJyZWdpc3RlckVmZmVjdCIsIkNWTWFza0VsZW1lbnQiLCJoYXNNYXNrcyIsImNhbnZhc0NvbnRleHQiLCJiZWdpblBhdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJiZXppZXJDdXJ2ZVRvIiwic2F2ZSIsImNsaXAiLCJDVkJhc2VFbGVtZW50Iiwib3BlcmF0aW9uc01hcCIsImNyZWF0ZUVsZW1lbnRzIiwiYnVmZmVycyIsImJ1ZmZlckNhbnZhcyIsImJ1ZmZlckNhbnZhczIiLCJfaXNQcm94eSIsInRyYW5zZm9ybUNhbnZhcyIsImJsZW5kTW9kZSIsImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiIsImhpZGVFbGVtZW50Iiwic2hvd0VsZW1lbnQiLCJjbGVhckNhbnZhcyIsImNsZWFyUmVjdCIsInByZXBhcmVMYXllciIsImJ1ZmZlciIsImJ1ZmZlckN0eCIsImRyYXdJbWFnZSIsImdldFRyYW5zZm9ybSIsImV4aXRMYXllciIsImZvcmNlUmVhbFN0YWNrIiwiY3R4VHJhbnNmb3JtIiwiY3R4T3BhY2l0eSIsInJlc3RvcmUiLCJDVlNoYXBlRGF0YSIsInRyYW5zZm9ybXNNYW5hZ2VyIiwic3R5bGVkU2hhcGVzIiwic3R5bGVkU2hhcGUiLCJ0ck5vZGVzIiwiQ1ZTaGFwZUVsZW1lbnQiLCJ0cmFuc2Zvcm1IZWxwZXIiLCJkYXNoUmVzZXR0ZXIiLCJwcmVUcmFuc2Zvcm1zIiwiY28iLCJ3aSIsImRhIiwiYWRkVHJhbnNmb3JtVG9TdHlsZUxpc3QiLCJyZW1vdmVUcmFuc2Zvcm1Gcm9tU3R5bGVMaXN0IiwiY2xvc2VTdHlsZXMiLCJzaG91bGRSZW5kZXIiLCJvd25UcmFuc2Zvcm1zIiwiX3Nob3VsZFJlbmRlciIsInJlbmRlclNoYXBlVHJhbnNmb3JtIiwicGFyZW50VHJhbnNmb3JtIiwiZ3JvdXBUcmFuc2Zvcm0iLCJkcmF3TGF5ZXIiLCJub2RlcyIsImN1cnJlbnRTdHlsZSIsImNvT3AiLCJjdXJyZW50R2xvYmFsQWxwaGEiLCJjdHhTdHJva2VTdHlsZSIsImdyZCIsImN0eExpbmVXaWR0aCIsImN0eExpbmVDYXAiLCJjdHhMaW5lSm9pbiIsImN0eE1pdGVyTGltaXQiLCJjdHhGaWxsU3R5bGUiLCJzZXRMaW5lRGFzaCIsImxpbmVEYXNoT2Zmc2V0IiwiY2xvc2VQYXRoIiwiY3R4U3Ryb2tlIiwiY3R4RmlsbCIsImlzTWFpbiIsInJlbmRlckdyYWRpZW50RmlsbCIsInJlbmRlclN0eWxlZFNoYXBlIiwic2hhcGVOb2RlcyIsImdyb3VwVHJhbnNmb3JtTWF0IiwiY3JlYXRlTGluZWFyR3JhZGllbnQiLCJjcmVhdGVSYWRpYWxHcmFkaWVudCIsImFkZENvbG9yU3RvcCIsIkNWVGV4dEVsZW1lbnQiLCJzdHJva2UiLCJmaWxsIiwiY3VycmVudFJlbmRlciIsInNXaWR0aCIsImZWYWx1ZSIsImhhc0ZpbGwiLCJoYXNTdHJva2UiLCJjb21tYW5kcyIsInBhdGhBcnIiLCJjb21tYW5kc0NvdW50ZXIiLCJsYXN0RmlsbCIsImxhc3RTdHJva2UiLCJsYXN0U3Ryb2tlVyIsIkNWSW1hZ2VFbGVtZW50IiwiaW1nVyIsImltZ0giLCJpbWdSZWwiLCJjYW52YXNSZWwiLCJ3aWR0aENyb3AiLCJoZWlnaHRDcm9wIiwicGFyIiwiQ1ZTb2xpZEVsZW1lbnQiLCJjdHhGaWxsUmVjdCIsIkNhbnZhc1JlbmRlcmVyQmFzZSIsImdsb2JhbEFscGhhIiwic3Ryb2tlU3R5bGUiLCJsaW5lQ2FwIiwicnVsZSIsImNvbnRleHREYXRhIiwiYWN0aW9uRmxhZyIsImNvbnRhaW5lclN0eWxlIiwibW96VHJhbnNmb3JtT3JpZ2luIiwiY29udGV4dCIsInNldENvbnRleHQiLCJpc0Rhc2hlZCIsImVsZW1lbnRXaWR0aCIsImVsZW1lbnRIZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJkcHIiLCJlbGVtZW50UmVsIiwiYW5pbWF0aW9uUmVsIiwiZmlsbFR5cGUiLCJDYW52YXNDb250ZXh0IiwiQ1ZDb250ZXh0RGF0YSIsInN0YWNrIiwiY0FyclBvcyIsImNUciIsIm5hdGl2ZUNvbnRleHQiLCJ0cmFuc2Zvcm1NYXQiLCJjdXJyZW50T3BhY2l0eSIsImN1cnJlbnRGaWxsU3R5bGUiLCJhcHBsaWVkRmlsbFN0eWxlIiwiY3VycmVudFN0cm9rZVN0eWxlIiwiYXBwbGllZFN0cm9rZVN0eWxlIiwiY3VycmVudExpbmVXaWR0aCIsImFwcGxpZWRMaW5lV2lkdGgiLCJjdXJyZW50TGluZUNhcCIsImFwcGxpZWRMaW5lQ2FwIiwiY3VycmVudExpbmVKb2luIiwiYXBwbGllZExpbmVKb2luIiwiYXBwbGllZE1pdGVyTGltaXQiLCJjdXJyZW50TWl0ZXJMaW1pdCIsImR1cGxpY2F0ZSIsIm5ld0xlbmd0aCIsImZvcmNlUmVzdG9yZSIsImN1cnJlbnRDb250ZXh0IiwicHJldlN0YWNrIiwic2F2ZU9uTmF0aXZlRmxhZyIsImN1cnJlbnRTdGFjayIsIm5ld1N0YWNrIiwic2V0T3BhY2l0eSIsInRyUHJvcHMiLCJDVkNvbXBFbGVtZW50IiwiQ2FudmFzUmVuZGVyZXIiLCJkZXZpY2VQaXhlbFJhdGlvIiwiSEJhc2VFbGVtZW50IiwiY2hlY2tCbGVuZE1vZGUiLCJ0ZyIsInRyYW5zZm9ybWVkRWxlbWVudFN0eWxlIiwibWF0cml4VmFsdWUiLCJ3ZWJraXRUcmFuc2Zvcm0iLCJhZGRFZmZlY3RzIiwiSFNvbGlkRWxlbWVudCIsImJhY2tncm91bmRDb2xvciIsIkhTaGFwZUVsZW1lbnQiLCJzaGFwZXNDb250YWluZXIiLCJjdXJyZW50QkJveCIsIl9yZW5kZXJTaGFwZUZyYW1lIiwic2hhcGVDb250IiwiZ2V0VHJhbnNmb3JtZWRQb2ludCIsImNhbGN1bGF0ZVNoYXBlQm91bmRpbmdCb3giLCJpdGVtIiwidlBvaW50Iiwib1BvaW50IiwibmV4dElQb2ludCIsIm5leHRWUG9pbnQiLCJjaGVja0JvdW5kcyIsImdldEJvdW5kc09mQ3VydmUiLCJzaGFwZUJvdW5kaW5nQm94IiwieE1heCIsInlNYXgiLCJ0ZW1wQm91bmRpbmdCb3giLCJiMmFjIiwiY2FsY3VsYXRlRiIsImNhbGN1bGF0ZUJvdW5kaW5nQm94IiwiZXhwYW5kU3Ryb2tlQm91bmRpbmdCb3giLCJ3aWR0aFByb3BlcnR5Iiwia2Z3IiwiY3VycmVudEJveENvbnRhaW5zIiwiY2hhbmdlZCIsInNoYXBlU3R5bGUiLCJzaGFwZVRyYW5zZm9ybSIsIkhUZXh0RWxlbWVudCIsInRleHRQYXRocyIsImlzTWFza2VkIiwiY29tcFciLCJjb21wSCIsImlubmVyRWxlbVN0eWxlIiwidGV4dENvbG9yIiwic3Ryb2tlV2lkdGgiLCJsaW5lSGVpZ2h0IiwidFBhcmVudCIsInRDb250IiwiY2hpbGRyZW4iLCJ0Q29udFN0eWxlIiwidENvbnRUcmFuc2xhdGlvbiIsInRTdHlsZSIsInRTcGFuVHJhbnNsYXRpb24iLCJzdmdTdHlsZSIsInRyYW5zbGF0aW9uIiwidGV4dFBhdGgiLCJtYXJnaW4iLCJzdmdUcmFuc2Zvcm0iLCJIQ2FtZXJhRWxlbWVudCIsInBlIiwiX3ByZXZNYXQiLCJzZXR1cCIsInRocmVlREVsZW1lbnRzIiwicGVyc3BlY3RpdmVTdHlsZSIsInBlcnNwZWN0aXZlRWxlbSIsInBlcnNwZWN0aXZlIiwid2Via2l0UGVyc3BlY3RpdmUiLCJtVHJhbnNmIiwiZGlmZlZlY3RvciIsIm1hZyIsImxvb2tEaXIiLCJsb29rTGVuZ3RoT25YWiIsIm1Sb3RhdGlvblgiLCJtUm90YXRpb25ZIiwiaGFzTWF0cml4Q2hhbmdlZCIsIm1hdFZhbHVlIiwiSEltYWdlRWxlbWVudCIsIkltYWdlIiwiaW1hZ2VFbGVtIiwiSHlicmlkUmVuZGVyZXJCYXNlIiwiY2FtZXJhIiwibmV3RE9NRWxlbWVudCIsImRkZCIsImFkZFRvM2RDb250YWluZXIiLCJuZXh0RE9NRWxlbWVudCIsIm5leHRMYXllciIsInRtcERPTUVsZW1lbnQiLCJnZXRUaHJlZURDb250YWluZXJCeVBvcyIsInN0YXJ0UG9zIiwiZW5kUG9zIiwiY3JlYXRlVGhyZWVEQ29udGFpbmVyIiwidGhyZWVEQ29udGFpbmVyRGF0YSIsImJ1aWxkM2RDb250YWluZXJzIiwibGFzdFRocmVlRENvbnRhaW5lckRhdGEiLCJjdXJyZW50Q29udGFpbmVyIiwicmVzaXplckVsZW0iLCJvdmVyZmxvdyIsImNXaWR0aCIsImNIZWlnaHQiLCJmbG9hdGluZ0NvbnRhaW5lciIsIkhDb21wRWxlbWVudCIsIl9jcmVhdGVCYXNlQ29udGFpbmVyRWxlbWVudHMiLCJIeWJyaWRSZW5kZXJlciIsIl90aGlzTGF5ZXJGdW5jdGlvbiIsImRlZmluZVByb3BlcnR5IiwicGl4ZWxBc3BlY3QiLCJmcmFtZUR1cmF0aW9uIiwiZGlzcGxheVN0YXJ0VGltZSIsIm51bUxheWVycyIsIl90eXBlb2YkMiIsInNlZWRSYW5kb20iLCJjaHVua3MiLCJkaWdpdHMiLCJybmduYW1lIiwic3RhcnRkZW5vbSIsInNpZ25pZmljYW5jZSIsIm5vZGVjcnlwdG8iLCJzZWVkcmFuZG9tIiwic2VlZCIsIm9wdGlvbnMiLCJlbnRyb3B5Iiwic2hvcnRzZWVkIiwibWl4a2V5IiwiZmxhdHRlbiIsInRvc3RyaW5nIiwiYXV0b3NlZWQiLCJhcmM0IiwiQVJDNCIsInBybmciLCJpbnQzMiIsInF1aWNrIiwiUyIsInBhc3MiLCJpc19tYXRoX2NhbGwiLCJzdGF0ZSIsImNvcHkiLCJrZXlsZW4iLCJtZSIsInJlc3VsdCIsInR5cCIsInN0cmluZ3NlZWQiLCJzbWVhciIsInJhbmRvbUJ5dGVzIiwiVWludDhBcnJheSIsImNyeXB0byIsIm1zQ3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwiYnJvd3NlciIsInBsdWdpbnMiLCJzY3JlZW4iLCJpbml0aWFsaXplJDIiLCJwcm9wVHlwZXMiLCJTSEFQRSIsIl90eXBlb2YkMSIsIkV4cHJlc3Npb25NYW5hZ2VyIiwiZmV0Y2giLCJmcmFtZXMiLCJfbG90dGllR2xvYmFsIiwiJGJtX2lzSW5zdGFuY2VPZkFycmF5IiwiaXNOdW1lcmFibGUiLCJ0T2ZWIiwiJGJtX25lZyIsInRPZkEiLCJsZW5BIiwicmV0QXJyIiwiZWFzZUluQmV6IiwiZWFzZU91dEJleiIsImVhc2VJbk91dEJleiIsInRPZkIiLCJsZW5CIiwic3ViIiwibXVsIiwibW9kIiwiJGJtX3N1bSIsIiRibV9zdWIiLCIkYm1fbXVsIiwiJGJtX2RpdiIsIiRibV9tb2QiLCJjbGFtcCIsIm1tIiwicmFkaWFuc1RvRGVncmVlcyIsInJhZGlhbnNfdG9fZGVncmVlcyIsImRlZ3JlZXNUb1JhZGlhbnMiLCJkZWdyZWVzX3RvX3JhZGlhbnMiLCJoZWxwZXJMZW5ndGhBcnJheSIsImFycjEiLCJhcnIyIiwibm9ybWFsaXplIiwidmVjIiwicmdiVG9Ic2wiLCJodWUycmdiIiwiaHNsVG9SZ2IiLCJsaW5lYXIiLCJ0TWluIiwidE1heCIsInZhbHVlMSIsInZhbHVlMiIsIl90TWluIiwicm5kIiwicm5kbSIsImNyZWF0ZVBhdGgiLCJpblRhbmdlbnRzIiwib3V0VGFuZ2VudHMiLCJhcnJQbGFjZWhvbGRlciIsImluVmVydGV4UG9pbnQiLCJvdXRWZXJ0ZXhQb2ludCIsImluaXRpYXRlRXhwcmVzc2lvbiIsInByb3BlcnR5Iiwibm9PcCIsIl92YWx1ZSIsIm5lZWRzVmVsb2NpdHkiLCJfbmVlZHNSYW5kb20iLCJlbGVtVHlwZSIsIiRibV90cmFuc2Zvcm0iLCJ0aGlzUHJvcGVydHkiLCJ2YWx1ZUF0VGltZSIsImluUG9pbnQiLCJvdXRQb2ludCIsImxvb3BJbiIsImxvb3BfaW4iLCJsb29wT3V0IiwibG9vcF9vdXQiLCJzbW9vdGgiLCJ0b1dvcmxkIiwiZnJvbVdvcmxkIiwiZnJvbUNvbXAiLCJ0b0NvbXAiLCJmcm9tQ29tcFRvU3VyZmFjZSIsInJvdGF0aW9uIiwiYW5jaG9yUG9pbnQiLCJ0aGlzTGF5ZXIiLCJ0aGlzQ29tcCIsInZlbG9jaXR5QXRUaW1lIiwic2NvcGVkX2JtX3J0IiwiZXhwcmVzc2lvbl9mdW5jdGlvbiIsImV2YWwiLCJudW1LZXlzIiwiYWN0aXZlIiwid2lnZ2xlIiwiZnJlcSIsImFtcCIsImlXaWdnbGUiLCJsZW5XaWdnbGUiLCJhZGRlZEFtcHMiLCJwZXJpb2RzIiwibG9vcEluRHVyYXRpb24iLCJsb29wT3V0RHVyYXRpb24iLCJnZXRWZWxvY2l0eUF0VGltZSIsImxvb2tBdCIsImVsZW0xIiwiZWxlbTIiLCJmVmVjIiwicGl0Y2giLCJ5YXciLCJlYXNlT3V0IiwidmFsMSIsInZhbDIiLCJhcHBseUVhc2UiLCJlYXNlSW4iLCJlYXNlIiwiaUtleSIsImxlbktleSIsIm5lYXJlc3RLZXkiLCJvYktleSIsImZyYW1lc1RvVGltZSIsImZwcyIsInRpbWVUb0ZyYW1lcyIsInJhbmRTZWVkIiwic3Vic3RyaW5nIiwicG9zdGVyaXplVGltZSIsImZyYW1lc1BlclNlY29uZCIsInZlbG9jaXR5IiwidGV4dEluZGV4IiwidGV4dFRvdGFsIiwic2VsZWN0b3JWYWx1ZSIsImhhc1BhcmVudCIsImV4ZWN1dGVFeHByZXNzaW9uIiwiZnJhbWVFeHByZXNzaW9uSWQiLCJfX3ByZXZlbnREZWFkQ29kZVJlbW92YWwiLCJFeHByZXNzaW9ucyIsInN0YWNrQ291bnQiLCJyZWdpc3RlcnMiLCJwdXNoRXhwcmVzc2lvbiIsInBvcEV4cHJlc3Npb24iLCJyZWxlYXNlSW5zdGFuY2VzIiwicmVnaXN0ZXJFeHByZXNzaW9uUHJvcGVydHkiLCJleHByZXNzaW9uIiwiTWFza01hbmFnZXJJbnRlcmZhY2UiLCJNYXNrSW50ZXJmYWNlIiwiX21hc2siLCJfZGF0YSIsIk1hc2tNYW5hZ2VyIiwiX21hc2tzSW50ZXJmYWNlcyIsIm1hc2tGdW5jdGlvbiIsIkV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSIsImRlZmF1bHRVbmlkaW1lbnNpb25hbFZhbHVlIiwiZGVmYXVsdE11bHRpZGltZW5zaW9uYWxWYWx1ZSIsImNvbXBsZXRlUHJvcGVydHkiLCJleHByZXNzaW9uVmFsdWUiLCJ2YWx1ZVByb3AiLCJzcGVlZEF0VGltZSIsImdldFNwZWVkQXRUaW1lIiwicHJvcGVydHlHcm91cCIsIlVuaWRpbWVuc2lvbmFsUHJvcGVydHlJbnRlcmZhY2UiLCJNdWx0aWRpbWVuc2lvbmFsUHJvcGVydHlJbnRlcmZhY2UiLCJhcnJWYWx1ZSIsImRlZmF1bHRHZXR0ZXIiLCJUcmFuc2Zvcm1FeHByZXNzaW9uSW50ZXJmYWNlIiwiX3RoaXNGdW5jdGlvbiIsInhSb3RhdGlvbiIsInlSb3RhdGlvbiIsInhQb3NpdGlvbiIsInlQb3NpdGlvbiIsInpQb3NpdGlvbiIsIl9weCIsIl9weSIsIl9weiIsIl90cmFuc2Zvcm1GYWN0b3J5IiwiZ2V0TWF0cml4IiwidG9Xb3JsZE1hdCIsInByb3BNYXRyaXgiLCJ0b1dvcmxkVmVjIiwiYXBwbHlQb2ludCIsImZyb21Xb3JsZFZlYyIsImludmVydFBvaW50Iiwic2FtcGxlSW1hZ2UiLCJ0cmFuc2Zvcm1JbnRlcmZhY2UiLCJfcmVnaXN0ZXJNYXNrSW50ZXJmYWNlIiwiX3JlZ2lzdGVyRWZmZWN0c0ludGVyZmFjZSIsImFuY2hvclBvaW50RGVzY3JpcHRvciIsImRlZmluZVByb3BlcnRpZXMiLCJhbmNob3JfcG9pbnQiLCJzdGFydFRpbWUiLCJfbmFtZSIsInByb3BlcnR5R3JvdXBGYWN0b3J5IiwiaW50ZXJmYWNlRnVuY3Rpb24iLCJwYXJlbnRQcm9wZXJ0eUdyb3VwIiwiUHJvcGVydHlJbnRlcmZhY2UiLCJwcm9wZXJ0eU5hbWUiLCJfcHJvcGVydHlHcm91cCIsImVmZmVjdHNEYXRhIiwiY3JlYXRlR3JvdXBJbnRlcmZhY2UiLCJncm91cEludGVyZmFjZSIsIm1uIiwiY3JlYXRlVmFsdWVJbnRlcmZhY2UiLCJudW1Qcm9wZXJ0aWVzIiwibnAiLCJlbmFibGVkIiwiZW4iLCJleHByZXNzaW9uUHJvcGVydHkiLCJzZXRHcm91cFByb3BlcnR5IiwiU2hhcGVQYXRoSW50ZXJmYWNlIiwicGF0aEludGVyZmFjZUZhY3RvcnkiLCJ2aWV3IiwicHJvcGVydHlJbmRleCIsIml0ZXJhdGVFbGVtZW50cyIsImdyb3VwSW50ZXJmYWNlRmFjdG9yeSIsImZpbGxJbnRlcmZhY2VGYWN0b3J5Iiwic3Ryb2tlSW50ZXJmYWNlRmFjdG9yeSIsInRyaW1JbnRlcmZhY2VGYWN0b3J5IiwiZWxsaXBzZUludGVyZmFjZUZhY3RvcnkiLCJzdGFySW50ZXJmYWNlRmFjdG9yeSIsInJlY3RJbnRlcmZhY2VGYWN0b3J5Iiwicm91bmRlZEludGVyZmFjZUZhY3RvcnkiLCJyZXBlYXRlckludGVyZmFjZUZhY3RvcnkiLCJncmFkaWVudEZpbGxJbnRlcmZhY2VGYWN0b3J5IiwiZGVmYXVsdEludGVyZmFjZUZhY3RvcnkiLCJjb250ZW50c0ludGVyZmFjZUZhY3RvcnkiLCJpbnRlcmZhY2VzIiwiX2ludGVyZmFjZUZ1bmN0aW9uIiwidHJhbnNmb3JtSW50ZXJmYWNlRmFjdG9yeSIsImNpeCIsInN0YXJ0UG9pbnQiLCJlbmRQb2ludCIsIl9kYXNoUHJvcGVydHlHcm91cCIsImRhc2hPYiIsImFkZFByb3BlcnR5VG9EYXNoT2IiLCJkYXNoIiwic3RhcnQiLCJza2V3QXhpcyIsIm91dGVyUmFkaXVzIiwib3V0ZXJSb3VuZG5lc3MiLCJpbm5lclJhZGl1cyIsImlubmVyUm91bmRuZXNzIiwicGFyZW50R3JvdXBXcmFwcGVyIiwiX3NvdXJjZVRleHQiLCJzb3VyY2VUZXh0Iiwic3RyaW5nVmFsdWUiLCJmaWxsQ29sb3IiLCJvdXRsaW5lSW50ZXJmYWNlRmFjdG9yeSIsImN1cnJlbnRQcm9wZXJ0eU5hbWUiLCJjdXJyZW50UHJvcGVydHkiLCJwcm9wZXJ0eU5hbWVJbmRleCIsImRhdGFJbnRlcmZhY2VGYWN0b3J5Iiwib3V0bGluZUludGVyZmFjZSIsImRhdGFJbnRlcmZhY2UiLCJmb290YWdlIiwiZ2V0SW50ZXJmYWNlIiwiZXhwcmVzc2lvbkhlbHBlcnMiLCJzZWFyY2hFeHByZXNzaW9ucyIsIl9jYWNoaW5nQXRUaW1lIiwic3BlZWQiLCJnZXRTdGF0aWNWYWx1ZUF0VGltZSIsImFkZFByb3BlcnR5RGVjb3JhdG9yIiwiZHVyYXRpb25GbGFnIiwibGFzdEtleUZyYW1lIiwiY3ljbGVEdXJhdGlvbiIsImZpcnN0S2V5RnJhbWUiLCJyZXQiLCJpbml0ViIsImVuZFYiLCJjdXJyZW50IiwicmVwZWF0cyIsImxhc3RWYWx1ZSIsIm5leHRMYXN0VmFsdWUiLCJmaXJzdFZhbHVlIiwibmV4dEZpcnN0VmFsdWUiLCJzYW1wbGVzIiwiZW5kRnJhbWUiLCJzYW1wbGVGcmVxdWVuY3kiLCJzYW1wbGVWYWx1ZSIsImdldFRyYW5zZm9ybVZhbHVlQXRUaW1lIiwiX3RyYW5zZm9ybUNhY2hpbmdBdFRpbWUiLCJhbmNob3IiLCJyb3RhdGlvbloiLCJyb3RhdGlvblkiLCJyb3RhdGlvblgiLCJvcmllbnRhdGlvbiIsInBvc2l0aW9uWCIsInBvc2l0aW9uWSIsInBvc2l0aW9uWiIsImdldFRyYW5zZm9ybVN0YXRpY1ZhbHVlQXRUaW1lIiwicHJvcGVydHlHZXRQcm9wIiwiZ2V0U2hhcGVWYWx1ZUF0VGltZSIsInNoYXBlVmFsdWUiLCJsYXN0VGltZSIsIlNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uIiwiS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eUNvbnN0cnVjdG9yRnVuY3Rpb24iLCJTaGFwZUV4cHJlc3Npb25zIiwiaXNDbG9zZWQiLCJwb2ludE9uUGF0aCIsIl9zZWdtZW50c0xlbmd0aCIsImFjY3VtdWxhdGVkTGVuZ3RoIiwiaW5pdEluZGV4IiwiZW5kSW5kZXgiLCJ2ZWN0b3JPblBhdGgiLCJ2ZWN0b3JUeXBlIiwieExlbmd0aCIsInlMZW5ndGgiLCJtYWduaXR1ZGUiLCJ1bml0VmVjdG9yIiwidGFuZ2VudE9uUGF0aCIsIm5vcm1hbE9uUGF0aCIsInByb3BlcnR5R2V0U2hhcGVQcm9wIiwidHJpbXMiLCJpbml0aWFsaXplJDEiLCJhZGREZWNvcmF0b3IiLCJjYWxjdWxhdGVFeHByZXNzaW9uIiwiZ2V0RXhwcmVzc2lvblZhbHVlIiwiaXNLZXlmcmFtZWQiLCJoYXNFeHByZXNzaW9ucyIsImluaXRpYWxpemUiLCJTVkdDb21wb3NhYmxlRWZmZWN0IiwiY3JlYXRlTWVyZ2VOb2RlIiwicmVzdWx0SWQiLCJpbnMiLCJmZU1lcmdlIiwiZmVNZXJnZU5vZGUiLCJsaW5lYXJGaWx0ZXJWYWx1ZSIsIlNWR1RpbnRGaWx0ZXIiLCJsaW5lYXJGaWx0ZXIiLCJtYXRyaXhGaWx0ZXIiLCJjb2xvckJsYWNrIiwiY29sb3JXaGl0ZSIsIlNWR0ZpbGxGaWx0ZXIiLCJTVkdTdHJva2VFZmZlY3QiLCJpbml0aWFsaXplZCIsImVsZW1DaGlsZHJlbiIsImNoaWxkTm9kZXMiLCJncm91cFBhdGgiLCJyZW1vdmVBdHRyaWJ1dGUiLCJwYXRoTWFza2VyIiwiZGFzaGFycmF5VmFsdWUiLCJnZXRUb3RhbExlbmd0aCIsImxpbmVMZW5ndGgiLCJ1bml0cyIsIlNWR1RyaXRvbmVGaWx0ZXIiLCJmZUNvbXBvbmVudFRyYW5zZmVyIiwiZmVGdW5jUiIsImZlRnVuY0ciLCJmZUZ1bmNCIiwiY29sb3IxIiwiY29sb3IyIiwiY29sb3IzIiwidGFibGVSIiwidGFibGVHIiwidGFibGVCIiwiU1ZHUHJvTGV2ZWxzRmlsdGVyIiwiY3JlYXRlRmVGdW5jIiwiZmVGdW5jQSIsImZlRnVuY1JDb21wb3NlZCIsImZlRnVuY0dDb21wb3NlZCIsImZlRnVuY0JDb21wb3NlZCIsImdldFRhYmxlVmFsdWUiLCJpbnB1dEJsYWNrIiwiaW5wdXRXaGl0ZSIsImdhbW1hIiwib3V0cHV0QmxhY2siLCJvdXRwdXRXaGl0ZSIsInRhYmxlIiwiY29sb3JWYWx1ZSIsIm91dHB1dERlbHRhIiwiaW5wdXREZWx0YSIsIlNWR0Ryb3BTaGFkb3dFZmZlY3QiLCJnbG9iYWxGaWx0ZXJTaXplIiwiZmVHYXVzc2lhbkJsdXIiLCJmZU9mZnNldCIsImZlRmxvb2QiLCJmZUNvbXBvc2l0ZSIsImNvbCIsIl9zdmdNYXR0ZVN5bWJvbHMiLCJTVkdNYXR0ZTNFZmZlY3QiLCJmaWx0ZXJFbGVtIiwiZmluZFN5bWJvbCIsInJlcGxhY2VJblBhcmVudCIsInN5bWJvbElkIiwibmV4dENoaWxkIiwidXNlRWxlbSIsInNldEVsZW1lbnRBc01hc2siLCJzeW1ib2wiLCJTVkdHYXVzc2lhbkJsdXJFZmZlY3QiLCJrQmx1cnJpbmVzc1RvU2lnbWEiLCJzaWdtYSIsImRpbWVuc2lvbnMiLCJzaWdtYVgiLCJzaWdtYVkiLCJlZGdlTW9kZSIsIlRyYW5zZm9ybUVmZmVjdCIsImZvcmNlRnJhbWUiLCJpc1VuaWZvcm1TY2FsZSIsInNjYWxlSGVpZ2h0Iiwic2NhbGVXaWR0aCIsIlNWR1RyYW5zZm9ybUVmZmVjdCIsIkNWVHJhbnNmb3JtRWZmZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/lottie-web/build/player/lottie.js\n");

/***/ })

};
;