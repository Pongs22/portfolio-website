"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./node_modules/split-type/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/split-type/dist/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ SplitType; }\n/* harmony export */ });\n/**\n * SplitType\n * https://github.com/lukePeavey/SplitType\n * @version 0.3.4\n * @author Luke Peavey <lwpeavey@gmail.com>\n */ // Polyfill the following DOM methods that are not supported in IE 11.\n(function() {\n    function append() {\n        var length = arguments.length;\n        for(var i = 0; i < length; i++){\n            var node = i < 0 || arguments.length <= i ? undefined : arguments[i];\n            if (node.nodeType === 1 || node.nodeType === 11) this.appendChild(node);\n            else this.appendChild(document.createTextNode(String(node)));\n        }\n    }\n    function replaceChildren() {\n        while(this.lastChild){\n            this.removeChild(this.lastChild);\n        }\n        if (arguments.length) this.append.apply(this, arguments);\n    }\n    function replaceWith() {\n        var parent = this.parentNode;\n        for(var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++){\n            nodes[_key] = arguments[_key];\n        }\n        var i = nodes.length;\n        if (!parent) return;\n        if (!i) parent.removeChild(this);\n        while(i--){\n            var node = nodes[i];\n            if (typeof node !== \"object\") {\n                node = this.ownerDocument.createTextNode(node);\n            } else if (node.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n            if (!i) {\n                parent.replaceChild(node, this);\n            } else {\n                parent.insertBefore(this.previousSibling, node);\n            }\n        }\n    }\n    if (typeof Element !== \"undefined\") {\n        if (!Element.prototype.append) {\n            Element.prototype.append = append;\n            DocumentFragment.prototype.append = append;\n        }\n        if (!Element.prototype.replaceChildren) {\n            Element.prototype.replaceChildren = replaceChildren;\n            DocumentFragment.prototype.replaceChildren = replaceChildren;\n        }\n        if (!Element.prototype.replaceWith) {\n            Element.prototype.replaceWith = replaceWith;\n            DocumentFragment.prototype.replaceWith = replaceWith;\n        }\n    }\n})();\nfunction _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        });\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _iterableToArrayLimit(arr, i) {\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n/**\n * Shallow merges the properties of an object with the target object. Only\n * includes properties that exist on the target object. Non-writable properties\n * on the target object will not be over-written.\n *\n * @param {Object} target\n * @param {Object} object\n */ function extend(target, object) {\n    return Object.getOwnPropertyNames(Object(target)).reduce(function(extended, key) {\n        var currentValue = Object.getOwnPropertyDescriptor(Object(target), key);\n        var newValue = Object.getOwnPropertyDescriptor(Object(object), key);\n        return Object.defineProperty(extended, key, newValue || currentValue);\n    }, {});\n}\n/**\n * Checks if given value is a string\n *\n * @param {any} value\n * @return {boolean} `true` if `value` is a string, else `false`\n */ function isString(value) {\n    return typeof value === \"string\";\n}\nfunction isArray(value) {\n    return Array.isArray(value);\n}\n/**\n * Parses user supplied settings objects.\n */ function parseSettings() {\n    var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var object = extend(settings); // `split` may be used as an alias for the `types` option\n    // Parse the `types` settings into an array of valid split types.\n    // If `types` is explicitly set to an empty string or array, text will not be\n    // split at all.\n    var types;\n    if (object.types !== undefined) {\n        types = object.types;\n    } else if (object.split !== undefined) {\n        types = object.split;\n    }\n    if (types !== undefined) {\n        object.types = (isString(types) || isArray(types) ? String(types) : \"\").split(\",\").map(function(type) {\n            return String(type).trim();\n        }).filter(function(type) {\n            return /((line)|(word)|(char))/i.test(type);\n        });\n    } // Support `position: absolute` as an alias for `absolute: true`\n    if (object.absolute || object.position) {\n        object.absolute = object.absolute || /absolute/.test(settings.position);\n    }\n    return object;\n}\n/**\n * Takes a list of `types` and returns an object\n *\n * @param {string | string[]} value a comma separated list of split types\n * @return {{lines: boolean, words: boolean, chars: boolean}}\n */ function parseTypes(value) {\n    var types = isString(value) || isArray(value) ? String(value) : \"\";\n    return {\n        none: !types,\n        lines: /line/i.test(types),\n        words: /word/i.test(types),\n        chars: /char/i.test(types)\n    };\n}\n/**\n * Returns true if `value` is a non-null object.\n * @param {any} value\n * @return {boolean}\n */ function isObject(value) {\n    return value !== null && typeof value === \"object\";\n}\n/**\n * Returns true if `input` is one of the following:\n * - `Element`\n * - `Text`\n * - `DocumentFragment`\n */ function isNode(input) {\n    return isObject(input) && /^(1|3|11)$/.test(input.nodeType);\n}\n/**\n * Checks if `value` is a valid array-like length.\n * Original source: Lodash\n *\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3)\n * // => true\n *\n * _.isLength(Number.MIN_VALUE)\n * // => false\n *\n * _.isLength(Infinity)\n * // => false\n *\n * _.isLength('3')\n * // => false\n */ function isLength(value) {\n    return typeof value === \"number\" && value > -1 && value % 1 === 0;\n}\n/**\n * Checks if `value` is an array-like object\n * @param {any} value\n * @return {boolean} true if `value` is array-like`, else `false`\n * @example\n * isArrayLike(new Array())\n * // => true\n *\n * isArrayLike(document.querySelectorAll('div'))\n * // => true\n *\n * isArrayLike(document.getElementsByTagName('div'))\n * // => true\n *\n * isArrayLike(() => {})\n * // => false\n *\n * isArrayLike({foo: 'bar'})\n * // => false\n *\n * * isArrayLike(null)\n * // => false\n */ function isArrayLike(value) {\n    return isObject(value) && isLength(value.length);\n}\n/**\n * Coerces `value` to an `Array`.\n *\n * @param {any} value\n * @return {any[]}\n * @example\n * // If `value` is any `Array`, returns original `Array`\n * let arr = [1, 2]\n * toArray(arr)\n * // => arr\n *\n * // If `value` is an `ArrayLike`, its equivalent to `Array.from(value)`\n * let nodeList = document.querySelectorAll('div')\n * toArray(nodeList)\n * // => HTMLElement[] s\n *\n * // If value is falsy, returns empty array\n * toArray(null)\n * // => []\n *\n * // For any other type of value, its equivalent to `Array.of(value)`\n * let element = document.createElement('div')\n * toArray(element)\n * // => [element]\n *\n */ function toArray(value) {\n    if (isArray(value)) return value;\n    if (value == null) return [];\n    return isArrayLike(value) ? Array.prototype.slice.call(value) : [\n        value\n    ];\n}\n/**\n * Processes target elements for the splitType function.\n *\n * @param {any} target Can be one of the following:\n * 1. `string` - A css selector\n * 2. `HTMLElement` - A single element\n * 3. `NodeList` - A nodeList\n * 4. `Element[]` - An array of elements\n * 5. `Array<NodeList|Element[]>` - An nested array of elements\n * @returns {Element[]} A flat array HTML elements\n * @return A flat array of elements or empty array if no elements are found\n */ function getTargetElements(target) {\n    var elements = target; // If `target` is a selector string...\n    if (isString(target)) {\n        if (/^(#[a-z]\\w+)$/.test(target.trim())) {\n            // If `target` is an ID, use `getElementById`\n            elements = document.getElementById(target.trim().slice(1));\n        } else {\n            // Else use `querySelectorAll`\n            elements = document.querySelectorAll(target);\n        }\n    } // Return a flattened array of elements\n    return toArray(elements).reduce(function(result, element) {\n        return [].concat(_toConsumableArray(result), _toConsumableArray(toArray(element).filter(isNode)));\n    }, []);\n}\nvar entries = Object.entries;\nvar expando = \"_splittype\";\nvar cache = {};\nvar uid = 0;\n/**\n * Stores data associated with DOM elements or other objects. This is a\n * simplified version of jQuery's data method.\n *\n * @signature Data(owner)\n * @description Get the data store object for the given owner.\n * @param {Object} owner the object that data will be associated with.\n * @return {Object} the data object for given `owner`. If no data exists\n *     for the given object, creates a new data store and returns it.\n *\n * @signature Data(owner, key)\n * @description Get the value\n * @param {Object} owner\n * @param {string} key\n * @return {any} the value of the provided key. If key does not exist, returns\n *     undefined.\n *\n * @signature Data(owner, key, value)\n * @description Sets the given key/value pair in data store\n * @param {Object} owner\n * @param {string} key\n * @param {any} value\n */ function set(owner, key, value) {\n    if (!isObject(owner)) {\n        console.warn(\"[data.set] owner is not an object\");\n        return null;\n    }\n    var id = owner[expando] || (owner[expando] = ++uid);\n    var data = cache[id] || (cache[id] = {});\n    if (value === undefined) {\n        if (!!key && Object.getPrototypeOf(key) === Object.prototype) {\n            cache[id] = _objectSpread2(_objectSpread2({}, data), key);\n        }\n    } else if (key !== undefined) {\n        data[key] = value;\n    }\n    return value;\n}\nfunction get(owner, key) {\n    var id = isObject(owner) ? owner[expando] : null;\n    var data = id && cache[id] || {};\n    if (key === undefined) {\n        return data;\n    }\n    return data[key];\n}\n/**\n * Remove all data associated with the given element\n */ function remove(element) {\n    var id = element && element[expando];\n    if (id) {\n        delete element[id];\n        delete cache[id];\n    }\n}\n/**\n * Clear all cached data\n */ function clear() {\n    Object.keys(cache).forEach(function(key) {\n        delete cache[key];\n    });\n}\n/**\n * Remove all temporary data from the store.\n */ function cleanup() {\n    entries(cache).forEach(function(_ref) {\n        var _ref2 = _slicedToArray(_ref, 2), id = _ref2[0], _ref2$ = _ref2[1], isRoot = _ref2$.isRoot, isSplit = _ref2$.isSplit;\n        if (!isRoot || !isSplit) {\n            cache[id] = null;\n            delete cache[id];\n        }\n    });\n}\n/**\n * Splits a string into an array of words.\n *\n * @param {string} string\n * @param {string | RegExp} [separator = ' ']\n * @return {string[]} Array of words\n */ function toWords(value) {\n    var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \" \";\n    var string = value ? String(value) : \"\";\n    return string.trim().replace(/\\s+/g, \" \").split(separator);\n}\n/**\n * Based on lodash#split <https://lodash.com/license>\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters &\n * Editors\n */ var rsAstralRange = \"\\ud800-\\udfff\";\nvar rsComboMarksRange = \"\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23\";\nvar rsComboSymbolsRange = \"\\\\u20d0-\\\\u20f0\";\nvar rsVarRange = \"\\\\ufe0e\\\\ufe0f\";\n/** Used to compose unicode capture groups. */ var rsAstral = \"[\".concat(rsAstralRange, \"]\");\nvar rsCombo = \"[\".concat(rsComboMarksRange).concat(rsComboSymbolsRange, \"]\");\nvar rsFitz = \"\\ud83c[\\udffb-\\udfff]\";\nvar rsModifier = \"(?:\".concat(rsCombo, \"|\").concat(rsFitz, \")\");\nvar rsNonAstral = \"[^\".concat(rsAstralRange, \"]\");\nvar rsRegional = \"(?:\\ud83c[\\udde6-\\uddff]){2}\";\nvar rsSurrPair = \"[\\ud800-\\udbff][\\udc00-\\udfff]\";\nvar rsZWJ = \"\\\\u200d\";\n/** Used to compose unicode regexes. */ var reOptMod = \"\".concat(rsModifier, \"?\");\nvar rsOptVar = \"[\".concat(rsVarRange, \"]?\");\nvar rsOptJoin = \"(?:\" + rsZWJ + \"(?:\" + [\n    rsNonAstral,\n    rsRegional,\n    rsSurrPair\n].join(\"|\") + \")\" + rsOptVar + reOptMod + \")*\";\nvar rsSeq = rsOptVar + reOptMod + rsOptJoin;\nvar rsSymbol = \"(?:\".concat([\n    \"\".concat(rsNonAstral).concat(rsCombo, \"?\"),\n    rsCombo,\n    rsRegional,\n    rsSurrPair,\n    rsAstral\n].join(\"|\"), \"\\n)\");\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */ var reUnicode = RegExp(\"\".concat(rsFitz, \"(?=\").concat(rsFitz, \")|\").concat(rsSymbol).concat(rsSeq), \"g\");\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */ var unicodeRange = [\n    rsZWJ,\n    rsAstralRange,\n    rsComboMarksRange,\n    rsComboSymbolsRange,\n    rsVarRange\n];\nvar reHasUnicode = RegExp(\"[\".concat(unicodeRange.join(\"\"), \"]\"));\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */ function asciiToArray(string) {\n    return string.split(\"\");\n}\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */ function hasUnicode(string) {\n    return reHasUnicode.test(string);\n}\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */ function unicodeToArray(string) {\n    return string.match(reUnicode) || [];\n}\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */ function stringToArray(string) {\n    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n}\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values.\n *\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */ function toString(value) {\n    return value == null ? \"\" : String(value);\n}\n/**\n * Splits `string` into an array of characters. If `separator` is omitted,\n * it behaves likes split.split('').\n *\n * Unlike native string.split(''), it can split strings that contain unicode\n * characters like emojis and symbols.\n *\n * @param {string} [string=''] The string to split.\n * @param {RegExp|string} [separator=''] The separator pattern to split by.\n * @returns {Array} Returns the string segments.\n * @example\n * toChars('foo');\n * // => ['f', 'o', 'o']\n *\n * toChars('foo bar');\n * // => [\"f\", \"o\", \"o\", \" \", \"b\", \"a\", \"r\"]\n *\n * toChars('fðŸ˜€o');\n * // => ['f', 'ðŸ˜€', 'o']\n *\n * toChars('f-ðŸ˜€-o', /-/);\n * // => ['f', 'ðŸ˜€', 'o']\n *\n */ function toChars(string) {\n    var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    string = toString(string);\n    if (string && isString(string)) {\n        if (!separator && hasUnicode(string)) {\n            return stringToArray(string);\n        }\n    }\n    return string.split(separator);\n}\n/**\n * Create an HTML element with the the given attributes\n *\n * attributes can include standard HTML attribute, as well as the following\n * \"special\" properties:\n *   - children: HTMLElement | ArrayLike<HTMLElement>\n *   - textContent: string\n *   - innerHTML: string\n *\n * @param {string} name\n * @param  {Object} [attributes]\n * @returns {HTMLElement}\n */ function createElement(name, attributes) {\n    var element = document.createElement(name);\n    if (!attributes) {\n        // When called without the second argument, its just return the result\n        // of `document.createElement`\n        return element;\n    }\n    Object.keys(attributes).forEach(function(attribute) {\n        var rawValue = attributes[attribute];\n        var value = isString(rawValue) ? rawValue.trim() : rawValue; // Ignore attribute if the value is `null` or an empty string\n        if (value === null || value === \"\") return;\n        if (attribute === \"children\") {\n            // Children can be one or more Elements or DOM strings\n            element.append.apply(element, _toConsumableArray(toArray(value)));\n        } else {\n            // Handle standard HTML attributes\n            element.setAttribute(attribute, value);\n        }\n    });\n    return element;\n}\nvar defaults = {\n    splitClass: \"\",\n    lineClass: \"line\",\n    wordClass: \"word\",\n    charClass: \"char\",\n    types: [\n        \"lines\",\n        \"words\",\n        \"chars\"\n    ],\n    absolute: false,\n    tagName: \"div\"\n};\n/**\n * Splits the text content of a single TextNode into words and/or characters.\n *\n * This functions gets called for every text node inside the target element. It\n * replaces the text node with a document fragment containing the split text.\n * Returns an array of the split word and character elements from this node.\n *\n * @param {TextNode} textNode\n * @param {Object} settings\n * @return {{words: Element[], chars: Element[]}}\n */ function splitWordsAndChars(textNode, settings) {\n    settings = extend(defaults, settings); // The split types\n    var types = parseTypes(settings.types); // the tag name for split text nodes\n    var TAG_NAME = settings.tagName; // value of the text node\n    var VALUE = textNode.nodeValue; // `splitText` is a wrapper to hold the HTML structure\n    var splitText = document.createDocumentFragment(); // Arrays of split word and character elements\n    var words = [];\n    var chars = [];\n    if (/^\\s/.test(VALUE)) {\n        splitText.append(\" \");\n    } // Create an array of wrapped word elements.\n    words = toWords(VALUE).reduce(function(result, WORD, idx, arr) {\n        // Let `wordElement` be the wrapped element for the current word\n        var wordElement;\n        var characterElementsForCurrentWord; // -> If splitting text into characters...\n        if (types.chars) {\n            // Iterate through the characters in the current word\n            characterElementsForCurrentWord = toChars(WORD).map(function(CHAR) {\n                var characterElement = createElement(TAG_NAME, {\n                    \"class\": \"\".concat(settings.splitClass, \" \").concat(settings.charClass),\n                    style: \"display: inline-block;\",\n                    children: CHAR\n                });\n                set(characterElement, \"isChar\", true);\n                chars = [].concat(_toConsumableArray(chars), [\n                    characterElement\n                ]);\n                return characterElement;\n            });\n        } // END IF;\n        if (types.words || types.lines) {\n            // -> If Splitting Text Into Words...\n            //    Create an element to wrap the current word. If we are also\n            //    splitting text into characters, the word element will contain the\n            //    wrapped character nodes for this word. If not, it will contain the\n            //    plain text content (WORD)\n            wordElement = createElement(TAG_NAME, {\n                \"class\": \"\".concat(settings.wordClass, \" \").concat(settings.splitClass),\n                style: \"display: inline-block; \".concat(types.words && settings.absolute ? \"position: relative;\" : \"\"),\n                children: types.chars ? characterElementsForCurrentWord : WORD\n            });\n            set(wordElement, {\n                isWord: true,\n                isWordStart: true,\n                isWordEnd: true\n            });\n            splitText.appendChild(wordElement);\n        } else {\n            // -> If NOT splitting into words OR lines...\n            //    Append the characters elements directly to splitText.\n            characterElementsForCurrentWord.forEach(function(characterElement) {\n                splitText.appendChild(characterElement);\n            });\n        }\n        if (idx < arr.length - 1) {\n            // Add a space after the word.\n            splitText.append(\" \");\n        } // If not splitting text into words, we return an empty array\n        return types.words ? result.concat(wordElement) : result;\n    }, []); // END LOOP;\n    // Add a trailing white space to maintain word spacing\n    if (/\\s$/.test(VALUE)) {\n        splitText.append(\" \");\n    }\n    textNode.replaceWith(splitText);\n    return {\n        words: words,\n        chars: chars\n    };\n}\n/**\n * Splits the text content of a target element into words and/or characters.\n * The function is recursive, it will also split the text content of any child\n * elements into words/characters, while preserving the nested elements.\n *\n * @param {Node} node an HTML Element or Text Node\n * @param {Object} setting splitType settings\n */ function split(node, settings) {\n    var type = node.nodeType; // Arrays of split words and characters\n    var wordsAndChars = {\n        words: [],\n        chars: []\n    }; // Only proceed if `node` is an `Element`, `Fragment`, or `Text`\n    if (!/(1|3|11)/.test(type)) {\n        return wordsAndChars;\n    } // A) IF `node` is TextNode that contains characters other than white space...\n    //    Split the text content of the node into words and/or characters\n    //    return an object containing the split word and character elements\n    if (type === 3 && /\\S/.test(node.nodeValue)) {\n        return splitWordsAndChars(node, settings);\n    } // B) ELSE `node` is an 'Element'\n    //    Iterate through its child nodes, calling the `split` function\n    //    recursively for each child node.\n    var childNodes = toArray(node.childNodes);\n    if (childNodes.length) {\n        set(node, \"isSplit\", true); // we need to set a few styles on nested html elements\n        if (!get(node).isRoot) {\n            node.style.display = \"inline-block\";\n            node.style.position = \"relative\"; // To maintain original spacing around nested elements when we are\n            // splitting text into lines, we need to check if the element should\n            // have a space before and after, and store that value for later.\n            // Note: this was necessary to maintain the correct spacing when nested\n            // elements do not align with word boundaries. For example, a nested\n            // element only wraps part of a word.\n            var nextSibling = node.nextSibling;\n            var prevSibling = node.previousSibling;\n            var text = node.textContent || \"\";\n            var textAfter = nextSibling ? nextSibling.textContent : \" \";\n            var textBefore = prevSibling ? prevSibling.textContent : \" \";\n            set(node, {\n                isWordEnd: /\\s$/.test(text) || /^\\s/.test(textAfter),\n                isWordStart: /^\\s/.test(text) || /\\s$/.test(textBefore)\n            });\n        }\n    } // Iterate through child nodes, calling `split` recursively\n    // Returns an object containing all split words and chars\n    return childNodes.reduce(function(result, child) {\n        var _split = split(child, settings), words = _split.words, chars = _split.chars;\n        return {\n            words: [].concat(_toConsumableArray(result.words), _toConsumableArray(words)),\n            chars: [].concat(_toConsumableArray(result.chars), _toConsumableArray(chars))\n        };\n    }, wordsAndChars);\n}\n/**\n * Gets the height and position of an element relative to offset parent.\n * Should be equivalent to offsetTop and offsetHeight, but with sub-pixel\n * precision.\n *\n * TODO needs work\n */ function getPosition(node, isWord, settings, scrollPos) {\n    if (!settings.absolute) {\n        return {\n            top: isWord ? node.offsetTop : null\n        };\n    }\n    var parent = node.offsetParent;\n    var _scrollPos = _slicedToArray(scrollPos, 2), scrollX = _scrollPos[0], scrollY = _scrollPos[1];\n    var parentX = 0;\n    var parentY = 0;\n    if (parent && parent !== document.body) {\n        var parentRect = parent.getBoundingClientRect();\n        parentX = parentRect.x + scrollX;\n        parentY = parentRect.y + scrollY;\n    }\n    var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height, x = _node$getBoundingClie.x, y = _node$getBoundingClie.y;\n    var top = y + scrollY - parentY;\n    var left = x + scrollX - parentX;\n    return {\n        width: width,\n        height: height,\n        top: top,\n        left: left\n    };\n}\n/**\n * Recursively \"un-splits\" text into words.\n * This is used when splitting text into lines but not words.\n * We initially split the text into words so we can maintain the correct line\n * breaks. Once text has been split into lines, we \"un-split\" the words...\n * @param {Element}\n * @return {void}\n */ function unSplitWords(element) {\n    if (!get(element).isWord) {\n        toArray(element.children).forEach(function(child) {\n            return unSplitWords(child);\n        });\n    } else {\n        remove(element);\n        element.replaceWith.apply(element, _toConsumableArray(element.childNodes));\n    }\n}\nvar createFragment = function createFragment() {\n    return document.createDocumentFragment();\n};\nfunction repositionAfterSplit(element, settings, scrollPos) {\n    var types = parseTypes(settings.types);\n    var TAG_NAME = settings.tagName;\n    var nodes = element.getElementsByTagName(\"*\");\n    var wordsInEachLine = [];\n    var wordsInCurrentLine = [];\n    var lineOffsetY = null;\n    var elementHeight;\n    var elementWidth;\n    var contentBox;\n    var lines = [];\n    /**------------------------------------------------\n   ** GET STYLES AND POSITIONS\n   **-----------------------------------------------*/ // There is no built-in way to detect natural line breaks in text (when a\n    // block of text wraps to fit its container). To split text into lines, we\n    // have to detect line breaks by checking the top offset of words. This is\n    // why text was split into words first. To apply absolute\n    // positioning, its also necessary to record the size and position of every\n    // split node (lines, words, characters).\n    // To consolidate DOM getting/settings, this is all done at the same time,\n    // before actually splitting text into lines, which involves restructuring\n    // the DOM again.\n    // Cache the element's parent and next sibling (for DOM removal).\n    var parent = element.parentElement;\n    var nextSibling = element.nextElementSibling; // a wrapper for the new HTML structure\n    var splitText = createFragment(); // get the computed style object for the element\n    var cs = window.getComputedStyle(element);\n    var align = cs.textAlign;\n    var fontSize = parseFloat(cs.fontSize);\n    var lineThreshold = fontSize * 0.2; // IF using absolute position...\n    if (settings.absolute) {\n        // Let contentBox be an object containing the width and offset position of\n        // the element's content box (the area inside padding box). This is needed\n        // (for absolute positioning) to set the width and position of line\n        // elements, which have not been created yet.\n        contentBox = {\n            left: element.offsetLeft,\n            top: element.offsetTop,\n            width: element.offsetWidth\n        }; // Let elementWidth and elementHeight be the actual width/height of the\n        // element. Also check if the element has inline height or width styles\n        // already set. If it does, cache those values for later.\n        elementWidth = element.offsetWidth;\n        elementHeight = element.offsetHeight; // Store the original inline height and width of the element\n        set(element, {\n            cssWidth: element.style.width,\n            cssHeight: element.style.height\n        });\n    } // Iterate over every node in the target element\n    toArray(nodes).forEach(function(node) {\n        // node is a word element or custom html element\n        var isWordLike = node.parentElement === element; // TODO needs work\n        // Get te size and position of split text nodes\n        var _getPosition = getPosition(node, isWordLike, settings, scrollPos), width = _getPosition.width, height = _getPosition.height, top = _getPosition.top, left = _getPosition.left; // If element is a `<br>` tag return here\n        if (/^br$/i.test(node.nodeName)) return;\n        if (types.lines && isWordLike) {\n            // We compare the top offset of the current word to the top offset of\n            // previous words on the current line. If the difference is greater than\n            // our defined threshold (20%), we assume this word is on a new line.\n            if (lineOffsetY === null || top - lineOffsetY >= lineThreshold) {\n                lineOffsetY = top;\n                wordsInEachLine.push(wordsInCurrentLine = []);\n            } // Add the current word node to the line array\n            wordsInCurrentLine.push(node);\n        } // END IF\n        if (settings.absolute) {\n            // Store the size and position split text nodes\n            set(node, {\n                top: top,\n                left: left,\n                width: width,\n                height: height\n            });\n        }\n    }); // END LOOP\n    // Remove the element from the DOM\n    if (parent) {\n        parent.removeChild(element);\n    }\n    /**------------------------------------------------\n   ** SPLIT LINES\n   **-----------------------------------------------*/ if (types.lines) {\n        // Iterate over lines of text (see 11 b)\n        // Let `line` be the array of words in the current line.\n        // Return an array of the wrapped line elements (lineElements)\n        lines = wordsInEachLine.map(function(wordsInThisLine) {\n            // Create an element to wrap the current line.\n            var lineElement = createElement(TAG_NAME, {\n                \"class\": \"\".concat(settings.splitClass, \" \").concat(settings.lineClass),\n                style: \"display: block; text-align: \".concat(align, \"; width: 100%;\")\n            });\n            set(lineElement, \"isLine\", true);\n            var lineDimensions = {\n                height: 0,\n                top: 1e4\n            }; // Append the `lineElement` to `container`\n            splitText.appendChild(lineElement); // Iterate over the word-level elements in the current line.\n            // Note: wordOrElement can either be a word node or nested element\n            wordsInThisLine.forEach(function(wordOrElement, idx, arr) {\n                var _data$get = get(wordOrElement), isWordEnd = _data$get.isWordEnd, top = _data$get.top, height = _data$get.height;\n                var next = arr[idx + 1]; // Determine line height / y-position\n                // we use the height and offsetTop of the words which we already\n                // recorded. Because custom nested elements could have their own\n                // styles, the words on a line may not all be the same height or\n                // y position. So we take the greatest height / y - offset of the\n                // words on this line.\n                lineDimensions.height = Math.max(lineDimensions.height, height);\n                lineDimensions.top = Math.min(lineDimensions.top, top); // append the current word/element\n                lineElement.appendChild(wordOrElement); // Determine if there should space after the current element...\n                // If this is not the last word on the current line.\n                // TODO - logic for handing spacing can be improved\n                if (isWordEnd && get(next).isWordStart) {\n                    lineElement.append(\" \");\n                }\n            }); // END LOOP\n            if (settings.absolute) {\n                set(lineElement, {\n                    height: lineDimensions.height,\n                    top: lineDimensions.top\n                });\n            }\n            return lineElement;\n        }); // END LOOP\n        if (!types.words) {\n            unSplitWords(splitText);\n        } // 10. Insert the new container\n        element.replaceChildren(splitText);\n    }\n    /**------------------------------------------------\n   **  SET ABSOLUTE POSITION\n   **-----------------------------------------------*/ // Apply absolute positioning to all child elements of the target element.\n    // This includes split lines, words, chars, and custom HTML elements that were\n    // included by the user. The size and position of child elements has already\n    // been recorded before splitting text into lines.\n    if (settings.absolute) {\n        // Set the width/height of the parent element so it does not collapse\n        // when its children are set to absolute position.\n        element.style.width = \"\".concat(element.style.width || elementWidth, \"px\");\n        element.style.height = \"\".concat(elementHeight, \"px\"); // Iterate over all child elements\n        toArray(nodes).forEach(function(node) {\n            var _data$get2 = get(node), isLine = _data$get2.isLine, top = _data$get2.top, left = _data$get2.left, width = _data$get2.width, height = _data$get2.height;\n            var parentData = get(node.parentElement);\n            var isChildOfLineNode = !isLine && parentData.isLine; // Set the top position of the current node.\n            // -> If `node` a line element, we use the top offset of its first child\n            // -> If `node` the child of line element, then its top offset is zero\n            node.style.top = \"\".concat(isChildOfLineNode ? top - parentData.top : top, \"px\"); // Set the left position of the current node.\n            // -> IF `node` is a line element, this is equal to the position left of\n            //    the content box of the parent element\n            // -> IF `node` is the child of a line element, the value has to adjusted\n            //    so its relative to the line element\n            node.style.left = isLine ? \"\".concat(contentBox.left, \"px\") : \"\".concat(left - (isChildOfLineNode ? contentBox.left : 0), \"px\"); // Set the height of the current node to the cached value.\n            node.style.height = \"\".concat(height, \"px\"); //  Set the width of the current node.\n            //  If its a line element, width is equal to the width of the contentBox.\n            node.style.width = isLine ? \"\".concat(contentBox.width, \"px\") : \"\".concat(width, \"px\"); // Finally, set the node's position to absolute.\n            node.style.position = \"absolute\";\n        });\n    } // end if;\n    // 14. Re-attach the element to the DOM\n    if (parent) {\n        if (nextSibling) parent.insertBefore(element, nextSibling);\n        else parent.appendChild(element);\n    }\n    return lines;\n}\nvar _defaults = extend(defaults, {});\nvar SplitType = /*#__PURE__*/ function() {\n    _createClass(SplitType, null, [\n        {\n            key: \"clearData\",\n            /**\n     * CLears all data\n     */ value: function clearData() {\n                clear();\n            }\n        },\n        {\n            key: \"setDefaults\",\n            /**\n     * Sets the default settings for all SplitType instances.\n     * The provided object will be merged with the existing defaults objects.\n     *\n     * @param {Object} settings an object containing the settings to override\n     * @returns {Object} the new default settings\n     * @public\n     * @static\n     * @example\n     * SplitType.setDefaults({ \"position\": \"absolute\" })\n     */ value: function setDefaults(options) {\n                _defaults = extend(_defaults, parseSettings(options));\n                return defaults;\n            }\n        },\n        {\n            key: \"revert\",\n            value: function revert(elements) {\n                getTargetElements(elements).forEach(function(element) {\n                    var _data$get = get(element), isSplit = _data$get.isSplit, html = _data$get.html, cssWidth = _data$get.cssWidth, cssHeight = _data$get.cssHeight;\n                    if (isSplit) {\n                        element.innerHTML = html;\n                        element.style.width = cssWidth || \"\";\n                        element.style.height = cssHeight || \"\";\n                        remove(element);\n                    }\n                });\n            }\n        },\n        {\n            key: \"create\",\n            value: function create(target, options) {\n                return new SplitType(target, options);\n            }\n        },\n        {\n            key: \"data\",\n            /**\n     * The internal data store\n     */ get: function get() {\n                return cache;\n            }\n        },\n        {\n            key: \"defaults\",\n            get: function get() {\n                return _defaults;\n            },\n            set: function set(options) {\n                _defaults = extend(_defaults, parseSettings(options));\n            }\n        }\n    ]);\n    function SplitType(elements, options) {\n        _classCallCheck(this, SplitType);\n        this.isSplit = false;\n        this.settings = extend(_defaults, parseSettings(options));\n        this.elements = getTargetElements(elements); // Start the split process\n        this.split();\n    }\n    /**\n   * Splits the text in all target elements. This method is called\n   * automatically when a new SplitType instance is created. It can also be\n   * called manually to re-split text with new options.\n   * @param {Object} options\n   * @public\n   */ _createClass(SplitType, [\n        {\n            key: \"split\",\n            value: function split$1(options) {\n                var _this = this;\n                // Revert target elements (if they are already split)\n                // Note: revert was already called once in the constructor. However, we\n                // need to call it again here so text is reverted when the user manually\n                // calls the `split` method to re-split text.\n                this.revert(); // Store the original html content of each target element\n                this.elements.forEach(function(element) {\n                    set(element, \"html\", element.innerHTML);\n                }); // Create arrays to hold the split lines, words, and characters\n                this.lines = [];\n                this.words = [];\n                this.chars = []; // cache vertical scroll position before splitting\n                var scrollPos = [\n                    window.pageXOffset,\n                    window.pageYOffset\n                ]; // If new options were passed into the `split()` method, update settings\n                if (options !== undefined) {\n                    this.settings = extend(this.settings, parseSettings(options));\n                }\n                var types = parseTypes(this.settings.types); // If the `types` option is set to an empty array, text will not be split.\n                // @example new SplitType('#target', { types: [] })\n                if (types.none) {\n                    return;\n                } // Split text in each target element\n                this.elements.forEach(function(element) {\n                    // Add the split text nodes from this element to the arrays of all split\n                    // text nodes for this instance.\n                    set(element, \"isRoot\", true);\n                    var _split2 = split(element, _this.settings), words = _split2.words, chars = _split2.chars;\n                    _this.words = [].concat(_toConsumableArray(_this.words), _toConsumableArray(words));\n                    _this.chars = [].concat(_toConsumableArray(_this.chars), _toConsumableArray(chars));\n                });\n                this.elements.forEach(function(element) {\n                    if (types.lines || _this.settings.absolute) {\n                        var lines = repositionAfterSplit(element, _this.settings, scrollPos);\n                        _this.lines = [].concat(_toConsumableArray(_this.lines), _toConsumableArray(lines));\n                    }\n                }); // Set isSplit to true for the SplitType instance\n                this.isSplit = true; // Set scroll position to cached value.\n                window.scrollTo(scrollPos[0], scrollPos[1]); // Clean up stored data\n                cleanup();\n            }\n        },\n        {\n            key: \"revert\",\n            value: function revert() {\n                if (this.isSplit) {\n                    // Reset instance properties if necessary\n                    this.lines = null;\n                    this.words = null;\n                    this.chars = null;\n                    this.isSplit = false;\n                }\n                SplitType.revert(this.elements);\n            }\n        }\n    ]);\n    return SplitType;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zcGxpdC10eXBlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7OztDQUtDLEdBRUQsc0VBQXNFO0FBRXJFO0lBQ0MsU0FBU0E7UUFDUCxJQUFJQyxTQUFTQyxVQUFVRCxNQUFNO1FBRTdCLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJRixRQUFRRSxJQUFLO1lBQy9CLElBQUlDLE9BQU9ELElBQUksS0FBS0QsVUFBVUQsTUFBTSxJQUFJRSxJQUFJRSxZQUFZSCxTQUFTLENBQUNDLEVBQUU7WUFDcEUsSUFBSUMsS0FBS0UsUUFBUSxLQUFLLEtBQUtGLEtBQUtFLFFBQVEsS0FBSyxJQUFJLElBQUksQ0FBQ0MsV0FBVyxDQUFDSDtpQkFBVyxJQUFJLENBQUNHLFdBQVcsQ0FBQ0MsU0FBU0MsY0FBYyxDQUFDQyxPQUFPTjtRQUMvSDtJQUNGO0lBRUEsU0FBU087UUFDUCxNQUFPLElBQUksQ0FBQ0MsU0FBUyxDQUFFO1lBQ3JCLElBQUksQ0FBQ0MsV0FBVyxDQUFDLElBQUksQ0FBQ0QsU0FBUztRQUNqQztRQUVBLElBQUlWLFVBQVVELE1BQU0sRUFBRSxJQUFJLENBQUNELE1BQU0sQ0FBQ2MsS0FBSyxDQUFDLElBQUksRUFBRVo7SUFDaEQ7SUFFQSxTQUFTYTtRQUNQLElBQUlDLFNBQVMsSUFBSSxDQUFDQyxVQUFVO1FBRTVCLElBQUssSUFBSUMsT0FBT2hCLFVBQVVELE1BQU0sRUFBRWtCLFFBQVEsSUFBSUMsTUFBTUYsT0FBT0csT0FBTyxHQUFHQSxPQUFPSCxNQUFNRyxPQUFRO1lBQ3hGRixLQUFLLENBQUNFLEtBQUssR0FBR25CLFNBQVMsQ0FBQ21CLEtBQUs7UUFDL0I7UUFFQSxJQUFJbEIsSUFBSWdCLE1BQU1sQixNQUFNO1FBQ3BCLElBQUksQ0FBQ2UsUUFBUTtRQUNiLElBQUksQ0FBQ2IsR0FBR2EsT0FBT0gsV0FBVyxDQUFDLElBQUk7UUFFL0IsTUFBT1YsSUFBSztZQUNW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QUFNakwsS0FBSyxHQUFHLEVBQUUsQ0FBQ2UsTUFBTSxDQUFDL0QsbUJBQW1CaU8sTUFBTWpMLEtBQUssR0FBR2hELG1CQUFtQmdEO29CQUM5RTtnQkFDRixJQUFJLGlEQUFpRDtnQkFFckQsSUFBSSxDQUFDbUMsT0FBTyxHQUFHLE1BQU0sdUNBQXVDO2dCQUU1RHlHLE9BQU95QyxRQUFRLENBQUN4RSxTQUFTLENBQUMsRUFBRSxFQUFFQSxTQUFTLENBQUMsRUFBRSxHQUFHLHVCQUF1QjtnQkFFcEUvRTtZQUNGO1FBU0Y7UUFBRztZQUNEMUcsS0FBSztZQUNMTSxPQUFPLFNBQVNrUDtnQkFDZCxJQUFJLElBQUksQ0FBQ3pJLE9BQU8sRUFBRTtvQkFDaEIseUNBQXlDO29CQUN6QyxJQUFJLENBQUNuQyxLQUFLLEdBQUc7b0JBQ2IsSUFBSSxDQUFDQyxLQUFLLEdBQUc7b0JBQ2IsSUFBSSxDQUFDQyxLQUFLLEdBQUc7b0JBQ2IsSUFBSSxDQUFDaUMsT0FBTyxHQUFHO2dCQUNqQjtnQkFFQXFJLFVBQVVJLE1BQU0sQ0FBQyxJQUFJLENBQUNsSyxRQUFRO1lBQ2hDO1FBQ0Y7S0FBRTtJQUVGLE9BQU84SjtBQUNUO0FBRWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zcGxpdC10eXBlL2Rpc3QvaW5kZXguanM/ODk0MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNwbGl0VHlwZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2x1a2VQZWF2ZXkvU3BsaXRUeXBlXG4gKiBAdmVyc2lvbiAwLjMuNFxuICogQGF1dGhvciBMdWtlIFBlYXZleSA8bHdwZWF2ZXlAZ21haWwuY29tPlxuICovXG5cbi8vIFBvbHlmaWxsIHRoZSBmb2xsb3dpbmcgRE9NIG1ldGhvZHMgdGhhdCBhcmUgbm90IHN1cHBvcnRlZCBpbiBJRSAxMS5cblxuKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gYXBwZW5kKCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBpIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaV07XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSB8fCBub2RlLm5vZGVUeXBlID09PSAxMSkgdGhpcy5hcHBlbmRDaGlsZChub2RlKTtlbHNlIHRoaXMuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKG5vZGUpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZUNoaWxkcmVuKCkge1xuICAgIHdoaWxlICh0aGlzLmxhc3RDaGlsZCkge1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLmxhc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHRoaXMuYXBwZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlV2l0aCgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG5vZGVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgbm9kZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgaWYgKCFwYXJlbnQpIHJldHVybjtcbiAgICBpZiAoIWkpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG5cbiAgICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpKSB7XG4gICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQobm9kZSwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMucHJldmlvdXNTaWJsaW5nLCBub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIEVsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKCFFbGVtZW50LnByb3RvdHlwZS5hcHBlbmQpIHtcbiAgICAgIEVsZW1lbnQucHJvdG90eXBlLmFwcGVuZCA9IGFwcGVuZDtcbiAgICAgIERvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLmFwcGVuZCA9IGFwcGVuZDtcbiAgICB9XG5cbiAgICBpZiAoIUVsZW1lbnQucHJvdG90eXBlLnJlcGxhY2VDaGlsZHJlbikge1xuICAgICAgRWxlbWVudC5wcm90b3R5cGUucmVwbGFjZUNoaWxkcmVuID0gcmVwbGFjZUNoaWxkcmVuO1xuICAgICAgRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUucmVwbGFjZUNoaWxkcmVuID0gcmVwbGFjZUNoaWxkcmVuO1xuICAgIH1cblxuICAgIGlmICghRWxlbWVudC5wcm90b3R5cGUucmVwbGFjZVdpdGgpIHtcbiAgICAgIEVsZW1lbnQucHJvdG90eXBlLnJlcGxhY2VXaXRoID0gcmVwbGFjZVdpdGg7XG4gICAgICBEb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS5yZXBsYWNlV2l0aCA9IHJlcGxhY2VXaXRoO1xuICAgIH1cbiAgfVxufSkoKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbi8qKlxuICogU2hhbGxvdyBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IHdpdGggdGhlIHRhcmdldCBvYmplY3QuIE9ubHlcbiAqIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBleGlzdCBvbiB0aGUgdGFyZ2V0IG9iamVjdC4gTm9uLXdyaXRhYmxlIHByb3BlcnRpZXNcbiAqIG9uIHRoZSB0YXJnZXQgb2JqZWN0IHdpbGwgbm90IGJlIG92ZXItd3JpdHRlbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoT2JqZWN0KHRhcmdldCkpLnJlZHVjZShmdW5jdGlvbiAoZXh0ZW5kZWQsIGtleSkge1xuICAgIHZhciBjdXJyZW50VmFsdWUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdCh0YXJnZXQpLCBrZXkpO1xuICAgIHZhciBuZXdWYWx1ZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0KG9iamVjdCksIGtleSk7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHRlbmRlZCwga2V5LCBuZXdWYWx1ZSB8fCBjdXJyZW50VmFsdWUpO1xuICB9LCB7fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGdpdmVuIHZhbHVlIGlzIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgdXNlciBzdXBwbGllZCBzZXR0aW5ncyBvYmplY3RzLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlU2V0dGluZ3MoKSB7XG4gIHZhciBzZXR0aW5ncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBvYmplY3QgPSBleHRlbmQoc2V0dGluZ3MpOyAvLyBgc3BsaXRgIG1heSBiZSB1c2VkIGFzIGFuIGFsaWFzIGZvciB0aGUgYHR5cGVzYCBvcHRpb25cbiAgLy8gUGFyc2UgdGhlIGB0eXBlc2Agc2V0dGluZ3MgaW50byBhbiBhcnJheSBvZiB2YWxpZCBzcGxpdCB0eXBlcy5cbiAgLy8gSWYgYHR5cGVzYCBpcyBleHBsaWNpdGx5IHNldCB0byBhbiBlbXB0eSBzdHJpbmcgb3IgYXJyYXksIHRleHQgd2lsbCBub3QgYmVcbiAgLy8gc3BsaXQgYXQgYWxsLlxuXG4gIHZhciB0eXBlcztcblxuICBpZiAob2JqZWN0LnR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICB0eXBlcyA9IG9iamVjdC50eXBlcztcbiAgfSBlbHNlIGlmIChvYmplY3Quc3BsaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHR5cGVzID0gb2JqZWN0LnNwbGl0O1xuICB9XG5cbiAgaWYgKHR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBvYmplY3QudHlwZXMgPSAoaXNTdHJpbmcodHlwZXMpIHx8IGlzQXJyYXkodHlwZXMpID8gU3RyaW5nKHR5cGVzKSA6ICcnKS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgcmV0dXJuIFN0cmluZyh0eXBlKS50cmltKCk7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICByZXR1cm4gLygobGluZSl8KHdvcmQpfChjaGFyKSkvaS50ZXN0KHR5cGUpO1xuICAgIH0pO1xuICB9IC8vIFN1cHBvcnQgYHBvc2l0aW9uOiBhYnNvbHV0ZWAgYXMgYW4gYWxpYXMgZm9yIGBhYnNvbHV0ZTogdHJ1ZWBcblxuXG4gIGlmIChvYmplY3QuYWJzb2x1dGUgfHwgb2JqZWN0LnBvc2l0aW9uKSB7XG4gICAgb2JqZWN0LmFic29sdXRlID0gb2JqZWN0LmFic29sdXRlIHx8IC9hYnNvbHV0ZS8udGVzdChzZXR0aW5ncy5wb3NpdGlvbik7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG4vKipcbiAqIFRha2VzIGEgbGlzdCBvZiBgdHlwZXNgIGFuZCByZXR1cm5zIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IHZhbHVlIGEgY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2Ygc3BsaXQgdHlwZXNcbiAqIEByZXR1cm4ge3tsaW5lczogYm9vbGVhbiwgd29yZHM6IGJvb2xlYW4sIGNoYXJzOiBib29sZWFufX1cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVR5cGVzKHZhbHVlKSB7XG4gIHZhciB0eXBlcyA9IGlzU3RyaW5nKHZhbHVlKSB8fCBpc0FycmF5KHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHtcbiAgICBub25lOiAhdHlwZXMsXG4gICAgbGluZXM6IC9saW5lL2kudGVzdCh0eXBlcyksXG4gICAgd29yZHM6IC93b3JkL2kudGVzdCh0eXBlcyksXG4gICAgY2hhcnM6IC9jaGFyL2kudGVzdCh0eXBlcylcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhIG5vbi1udWxsIG9iamVjdC5cbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBpbnB1dGAgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gKiAtIGBFbGVtZW50YFxuICogLSBgVGV4dGBcbiAqIC0gYERvY3VtZW50RnJhZ21lbnRgXG4gKi9cblxuZnVuY3Rpb24gaXNOb2RlKGlucHV0KSB7XG4gIHJldHVybiBpc09iamVjdChpbnB1dCkgJiYgL14oMXwzfDExKSQvLnRlc3QoaW5wdXQubm9kZVR5cGUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKiBPcmlnaW5hbCBzb3VyY2U6IExvZGFzaFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKVxuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSlcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSlcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpXG4gKiAvLyA9PiBmYWxzZVxuICovXG5cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09PSAwO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdFxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZWAsIGVsc2UgYGZhbHNlYFxuICogQGV4YW1wbGVcbiAqIGlzQXJyYXlMaWtlKG5ldyBBcnJheSgpKVxuICogLy8gPT4gdHJ1ZVxuICpcbiAqIGlzQXJyYXlMaWtlKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2RpdicpKVxuICogLy8gPT4gdHJ1ZVxuICpcbiAqIGlzQXJyYXlMaWtlKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdkaXYnKSlcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBpc0FycmF5TGlrZSgoKSA9PiB7fSlcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogaXNBcnJheUxpa2Uoe2ZvbzogJ2Jhcid9KVxuICogLy8gPT4gZmFsc2VcbiAqXG4gKiAqIGlzQXJyYXlMaWtlKG51bGwpXG4gKiAvLyA9PiBmYWxzZVxuICovXG5cblxuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpO1xufVxuXG4vKipcbiAqIENvZXJjZXMgYHZhbHVlYCB0byBhbiBgQXJyYXlgLlxuICpcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybiB7YW55W119XG4gKiBAZXhhbXBsZVxuICogLy8gSWYgYHZhbHVlYCBpcyBhbnkgYEFycmF5YCwgcmV0dXJucyBvcmlnaW5hbCBgQXJyYXlgXG4gKiBsZXQgYXJyID0gWzEsIDJdXG4gKiB0b0FycmF5KGFycilcbiAqIC8vID0+IGFyclxuICpcbiAqIC8vIElmIGB2YWx1ZWAgaXMgYW4gYEFycmF5TGlrZWAsIGl0cyBlcXVpdmFsZW50IHRvIGBBcnJheS5mcm9tKHZhbHVlKWBcbiAqIGxldCBub2RlTGlzdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2RpdicpXG4gKiB0b0FycmF5KG5vZGVMaXN0KVxuICogLy8gPT4gSFRNTEVsZW1lbnRbXSBzXG4gKlxuICogLy8gSWYgdmFsdWUgaXMgZmFsc3ksIHJldHVybnMgZW1wdHkgYXJyYXlcbiAqIHRvQXJyYXkobnVsbClcbiAqIC8vID0+IFtdXG4gKlxuICogLy8gRm9yIGFueSBvdGhlciB0eXBlIG9mIHZhbHVlLCBpdHMgZXF1aXZhbGVudCB0byBgQXJyYXkub2YodmFsdWUpYFxuICogbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICogdG9BcnJheShlbGVtZW50KVxuICogLy8gPT4gW2VsZW1lbnRdXG4gKlxuICovXG5cbmZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gW107XG4gIHJldHVybiBpc0FycmF5TGlrZSh2YWx1ZSkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh2YWx1ZSkgOiBbdmFsdWVdO1xufVxuXG4vKipcbiAqIFByb2Nlc3NlcyB0YXJnZXQgZWxlbWVudHMgZm9yIHRoZSBzcGxpdFR5cGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHthbnl9IHRhcmdldCBDYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gKiAxLiBgc3RyaW5nYCAtIEEgY3NzIHNlbGVjdG9yXG4gKiAyLiBgSFRNTEVsZW1lbnRgIC0gQSBzaW5nbGUgZWxlbWVudFxuICogMy4gYE5vZGVMaXN0YCAtIEEgbm9kZUxpc3RcbiAqIDQuIGBFbGVtZW50W11gIC0gQW4gYXJyYXkgb2YgZWxlbWVudHNcbiAqIDUuIGBBcnJheTxOb2RlTGlzdHxFbGVtZW50W10+YCAtIEFuIG5lc3RlZCBhcnJheSBvZiBlbGVtZW50c1xuICogQHJldHVybnMge0VsZW1lbnRbXX0gQSBmbGF0IGFycmF5IEhUTUwgZWxlbWVudHNcbiAqIEByZXR1cm4gQSBmbGF0IGFycmF5IG9mIGVsZW1lbnRzIG9yIGVtcHR5IGFycmF5IGlmIG5vIGVsZW1lbnRzIGFyZSBmb3VuZFxuICovXG5cbmZ1bmN0aW9uIGdldFRhcmdldEVsZW1lbnRzKHRhcmdldCkge1xuICB2YXIgZWxlbWVudHMgPSB0YXJnZXQ7IC8vIElmIGB0YXJnZXRgIGlzIGEgc2VsZWN0b3Igc3RyaW5nLi4uXG5cbiAgaWYgKGlzU3RyaW5nKHRhcmdldCkpIHtcbiAgICBpZiAoL14oI1thLXpdXFx3KykkLy50ZXN0KHRhcmdldC50cmltKCkpKSB7XG4gICAgICAvLyBJZiBgdGFyZ2V0YCBpcyBhbiBJRCwgdXNlIGBnZXRFbGVtZW50QnlJZGBcbiAgICAgIGVsZW1lbnRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0LnRyaW0oKS5zbGljZSgxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVsc2UgdXNlIGBxdWVyeVNlbGVjdG9yQWxsYFxuICAgICAgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRhcmdldCk7XG4gICAgfVxuICB9IC8vIFJldHVybiBhIGZsYXR0ZW5lZCBhcnJheSBvZiBlbGVtZW50c1xuXG5cbiAgcmV0dXJuIHRvQXJyYXkoZWxlbWVudHMpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocmVzdWx0KSwgX3RvQ29uc3VtYWJsZUFycmF5KHRvQXJyYXkoZWxlbWVudCkuZmlsdGVyKGlzTm9kZSkpKTtcbiAgfSwgW10pO1xufVxuXG52YXIgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzO1xuXG52YXIgZXhwYW5kbyA9IFwiX3NwbGl0dHlwZVwiO1xudmFyIGNhY2hlID0ge307XG52YXIgdWlkID0gMDtcbi8qKlxuICogU3RvcmVzIGRhdGEgYXNzb2NpYXRlZCB3aXRoIERPTSBlbGVtZW50cyBvciBvdGhlciBvYmplY3RzLiBUaGlzIGlzIGFcbiAqIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiBqUXVlcnkncyBkYXRhIG1ldGhvZC5cbiAqXG4gKiBAc2lnbmF0dXJlIERhdGEob3duZXIpXG4gKiBAZGVzY3JpcHRpb24gR2V0IHRoZSBkYXRhIHN0b3JlIG9iamVjdCBmb3IgdGhlIGdpdmVuIG93bmVyLlxuICogQHBhcmFtIHtPYmplY3R9IG93bmVyIHRoZSBvYmplY3QgdGhhdCBkYXRhIHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoLlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgZGF0YSBvYmplY3QgZm9yIGdpdmVuIGBvd25lcmAuIElmIG5vIGRhdGEgZXhpc3RzXG4gKiAgICAgZm9yIHRoZSBnaXZlbiBvYmplY3QsIGNyZWF0ZXMgYSBuZXcgZGF0YSBzdG9yZSBhbmQgcmV0dXJucyBpdC5cbiAqXG4gKiBAc2lnbmF0dXJlIERhdGEob3duZXIsIGtleSlcbiAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gb3duZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge2FueX0gdGhlIHZhbHVlIG9mIHRoZSBwcm92aWRlZCBrZXkuIElmIGtleSBkb2VzIG5vdCBleGlzdCwgcmV0dXJuc1xuICogICAgIHVuZGVmaW5lZC5cbiAqXG4gKiBAc2lnbmF0dXJlIERhdGEob3duZXIsIGtleSwgdmFsdWUpXG4gKiBAZGVzY3JpcHRpb24gU2V0cyB0aGUgZ2l2ZW4ga2V5L3ZhbHVlIHBhaXIgaW4gZGF0YSBzdG9yZVxuICogQHBhcmFtIHtPYmplY3R9IG93bmVyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqL1xuXG5mdW5jdGlvbiBzZXQob3duZXIsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdChvd25lcikpIHtcbiAgICBjb25zb2xlLndhcm4oJ1tkYXRhLnNldF0gb3duZXIgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGlkID0gb3duZXJbZXhwYW5kb10gfHwgKG93bmVyW2V4cGFuZG9dID0gKyt1aWQpO1xuICB2YXIgZGF0YSA9IGNhY2hlW2lkXSB8fCAoY2FjaGVbaWRdID0ge30pO1xuXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCEha2V5ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihrZXkpID09PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICBjYWNoZVtpZF0gPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGF0YSksIGtleSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGF0YVtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBnZXQob3duZXIsIGtleSkge1xuICB2YXIgaWQgPSBpc09iamVjdChvd25lcikgPyBvd25lcltleHBhbmRvXSA6IG51bGw7XG4gIHZhciBkYXRhID0gaWQgJiYgY2FjaGVbaWRdIHx8IHt9O1xuXG4gIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcmV0dXJuIGRhdGFba2V5XTtcbn1cbi8qKlxuICogUmVtb3ZlIGFsbCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZShlbGVtZW50KSB7XG4gIHZhciBpZCA9IGVsZW1lbnQgJiYgZWxlbWVudFtleHBhbmRvXTtcblxuICBpZiAoaWQpIHtcbiAgICBkZWxldGUgZWxlbWVudFtpZF07XG4gICAgZGVsZXRlIGNhY2hlW2lkXTtcbiAgfVxufVxuLyoqXG4gKiBDbGVhciBhbGwgY2FjaGVkIGRhdGFcbiAqL1xuXG5mdW5jdGlvbiBjbGVhcigpIHtcbiAgT2JqZWN0LmtleXMoY2FjaGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbGV0ZSBjYWNoZVtrZXldO1xuICB9KTtcbn1cbi8qKlxuICogUmVtb3ZlIGFsbCB0ZW1wb3JhcnkgZGF0YSBmcm9tIHRoZSBzdG9yZS5cbiAqL1xuXG5mdW5jdGlvbiBjbGVhbnVwKCkge1xuICBlbnRyaWVzKGNhY2hlKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgIGlkID0gX3JlZjJbMF0sXG4gICAgICAgIF9yZWYyJCA9IF9yZWYyWzFdLFxuICAgICAgICBpc1Jvb3QgPSBfcmVmMiQuaXNSb290LFxuICAgICAgICBpc1NwbGl0ID0gX3JlZjIkLmlzU3BsaXQ7XG5cbiAgICBpZiAoIWlzUm9vdCB8fCAhaXNTcGxpdCkge1xuICAgICAgY2FjaGVbaWRdID0gbnVsbDtcbiAgICAgIGRlbGV0ZSBjYWNoZVtpZF07XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTcGxpdHMgYSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZyB8IFJlZ0V4cH0gW3NlcGFyYXRvciA9ICcgJ11cbiAqIEByZXR1cm4ge3N0cmluZ1tdfSBBcnJheSBvZiB3b3Jkc1xuICovXG5mdW5jdGlvbiB0b1dvcmRzKHZhbHVlKSB7XG4gIHZhciBzZXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcgJztcbiAgdmFyIHN0cmluZyA9IHZhbHVlID8gU3RyaW5nKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gc3RyaW5nLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcgJykuc3BsaXQoc2VwYXJhdG9yKTtcbn1cblxuLyoqXG4gKiBCYXNlZCBvbiBsb2Rhc2gjc3BsaXQgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmXG4gKiBFZGl0b3JzXG4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gXCJcXFxcdWQ4MDAtXFxcXHVkZmZmXCI7XG52YXIgcnNDb21ib01hcmtzUmFuZ2UgPSBcIlxcXFx1MDMwMC1cXFxcdTAzNmZcXFxcdWZlMjAtXFxcXHVmZTIzXCI7XG52YXIgcnNDb21ib1N5bWJvbHNSYW5nZSA9IFwiXFxcXHUyMGQwLVxcXFx1MjBmMFwiO1xudmFyIHJzVmFyUmFuZ2UgPSBcIlxcXFx1ZmUwZVxcXFx1ZmUwZlwiO1xuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xuXG52YXIgcnNBc3RyYWwgPSBcIltcIi5jb25jYXQocnNBc3RyYWxSYW5nZSwgXCJdXCIpO1xudmFyIHJzQ29tYm8gPSBcIltcIi5jb25jYXQocnNDb21ib01hcmtzUmFuZ2UpLmNvbmNhdChyc0NvbWJvU3ltYm9sc1JhbmdlLCBcIl1cIik7XG52YXIgcnNGaXR6ID0gXCJcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl1cIjtcbnZhciByc01vZGlmaWVyID0gXCIoPzpcIi5jb25jYXQocnNDb21ibywgXCJ8XCIpLmNvbmNhdChyc0ZpdHosIFwiKVwiKTtcbnZhciByc05vbkFzdHJhbCA9IFwiW15cIi5jb25jYXQocnNBc3RyYWxSYW5nZSwgXCJdXCIpO1xudmFyIHJzUmVnaW9uYWwgPSBcIig/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn1cIjtcbnZhciByc1N1cnJQYWlyID0gXCJbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl1cIjtcbnZhciByc1pXSiA9IFwiXFxcXHUyMDBkXCI7XG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cblxudmFyIHJlT3B0TW9kID0gXCJcIi5jb25jYXQocnNNb2RpZmllciwgXCI/XCIpO1xudmFyIHJzT3B0VmFyID0gXCJbXCIuY29uY2F0KHJzVmFyUmFuZ2UsIFwiXT9cIik7XG52YXIgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJztcbnZhciByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW47XG52YXIgcnNTeW1ib2wgPSBcIig/OlwiLmNvbmNhdChbXCJcIi5jb25jYXQocnNOb25Bc3RyYWwpLmNvbmNhdChyc0NvbWJvLCBcIj9cIiksIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JyksIFwiXFxuKVwiKTtcbi8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG5cbnZhciByZVVuaWNvZGUgPSBSZWdFeHAoXCJcIi5jb25jYXQocnNGaXR6LCBcIig/PVwiKS5jb25jYXQocnNGaXR6LCBcIil8XCIpLmNvbmNhdChyc1N5bWJvbCkuY29uY2F0KHJzU2VxKSwgJ2cnKTtcbi8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHdpdGggW3plcm8td2lkdGggam9pbmVycyBvciBjb2RlIHBvaW50cyBmcm9tIHRoZSBhc3RyYWwgcGxhbmVzXShodHRwOi8vZWV2LmVlL2Jsb2cvMjAxNS8wOS8xMi9kYXJrLWNvcm5lcnMtb2YtdW5pY29kZS8pLiAqL1xuXG52YXIgdW5pY29kZVJhbmdlID0gW3JzWldKLCByc0FzdHJhbFJhbmdlLCByc0NvbWJvTWFya3NSYW5nZSwgcnNDb21ib1N5bWJvbHNSYW5nZSwgcnNWYXJSYW5nZV07XG52YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKFwiW1wiLmNvbmNhdCh1bmljb2RlUmFuZ2Uuam9pbignJyksIFwiXVwiKSk7XG4vKipcbiAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5cbmZ1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG59XG4vKipcbiAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgc3ltYm9sIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cblxuXG5mdW5jdGlvbiBoYXNVbmljb2RlKHN0cmluZykge1xuICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICovXG5cblxuZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlKSB8fCBbXTtcbn1cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cblxuXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5KHN0cmluZykge1xuICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cblxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IFN0cmluZyh2YWx1ZSk7XG59XG4vKipcbiAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGNoYXJhY3RlcnMuIElmIGBzZXBhcmF0b3JgIGlzIG9taXR0ZWQsXG4gKiBpdCBiZWhhdmVzIGxpa2VzIHNwbGl0LnNwbGl0KCcnKS5cbiAqXG4gKiBVbmxpa2UgbmF0aXZlIHN0cmluZy5zcGxpdCgnJyksIGl0IGNhbiBzcGxpdCBzdHJpbmdzIHRoYXQgY29udGFpbiB1bmljb2RlXG4gKiBjaGFyYWN0ZXJzIGxpa2UgZW1vamlzIGFuZCBzeW1ib2xzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHNwbGl0LlxuICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbc2VwYXJhdG9yPScnXSBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gc3BsaXQgYnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHN0cmluZyBzZWdtZW50cy5cbiAqIEBleGFtcGxlXG4gKiB0b0NoYXJzKCdmb28nKTtcbiAqIC8vID0+IFsnZicsICdvJywgJ28nXVxuICpcbiAqIHRvQ2hhcnMoJ2ZvbyBiYXInKTtcbiAqIC8vID0+IFtcImZcIiwgXCJvXCIsIFwib1wiLCBcIiBcIiwgXCJiXCIsIFwiYVwiLCBcInJcIl1cbiAqXG4gKiB0b0NoYXJzKCdm8J+YgG8nKTtcbiAqIC8vID0+IFsnZicsICfwn5iAJywgJ28nXVxuICpcbiAqIHRvQ2hhcnMoJ2Yt8J+YgC1vJywgLy0vKTtcbiAqIC8vID0+IFsnZicsICfwn5iAJywgJ28nXVxuICpcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQ2hhcnMoc3RyaW5nKSB7XG4gIHZhciBzZXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gIGlmIChzdHJpbmcgJiYgaXNTdHJpbmcoc3RyaW5nKSkge1xuICAgIGlmICghc2VwYXJhdG9yICYmIGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHN0cmluZ1RvQXJyYXkoc3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyaW5nLnNwbGl0KHNlcGFyYXRvcik7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIEhUTUwgZWxlbWVudCB3aXRoIHRoZSB0aGUgZ2l2ZW4gYXR0cmlidXRlc1xuICpcbiAqIGF0dHJpYnV0ZXMgY2FuIGluY2x1ZGUgc3RhbmRhcmQgSFRNTCBhdHRyaWJ1dGUsIGFzIHdlbGwgYXMgdGhlIGZvbGxvd2luZ1xuICogXCJzcGVjaWFsXCIgcHJvcGVydGllczpcbiAqICAgLSBjaGlsZHJlbjogSFRNTEVsZW1lbnQgfCBBcnJheUxpa2U8SFRNTEVsZW1lbnQ+XG4gKiAgIC0gdGV4dENvbnRlbnQ6IHN0cmluZ1xuICogICAtIGlubmVySFRNTDogc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSAge09iamVjdH0gW2F0dHJpYnV0ZXNdXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcblxuICBpZiAoIWF0dHJpYnV0ZXMpIHtcbiAgICAvLyBXaGVuIGNhbGxlZCB3aXRob3V0IHRoZSBzZWNvbmQgYXJndW1lbnQsIGl0cyBqdXN0IHJldHVybiB0aGUgcmVzdWx0XG4gICAgLy8gb2YgYGRvY3VtZW50LmNyZWF0ZUVsZW1lbnRgXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICB2YXIgcmF3VmFsdWUgPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XG4gICAgdmFyIHZhbHVlID0gaXNTdHJpbmcocmF3VmFsdWUpID8gcmF3VmFsdWUudHJpbSgpIDogcmF3VmFsdWU7IC8vIElnbm9yZSBhdHRyaWJ1dGUgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCBvciBhbiBlbXB0eSBzdHJpbmdcblxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJycpIHJldHVybjtcblxuICAgIGlmIChhdHRyaWJ1dGUgPT09ICdjaGlsZHJlbicpIHtcbiAgICAgIC8vIENoaWxkcmVuIGNhbiBiZSBvbmUgb3IgbW9yZSBFbGVtZW50cyBvciBET00gc3RyaW5nc1xuICAgICAgZWxlbWVudC5hcHBlbmQuYXBwbHkoZWxlbWVudCwgX3RvQ29uc3VtYWJsZUFycmF5KHRvQXJyYXkodmFsdWUpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEhhbmRsZSBzdGFuZGFyZCBIVE1MIGF0dHJpYnV0ZXNcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG4gIHNwbGl0Q2xhc3M6ICcnLFxuICBsaW5lQ2xhc3M6ICdsaW5lJyxcbiAgd29yZENsYXNzOiAnd29yZCcsXG4gIGNoYXJDbGFzczogJ2NoYXInLFxuICB0eXBlczogWydsaW5lcycsICd3b3JkcycsICdjaGFycyddLFxuICBhYnNvbHV0ZTogZmFsc2UsXG4gIHRhZ05hbWU6ICdkaXYnXG59O1xuXG4vKipcbiAqIFNwbGl0cyB0aGUgdGV4dCBjb250ZW50IG9mIGEgc2luZ2xlIFRleHROb2RlIGludG8gd29yZHMgYW5kL29yIGNoYXJhY3RlcnMuXG4gKlxuICogVGhpcyBmdW5jdGlvbnMgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IHRleHQgbm9kZSBpbnNpZGUgdGhlIHRhcmdldCBlbGVtZW50LiBJdFxuICogcmVwbGFjZXMgdGhlIHRleHQgbm9kZSB3aXRoIGEgZG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmluZyB0aGUgc3BsaXQgdGV4dC5cbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHNwbGl0IHdvcmQgYW5kIGNoYXJhY3RlciBlbGVtZW50cyBmcm9tIHRoaXMgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge1RleHROb2RlfSB0ZXh0Tm9kZVxuICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzXG4gKiBAcmV0dXJuIHt7d29yZHM6IEVsZW1lbnRbXSwgY2hhcnM6IEVsZW1lbnRbXX19XG4gKi9cblxuZnVuY3Rpb24gc3BsaXRXb3Jkc0FuZENoYXJzKHRleHROb2RlLCBzZXR0aW5ncykge1xuICBzZXR0aW5ncyA9IGV4dGVuZChkZWZhdWx0cywgc2V0dGluZ3MpOyAvLyBUaGUgc3BsaXQgdHlwZXNcblxuICB2YXIgdHlwZXMgPSBwYXJzZVR5cGVzKHNldHRpbmdzLnR5cGVzKTsgLy8gdGhlIHRhZyBuYW1lIGZvciBzcGxpdCB0ZXh0IG5vZGVzXG5cbiAgdmFyIFRBR19OQU1FID0gc2V0dGluZ3MudGFnTmFtZTsgLy8gdmFsdWUgb2YgdGhlIHRleHQgbm9kZVxuXG4gIHZhciBWQUxVRSA9IHRleHROb2RlLm5vZGVWYWx1ZTsgLy8gYHNwbGl0VGV4dGAgaXMgYSB3cmFwcGVyIHRvIGhvbGQgdGhlIEhUTUwgc3RydWN0dXJlXG5cbiAgdmFyIHNwbGl0VGV4dCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTsgLy8gQXJyYXlzIG9mIHNwbGl0IHdvcmQgYW5kIGNoYXJhY3RlciBlbGVtZW50c1xuXG4gIHZhciB3b3JkcyA9IFtdO1xuICB2YXIgY2hhcnMgPSBbXTtcblxuICBpZiAoL15cXHMvLnRlc3QoVkFMVUUpKSB7XG4gICAgc3BsaXRUZXh0LmFwcGVuZCgnICcpO1xuICB9IC8vIENyZWF0ZSBhbiBhcnJheSBvZiB3cmFwcGVkIHdvcmQgZWxlbWVudHMuXG5cblxuICB3b3JkcyA9IHRvV29yZHMoVkFMVUUpLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBXT1JELCBpZHgsIGFycikge1xuICAgIC8vIExldCBgd29yZEVsZW1lbnRgIGJlIHRoZSB3cmFwcGVkIGVsZW1lbnQgZm9yIHRoZSBjdXJyZW50IHdvcmRcbiAgICB2YXIgd29yZEVsZW1lbnQ7XG4gICAgdmFyIGNoYXJhY3RlckVsZW1lbnRzRm9yQ3VycmVudFdvcmQ7IC8vIC0+IElmIHNwbGl0dGluZyB0ZXh0IGludG8gY2hhcmFjdGVycy4uLlxuXG4gICAgaWYgKHR5cGVzLmNoYXJzKSB7XG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGNoYXJhY3RlcnMgaW4gdGhlIGN1cnJlbnQgd29yZFxuICAgICAgY2hhcmFjdGVyRWxlbWVudHNGb3JDdXJyZW50V29yZCA9IHRvQ2hhcnMoV09SRCkubWFwKGZ1bmN0aW9uIChDSEFSKSB7XG4gICAgICAgIHZhciBjaGFyYWN0ZXJFbGVtZW50ID0gY3JlYXRlRWxlbWVudChUQUdfTkFNRSwge1xuICAgICAgICAgIFwiY2xhc3NcIjogXCJcIi5jb25jYXQoc2V0dGluZ3Muc3BsaXRDbGFzcywgXCIgXCIpLmNvbmNhdChzZXR0aW5ncy5jaGFyQ2xhc3MpLFxuICAgICAgICAgIHN0eWxlOiAnZGlzcGxheTogaW5saW5lLWJsb2NrOycsXG4gICAgICAgICAgY2hpbGRyZW46IENIQVJcbiAgICAgICAgfSk7XG4gICAgICAgIHNldChjaGFyYWN0ZXJFbGVtZW50LCAnaXNDaGFyJywgdHJ1ZSk7XG4gICAgICAgIGNoYXJzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShjaGFycyksIFtjaGFyYWN0ZXJFbGVtZW50XSk7XG4gICAgICAgIHJldHVybiBjaGFyYWN0ZXJFbGVtZW50O1xuICAgICAgfSk7XG4gICAgfSAvLyBFTkQgSUY7XG5cblxuICAgIGlmICh0eXBlcy53b3JkcyB8fCB0eXBlcy5saW5lcykge1xuICAgICAgLy8gLT4gSWYgU3BsaXR0aW5nIFRleHQgSW50byBXb3Jkcy4uLlxuICAgICAgLy8gICAgQ3JlYXRlIGFuIGVsZW1lbnQgdG8gd3JhcCB0aGUgY3VycmVudCB3b3JkLiBJZiB3ZSBhcmUgYWxzb1xuICAgICAgLy8gICAgc3BsaXR0aW5nIHRleHQgaW50byBjaGFyYWN0ZXJzLCB0aGUgd29yZCBlbGVtZW50IHdpbGwgY29udGFpbiB0aGVcbiAgICAgIC8vICAgIHdyYXBwZWQgY2hhcmFjdGVyIG5vZGVzIGZvciB0aGlzIHdvcmQuIElmIG5vdCwgaXQgd2lsbCBjb250YWluIHRoZVxuICAgICAgLy8gICAgcGxhaW4gdGV4dCBjb250ZW50IChXT1JEKVxuICAgICAgd29yZEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFRBR19OQU1FLCB7XG4gICAgICAgIFwiY2xhc3NcIjogXCJcIi5jb25jYXQoc2V0dGluZ3Mud29yZENsYXNzLCBcIiBcIikuY29uY2F0KHNldHRpbmdzLnNwbGl0Q2xhc3MpLFxuICAgICAgICBzdHlsZTogXCJkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IFwiLmNvbmNhdCh0eXBlcy53b3JkcyAmJiBzZXR0aW5ncy5hYnNvbHV0ZSA/IFwicG9zaXRpb246IHJlbGF0aXZlO1wiIDogJycpLFxuICAgICAgICBjaGlsZHJlbjogdHlwZXMuY2hhcnMgPyBjaGFyYWN0ZXJFbGVtZW50c0ZvckN1cnJlbnRXb3JkIDogV09SRFxuICAgICAgfSk7XG4gICAgICBzZXQod29yZEVsZW1lbnQsIHtcbiAgICAgICAgaXNXb3JkOiB0cnVlLFxuICAgICAgICBpc1dvcmRTdGFydDogdHJ1ZSxcbiAgICAgICAgaXNXb3JkRW5kOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHNwbGl0VGV4dC5hcHBlbmRDaGlsZCh3b3JkRWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIC0+IElmIE5PVCBzcGxpdHRpbmcgaW50byB3b3JkcyBPUiBsaW5lcy4uLlxuICAgICAgLy8gICAgQXBwZW5kIHRoZSBjaGFyYWN0ZXJzIGVsZW1lbnRzIGRpcmVjdGx5IHRvIHNwbGl0VGV4dC5cbiAgICAgIGNoYXJhY3RlckVsZW1lbnRzRm9yQ3VycmVudFdvcmQuZm9yRWFjaChmdW5jdGlvbiAoY2hhcmFjdGVyRWxlbWVudCkge1xuICAgICAgICBzcGxpdFRleHQuYXBwZW5kQ2hpbGQoY2hhcmFjdGVyRWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaWR4IDwgYXJyLmxlbmd0aCAtIDEpIHtcbiAgICAgIC8vIEFkZCBhIHNwYWNlIGFmdGVyIHRoZSB3b3JkLlxuICAgICAgc3BsaXRUZXh0LmFwcGVuZCgnICcpO1xuICAgIH0gLy8gSWYgbm90IHNwbGl0dGluZyB0ZXh0IGludG8gd29yZHMsIHdlIHJldHVybiBhbiBlbXB0eSBhcnJheVxuXG5cbiAgICByZXR1cm4gdHlwZXMud29yZHMgPyByZXN1bHQuY29uY2F0KHdvcmRFbGVtZW50KSA6IHJlc3VsdDtcbiAgfSwgW10pOyAvLyBFTkQgTE9PUDtcbiAgLy8gQWRkIGEgdHJhaWxpbmcgd2hpdGUgc3BhY2UgdG8gbWFpbnRhaW4gd29yZCBzcGFjaW5nXG5cbiAgaWYgKC9cXHMkLy50ZXN0KFZBTFVFKSkge1xuICAgIHNwbGl0VGV4dC5hcHBlbmQoJyAnKTtcbiAgfVxuXG4gIHRleHROb2RlLnJlcGxhY2VXaXRoKHNwbGl0VGV4dCk7XG4gIHJldHVybiB7XG4gICAgd29yZHM6IHdvcmRzLFxuICAgIGNoYXJzOiBjaGFyc1xuICB9O1xufVxuXG4vKipcbiAqIFNwbGl0cyB0aGUgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IGVsZW1lbnQgaW50byB3b3JkcyBhbmQvb3IgY2hhcmFjdGVycy5cbiAqIFRoZSBmdW5jdGlvbiBpcyByZWN1cnNpdmUsIGl0IHdpbGwgYWxzbyBzcGxpdCB0aGUgdGV4dCBjb250ZW50IG9mIGFueSBjaGlsZFxuICogZWxlbWVudHMgaW50byB3b3Jkcy9jaGFyYWN0ZXJzLCB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBuZXN0ZWQgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIGFuIEhUTUwgRWxlbWVudCBvciBUZXh0IE5vZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nIHNwbGl0VHlwZSBzZXR0aW5nc1xuICovXG5cbmZ1bmN0aW9uIHNwbGl0KG5vZGUsIHNldHRpbmdzKSB7XG4gIHZhciB0eXBlID0gbm9kZS5ub2RlVHlwZTsgLy8gQXJyYXlzIG9mIHNwbGl0IHdvcmRzIGFuZCBjaGFyYWN0ZXJzXG5cbiAgdmFyIHdvcmRzQW5kQ2hhcnMgPSB7XG4gICAgd29yZHM6IFtdLFxuICAgIGNoYXJzOiBbXVxuICB9OyAvLyBPbmx5IHByb2NlZWQgaWYgYG5vZGVgIGlzIGFuIGBFbGVtZW50YCwgYEZyYWdtZW50YCwgb3IgYFRleHRgXG5cbiAgaWYgKCEvKDF8M3wxMSkvLnRlc3QodHlwZSkpIHtcbiAgICByZXR1cm4gd29yZHNBbmRDaGFycztcbiAgfSAvLyBBKSBJRiBgbm9kZWAgaXMgVGV4dE5vZGUgdGhhdCBjb250YWlucyBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gd2hpdGUgc3BhY2UuLi5cbiAgLy8gICAgU3BsaXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgbm9kZSBpbnRvIHdvcmRzIGFuZC9vciBjaGFyYWN0ZXJzXG4gIC8vICAgIHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgc3BsaXQgd29yZCBhbmQgY2hhcmFjdGVyIGVsZW1lbnRzXG5cblxuICBpZiAodHlwZSA9PT0gMyAmJiAvXFxTLy50ZXN0KG5vZGUubm9kZVZhbHVlKSkge1xuICAgIHJldHVybiBzcGxpdFdvcmRzQW5kQ2hhcnMobm9kZSwgc2V0dGluZ3MpO1xuICB9IC8vIEIpIEVMU0UgYG5vZGVgIGlzIGFuICdFbGVtZW50J1xuICAvLyAgICBJdGVyYXRlIHRocm91Z2ggaXRzIGNoaWxkIG5vZGVzLCBjYWxsaW5nIHRoZSBgc3BsaXRgIGZ1bmN0aW9uXG4gIC8vICAgIHJlY3Vyc2l2ZWx5IGZvciBlYWNoIGNoaWxkIG5vZGUuXG5cblxuICB2YXIgY2hpbGROb2RlcyA9IHRvQXJyYXkobm9kZS5jaGlsZE5vZGVzKTtcblxuICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICBzZXQobm9kZSwgJ2lzU3BsaXQnLCB0cnVlKTsgLy8gd2UgbmVlZCB0byBzZXQgYSBmZXcgc3R5bGVzIG9uIG5lc3RlZCBodG1sIGVsZW1lbnRzXG5cbiAgICBpZiAoIWdldChub2RlKS5pc1Jvb3QpIHtcbiAgICAgIG5vZGUuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7IC8vIFRvIG1haW50YWluIG9yaWdpbmFsIHNwYWNpbmcgYXJvdW5kIG5lc3RlZCBlbGVtZW50cyB3aGVuIHdlIGFyZVxuICAgICAgLy8gc3BsaXR0aW5nIHRleHQgaW50byBsaW5lcywgd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgZWxlbWVudCBzaG91bGRcbiAgICAgIC8vIGhhdmUgYSBzcGFjZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmQgc3RvcmUgdGhhdCB2YWx1ZSBmb3IgbGF0ZXIuXG4gICAgICAvLyBOb3RlOiB0aGlzIHdhcyBuZWNlc3NhcnkgdG8gbWFpbnRhaW4gdGhlIGNvcnJlY3Qgc3BhY2luZyB3aGVuIG5lc3RlZFxuICAgICAgLy8gZWxlbWVudHMgZG8gbm90IGFsaWduIHdpdGggd29yZCBib3VuZGFyaWVzLiBGb3IgZXhhbXBsZSwgYSBuZXN0ZWRcbiAgICAgIC8vIGVsZW1lbnQgb25seSB3cmFwcyBwYXJ0IG9mIGEgd29yZC5cblxuICAgICAgdmFyIG5leHRTaWJsaW5nID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIHZhciBwcmV2U2libGluZyA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgdmFyIHRleHQgPSBub2RlLnRleHRDb250ZW50IHx8ICcnO1xuICAgICAgdmFyIHRleHRBZnRlciA9IG5leHRTaWJsaW5nID8gbmV4dFNpYmxpbmcudGV4dENvbnRlbnQgOiAnICc7XG4gICAgICB2YXIgdGV4dEJlZm9yZSA9IHByZXZTaWJsaW5nID8gcHJldlNpYmxpbmcudGV4dENvbnRlbnQgOiAnICc7XG4gICAgICBzZXQobm9kZSwge1xuICAgICAgICBpc1dvcmRFbmQ6IC9cXHMkLy50ZXN0KHRleHQpIHx8IC9eXFxzLy50ZXN0KHRleHRBZnRlciksXG4gICAgICAgIGlzV29yZFN0YXJ0OiAvXlxccy8udGVzdCh0ZXh0KSB8fCAvXFxzJC8udGVzdCh0ZXh0QmVmb3JlKVxuICAgICAgfSk7XG4gICAgfVxuICB9IC8vIEl0ZXJhdGUgdGhyb3VnaCBjaGlsZCBub2RlcywgY2FsbGluZyBgc3BsaXRgIHJlY3Vyc2l2ZWx5XG4gIC8vIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHNwbGl0IHdvcmRzIGFuZCBjaGFyc1xuXG5cbiAgcmV0dXJuIGNoaWxkTm9kZXMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGNoaWxkKSB7XG4gICAgdmFyIF9zcGxpdCA9IHNwbGl0KGNoaWxkLCBzZXR0aW5ncyksXG4gICAgICAgIHdvcmRzID0gX3NwbGl0LndvcmRzLFxuICAgICAgICBjaGFycyA9IF9zcGxpdC5jaGFycztcblxuICAgIHJldHVybiB7XG4gICAgICB3b3JkczogW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZXN1bHQud29yZHMpLCBfdG9Db25zdW1hYmxlQXJyYXkod29yZHMpKSxcbiAgICAgIGNoYXJzOiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlc3VsdC5jaGFycyksIF90b0NvbnN1bWFibGVBcnJheShjaGFycykpXG4gICAgfTtcbiAgfSwgd29yZHNBbmRDaGFycyk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGVpZ2h0IGFuZCBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIG9mZnNldCBwYXJlbnQuXG4gKiBTaG91bGQgYmUgZXF1aXZhbGVudCB0byBvZmZzZXRUb3AgYW5kIG9mZnNldEhlaWdodCwgYnV0IHdpdGggc3ViLXBpeGVsXG4gKiBwcmVjaXNpb24uXG4gKlxuICogVE9ETyBuZWVkcyB3b3JrXG4gKi9cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUsIGlzV29yZCwgc2V0dGluZ3MsIHNjcm9sbFBvcykge1xuICBpZiAoIXNldHRpbmdzLmFic29sdXRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogaXNXb3JkID8gbm9kZS5vZmZzZXRUb3AgOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHZhciBwYXJlbnQgPSBub2RlLm9mZnNldFBhcmVudDtcblxuICB2YXIgX3Njcm9sbFBvcyA9IF9zbGljZWRUb0FycmF5KHNjcm9sbFBvcywgMiksXG4gICAgICBzY3JvbGxYID0gX3Njcm9sbFBvc1swXSxcbiAgICAgIHNjcm9sbFkgPSBfc2Nyb2xsUG9zWzFdO1xuXG4gIHZhciBwYXJlbnRYID0gMDtcbiAgdmFyIHBhcmVudFkgPSAwO1xuXG4gIGlmIChwYXJlbnQgJiYgcGFyZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgdmFyIHBhcmVudFJlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcGFyZW50WCA9IHBhcmVudFJlY3QueCArIHNjcm9sbFg7XG4gICAgcGFyZW50WSA9IHBhcmVudFJlY3QueSArIHNjcm9sbFk7XG4gIH1cblxuICB2YXIgX25vZGUkZ2V0Qm91bmRpbmdDbGllID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHdpZHRoID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLmhlaWdodCxcbiAgICAgIHggPSBfbm9kZSRnZXRCb3VuZGluZ0NsaWUueCxcbiAgICAgIHkgPSBfbm9kZSRnZXRCb3VuZGluZ0NsaWUueTtcblxuICB2YXIgdG9wID0geSArIHNjcm9sbFkgLSBwYXJlbnRZO1xuICB2YXIgbGVmdCA9IHggKyBzY3JvbGxYIC0gcGFyZW50WDtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgdG9wOiB0b3AsXG4gICAgbGVmdDogbGVmdFxuICB9O1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IFwidW4tc3BsaXRzXCIgdGV4dCBpbnRvIHdvcmRzLlxuICogVGhpcyBpcyB1c2VkIHdoZW4gc3BsaXR0aW5nIHRleHQgaW50byBsaW5lcyBidXQgbm90IHdvcmRzLlxuICogV2UgaW5pdGlhbGx5IHNwbGl0IHRoZSB0ZXh0IGludG8gd29yZHMgc28gd2UgY2FuIG1haW50YWluIHRoZSBjb3JyZWN0IGxpbmVcbiAqIGJyZWFrcy4gT25jZSB0ZXh0IGhhcyBiZWVuIHNwbGl0IGludG8gbGluZXMsIHdlIFwidW4tc3BsaXRcIiB0aGUgd29yZHMuLi5cbiAqIEBwYXJhbSB7RWxlbWVudH1cbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cblxuZnVuY3Rpb24gdW5TcGxpdFdvcmRzKGVsZW1lbnQpIHtcbiAgaWYgKCFnZXQoZWxlbWVudCkuaXNXb3JkKSB7XG4gICAgdG9BcnJheShlbGVtZW50LmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIHVuU3BsaXRXb3JkcyhjaGlsZCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQucmVwbGFjZVdpdGguYXBwbHkoZWxlbWVudCwgX3RvQ29uc3VtYWJsZUFycmF5KGVsZW1lbnQuY2hpbGROb2RlcykpO1xuICB9XG59XG5cbnZhciBjcmVhdGVGcmFnbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50KCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xufTtcblxuZnVuY3Rpb24gcmVwb3NpdGlvbkFmdGVyU3BsaXQoZWxlbWVudCwgc2V0dGluZ3MsIHNjcm9sbFBvcykge1xuICB2YXIgdHlwZXMgPSBwYXJzZVR5cGVzKHNldHRpbmdzLnR5cGVzKTtcbiAgdmFyIFRBR19OQU1FID0gc2V0dGluZ3MudGFnTmFtZTtcbiAgdmFyIG5vZGVzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpO1xuICB2YXIgd29yZHNJbkVhY2hMaW5lID0gW107XG4gIHZhciB3b3Jkc0luQ3VycmVudExpbmUgPSBbXTtcbiAgdmFyIGxpbmVPZmZzZXRZID0gbnVsbDtcbiAgdmFyIGVsZW1lbnRIZWlnaHQ7XG4gIHZhciBlbGVtZW50V2lkdGg7XG4gIHZhciBjb250ZW50Qm94O1xuICB2YXIgbGluZXMgPSBbXTtcbiAgLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqKiBHRVQgU1RZTEVTIEFORCBQT1NJVElPTlNcbiAgICoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAvLyBUaGVyZSBpcyBubyBidWlsdC1pbiB3YXkgdG8gZGV0ZWN0IG5hdHVyYWwgbGluZSBicmVha3MgaW4gdGV4dCAod2hlbiBhXG4gIC8vIGJsb2NrIG9mIHRleHQgd3JhcHMgdG8gZml0IGl0cyBjb250YWluZXIpLiBUbyBzcGxpdCB0ZXh0IGludG8gbGluZXMsIHdlXG4gIC8vIGhhdmUgdG8gZGV0ZWN0IGxpbmUgYnJlYWtzIGJ5IGNoZWNraW5nIHRoZSB0b3Agb2Zmc2V0IG9mIHdvcmRzLiBUaGlzIGlzXG4gIC8vIHdoeSB0ZXh0IHdhcyBzcGxpdCBpbnRvIHdvcmRzIGZpcnN0LiBUbyBhcHBseSBhYnNvbHV0ZVxuICAvLyBwb3NpdGlvbmluZywgaXRzIGFsc28gbmVjZXNzYXJ5IHRvIHJlY29yZCB0aGUgc2l6ZSBhbmQgcG9zaXRpb24gb2YgZXZlcnlcbiAgLy8gc3BsaXQgbm9kZSAobGluZXMsIHdvcmRzLCBjaGFyYWN0ZXJzKS5cbiAgLy8gVG8gY29uc29saWRhdGUgRE9NIGdldHRpbmcvc2V0dGluZ3MsIHRoaXMgaXMgYWxsIGRvbmUgYXQgdGhlIHNhbWUgdGltZSxcbiAgLy8gYmVmb3JlIGFjdHVhbGx5IHNwbGl0dGluZyB0ZXh0IGludG8gbGluZXMsIHdoaWNoIGludm9sdmVzIHJlc3RydWN0dXJpbmdcbiAgLy8gdGhlIERPTSBhZ2Fpbi5cbiAgLy8gQ2FjaGUgdGhlIGVsZW1lbnQncyBwYXJlbnQgYW5kIG5leHQgc2libGluZyAoZm9yIERPTSByZW1vdmFsKS5cblxuICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICB2YXIgbmV4dFNpYmxpbmcgPSBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZzsgLy8gYSB3cmFwcGVyIGZvciB0aGUgbmV3IEhUTUwgc3RydWN0dXJlXG5cbiAgdmFyIHNwbGl0VGV4dCA9IGNyZWF0ZUZyYWdtZW50KCk7IC8vIGdldCB0aGUgY29tcHV0ZWQgc3R5bGUgb2JqZWN0IGZvciB0aGUgZWxlbWVudFxuXG4gIHZhciBjcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB2YXIgYWxpZ24gPSBjcy50ZXh0QWxpZ247XG4gIHZhciBmb250U2l6ZSA9IHBhcnNlRmxvYXQoY3MuZm9udFNpemUpO1xuICB2YXIgbGluZVRocmVzaG9sZCA9IGZvbnRTaXplICogMC4yOyAvLyBJRiB1c2luZyBhYnNvbHV0ZSBwb3NpdGlvbi4uLlxuXG4gIGlmIChzZXR0aW5ncy5hYnNvbHV0ZSkge1xuICAgIC8vIExldCBjb250ZW50Qm94IGJlIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSB3aWR0aCBhbmQgb2Zmc2V0IHBvc2l0aW9uIG9mXG4gICAgLy8gdGhlIGVsZW1lbnQncyBjb250ZW50IGJveCAodGhlIGFyZWEgaW5zaWRlIHBhZGRpbmcgYm94KS4gVGhpcyBpcyBuZWVkZWRcbiAgICAvLyAoZm9yIGFic29sdXRlIHBvc2l0aW9uaW5nKSB0byBzZXQgdGhlIHdpZHRoIGFuZCBwb3NpdGlvbiBvZiBsaW5lXG4gICAgLy8gZWxlbWVudHMsIHdoaWNoIGhhdmUgbm90IGJlZW4gY3JlYXRlZCB5ZXQuXG4gICAgY29udGVudEJveCA9IHtcbiAgICAgIGxlZnQ6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICAgIHRvcDogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aFxuICAgIH07IC8vIExldCBlbGVtZW50V2lkdGggYW5kIGVsZW1lbnRIZWlnaHQgYmUgdGhlIGFjdHVhbCB3aWR0aC9oZWlnaHQgb2YgdGhlXG4gICAgLy8gZWxlbWVudC4gQWxzbyBjaGVjayBpZiB0aGUgZWxlbWVudCBoYXMgaW5saW5lIGhlaWdodCBvciB3aWR0aCBzdHlsZXNcbiAgICAvLyBhbHJlYWR5IHNldC4gSWYgaXQgZG9lcywgY2FjaGUgdGhvc2UgdmFsdWVzIGZvciBsYXRlci5cblxuICAgIGVsZW1lbnRXaWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgZWxlbWVudEhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0OyAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgaW5saW5lIGhlaWdodCBhbmQgd2lkdGggb2YgdGhlIGVsZW1lbnRcblxuICAgIHNldChlbGVtZW50LCB7XG4gICAgICBjc3NXaWR0aDogZWxlbWVudC5zdHlsZS53aWR0aCxcbiAgICAgIGNzc0hlaWdodDogZWxlbWVudC5zdHlsZS5oZWlnaHRcbiAgICB9KTtcbiAgfSAvLyBJdGVyYXRlIG92ZXIgZXZlcnkgbm9kZSBpbiB0aGUgdGFyZ2V0IGVsZW1lbnRcblxuXG4gIHRvQXJyYXkobm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAvLyBub2RlIGlzIGEgd29yZCBlbGVtZW50IG9yIGN1c3RvbSBodG1sIGVsZW1lbnRcbiAgICB2YXIgaXNXb3JkTGlrZSA9IG5vZGUucGFyZW50RWxlbWVudCA9PT0gZWxlbWVudDsgLy8gVE9ETyBuZWVkcyB3b3JrXG4gICAgLy8gR2V0IHRlIHNpemUgYW5kIHBvc2l0aW9uIG9mIHNwbGl0IHRleHQgbm9kZXNcblxuICAgIHZhciBfZ2V0UG9zaXRpb24gPSBnZXRQb3NpdGlvbihub2RlLCBpc1dvcmRMaWtlLCBzZXR0aW5ncywgc2Nyb2xsUG9zKSxcbiAgICAgICAgd2lkdGggPSBfZ2V0UG9zaXRpb24ud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9nZXRQb3NpdGlvbi5oZWlnaHQsXG4gICAgICAgIHRvcCA9IF9nZXRQb3NpdGlvbi50b3AsXG4gICAgICAgIGxlZnQgPSBfZ2V0UG9zaXRpb24ubGVmdDsgLy8gSWYgZWxlbWVudCBpcyBhIGA8YnI+YCB0YWcgcmV0dXJuIGhlcmVcblxuXG4gICAgaWYgKC9eYnIkL2kudGVzdChub2RlLm5vZGVOYW1lKSkgcmV0dXJuO1xuXG4gICAgaWYgKHR5cGVzLmxpbmVzICYmIGlzV29yZExpa2UpIHtcbiAgICAgIC8vIFdlIGNvbXBhcmUgdGhlIHRvcCBvZmZzZXQgb2YgdGhlIGN1cnJlbnQgd29yZCB0byB0aGUgdG9wIG9mZnNldCBvZlxuICAgICAgLy8gcHJldmlvdXMgd29yZHMgb24gdGhlIGN1cnJlbnQgbGluZS4gSWYgdGhlIGRpZmZlcmVuY2UgaXMgZ3JlYXRlciB0aGFuXG4gICAgICAvLyBvdXIgZGVmaW5lZCB0aHJlc2hvbGQgKDIwJSksIHdlIGFzc3VtZSB0aGlzIHdvcmQgaXMgb24gYSBuZXcgbGluZS5cbiAgICAgIGlmIChsaW5lT2Zmc2V0WSA9PT0gbnVsbCB8fCB0b3AgLSBsaW5lT2Zmc2V0WSA+PSBsaW5lVGhyZXNob2xkKSB7XG4gICAgICAgIGxpbmVPZmZzZXRZID0gdG9wO1xuICAgICAgICB3b3Jkc0luRWFjaExpbmUucHVzaCh3b3Jkc0luQ3VycmVudExpbmUgPSBbXSk7XG4gICAgICB9IC8vIEFkZCB0aGUgY3VycmVudCB3b3JkIG5vZGUgdG8gdGhlIGxpbmUgYXJyYXlcblxuXG4gICAgICB3b3Jkc0luQ3VycmVudExpbmUucHVzaChub2RlKTtcbiAgICB9IC8vIEVORCBJRlxuXG5cbiAgICBpZiAoc2V0dGluZ3MuYWJzb2x1dGUpIHtcbiAgICAgIC8vIFN0b3JlIHRoZSBzaXplIGFuZCBwb3NpdGlvbiBzcGxpdCB0ZXh0IG5vZGVzXG4gICAgICBzZXQobm9kZSwge1xuICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICB9KTsgLy8gRU5EIExPT1BcbiAgLy8gUmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gdGhlIERPTVxuXG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gIH1cbiAgLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqKiBTUExJVCBMSU5FU1xuICAgKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuICBpZiAodHlwZXMubGluZXMpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgbGluZXMgb2YgdGV4dCAoc2VlIDExIGIpXG4gICAgLy8gTGV0IGBsaW5lYCBiZSB0aGUgYXJyYXkgb2Ygd29yZHMgaW4gdGhlIGN1cnJlbnQgbGluZS5cbiAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgdGhlIHdyYXBwZWQgbGluZSBlbGVtZW50cyAobGluZUVsZW1lbnRzKVxuICAgIGxpbmVzID0gd29yZHNJbkVhY2hMaW5lLm1hcChmdW5jdGlvbiAod29yZHNJblRoaXNMaW5lKSB7XG4gICAgICAvLyBDcmVhdGUgYW4gZWxlbWVudCB0byB3cmFwIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICB2YXIgbGluZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFRBR19OQU1FLCB7XG4gICAgICAgIFwiY2xhc3NcIjogXCJcIi5jb25jYXQoc2V0dGluZ3Muc3BsaXRDbGFzcywgXCIgXCIpLmNvbmNhdChzZXR0aW5ncy5saW5lQ2xhc3MpLFxuICAgICAgICBzdHlsZTogXCJkaXNwbGF5OiBibG9jazsgdGV4dC1hbGlnbjogXCIuY29uY2F0KGFsaWduLCBcIjsgd2lkdGg6IDEwMCU7XCIpXG4gICAgICB9KTtcbiAgICAgIHNldChsaW5lRWxlbWVudCwgJ2lzTGluZScsIHRydWUpO1xuICAgICAgdmFyIGxpbmVEaW1lbnNpb25zID0ge1xuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHRvcDogMWU0XG4gICAgICB9OyAvLyBBcHBlbmQgdGhlIGBsaW5lRWxlbWVudGAgdG8gYGNvbnRhaW5lcmBcblxuICAgICAgc3BsaXRUZXh0LmFwcGVuZENoaWxkKGxpbmVFbGVtZW50KTsgLy8gSXRlcmF0ZSBvdmVyIHRoZSB3b3JkLWxldmVsIGVsZW1lbnRzIGluIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICAvLyBOb3RlOiB3b3JkT3JFbGVtZW50IGNhbiBlaXRoZXIgYmUgYSB3b3JkIG5vZGUgb3IgbmVzdGVkIGVsZW1lbnRcblxuICAgICAgd29yZHNJblRoaXNMaW5lLmZvckVhY2goZnVuY3Rpb24gKHdvcmRPckVsZW1lbnQsIGlkeCwgYXJyKSB7XG4gICAgICAgIHZhciBfZGF0YSRnZXQgPSBnZXQod29yZE9yRWxlbWVudCksXG4gICAgICAgICAgICBpc1dvcmRFbmQgPSBfZGF0YSRnZXQuaXNXb3JkRW5kLFxuICAgICAgICAgICAgdG9wID0gX2RhdGEkZ2V0LnRvcCxcbiAgICAgICAgICAgIGhlaWdodCA9IF9kYXRhJGdldC5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIG5leHQgPSBhcnJbaWR4ICsgMV07IC8vIERldGVybWluZSBsaW5lIGhlaWdodCAvIHktcG9zaXRpb25cbiAgICAgICAgLy8gd2UgdXNlIHRoZSBoZWlnaHQgYW5kIG9mZnNldFRvcCBvZiB0aGUgd29yZHMgd2hpY2ggd2UgYWxyZWFkeVxuICAgICAgICAvLyByZWNvcmRlZC4gQmVjYXVzZSBjdXN0b20gbmVzdGVkIGVsZW1lbnRzIGNvdWxkIGhhdmUgdGhlaXIgb3duXG4gICAgICAgIC8vIHN0eWxlcywgdGhlIHdvcmRzIG9uIGEgbGluZSBtYXkgbm90IGFsbCBiZSB0aGUgc2FtZSBoZWlnaHQgb3JcbiAgICAgICAgLy8geSBwb3NpdGlvbi4gU28gd2UgdGFrZSB0aGUgZ3JlYXRlc3QgaGVpZ2h0IC8geSAtIG9mZnNldCBvZiB0aGVcbiAgICAgICAgLy8gd29yZHMgb24gdGhpcyBsaW5lLlxuXG4gICAgICAgIGxpbmVEaW1lbnNpb25zLmhlaWdodCA9IE1hdGgubWF4KGxpbmVEaW1lbnNpb25zLmhlaWdodCwgaGVpZ2h0KTtcbiAgICAgICAgbGluZURpbWVuc2lvbnMudG9wID0gTWF0aC5taW4obGluZURpbWVuc2lvbnMudG9wLCB0b3ApOyAvLyBhcHBlbmQgdGhlIGN1cnJlbnQgd29yZC9lbGVtZW50XG5cbiAgICAgICAgbGluZUVsZW1lbnQuYXBwZW5kQ2hpbGQod29yZE9yRWxlbWVudCk7IC8vIERldGVybWluZSBpZiB0aGVyZSBzaG91bGQgc3BhY2UgYWZ0ZXIgdGhlIGN1cnJlbnQgZWxlbWVudC4uLlxuICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCB0aGUgbGFzdCB3b3JkIG9uIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICAgIC8vIFRPRE8gLSBsb2dpYyBmb3IgaGFuZGluZyBzcGFjaW5nIGNhbiBiZSBpbXByb3ZlZFxuXG4gICAgICAgIGlmIChpc1dvcmRFbmQgJiYgZ2V0KG5leHQpLmlzV29yZFN0YXJ0KSB7XG4gICAgICAgICAgbGluZUVsZW1lbnQuYXBwZW5kKCcgJyk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBFTkQgTE9PUFxuXG4gICAgICBpZiAoc2V0dGluZ3MuYWJzb2x1dGUpIHtcbiAgICAgICAgc2V0KGxpbmVFbGVtZW50LCB7XG4gICAgICAgICAgaGVpZ2h0OiBsaW5lRGltZW5zaW9ucy5oZWlnaHQsXG4gICAgICAgICAgdG9wOiBsaW5lRGltZW5zaW9ucy50b3BcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaW5lRWxlbWVudDtcbiAgICB9KTsgLy8gRU5EIExPT1BcblxuICAgIGlmICghdHlwZXMud29yZHMpIHtcbiAgICAgIHVuU3BsaXRXb3JkcyhzcGxpdFRleHQpO1xuICAgIH0gLy8gMTAuIEluc2VydCB0aGUgbmV3IGNvbnRhaW5lclxuXG5cbiAgICBlbGVtZW50LnJlcGxhY2VDaGlsZHJlbihzcGxpdFRleHQpO1xuICB9XG4gIC8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiogIFNFVCBBQlNPTFVURSBQT1NJVElPTlxuICAgKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIC8vIEFwcGx5IGFic29sdXRlIHBvc2l0aW9uaW5nIHRvIGFsbCBjaGlsZCBlbGVtZW50cyBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gIC8vIFRoaXMgaW5jbHVkZXMgc3BsaXQgbGluZXMsIHdvcmRzLCBjaGFycywgYW5kIGN1c3RvbSBIVE1MIGVsZW1lbnRzIHRoYXQgd2VyZVxuICAvLyBpbmNsdWRlZCBieSB0aGUgdXNlci4gVGhlIHNpemUgYW5kIHBvc2l0aW9uIG9mIGNoaWxkIGVsZW1lbnRzIGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gcmVjb3JkZWQgYmVmb3JlIHNwbGl0dGluZyB0ZXh0IGludG8gbGluZXMuXG5cblxuICBpZiAoc2V0dGluZ3MuYWJzb2x1dGUpIHtcbiAgICAvLyBTZXQgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgcGFyZW50IGVsZW1lbnQgc28gaXQgZG9lcyBub3QgY29sbGFwc2VcbiAgICAvLyB3aGVuIGl0cyBjaGlsZHJlbiBhcmUgc2V0IHRvIGFic29sdXRlIHBvc2l0aW9uLlxuICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdChlbGVtZW50LnN0eWxlLndpZHRoIHx8IGVsZW1lbnRXaWR0aCwgXCJweFwiKTtcbiAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGVsZW1lbnRIZWlnaHQsIFwicHhcIik7IC8vIEl0ZXJhdGUgb3ZlciBhbGwgY2hpbGQgZWxlbWVudHNcblxuICAgIHRvQXJyYXkobm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBfZGF0YSRnZXQyID0gZ2V0KG5vZGUpLFxuICAgICAgICAgIGlzTGluZSA9IF9kYXRhJGdldDIuaXNMaW5lLFxuICAgICAgICAgIHRvcCA9IF9kYXRhJGdldDIudG9wLFxuICAgICAgICAgIGxlZnQgPSBfZGF0YSRnZXQyLmxlZnQsXG4gICAgICAgICAgd2lkdGggPSBfZGF0YSRnZXQyLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF9kYXRhJGdldDIuaGVpZ2h0O1xuXG4gICAgICB2YXIgcGFyZW50RGF0YSA9IGdldChub2RlLnBhcmVudEVsZW1lbnQpO1xuICAgICAgdmFyIGlzQ2hpbGRPZkxpbmVOb2RlID0gIWlzTGluZSAmJiBwYXJlbnREYXRhLmlzTGluZTsgLy8gU2V0IHRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgIC8vIC0+IElmIGBub2RlYCBhIGxpbmUgZWxlbWVudCwgd2UgdXNlIHRoZSB0b3Agb2Zmc2V0IG9mIGl0cyBmaXJzdCBjaGlsZFxuICAgICAgLy8gLT4gSWYgYG5vZGVgIHRoZSBjaGlsZCBvZiBsaW5lIGVsZW1lbnQsIHRoZW4gaXRzIHRvcCBvZmZzZXQgaXMgemVyb1xuXG4gICAgICBub2RlLnN0eWxlLnRvcCA9IFwiXCIuY29uY2F0KGlzQ2hpbGRPZkxpbmVOb2RlID8gdG9wIC0gcGFyZW50RGF0YS50b3AgOiB0b3AsIFwicHhcIik7IC8vIFNldCB0aGUgbGVmdCBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBub2RlLlxuICAgICAgLy8gLT4gSUYgYG5vZGVgIGlzIGEgbGluZSBlbGVtZW50LCB0aGlzIGlzIGVxdWFsIHRvIHRoZSBwb3NpdGlvbiBsZWZ0IG9mXG4gICAgICAvLyAgICB0aGUgY29udGVudCBib3ggb2YgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgICAvLyAtPiBJRiBgbm9kZWAgaXMgdGhlIGNoaWxkIG9mIGEgbGluZSBlbGVtZW50LCB0aGUgdmFsdWUgaGFzIHRvIGFkanVzdGVkXG4gICAgICAvLyAgICBzbyBpdHMgcmVsYXRpdmUgdG8gdGhlIGxpbmUgZWxlbWVudFxuXG4gICAgICBub2RlLnN0eWxlLmxlZnQgPSBpc0xpbmUgPyBcIlwiLmNvbmNhdChjb250ZW50Qm94LmxlZnQsIFwicHhcIikgOiBcIlwiLmNvbmNhdChsZWZ0IC0gKGlzQ2hpbGRPZkxpbmVOb2RlID8gY29udGVudEJveC5sZWZ0IDogMCksIFwicHhcIik7IC8vIFNldCB0aGUgaGVpZ2h0IG9mIHRoZSBjdXJyZW50IG5vZGUgdG8gdGhlIGNhY2hlZCB2YWx1ZS5cblxuICAgICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIik7IC8vICBTZXQgdGhlIHdpZHRoIG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgICAvLyAgSWYgaXRzIGEgbGluZSBlbGVtZW50LCB3aWR0aCBpcyBlcXVhbCB0byB0aGUgd2lkdGggb2YgdGhlIGNvbnRlbnRCb3guXG5cbiAgICAgIG5vZGUuc3R5bGUud2lkdGggPSBpc0xpbmUgPyBcIlwiLmNvbmNhdChjb250ZW50Qm94LndpZHRoLCBcInB4XCIpIDogXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIik7IC8vIEZpbmFsbHksIHNldCB0aGUgbm9kZSdzIHBvc2l0aW9uIHRvIGFic29sdXRlLlxuXG4gICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB9KTtcbiAgfSAvLyBlbmQgaWY7XG4gIC8vIDE0LiBSZS1hdHRhY2ggdGhlIGVsZW1lbnQgdG8gdGhlIERPTVxuXG5cbiAgaWYgKHBhcmVudCkge1xuICAgIGlmIChuZXh0U2libGluZykgcGFyZW50Lmluc2VydEJlZm9yZShlbGVtZW50LCBuZXh0U2libGluZyk7ZWxzZSBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gbGluZXM7XG59XG5cbnZhciBfZGVmYXVsdHMgPSBleHRlbmQoZGVmYXVsdHMsIHt9KTtcblxudmFyIFNwbGl0VHlwZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIF9jcmVhdGVDbGFzcyhTcGxpdFR5cGUsIG51bGwsIFt7XG4gICAga2V5OiBcImNsZWFyRGF0YVwiLFxuXG4gICAgLyoqXG4gICAgICogQ0xlYXJzIGFsbCBkYXRhXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyRGF0YSgpIHtcbiAgICAgIGNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHNldHRpbmdzIGZvciBhbGwgc3BsaXRUeXBlIGluc3RhbmNlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNldERlZmF1bHRzXCIsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkZWZhdWx0IHNldHRpbmdzIGZvciBhbGwgU3BsaXRUeXBlIGluc3RhbmNlcy5cbiAgICAgKiBUaGUgcHJvdmlkZWQgb2JqZWN0IHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIGV4aXN0aW5nIGRlZmF1bHRzIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNldHRpbmdzIHRvIG92ZXJyaWRlXG4gICAgICogQHJldHVybnMge09iamVjdH0gdGhlIG5ldyBkZWZhdWx0IHNldHRpbmdzXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFNwbGl0VHlwZS5zZXREZWZhdWx0cyh7IFwicG9zaXRpb25cIjogXCJhYnNvbHV0ZVwiIH0pXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERlZmF1bHRzKG9wdGlvbnMpIHtcbiAgICAgIF9kZWZhdWx0cyA9IGV4dGVuZChfZGVmYXVsdHMsIHBhcnNlU2V0dGluZ3Mob3B0aW9ucykpO1xuICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXZlcnQgdGFyZ2V0IGVsZW1lbnRzIHRvIHRoZWlyIG9yaWdpbmFsIGh0bWwgY29udGVudFxuICAgICAqIEhhcyBubyBlZmZlY3Qgb24gdGhhdFxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGVsZW1lbnRzIFRoZSB0YXJnZXQgZWxlbWVudHMgdG8gcmV2ZXJ0LiBPbmUgb2Y6XG4gICAgICogIC0ge3N0cmluZ30gQSBjc3Mgc2VsZWN0b3JcbiAgICAgKiAgLSB7SFRNTEVsZW1lbnR9IEEgc2luZ2xlIGVsZW1lbnRcbiAgICAgKiAtICB7Tm9kZUxpc3R9IEEgTm9kZUxpc3Qgb3IgY29sbGVjdGlvblxuICAgICAqICAtIHtIVE1MRWxlbWVudFtdfSBBbiBhcnJheSBvZiBFbGVtZW50c1xuICAgICAqIC0gIHtBcnJheTxIVE1MRWxlbWVudHxOb2RlTGlzdHxIVE1MRWxlbWVudFtdPn0gQSBuZXN0ZWQgYXJyYXkgb2YgZWxlbWVudHNcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXZlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2ZXJ0KGVsZW1lbnRzKSB7XG4gICAgICBnZXRUYXJnZXRFbGVtZW50cyhlbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgX2RhdGEkZ2V0ID0gZ2V0KGVsZW1lbnQpLFxuICAgICAgICAgICAgaXNTcGxpdCA9IF9kYXRhJGdldC5pc1NwbGl0LFxuICAgICAgICAgICAgaHRtbCA9IF9kYXRhJGdldC5odG1sLFxuICAgICAgICAgICAgY3NzV2lkdGggPSBfZGF0YSRnZXQuY3NzV2lkdGgsXG4gICAgICAgICAgICBjc3NIZWlnaHQgPSBfZGF0YSRnZXQuY3NzSGVpZ2h0O1xuXG4gICAgICAgIGlmIChpc1NwbGl0KSB7XG4gICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBjc3NXaWR0aCB8fCAnJztcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IGNzc0hlaWdodCB8fCAnJztcbiAgICAgICAgICByZW1vdmUoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNwbGl0VHlwZSBpbnN0YW5jZVxuICAgICAqIFRoaXMgc3RhdGljIG1ldGhvZCBwcm92aWRlcyBhIHdheSB0byBjcmVhdGUgYSBgU3BsaXRUeXBlYCBpbnN0YW5jZSB3aXRob3V0XG4gICAgICogdXNpbmcgdGhlIGBuZXdgIGtleXdvcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gdGFyZ2V0IFRoZSB0YXJnZXQgZWxlbWVudHMgdG8gc3BsaXQuIE9uZSBvZjpcbiAgICAgKiAgLSB7c3RyaW5nfSBBIGNzcyBzZWxlY3RvclxuICAgICAqICAtIHtIVE1MRWxlbWVudH0gQSBzaW5nbGUgZWxlbWVudFxuICAgICAqIC0gIHtOb2RlTGlzdH0gQSBOb2RlTGlzdCBvciBjb2xsZWN0aW9uXG4gICAgICogIC0ge0hUTUxFbGVtZW50W119IEFuIGFycmF5IG9mIEVsZW1lbnRzXG4gICAgICogLSAge0FycmF5PEhUTUxFbGVtZW50fE5vZGVMaXN0fEhUTUxFbGVtZW50W10+fSBBIG5lc3RlZCBhcnJheSBvZiBlbGVtZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gU2V0dGluZ3MgZm9yIHRoZSBTcGxpdFR5cGUgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtTcGxpdFR5cGV9IHRoZSBTcGxpdFR5cGUgaW5zdGFuY2VcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyBTcGxpdFR5cGUodGFyZ2V0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgU3BsaXRUeXBlYCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGVsZW1lbnRzIFRoZSB0YXJnZXQgZWxlbWVudHMgdG8gc3BsaXQuIE9uZSBvZjpcbiAgICAgKiAgLSB7c3RyaW5nfSBBIGNzcyBzZWxlY3RvclxuICAgICAqICAtIHtIVE1MRWxlbWVudH0gQSBzaW5nbGUgZWxlbWVudFxuICAgICAqIC0gIHtOb2RlTGlzdH0gQSBOb2RlTGlzdCBvciBjb2xsZWN0aW9uXG4gICAgICogIC0ge0hUTUxFbGVtZW50W119IEFuIGFycmF5IG9mIEVsZW1lbnRzXG4gICAgICogLSAge0FycmF5PEhUTUxFbGVtZW50fE5vZGVMaXN0fEhUTUxFbGVtZW50W10+fSBBIG5lc3RlZCBhcnJheSBvZiBlbGVtZW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gU2V0dGluZ3MgZm9yIHRoZSBTcGxpdFR5cGUgaW5zdGFuY2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRhdGFcIixcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcm5hbCBkYXRhIHN0b3JlXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlZmF1bHRzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2RlZmF1bHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkZWZhdWx0IHNldHRpbmdzIGZvciBhbGwgU3BsaXRUeXBlIGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgYFNwbGl0VHlwZS5kZWZhdWx0c2AgdG8gYW4gb2JqZWN0IHdpbGwgbWVyZ2UgdGhhdCBvYmplY3Qgd2l0aCB0aGVcbiAgICAgKiBleGlzdGluZyBkZWZhdWx0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5ncyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgc2V0dGluZ3MgdG8gb3ZlcnJpZGVcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFNwbGl0VHlwZS5kZWZhdWx0cyA9IHsgXCJwb3NpdGlvblwiOiBcImFic29sdXRlXCIgfVxuICAgICAqL1xuICAgICxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChvcHRpb25zKSB7XG4gICAgICBfZGVmYXVsdHMgPSBleHRlbmQoX2RlZmF1bHRzLCBwYXJzZVNldHRpbmdzKG9wdGlvbnMpKTtcbiAgICB9XG4gIH1dKTtcblxuICBmdW5jdGlvbiBTcGxpdFR5cGUoZWxlbWVudHMsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3BsaXRUeXBlKTtcblxuICAgIHRoaXMuaXNTcGxpdCA9IGZhbHNlO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBleHRlbmQoX2RlZmF1bHRzLCBwYXJzZVNldHRpbmdzKG9wdGlvbnMpKTtcbiAgICB0aGlzLmVsZW1lbnRzID0gZ2V0VGFyZ2V0RWxlbWVudHMoZWxlbWVudHMpOyAvLyBTdGFydCB0aGUgc3BsaXQgcHJvY2Vzc1xuXG4gICAgdGhpcy5zcGxpdCgpO1xuICB9XG4gIC8qKlxuICAgKiBTcGxpdHMgdGhlIHRleHQgaW4gYWxsIHRhcmdldCBlbGVtZW50cy4gVGhpcyBtZXRob2QgaXMgY2FsbGVkXG4gICAqIGF1dG9tYXRpY2FsbHkgd2hlbiBhIG5ldyBTcGxpdFR5cGUgaW5zdGFuY2UgaXMgY3JlYXRlZC4gSXQgY2FuIGFsc28gYmVcbiAgICogY2FsbGVkIG1hbnVhbGx5IHRvIHJlLXNwbGl0IHRleHQgd2l0aCBuZXcgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHB1YmxpY1xuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhTcGxpdFR5cGUsIFt7XG4gICAga2V5OiBcInNwbGl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0JDEob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy8gUmV2ZXJ0IHRhcmdldCBlbGVtZW50cyAoaWYgdGhleSBhcmUgYWxyZWFkeSBzcGxpdClcbiAgICAgIC8vIE5vdGU6IHJldmVydCB3YXMgYWxyZWFkeSBjYWxsZWQgb25jZSBpbiB0aGUgY29uc3RydWN0b3IuIEhvd2V2ZXIsIHdlXG4gICAgICAvLyBuZWVkIHRvIGNhbGwgaXQgYWdhaW4gaGVyZSBzbyB0ZXh0IGlzIHJldmVydGVkIHdoZW4gdGhlIHVzZXIgbWFudWFsbHlcbiAgICAgIC8vIGNhbGxzIHRoZSBgc3BsaXRgIG1ldGhvZCB0byByZS1zcGxpdCB0ZXh0LlxuICAgICAgdGhpcy5yZXZlcnQoKTsgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIGh0bWwgY29udGVudCBvZiBlYWNoIHRhcmdldCBlbGVtZW50XG5cbiAgICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBzZXQoZWxlbWVudCwgJ2h0bWwnLCBlbGVtZW50LmlubmVySFRNTCk7XG4gICAgICB9KTsgLy8gQ3JlYXRlIGFycmF5cyB0byBob2xkIHRoZSBzcGxpdCBsaW5lcywgd29yZHMsIGFuZCBjaGFyYWN0ZXJzXG5cbiAgICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICAgIHRoaXMud29yZHMgPSBbXTtcbiAgICAgIHRoaXMuY2hhcnMgPSBbXTsgLy8gY2FjaGUgdmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uIGJlZm9yZSBzcGxpdHRpbmdcblxuICAgICAgdmFyIHNjcm9sbFBvcyA9IFt3aW5kb3cucGFnZVhPZmZzZXQsIHdpbmRvdy5wYWdlWU9mZnNldF07IC8vIElmIG5ldyBvcHRpb25zIHdlcmUgcGFzc2VkIGludG8gdGhlIGBzcGxpdCgpYCBtZXRob2QsIHVwZGF0ZSBzZXR0aW5nc1xuXG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBleHRlbmQodGhpcy5zZXR0aW5ncywgcGFyc2VTZXR0aW5ncyhvcHRpb25zKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlcyA9IHBhcnNlVHlwZXModGhpcy5zZXR0aW5ncy50eXBlcyk7IC8vIElmIHRoZSBgdHlwZXNgIG9wdGlvbiBpcyBzZXQgdG8gYW4gZW1wdHkgYXJyYXksIHRleHQgd2lsbCBub3QgYmUgc3BsaXQuXG4gICAgICAvLyBAZXhhbXBsZSBuZXcgU3BsaXRUeXBlKCcjdGFyZ2V0JywgeyB0eXBlczogW10gfSlcblxuICAgICAgaWYgKHR5cGVzLm5vbmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBTcGxpdCB0ZXh0IGluIGVhY2ggdGFyZ2V0IGVsZW1lbnRcblxuXG4gICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBzcGxpdCB0ZXh0IG5vZGVzIGZyb20gdGhpcyBlbGVtZW50IHRvIHRoZSBhcnJheXMgb2YgYWxsIHNwbGl0XG4gICAgICAgIC8vIHRleHQgbm9kZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgIHNldChlbGVtZW50LCAnaXNSb290JywgdHJ1ZSk7XG5cbiAgICAgICAgdmFyIF9zcGxpdDIgPSBzcGxpdChlbGVtZW50LCBfdGhpcy5zZXR0aW5ncyksXG4gICAgICAgICAgICB3b3JkcyA9IF9zcGxpdDIud29yZHMsXG4gICAgICAgICAgICBjaGFycyA9IF9zcGxpdDIuY2hhcnM7XG5cbiAgICAgICAgX3RoaXMud29yZHMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KF90aGlzLndvcmRzKSwgX3RvQ29uc3VtYWJsZUFycmF5KHdvcmRzKSk7XG4gICAgICAgIF90aGlzLmNoYXJzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShfdGhpcy5jaGFycyksIF90b0NvbnN1bWFibGVBcnJheShjaGFycykpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVzLmxpbmVzIHx8IF90aGlzLnNldHRpbmdzLmFic29sdXRlKSB7XG4gICAgICAgICAgdmFyIGxpbmVzID0gcmVwb3NpdGlvbkFmdGVyU3BsaXQoZWxlbWVudCwgX3RoaXMuc2V0dGluZ3MsIHNjcm9sbFBvcyk7XG4gICAgICAgICAgX3RoaXMubGluZXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KF90aGlzLmxpbmVzKSwgX3RvQ29uc3VtYWJsZUFycmF5KGxpbmVzKSk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBTZXQgaXNTcGxpdCB0byB0cnVlIGZvciB0aGUgU3BsaXRUeXBlIGluc3RhbmNlXG5cbiAgICAgIHRoaXMuaXNTcGxpdCA9IHRydWU7IC8vIFNldCBzY3JvbGwgcG9zaXRpb24gdG8gY2FjaGVkIHZhbHVlLlxuXG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oc2Nyb2xsUG9zWzBdLCBzY3JvbGxQb3NbMV0pOyAvLyBDbGVhbiB1cCBzdG9yZWQgZGF0YVxuXG4gICAgICBjbGVhbnVwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldmVydHMgdGFyZ2V0IGVsZW1lbnQocykgYmFjayB0byB0aGVpciBvcmlnaW5hbCBodG1sIGNvbnRlbnRcbiAgICAgKiBEZWxldGVzIGFsbCBzdG9yZWQgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIHRhcmdldCBlbGVtZW50c1xuICAgICAqIFJlc2V0cyB0aGUgcHJvcGVydGllcyBvbiB0aGUgc3BsaXRUeXBlIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXZlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2ZXJ0KCkge1xuICAgICAgaWYgKHRoaXMuaXNTcGxpdCkge1xuICAgICAgICAvLyBSZXNldCBpbnN0YW5jZSBwcm9wZXJ0aWVzIGlmIG5lY2Vzc2FyeVxuICAgICAgICB0aGlzLmxpbmVzID0gbnVsbDtcbiAgICAgICAgdGhpcy53b3JkcyA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hhcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmlzU3BsaXQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgU3BsaXRUeXBlLnJldmVydCh0aGlzLmVsZW1lbnRzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3BsaXRUeXBlO1xufSgpO1xuXG5leHBvcnQgeyBTcGxpdFR5cGUgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbImFwcGVuZCIsImxlbmd0aCIsImFyZ3VtZW50cyIsImkiLCJub2RlIiwidW5kZWZpbmVkIiwibm9kZVR5cGUiLCJhcHBlbmRDaGlsZCIsImRvY3VtZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJTdHJpbmciLCJyZXBsYWNlQ2hpbGRyZW4iLCJsYXN0Q2hpbGQiLCJyZW1vdmVDaGlsZCIsImFwcGx5IiwicmVwbGFjZVdpdGgiLCJwYXJlbnQiLCJwYXJlbnROb2RlIiwiX2xlbiIsIm5vZGVzIiwiQXJyYXkiLCJfa2V5Iiwib3duZXJEb2N1bWVudCIsInJlcGxhY2VDaGlsZCIsImluc2VydEJlZm9yZSIsInByZXZpb3VzU2libGluZyIsIkVsZW1lbnQiLCJwcm90b3R5cGUiLCJEb2N1bWVudEZyYWdtZW50IiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJ2YWx1ZSIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicHVzaCIsIl9vYmplY3RTcHJlYWQyIiwic291cmNlIiwiZm9yRWFjaCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVNwcmVhZCIsImlzQXJyYXkiLCJfYXJyYXlMaWtlVG9BcnJheSIsIml0ZXIiLCJTeW1ib2wiLCJpdGVyYXRvciIsImZyb20iLCJfYXJyIiwiX24iLCJfZCIsIl9lIiwiX2kiLCJfcyIsIm5leHQiLCJkb25lIiwiZXJyIiwibyIsIm1pbkxlbiIsIm4iLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsInRlc3QiLCJsZW4iLCJhcnIyIiwiZXh0ZW5kIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInJlZHVjZSIsImV4dGVuZGVkIiwiY3VycmVudFZhbHVlIiwibmV3VmFsdWUiLCJpc1N0cmluZyIsInBhcnNlU2V0dGluZ3MiLCJzZXR0aW5ncyIsInR5cGVzIiwic3BsaXQiLCJtYXAiLCJ0eXBlIiwidHJpbSIsImFic29sdXRlIiwicG9zaXRpb24iLCJwYXJzZVR5cGVzIiwibm9uZSIsImxpbmVzIiwid29yZHMiLCJjaGFycyIsImlzT2JqZWN0IiwiaXNOb2RlIiwiaW5wdXQiLCJpc0xlbmd0aCIsImlzQXJyYXlMaWtlIiwidG9BcnJheSIsImdldFRhcmdldEVsZW1lbnRzIiwiZWxlbWVudHMiLCJnZXRFbGVtZW50QnlJZCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJyZXN1bHQiLCJlbGVtZW50IiwiY29uY2F0IiwiZW50cmllcyIsImV4cGFuZG8iLCJjYWNoZSIsInVpZCIsInNldCIsIm93bmVyIiwiY29uc29sZSIsIndhcm4iLCJpZCIsImRhdGEiLCJnZXRQcm90b3R5cGVPZiIsImdldCIsInJlbW92ZSIsImNsZWFyIiwiY2xlYW51cCIsIl9yZWYiLCJfcmVmMiIsIl9yZWYyJCIsImlzUm9vdCIsImlzU3BsaXQiLCJ0b1dvcmRzIiwic2VwYXJhdG9yIiwic3RyaW5nIiwicmVwbGFjZSIsInJzQXN0cmFsUmFuZ2UiLCJyc0NvbWJvTWFya3NSYW5nZSIsInJzQ29tYm9TeW1ib2xzUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNBc3RyYWwiLCJyc0NvbWJvIiwicnNGaXR6IiwicnNNb2RpZmllciIsInJzTm9uQXN0cmFsIiwicnNSZWdpb25hbCIsInJzU3VyclBhaXIiLCJyc1pXSiIsInJlT3B0TW9kIiwicnNPcHRWYXIiLCJyc09wdEpvaW4iLCJqb2luIiwicnNTZXEiLCJyc1N5bWJvbCIsInJlVW5pY29kZSIsIlJlZ0V4cCIsInVuaWNvZGVSYW5nZSIsInJlSGFzVW5pY29kZSIsImFzY2lpVG9BcnJheSIsImhhc1VuaWNvZGUiLCJ1bmljb2RlVG9BcnJheSIsIm1hdGNoIiwic3RyaW5nVG9BcnJheSIsInRvQ2hhcnMiLCJjcmVhdGVFbGVtZW50IiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZSIsInJhd1ZhbHVlIiwic2V0QXR0cmlidXRlIiwiZGVmYXVsdHMiLCJzcGxpdENsYXNzIiwibGluZUNsYXNzIiwid29yZENsYXNzIiwiY2hhckNsYXNzIiwidGFnTmFtZSIsInNwbGl0V29yZHNBbmRDaGFycyIsInRleHROb2RlIiwiVEFHX05BTUUiLCJWQUxVRSIsIm5vZGVWYWx1ZSIsInNwbGl0VGV4dCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJXT1JEIiwiaWR4Iiwid29yZEVsZW1lbnQiLCJjaGFyYWN0ZXJFbGVtZW50c0ZvckN1cnJlbnRXb3JkIiwiQ0hBUiIsImNoYXJhY3RlckVsZW1lbnQiLCJzdHlsZSIsImNoaWxkcmVuIiwiaXNXb3JkIiwiaXNXb3JkU3RhcnQiLCJpc1dvcmRFbmQiLCJ3b3Jkc0FuZENoYXJzIiwiY2hpbGROb2RlcyIsImRpc3BsYXkiLCJuZXh0U2libGluZyIsInByZXZTaWJsaW5nIiwidGV4dCIsInRleHRDb250ZW50IiwidGV4dEFmdGVyIiwidGV4dEJlZm9yZSIsImNoaWxkIiwiX3NwbGl0IiwiZ2V0UG9zaXRpb24iLCJzY3JvbGxQb3MiLCJ0b3AiLCJvZmZzZXRUb3AiLCJvZmZzZXRQYXJlbnQiLCJfc2Nyb2xsUG9zIiwic2Nyb2xsWCIsInNjcm9sbFkiLCJwYXJlbnRYIiwicGFyZW50WSIsImJvZHkiLCJwYXJlbnRSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwieCIsInkiLCJfbm9kZSRnZXRCb3VuZGluZ0NsaWUiLCJ3aWR0aCIsImhlaWdodCIsImxlZnQiLCJ1blNwbGl0V29yZHMiLCJjcmVhdGVGcmFnbWVudCIsInJlcG9zaXRpb25BZnRlclNwbGl0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJ3b3Jkc0luRWFjaExpbmUiLCJ3b3Jkc0luQ3VycmVudExpbmUiLCJsaW5lT2Zmc2V0WSIsImVsZW1lbnRIZWlnaHQiLCJlbGVtZW50V2lkdGgiLCJjb250ZW50Qm94IiwicGFyZW50RWxlbWVudCIsIm5leHRFbGVtZW50U2libGluZyIsImNzIiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImFsaWduIiwidGV4dEFsaWduIiwiZm9udFNpemUiLCJwYXJzZUZsb2F0IiwibGluZVRocmVzaG9sZCIsIm9mZnNldExlZnQiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImNzc1dpZHRoIiwiY3NzSGVpZ2h0IiwiaXNXb3JkTGlrZSIsIl9nZXRQb3NpdGlvbiIsIm5vZGVOYW1lIiwid29yZHNJblRoaXNMaW5lIiwibGluZUVsZW1lbnQiLCJsaW5lRGltZW5zaW9ucyIsIndvcmRPckVsZW1lbnQiLCJfZGF0YSRnZXQiLCJNYXRoIiwibWF4IiwibWluIiwiX2RhdGEkZ2V0MiIsImlzTGluZSIsInBhcmVudERhdGEiLCJpc0NoaWxkT2ZMaW5lTm9kZSIsIl9kZWZhdWx0cyIsIlNwbGl0VHlwZSIsImNsZWFyRGF0YSIsInNldERlZmF1bHRzIiwib3B0aW9ucyIsInJldmVydCIsImh0bWwiLCJpbm5lckhUTUwiLCJjcmVhdGUiLCJzcGxpdCQxIiwiX3RoaXMiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiX3NwbGl0MiIsInNjcm9sbFRvIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/split-type/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/blocks/hero/heroBlock.tsx":
/*!***************************************!*\
  !*** ./app/blocks/hero/heroBlock.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lottie_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lottie-react */ \"(app-pages-browser)/./node_modules/lottie-react/build/index.umd.js\");\n/* harmony import */ var lottie_react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lottie_react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _public_assets_featured_image_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../public/assets/featured-image.json */ \"(app-pages-browser)/./public/assets/featured-image.json\");\n/* harmony import */ var split_type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! split-type */ \"(app-pages-browser)/./node_modules/split-type/dist/index.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction HeroBlock(param) {\n    let {} = param;\n    _s();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        new split_type__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\"#split\");\n        new split_type__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\"#splitText\");\n        gsap.to(\"#split .char\", {\n            y: 0,\n            stagger: 0.02,\n            delay: 0.6,\n            duration: .1,\n            opacity: 1\n        });\n        gsap.to(\"#splitText .char\", {\n            y: 0,\n            stagger: 0.02,\n            delay: 0.02,\n            duration: .1,\n            opacity: 1\n        });\n        gsap.to(\".button-description .p\", {\n            y: 0,\n            stagger: 0.2,\n            delay: 1.8,\n            opacity: 1\n        });\n        gsap.to(\".button-description button\", {\n            y: 0,\n            stagger: 0.2,\n            duration: .1,\n            delay: 2,\n            opacity: 1\n        });\n        gsap.to(\".image-container\", {\n            y: 0,\n            stagger: 0.2,\n            delay: 2.25,\n            opacity: 1\n        });\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"jm-b-hero-sections bg-dark-blue-05 flex lg:pb-[185px] md:pb-[100px] pb-[50px] relative overflow-hidden justify-center text-center \",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"absolute top-[64px] md:top-[84px] w-screen h-screen z-1 align-items-center justify-center grid grid-cols-boxes-sm-width grid-rows-boxes-sm-height md:grid-cols-boxes-width-md md:grid-rows-boxes-height-md lg:grid-cols-boxes-width lg:grid-rows-boxes-height\",\n                    children: Array.from({\n                        length: 10 * 7\n                    }).map((_, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"col-span-1 size-[125px] md:size-[150px] lg:size-[200px] border border-dark-blue-01 hover:bg-dark-blue-03 transition-all \"\n                        }, index, false, {\n                            fileName: \"C:\\\\Users\\\\Acer\\\\Desktop\\\\portfolio-website\\\\app\\\\blocks\\\\hero\\\\heroBlock.tsx\",\n                            lineNumber: 60,\n                            columnNumber: 13\n                        }, this))\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Acer\\\\Desktop\\\\portfolio-website\\\\app\\\\blocks\\\\hero\\\\heroBlock.tsx\",\n                    lineNumber: 58,\n                    columnNumber: 9\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"container relative align-middle justify-center z-2 mt-[200px]\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"text-container max-w-[296px] md:max-w-[444px] lg:max-w-[625px] mx-auto\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"text-left font-oswald text-[19.5px] tracking-[0.536px] leading-normal md:text-[24px] md:tracking-[1.2px] lg:text-[30px] font-normal lg:tracking-[1.5px] p-0 md:pl-1 text-light-orange-05\",\n                                    id: \"split\",\n                                    children: \"Hi I am Jun Mar,\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\Acer\\\\Desktop\\\\portfolio-website\\\\app\\\\blocks\\\\hero\\\\heroBlock.tsx\",\n                                    lineNumber: 66,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                    className: \"font-oswald  text-[32px] md:text-[48px] tracking-[0.512px] leading-[29.184px] md:leading-[43.776px] md:tracking-[0.768px] lg:text-[67px] text-white lg:leading-[61.104px] lg:tracking-[1.072px]\",\n                                    id: \"splitText\",\n                                    children: [\n                                        \"FRONT END \",\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"text-light-blue-05\",\n                                            children: \"DEVELOPER\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Acer\\\\Desktop\\\\portfolio-website\\\\app\\\\blocks\\\\hero\\\\heroBlock.tsx\",\n                                            lineNumber: 67,\n                                            columnNumber: 246\n                                        }, this),\n                                        \"  \",\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Acer\\\\Desktop\\\\portfolio-website\\\\app\\\\blocks\\\\hero\\\\heroBlock.tsx\",\n                                            lineNumber: 67,\n                                            columnNumber: 301\n                                        }, this),\n                                        \" \",\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"text-[19.5px] tracking-[0.536px] md:text-[29px] md:tracking-[0.798px] lg:text-[41px] leading-normal lg:tracking-[1.128px]\",\n                                            children: [\n                                                \"AND I \",\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    className: \"text-light-blue-05\",\n                                                    children: \"LOVE\"\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\Acer\\\\Desktop\\\\portfolio-website\\\\app\\\\blocks\\\\hero\\\\heroBlock.tsx\",\n                                                    lineNumber: 67,\n                                                    columnNumber: 457\n                                                }, this),\n                                                \" DEVELOPING YOUR IDEAS\"\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"C:\\\\Users\\\\Acer\\\\Desktop\\\\portfolio-website\\\\app\\\\blocks\\\\hero\\\\heroBlock.tsx\",\n                                            lineNumber: 67,\n                                            columnNumber: 311\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\Acer\\\\Desktop\\\\portfolio-website\\\\app\\\\blocks\\\\hero\\\\heroBlock.tsx\",\n                                    lineNumber: 67,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"button-container flex justify-between mt-4\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"max-w-[170px] tracking-[0.1px] md:max-w-[275px] lg:max-w-[335px] text-left text-[10px] md:text-[16px] lg:text-[20px] text-light-gray-01 font-normal font-lato md:leading-[24px] leading-normal\",\n                                            children: \"I am skilled in building and designing things for the web. Currently working web-based projects at Greydient Lab.\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Acer\\\\Desktop\\\\portfolio-website\\\\app\\\\blocks\\\\hero\\\\heroBlock.tsx\",\n                                            lineNumber: 69,\n                                            columnNumber: 15\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            id: \"workshead\",\n                                            className: \"px-4 py-2 md:px-[22px] md:py-[10px] lg:px-[47px] lg:py-[19px] bg-light-orange-05 hover:bg-light-orange-03 transform transition-all text-white font-oswald text-[15px] md:text-[20px] lg:text-[24px] font-semibold rounded-[4px]\",\n                                            children: \"View Projects\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\Acer\\\\Desktop\\\\portfolio-website\\\\app\\\\blocks\\\\hero\\\\heroBlock.tsx\",\n                                            lineNumber: 70,\n                                            columnNumber: 15\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\Acer\\\\Desktop\\\\portfolio-website\\\\app\\\\blocks\\\\hero\\\\heroBlock.tsx\",\n                                    lineNumber: 68,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\Acer\\\\Desktop\\\\portfolio-website\\\\app\\\\blocks\\\\hero\\\\heroBlock.tsx\",\n                            lineNumber: 65,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"max-w-[1144px] mx-auto mt-20\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((lottie_react__WEBPACK_IMPORTED_MODULE_2___default()), {\n                                animationData: _public_assets_featured_image_json__WEBPACK_IMPORTED_MODULE_3__\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\Acer\\\\Desktop\\\\portfolio-website\\\\app\\\\blocks\\\\hero\\\\heroBlock.tsx\",\n                                lineNumber: 73,\n                                columnNumber: 57\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\Acer\\\\Desktop\\\\portfolio-website\\\\app\\\\blocks\\\\hero\\\\heroBlock.tsx\",\n                            lineNumber: 73,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\Acer\\\\Desktop\\\\portfolio-website\\\\app\\\\blocks\\\\hero\\\\heroBlock.tsx\",\n                    lineNumber: 64,\n                    columnNumber: 9\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\Acer\\\\Desktop\\\\portfolio-website\\\\app\\\\blocks\\\\hero\\\\heroBlock.tsx\",\n            lineNumber: 57,\n            columnNumber: 7\n        }, this)\n    }, void 0, false);\n}\n_s(HeroBlock, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = HeroBlock;\n/* harmony default export */ __webpack_exports__[\"default\"] = (HeroBlock);\nvar _c;\n$RefreshReg$(_c, \"HeroBlock\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9ibG9ja3MvaGVyby9oZXJvQmxvY2sudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFHaUQ7QUFDZjtBQUMyQztBQUMxQztBQUVuQyxTQUFTSyxVQUFVLEtBQ2xCO1FBRGtCLEVBQ2xCLEdBRGtCOztJQUVqQkosZ0RBQVNBLENBQUM7UUFFUixJQUFJRyxrREFBU0EsQ0FBQztRQUNkLElBQUlBLGtEQUFTQSxDQUFDO1FBRWRFLEtBQUtDLEVBQUUsQ0FBQyxnQkFBZ0I7WUFDdEJDLEdBQUc7WUFDSEMsU0FBUztZQUNUQyxPQUFPO1lBQ1BDLFVBQVU7WUFDVkMsU0FBUztRQUNYO1FBRUFOLEtBQUtDLEVBQUUsQ0FBQyxvQkFBb0I7WUFDMUJDLEdBQUc7WUFDSEMsU0FBUztZQUNUQyxPQUFPO1lBQ1BDLFVBQVU7WUFDVkMsU0FBUztRQUNYO1FBRUFOLEtBQUtDLEVBQUUsQ0FBQywwQkFBMEI7WUFDaENDLEdBQUc7WUFDSEMsU0FBUztZQUNUQyxPQUFPO1lBQ1BFLFNBQVM7UUFDWDtRQUVBTixLQUFLQyxFQUFFLENBQUMsOEJBQThCO1lBQ3BDQyxHQUFHO1lBQ0hDLFNBQVM7WUFDVEUsVUFBVTtZQUNWRCxPQUFPO1lBQ1BFLFNBQVM7UUFDWDtRQUVBTixLQUFLQyxFQUFFLENBQUMsb0JBQW9CO1lBQzFCQyxHQUFHO1lBQ0hDLFNBQVM7WUFDVEMsT0FBTztZQUNQRSxTQUFTO1FBQ1g7SUFFRixHQUFHLEVBQUU7SUFDTCxxQkFDRTtrQkFDRSw0RUFBQ0M7WUFBSUMsV0FBVTs7OEJBQ2IsOERBQUNEO29CQUFJQyxXQUFVOzhCQUNaQyxNQUFNQyxJQUFJLENBQUM7d0JBQUVDLFFBQVEsS0FBSztvQkFBRSxHQUFHQyxHQUFHLENBQUMsQ0FBQ0MsR0FBR0Msc0JBQ3RDLDhEQUFDUDs0QkFBZ0JDLFdBQVU7MkJBQWpCTTs7Ozs7Ozs7Ozs4QkFJZCw4REFBQ1A7b0JBQUlDLFdBQVU7O3NDQUNiLDhEQUFDRDs0QkFBSUMsV0FBVTs7OENBQ2IsOERBQUNPO29DQUFFUCxXQUFVO29DQUEyTFEsSUFBRzs4Q0FBUTs7Ozs7OzhDQUNuTiw4REFBQ0M7b0NBQUdULFdBQVU7b0NBQWtNUSxJQUFHOzt3Q0FBWTtzREFBVSw4REFBQ0U7NENBQUtWLFdBQVU7c0RBQXFCOzs7Ozs7d0NBQWdCO3NEQUFFLDhEQUFDVzs7Ozs7d0NBQVE7c0RBQUMsOERBQUNEOzRDQUFLVixXQUFVOztnREFBNEg7OERBQU0sOERBQUNVO29EQUFLVixXQUFVOzhEQUFxQjs7Ozs7O2dEQUFXOzs7Ozs7Ozs7Ozs7OzhDQUM1ZSw4REFBQ0Q7b0NBQUlDLFdBQVU7O3NEQUNiLDhEQUFDTzs0Q0FBRVAsV0FBVTtzREFBaU07Ozs7OztzREFDOU0sOERBQUNZOzRDQUFPSixJQUFHOzRDQUFZUixXQUFVO3NEQUFrTzs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NDQUd2USw4REFBQ0Q7NEJBQUlDLFdBQVU7c0NBQStCLDRFQUFDWixxREFBTUE7Z0NBQUN5QixlQUFleEIsK0RBQW1CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS2xHO0dBckVTRTtLQUFBQTtBQXVFVCwrREFBZUEsU0FBU0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvYmxvY2tzL2hlcm8vaGVyb0Jsb2NrLnRzeD8zY2JiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiXHJcblxyXG5pbXBvcnQgSW1hZ2UgZnJvbSAnbmV4dC9pbWFnZSdcclxuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgTG90dGllIGZyb20gXCJsb3R0aWUtcmVhY3RcIjtcclxuaW1wb3J0IGdyb292eVdhbGtBbmltYXRpb24gZnJvbSBcIi4uLy4uLy4uL3B1YmxpYy9hc3NldHMvZmVhdHVyZWQtaW1hZ2UuanNvblwiO1xyXG5pbXBvcnQgU3BsaXRUeXBlIGZyb20gJ3NwbGl0LXR5cGUnO1xyXG5cclxuZnVuY3Rpb24gSGVyb0Jsb2NrKHtcclxufSkge1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcblxyXG4gICAgbmV3IFNwbGl0VHlwZSgnI3NwbGl0Jyk7XHJcbiAgICBuZXcgU3BsaXRUeXBlKCcjc3BsaXRUZXh0Jyk7XHJcblxyXG4gICAgZ3NhcC50bygnI3NwbGl0IC5jaGFyJywge1xyXG4gICAgICB5OiAwLFxyXG4gICAgICBzdGFnZ2VyOiAwLjAyLFxyXG4gICAgICBkZWxheTogMC42LFxyXG4gICAgICBkdXJhdGlvbjogLjEsXHJcbiAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICB9KTtcclxuXHJcbiAgICBnc2FwLnRvKCcjc3BsaXRUZXh0IC5jaGFyJywge1xyXG4gICAgICB5OiAwLFxyXG4gICAgICBzdGFnZ2VyOiAwLjAyLFxyXG4gICAgICBkZWxheTogMC4wMixcclxuICAgICAgZHVyYXRpb246IC4xLFxyXG4gICAgICBvcGFjaXR5OiAxLFxyXG4gICAgfSk7XHJcblxyXG4gICAgZ3NhcC50bygnLmJ1dHRvbi1kZXNjcmlwdGlvbiAucCcsIHtcclxuICAgICAgeTogMCxcclxuICAgICAgc3RhZ2dlcjogMC4yLFxyXG4gICAgICBkZWxheTogMS44LFxyXG4gICAgICBvcGFjaXR5OiAxLFxyXG4gICAgfSk7XHJcblxyXG4gICAgZ3NhcC50bygnLmJ1dHRvbi1kZXNjcmlwdGlvbiBidXR0b24nLCB7XHJcbiAgICAgIHk6IDAsXHJcbiAgICAgIHN0YWdnZXI6IDAuMixcclxuICAgICAgZHVyYXRpb246IC4xLFxyXG4gICAgICBkZWxheTogMixcclxuICAgICAgb3BhY2l0eTogMSxcclxuICAgIH0pO1xyXG5cclxuICAgIGdzYXAudG8oJy5pbWFnZS1jb250YWluZXInLCB7XHJcbiAgICAgIHk6IDAsXHJcbiAgICAgIHN0YWdnZXI6IDAuMixcclxuICAgICAgZGVsYXk6IDIuMjUsXHJcbiAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICB9KTtcclxuXHJcbiAgfSwgW10pO1xyXG4gIHJldHVybiAoXHJcbiAgICA8PlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT0nam0tYi1oZXJvLXNlY3Rpb25zIGJnLWRhcmstYmx1ZS0wNSBmbGV4IGxnOnBiLVsxODVweF0gbWQ6cGItWzEwMHB4XSBwYi1bNTBweF0gcmVsYXRpdmUgb3ZlcmZsb3ctaGlkZGVuIGp1c3RpZnktY2VudGVyIHRleHQtY2VudGVyICc+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhYnNvbHV0ZSB0b3AtWzY0cHhdIG1kOnRvcC1bODRweF0gdy1zY3JlZW4gaC1zY3JlZW4gei0xIGFsaWduLWl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBncmlkIGdyaWQtY29scy1ib3hlcy1zbS13aWR0aCBncmlkLXJvd3MtYm94ZXMtc20taGVpZ2h0IG1kOmdyaWQtY29scy1ib3hlcy13aWR0aC1tZCBtZDpncmlkLXJvd3MtYm94ZXMtaGVpZ2h0LW1kIGxnOmdyaWQtY29scy1ib3hlcy13aWR0aCBsZzpncmlkLXJvd3MtYm94ZXMtaGVpZ2h0XCI+XHJcbiAgICAgICAgICB7QXJyYXkuZnJvbSh7IGxlbmd0aDogMTAgKiA3IH0pLm1hcCgoXywgaW5kZXgpID0+IChcclxuICAgICAgICAgICAgPGRpdiBrZXk9e2luZGV4fSBjbGFzc05hbWU9XCJjb2wtc3Bhbi0xIHNpemUtWzEyNXB4XSBtZDpzaXplLVsxNTBweF0gbGc6c2l6ZS1bMjAwcHhdIGJvcmRlciBib3JkZXItZGFyay1ibHVlLTAxIGhvdmVyOmJnLWRhcmstYmx1ZS0wMyB0cmFuc2l0aW9uLWFsbCBcIj48L2Rpdj5cclxuICAgICAgICAgICkpfVxyXG4gICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRhaW5lciByZWxhdGl2ZSBhbGlnbi1taWRkbGUganVzdGlmeS1jZW50ZXIgei0yIG10LVsyMDBweF1cIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jb250YWluZXIgbWF4LXctWzI5NnB4XSBtZDptYXgtdy1bNDQ0cHhdIGxnOm1heC13LVs2MjVweF0gbXgtYXV0b1wiPlxyXG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9J3RleHQtbGVmdCBmb250LW9zd2FsZCB0ZXh0LVsxOS41cHhdIHRyYWNraW5nLVswLjUzNnB4XSBsZWFkaW5nLW5vcm1hbCBtZDp0ZXh0LVsyNHB4XSBtZDp0cmFja2luZy1bMS4ycHhdIGxnOnRleHQtWzMwcHhdIGZvbnQtbm9ybWFsIGxnOnRyYWNraW5nLVsxLjVweF0gcC0wIG1kOnBsLTEgdGV4dC1saWdodC1vcmFuZ2UtMDUnIGlkPSdzcGxpdCc+SGkgSSBhbSBKdW4gTWFyLDwvcD5cclxuICAgICAgICAgICAgPGgxIGNsYXNzTmFtZT0nZm9udC1vc3dhbGQgIHRleHQtWzMycHhdIG1kOnRleHQtWzQ4cHhdIHRyYWNraW5nLVswLjUxMnB4XSBsZWFkaW5nLVsyOS4xODRweF0gbWQ6bGVhZGluZy1bNDMuNzc2cHhdIG1kOnRyYWNraW5nLVswLjc2OHB4XSBsZzp0ZXh0LVs2N3B4XSB0ZXh0LXdoaXRlIGxnOmxlYWRpbmctWzYxLjEwNHB4XSBsZzp0cmFja2luZy1bMS4wNzJweF0nIGlkPSdzcGxpdFRleHQnPkZST05UIEVORCA8c3BhbiBjbGFzc05hbWU9J3RleHQtbGlnaHQtYmx1ZS0wNSc+REVWRUxPUEVSPC9zcGFuPiAgPGJyPjwvYnI+IDxzcGFuIGNsYXNzTmFtZT0ndGV4dC1bMTkuNXB4XSB0cmFja2luZy1bMC41MzZweF0gbWQ6dGV4dC1bMjlweF0gbWQ6dHJhY2tpbmctWzAuNzk4cHhdIGxnOnRleHQtWzQxcHhdIGxlYWRpbmctbm9ybWFsIGxnOnRyYWNraW5nLVsxLjEyOHB4XSc+QU5EIEkgPHNwYW4gY2xhc3NOYW1lPSd0ZXh0LWxpZ2h0LWJsdWUtMDUnPkxPVkU8L3NwYW4+IERFVkVMT1BJTkcgWU9VUiBJREVBUzwvc3Bhbj48L2gxPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvbi1jb250YWluZXIgZmxleCBqdXN0aWZ5LWJldHdlZW4gbXQtNFwiPlxyXG4gICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT0nbWF4LXctWzE3MHB4XSB0cmFja2luZy1bMC4xcHhdIG1kOm1heC13LVsyNzVweF0gbGc6bWF4LXctWzMzNXB4XSB0ZXh0LWxlZnQgdGV4dC1bMTBweF0gbWQ6dGV4dC1bMTZweF0gbGc6dGV4dC1bMjBweF0gdGV4dC1saWdodC1ncmF5LTAxIGZvbnQtbm9ybWFsIGZvbnQtbGF0byBtZDpsZWFkaW5nLVsyNHB4XSBsZWFkaW5nLW5vcm1hbCc+SSBhbSBza2lsbGVkIGluIGJ1aWxkaW5nIGFuZCBkZXNpZ25pbmcgdGhpbmdzIGZvciB0aGUgd2ViLiBDdXJyZW50bHkgd29ya2luZyB3ZWItYmFzZWQgcHJvamVjdHMgYXQgR3JleWRpZW50IExhYi48L3A+XHJcbiAgICAgICAgICAgICAgPGJ1dHRvbiBpZD1cIndvcmtzaGVhZFwiIGNsYXNzTmFtZT0ncHgtNCBweS0yIG1kOnB4LVsyMnB4XSBtZDpweS1bMTBweF0gbGc6cHgtWzQ3cHhdIGxnOnB5LVsxOXB4XSBiZy1saWdodC1vcmFuZ2UtMDUgaG92ZXI6YmctbGlnaHQtb3JhbmdlLTAzIHRyYW5zZm9ybSB0cmFuc2l0aW9uLWFsbCB0ZXh0LXdoaXRlIGZvbnQtb3N3YWxkIHRleHQtWzE1cHhdIG1kOnRleHQtWzIwcHhdIGxnOnRleHQtWzI0cHhdIGZvbnQtc2VtaWJvbGQgcm91bmRlZC1bNHB4XSc+VmlldyBQcm9qZWN0czwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYXgtdy1bMTE0NHB4XSBteC1hdXRvIG10LTIwXCI+PExvdHRpZSBhbmltYXRpb25EYXRhPXtncm9vdnlXYWxrQW5pbWF0aW9ufSAvPjwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2RpdiA+XHJcbiAgICA8Lz5cclxuICApO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBIZXJvQmxvY2s7XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsIkxvdHRpZSIsImdyb292eVdhbGtBbmltYXRpb24iLCJTcGxpdFR5cGUiLCJIZXJvQmxvY2siLCJnc2FwIiwidG8iLCJ5Iiwic3RhZ2dlciIsImRlbGF5IiwiZHVyYXRpb24iLCJvcGFjaXR5IiwiZGl2IiwiY2xhc3NOYW1lIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwibWFwIiwiXyIsImluZGV4IiwicCIsImlkIiwiaDEiLCJzcGFuIiwiYnIiLCJidXR0b24iLCJhbmltYXRpb25EYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/blocks/hero/heroBlock.tsx\n"));

/***/ })

});